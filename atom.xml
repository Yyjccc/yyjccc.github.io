<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yyjccc的博客</title>
  
  <subtitle>yyjccc的博客</subtitle>
  <link href="https://yyjccc.github.io/atom.xml" rel="self"/>
  
  <link href="https://yyjccc.github.io/"/>
  <updated>2024-11-01T16:58:37.770Z</updated>
  <id>https://yyjccc.github.io/</id>
  
  <author>
    <name>Yyjccc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NTLM</title>
    <link href="https://yyjccc.github.io/2024/11/02/NTLM/"/>
    <id>https://yyjccc.github.io/2024/11/02/NTLM/</id>
    <published>2024-11-01T16:49:12.583Z</published>
    <updated>2024-11-01T16:58:37.770Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;NTLM 协议是 Microsoft 环境中使用的身份验证协议。特别是，它允许用户向服务器证明其身份，以便使用该服务器提供的服务。PTH在域渗透中并不陌生，hash 传递攻击 。NTLM Relay ,NTLM认证协议的中间人攻击,这些都设计到NTLM Hash 和Net-NTLM Hash 本文就来具体介绍&lt;/p&gt;
&lt;p&gt;There are two possible scenarios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户使用服务器本地帐户的凭据，在这种情况下，服务器在其本地数据库中拥有用户的密码，并且能够对用户进行身份验证；&lt;/li&gt;
&lt;li&gt;在Active Directory域环境中，用户在身份验证过程中使用域帐户，在这种情况下，服务器将必须要求域控制器验证用户提供的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;h3 id=&quot;Local-account&quot;&gt;&lt;a href=&quot;#Local-account&quot; class=&quot;headerlink&quot; title=&quot;Local account&quot;&gt;&lt;/a&gt;Local account&lt;/h3&gt;&lt;p&gt;服务器需要存储本地用户及其密码的哈希值。该数据库的名称是SAM （安全帐户管理器）。 SAM 可以在注册表中找到，特别是使用regedit工具，但仅当以SYSTEM身份访问时。可以使用&lt;a href=&quot;https://docs.microsoft.com/en-us/sysinternals/downloads/psexec&quot;&gt;psexec&lt;/a&gt;作为SYSTEM打开它：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;psexec.exe -i -s regedit.exe&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;psexec 是啥，先暂时跳过，之后再补&lt;/p&gt;
&lt;p&gt;在本地磁盘上对应着文件：C:&#92;Windows&#92;System32&#92;SAM&lt;/p&gt;
&lt;p&gt;因此它包含本地用户列表</summary>
      
    
    
    
    <category term="Windows" scheme="https://yyjccc.github.io/categories/Windows/"/>
    
    
    <category term="Windows" scheme="https://yyjccc.github.io/tags/Windows/"/>
    
    <category term="协议" scheme="https://yyjccc.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="NTLM" scheme="https://yyjccc.github.io/tags/NTLM/"/>
    
    <category term="横向移动" scheme="https://yyjccc.github.io/tags/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/"/>
    
    <category term="内网渗透" scheme="https://yyjccc.github.io/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>PE文件结构</title>
    <link href="https://yyjccc.github.io/2024/10/30/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://yyjccc.github.io/2024/10/30/PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</id>
    <published>2024-10-30T08:23:18.788Z</published>
    <updated>2024-10-30T08:57:30.143Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;pe文件结构只能说算一点点基础，顺带学习PE的时候再熟悉熟悉c语言和Windows API&lt;/p&gt;
&lt;p&gt;PE文件即Portable Execute Windows下可执行文件的总称，常见的有 DLL，EXE，OCX，SYS 等，PE文件可以说是在各个领域都有涉及，特别是病毒领域，内网渗透中的免杀对抗&lt;/p&gt;
&lt;p&gt;(免杀对抗环境从普通的杀软到edr,xdr等设备)&lt;/p&gt;
&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;p&gt;PE文件的结构有两种表现形式：一是存储在在硬盘中的文件，二是加载在内存中&lt;/p&gt;
&lt;img src=&quot;/img/24-10-30/1.png&quot;&gt;

&lt;p&gt;如上图可见，当PE文件加载到内存中后，DOS头到最后一个节区头的部分是一致的，而之后节区与节区之间的间隔，内存中的间隔会更大&lt;/p&gt;
&lt;p&gt;产生差异是因为内存对齐，主要是下面两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统通常以内存分页为单位（通常是 4 KB 或 2 MB 等）来管理内存。加载 PE 文件时，每个节会被分配到与分页边界对齐的内存地址&lt;/li&gt;
&lt;li&gt;在 PE 文件的头信息中，SectionAlignment 字段定义了各个节(段)在内存中的对齐方式。这种对齐方式一般也选择 4 KB 或更大，以保证节在内存中符合分页要求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在开始之前，先来点基础概念。对于学过操作系统的来说，这应该很好理解&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;地址&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般是指虚拟地址，而非物理地址，我们知道程序运行时候是使用操作系统分配的内存空间，所以用户并不知道具体的物理地址。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;镜像文件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;包含以 EXE 文件为代表的 “可执行文件”、以DLL文件为代表的“动态链接库”。因为他们常常被直接“复制”到内存，有“镜像”的某种意思。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;RAV&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Relatively Virtual Address。偏移(又称“相对虚拟地址”)。相对镜像基址的偏移。&lt;/p&gt;
&lt;p&gt;一般来说，PE文件在硬盘上和在内存里是不完全一样的。各个节在硬盘上是连续的，而在内存中是</summary>
      
    
    
    
    <category term="Windows" scheme="https://yyjccc.github.io/categories/Windows/"/>
    
    
    <category term="二进制" scheme="https://yyjccc.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    <category term="Windows" scheme="https://yyjccc.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>LLMNR&#92;NBT-NS&#92;MDNS欺骗</title>
    <link href="https://yyjccc.github.io/2024/10/10/LLMNR%E4%B8%8ENBTNS%E5%92%8CMDNS%E6%AC%BA%E9%AA%97/"/>
    <id>https://yyjccc.github.io/2024/10/10/LLMNR%E4%B8%8ENBTNS%E5%92%8CMDNS%E6%AC%BA%E9%AA%97/</id>
    <published>2024-10-10T10:58:28.596Z</published>
    <updated>2024-10-10T15:09:36.161Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;LLMNR、NetBIOS、MDNS 本质是对DNS的扩充，应用在内网中的DNS解析(局域网内未得到DNS响应等场景)&lt;/p&gt;
&lt;p&gt;LLMNR&#92;NetBIOS&#92;MDNS欺骗是中间人攻击，适合来获取凭证，如Net-NTLM Hash的获取 ,所以单独&lt;/p&gt;
&lt;p&gt;开了一篇来学习，不过Responder 已经集成了各种服务场景下的LLMNR&#92;NetBIOS&#92;MDNS 欺骗&lt;/p&gt;
&lt;h2 id=&quot;LLMNR&quot;&gt;&lt;a href=&quot;#LLMNR&quot; class=&quot;headerlink&quot; title=&quot;LLMNR&quot;&gt;&lt;/a&gt;LLMNR&lt;/h2&gt;&lt;p&gt;​	LLMNR(Link-Local Multicast Name Resolution) 是用于同一本地链路上的，基于DNS协议的一个协议，同一局域网中的主机可通过该协议去解析其他主机名&lt;/p&gt;
&lt;p&gt;是一种用于在局域网中解析主机名到IP地址的协议。它通常用于替代基于DNS的主机名解析，特别是在没有DNS服务器或者DNS服务器不可用的情况下。（如小型局域网没有搭建专门的DNS服务器）&lt;/p&gt;
&lt;p&gt;​	从 Windows Vista 开始支持 LLMNR ，Linux 系统也通过 systemd 实现了此协议，同时 LLMNR 也支持 IPv6。&lt;/p&gt;
&lt;p&gt;现在机器解析域名，查询顺序如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本地hosts 文件解析&lt;/li&gt;
&lt;li&gt;使用DNS解析&lt;/li&gt;
&lt;li&gt;使用LLMNR解析&lt;/li&gt;
&lt;li&gt;NetBIOS名称服务（NBT-NS）&lt;/li&gt;
&lt;li&gt;mDNS解析&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;LLMNR解析过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先检查本地NetBios缓存&lt;/li&gt;
&lt;li&gt;没有则向IPv4的组播地址224.0.0.252(IPv6的组播地址ff02::fb)组播LLMNR协议数据包&lt;/li&gt;
&lt;li&gt;收到该广播的数据包，若是要找的主机，则向广播主机单播一个返回数据包&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;组播：224.0.0.0/4 是保留给多播通信的地址范围，其中 224.0.0.0 到 224.0.0.255 是局部网络控制多播地址，它们用于在本地网络中传输控制消息，不能被路由器转发到其他网络&lt;/p&gt;
&lt;p&gt;LLMNR协议工作在UDP 5355端口&lt;/p&gt;
&lt;p&gt;LLMNR</summary>
      
    
    
    
    <category term="Windows" scheme="https://yyjccc.github.io/categories/Windows/"/>
    
    
    <category term="域渗透" scheme="https://yyjccc.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
    <category term="Windows" scheme="https://yyjccc.github.io/tags/Windows/"/>
    
    <category term="协议" scheme="https://yyjccc.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="网络安全" scheme="https://yyjccc.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Windows认证机制</title>
    <link href="https://yyjccc.github.io/2024/09/19/Windows%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/"/>
    <id>https://yyjccc.github.io/2024/09/19/Windows%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/</id>
    <published>2024-09-19T09:22:47.238Z</published>
    <updated>2024-09-19T09:26:11.726Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Windows认证机制&quot;&gt;&lt;a href=&quot;#Windows认证机制&quot; class=&quot;headerlink&quot; title=&quot;Windows认证机制&quot;&gt;&lt;/a&gt;Windows认证机制&lt;/h1&gt;&lt;p&gt;​	Windows 的认证机制也是一项基础，通过本文你能大致了解Windows认证机制，其中涉及常见的名词如NTLM哈希，PTH ,Kerberos协议，黄金票据、白银票据等等，希望师傅们看完能基本了解其含义和及其原理 &lt;/p&gt;
&lt;h2 id=&quot;Windows本地认证&quot;&gt;&lt;a href=&quot;#Windows本地认证&quot; class=&quot;headerlink&quot; title=&quot;Windows本地认证&quot;&gt;&lt;/a&gt;Windows本地认证&lt;/h2&gt;&lt;p&gt;密码存储路径：%SystemRoot%&#92;system32&#92;config&#92;sam&lt;/p&gt;
&lt;h3 id=&quot;NTLM-Hash&quot;&gt;&lt;a href=&quot;#NTLM-Hash&quot; class=&quot;headerlink&quot; title=&quot;NTLM Hash&quot;&gt;&lt;/a&gt;NTLM Hash&lt;/h3&gt;&lt;p&gt;NTLM Hash 是长度为32位由数字和字母组成的hash，支持Net NTLM 认证协议及本地认证&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows本身不存储用户的明文密码&lt;/li&gt;
&lt;li&gt;当用户登录时候，会与本地SAM中的NTLM hash进行比较&lt;/li&gt;
&lt;li&gt;在NTLM Hash 之前还存在LM Hash&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;生成&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/img/24-9-19/1.png&quot;&gt;



&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; passlib.&lt;span class=&quot;built_in&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; nthash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;h=nthash.&lt;span class=&quot;built_in&quot;&gt;hash&lt;/span&gt;(&lt;span class=&quot;str</summary>
      
    
    
    
    <category term="Windows" scheme="https://yyjccc.github.io/categories/Windows/"/>
    
    
    <category term="域渗透" scheme="https://yyjccc.github.io/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
    
    <category term="Windows安全" scheme="https://yyjccc.github.io/tags/Windows%E5%AE%89%E5%85%A8/"/>
    
    <category term="内网" scheme="https://yyjccc.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Apache OFBiz目录遍历导致RCE(CVE-2024-38856)</title>
    <link href="https://yyjccc.github.io/2024/08/09/Apache-OFBiz%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E5%AF%BC%E8%87%B4RCE-CVE-2024-38856/"/>
    <id>https://yyjccc.github.io/2024/08/09/Apache-OFBiz%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86%E5%AF%BC%E8%87%B4RCE-CVE-2024-38856/</id>
    <published>2024-08-09T07:27:08.500Z</published>
    <updated>2024-08-09T07:39:44.957Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Apache-OFBiz目录遍历导致RCE-CVE-2024-38856&quot;&gt;&lt;a href=&quot;#Apache-OFBiz目录遍历导致RCE-CVE-2024-38856&quot; class=&quot;headerlink&quot; title=&quot;Apache OFBiz目录遍历导致RCE(CVE-2024-38856)&quot;&gt;&lt;/a&gt;Apache OFBiz目录遍历导致RCE(CVE-2024-38856)&lt;/h1&gt;&lt;h3 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h3&gt;&lt;p&gt;下载地址： &lt;a href=&quot;https://ofbiz.apache.org/download.html&quot;&gt;https://ofbiz.apache.org/download.html&lt;/a&gt;&lt;br&gt;下载的是17.02版本（下载的是17.02版本（代码有点区别但是能复现漏洞，建议还是18版本） &lt;/p&gt;
&lt;p&gt;然后在build.gradle 中设置jvm 调式参数&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;List&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;jvmArguments&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;string&quot;&gt;&#39;-Xms128M&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;-Xmx1024M&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;img src=&quot;/img/24-8-9/1.png&quot;&gt;

&lt;p&gt; 构建项目：&lt;/p&gt;
&lt;figure class=&quot;highlight powershell&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;</summary>
      
    
    
    
    <category term="cve复现" scheme="https://yyjccc.github.io/categories/cve%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="web安全" scheme="https://yyjccc.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
    <category term="表达式注入" scheme="https://yyjccc.github.io/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/"/>
    
    <category term="Apache" scheme="https://yyjccc.github.io/tags/Apache/"/>
    
    <category term="cve" scheme="https://yyjccc.github.io/tags/cve/"/>
    
    <category term="Govvy" scheme="https://yyjccc.github.io/tags/Govvy/"/>
    
    <category term="路径遍历" scheme="https://yyjccc.github.io/tags/%E8%B7%AF%E5%BE%84%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>springcloud dataflow任意文件写入（CVE-2024-22263）</title>
    <link href="https://yyjccc.github.io/2024/07/12/springcloud-dataflow%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%EF%BC%88CVE-2024-22263%EF%BC%89/"/>
    <id>https://yyjccc.github.io/2024/07/12/springcloud-dataflow%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%EF%BC%88CVE-2024-22263%EF%BC%89/</id>
    <published>2024-07-12T04:51:51.201Z</published>
    <updated>2024-07-12T04:56:12.690Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;springcloud-dataflow任意文件写入（CVE-2024-22263）&quot;&gt;&lt;a href=&quot;#springcloud-dataflow任意文件写入（CVE-2024-22263）&quot; class=&quot;headerlink&quot; title=&quot;springcloud dataflow任意文件写入（CVE-2024-22263）&quot;&gt;&lt;/a&gt;springcloud dataflow任意文件写入（CVE-2024-22263）&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;信息参考&lt;/strong&gt;：&lt;a href=&quot;https://spring.io/security/cve-2024-22263&quot;&gt;https://spring.io/security/cve-2024-22263&lt;/a&gt;&lt;br&gt;&lt;strong&gt;披露时间&lt;/strong&gt;： 2024.5.23&lt;br&gt;&lt;strong&gt;分析时间&lt;/strong&gt;：2024.6.18&lt;br&gt;&lt;strong&gt;github源码&lt;/strong&gt;：&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-dataflow&quot;&gt;https://github.com/spring-cloud/spring-cloud-dataflow&lt;/a&gt;&lt;br&gt;&lt;strong&gt;github 修复 commit&lt;/strong&gt; ：&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-dataflow/commit/2ac9bfa5c2f7cdcc86938ce036283a37008add31&quot;&gt;Improved validateUploadRequest and applied after tmp directory was cr… · spring-cloud/spring-cloud-dataflow@2ac9bfa&lt;/a&gt;&lt;br&gt;&lt;strong&gt;分析版本&lt;/strong&gt;：2.11.2&lt;br&gt;&lt;strong&gt;其余信息&lt;/strong&gt;：分析时候暂无公开poc&lt;/p&gt;
&lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="cve复现" scheme="https://yyjccc.github.io/categories/cve%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="web安全" scheme="https://yyjccc.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
    <category term="springcloud" scheme="https://yyjccc.github.io/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>GeoServer表达式注入代码执行漏洞</title>
    <link href="https://yyjccc.github.io/2024/07/08/GeoServer%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>https://yyjccc.github.io/2024/07/08/GeoServer%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-07-08T06:41:41.939Z</published>
    <updated>2024-07-12T04:55:37.843Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GeoServer表达式注入代码执行漏洞&quot;&gt;&lt;a href=&quot;#GeoServer表达式注入代码执行漏洞&quot; class=&quot;headerlink&quot; title=&quot;GeoServer表达式注入代码执行漏洞&quot;&gt;&lt;/a&gt;GeoServer表达式注入代码执行漏洞&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;信息参考&lt;/strong&gt;：&lt;a href=&quot;https://avd.aliyun.com/detail?id=AVD-2024-36401&quot;&gt;https://avd.aliyun.com/detail?id=AVD-2024-36401&lt;/a&gt;&lt;br&gt;&lt;strong&gt;披露时间&lt;/strong&gt;： 2024.7.2&lt;br&gt;&lt;strong&gt;github源码&lt;/strong&gt;：&lt;a href=&quot;https://github.com/geoserver/geoserver&quot;&gt;https://github.com/geoserver/geoserver&lt;/a&gt;&lt;br&gt;&lt;strong&gt;分析版本&lt;/strong&gt;：2.25.0&lt;br&gt;&lt;strong&gt;漏洞版本&lt;/strong&gt;：&lt;br&gt;2.25.0 &amp;lt;= GeoServer &amp;lt; 2.25.2&lt;br&gt;2.24.0 &amp;lt;= GeoServer &amp;lt; 2.24.4&lt;br&gt;GeoServer &amp;lt; 2.23.6&lt;/p&gt;
&lt;p&gt;阐述：GeoServer由于GeoTool组件使用了含有漏洞的commons-jxpath组件导致表达式注入漏洞&lt;br&gt;相关信息：&lt;br&gt;漏洞通告：&lt;a href=&quot;https://github.com/geoserver/geoserver/security/advisories/GHSA-6jj6-gm7p-fcvv&quot;&gt;https://github.com/geoserver/geoserver/security/advisories/GHSA-6jj6-gm7p-fcvv&lt;/a&gt;&lt;br&gt;GeoTool组件通告：&lt;a href=&quot;https://github.com/geotools/geotools/security/advisories/GHSA-w3pj-</summary>
      
    
    
    
    <category term="cve复现" scheme="https://yyjccc.github.io/categories/cve%E5%A4%8D%E7%8E%B0/"/>
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
    <category term="表达式注入" scheme="https://yyjccc.github.io/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/"/>
    
    <category term="geoserver" scheme="https://yyjccc.github.io/tags/geoserver/"/>
    
  </entry>
  
  <entry>
    <title>Apache Commons JXPath</title>
    <link href="https://yyjccc.github.io/2024/07/08/Apache-Commons-JXPath/"/>
    <id>https://yyjccc.github.io/2024/07/08/Apache-Commons-JXPath/</id>
    <published>2024-07-08T02:29:38.691Z</published>
    <updated>2024-07-08T02:32:03.222Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Apache-Commons-JXPath&quot;&gt;&lt;a href=&quot;#Apache-Commons-JXPath&quot; class=&quot;headerlink&quot; title=&quot;Apache Commons JXPath&quot;&gt;&lt;/a&gt;Apache Commons JXPath&lt;/h1&gt;&lt;p&gt;Apache Commons JXPath是美国阿帕奇（Apache）基金会的一种 XPath 1.0 的基于 Java 的实现。JXPath 为使用 XPath 语法遍历 JavaBeans、DOM 和其他类型的对象的图形提供了 API。&lt;/p&gt;
&lt;p&gt;依赖&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;commons-jxpath&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;commons-jxpath&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.3&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;</summary>
      
    
    
    
    <category term="Life" scheme="https://yyjccc.github.io/categories/Life/"/>
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
    <category term="apache commons" scheme="https://yyjccc.github.io/tags/apache-commons/"/>
    
    <category term="表达式注入" scheme="https://yyjccc.github.io/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>Hessian</title>
    <link href="https://yyjccc.github.io/2024/06/07/Hessian/"/>
    <id>https://yyjccc.github.io/2024/06/07/Hessian/</id>
    <published>2024-06-07T09:45:13.479Z</published>
    <updated>2024-06-07T09:46:06.388Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hessian&quot;&gt;&lt;a href=&quot;#Hessian&quot; class=&quot;headerlink&quot; title=&quot;Hessian&quot;&gt;&lt;/a&gt;Hessian&lt;/h1&gt;&lt;p&gt;Hessian是一个轻量级的remoting onhttp工具，是一个轻量级的Java序列化/反序列化框架，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。&lt;/p&gt;
&lt;p&gt;RPC协议的一次远程通信过程如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端发起请求，并按照RPC协议格式填充信息&lt;/li&gt;
&lt;li&gt;填充完毕后将二进制格式文件转化为流，通过传输协议进行传输&lt;/li&gt;
&lt;li&gt;服务端接收到流后，将其转换为二进制格式文件，并按照RPC协议格式获取请求的信息并进行处理&lt;/li&gt;
&lt;li&gt;处理完毕后将结果按照RPC协议格式写入二进制格式文件中并返回&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;各种反序列化机制&quot;&gt;&lt;a href=&quot;#各种反序列化机制&quot; class=&quot;headerlink&quot; title=&quot;各种反序列化机制&quot;&gt;&lt;/a&gt;各种反序列化机制&lt;/h2&gt;&lt;p&gt;在网络通信过程中，我们想传输的内容肯定不止局限于文本或二进制信息，假如我们想要传递给远端一个特定的对象，那么这时就需要用到序列化和反序列化这种技术了。&lt;br&gt;在Java中，序列化能够将一个Java对象转换为一串&lt;strong&gt;便于传输&lt;/strong&gt;的字节序列。而反序列化与之相反，能够从字节序列中恢复出一个对象。参考&lt;a href=&quot;https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true&quot;&gt;marshalsec.pdf&lt;/a&gt;，我们可以将序列化/反序列化机制分大体分为两类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于Bean属性访问机制&lt;/li&gt;
&lt;li&gt;基于Field机制&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;基于Bean属性访问机制&quot;&gt;&lt;a href=&quot;#基于Bean属性访问机制&quot; class=&quot;headerlink&quot; title=&quot;基于Bean属性访问机制&quot;&gt;&lt;/a&gt;基于Bean属性访问机制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;SnakeYAML&lt;</summary>
      
    
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
    <category term="反序列化漏洞" scheme="https://yyjccc.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="Hessian" scheme="https://yyjccc.github.io/tags/Hessian/"/>
    
  </entry>
  
  <entry>
    <title>Groovy</title>
    <link href="https://yyjccc.github.io/2024/06/06/Groovy/"/>
    <id>https://yyjccc.github.io/2024/06/06/Groovy/</id>
    <published>2024-06-06T02:19:03.702Z</published>
    <updated>2024-06-06T02:21:32.261Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Groovy&quot;&gt;&lt;a href=&quot;#Groovy&quot; class=&quot;headerlink&quot; title=&quot;Groovy&quot;&gt;&lt;/a&gt;Groovy&lt;/h1&gt;&lt;p&gt;Groovy 是一种基于 JVM 的开发语言，具有类似于 Python，Ruby，Perl 和 Smalltalk 的功能。Groovy 既可以用作 Java 平台的编程语言，也可以用作脚本语言。groovy 编译之后生成 .class 文件，与 Java 编译生成的无异，因此可以在 JVM 上运行。&lt;/p&gt;
&lt;h2 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h2&gt;&lt;h3 id=&quot;MethodClosure&quot;&gt;&lt;a href=&quot;#MethodClosure&quot; class=&quot;headerlink&quot; title=&quot;MethodClosure&quot;&gt;&lt;/a&gt;MethodClosure&lt;/h3&gt;&lt;p&gt;org.codehaus.groovy.runtime.MethodClosure 是方法闭包，使用闭包代表了一个对象的一个方法，可以很方便的调用。&lt;br&gt;MethodClosure 初始化时接收两个参数，一个是对象，一个是对象的方法名称。&lt;br&gt;&lt;img src=&quot;/img/24-6-6/1.png&quot;&gt;&lt;br&gt;MethodClosure 中有一个 doCall 方法，调用 InvokerHelper.invokeMethod() 方法进行方法调用&lt;br&gt;&lt;img src=&quot;/img/24-6-6/2.png&quot;&gt;&lt;br&gt;这样就可以执行系统命令&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;MethodClosure&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;mc&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;MethodClosure&lt;/span&gt;(Runtime.getRun</summary>
      
    
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
    <category term="Groovy" scheme="https://yyjccc.github.io/tags/Groovy/"/>
    
    <category term="反序列化漏洞" scheme="https://yyjccc.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch</title>
    <link href="https://yyjccc.github.io/2024/06/02/Elasticsearch/"/>
    <id>https://yyjccc.github.io/2024/06/02/Elasticsearch/</id>
    <published>2024-06-02T09:57:22.194Z</published>
    <updated>2024-06-02T10:06:58.604Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Elasticsearch&quot;&gt;&lt;a href=&quot;#Elasticsearch&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch&quot;&gt;&lt;/a&gt;Elasticsearch&lt;/h1&gt;&lt;p&gt;基于java编写的Lucence的一层封装&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;Elasticsearch是面向文档的，关系行数据库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引（indices）:对应mysql中的数据库&lt;/li&gt;
&lt;li&gt;types: 对应表 &lt;/li&gt;
&lt;li&gt;documents: 对应mysql中行&lt;/li&gt;
&lt;li&gt;fields:  对应mysql中的字段&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;物理设计&lt;/strong&gt;：&lt;br&gt;        elasticsearch 在后台把每个索引划分成多个分片，每份分片可以在集群中的不同服务器间迁移&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逻辑设计&lt;/strong&gt;：&lt;br&gt;        一个索引类型中，包含多个文档，比如说文档1，文档2。 当我们索引一篇文档时，可以通过这样的一个顺序找到 它: 索引 ▷ 类型 ▷ 文档ID ，通过这个组合我们就能索引到某个具体的文档。 注意 : ID不必是整数，实际上它是个字符串。&lt;/p&gt;
&lt;h3 id=&quot;文档&quot;&gt;&lt;a href=&quot;#文档&quot; class=&quot;headerlink&quot; title=&quot;文档&quot;&gt;&lt;/a&gt;文档&lt;/h3&gt;&lt;p&gt;&lt;em&gt;文档就是一条一条的数据&lt;/em&gt;&lt;br&gt;         elasticsearch 是面向文档的，那么就意味着索引和搜索数据的最小单位是文档，elasticsearch 中，文档有几个 重要属性 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;自我包含&lt;/strong&gt;，一篇文档同时包含字段和对应的值，也就是同时包含 key:value！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;可以是层次型的&lt;/strong&gt;，一个文档中包含自文档，复杂的逻辑实体就是这么来的！其实就是个JSON对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;灵活的结构&lt;/strong&gt;，文档不依赖预先定义</summary>
      
    
    
    
    
    <category term="开发" scheme="https://yyjccc.github.io/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Elasticsearch" scheme="https://yyjccc.github.io/tags/Elasticsearch/"/>
    
    <category term="java" scheme="https://yyjccc.github.io/tags/java/"/>
    
    <category term="数据库" scheme="https://yyjccc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>幽默的Commons-Collections6调试</title>
    <link href="https://yyjccc.github.io/2024/05/14/%E5%B9%BD%E9%BB%98%E7%9A%84Commons-Collections6%E8%B0%83%E8%AF%95/"/>
    <id>https://yyjccc.github.io/2024/05/14/%E5%B9%BD%E9%BB%98%E7%9A%84Commons-Collections6%E8%B0%83%E8%AF%95/</id>
    <published>2024-05-14T12:28:03.574Z</published>
    <updated>2024-05-14T12:38:30.089Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;幽默的Commons-Collections6调试&quot;&gt;&lt;a href=&quot;#幽默的Commons-Collections6调试&quot; class=&quot;headerlink&quot; title=&quot;幽默的Commons-Collections6调试&quot;&gt;&lt;/a&gt;幽默的Commons-Collections6调试&lt;/h1&gt;&lt;p&gt;事情是在考完期中之后，同学在调式cc6链的时候发现了奇怪问题。&lt;/p&gt;
&lt;p&gt;（下面写的过于详细了。。。）&lt;/p&gt;
&lt;h2 id=&quot;问题发现&quot;&gt;&lt;a href=&quot;#问题发现&quot; class=&quot;headerlink&quot; title=&quot;问题发现&quot;&gt;&lt;/a&gt;问题发现&lt;/h2&gt;&lt;p&gt;（在尝试找出cc6中 为什么LazyMap 最后要使用remove的时候）&lt;br&gt;&lt;img src=&quot;/img/24-5-14/1.png&quot;&gt;&lt;br&gt;就是lazyMap中放的是空的HashMap&lt;br&gt;之前代码并没有向hashMap中写入任何东西，为什么在这里却必须要remove掉’aaa’才能触发链子呢&lt;/p&gt;
&lt;p&gt;于是调试&lt;br&gt;&lt;img src=&quot;/img/24-5-14/2.png&quot;&gt;&lt;br&gt;在创建TiedMapEntry的地方打上断点，跟进&lt;br&gt;&lt;img src=&quot;/img/24-5-14/3.png&quot;&gt;&lt;br&gt;赋值完map的时候还算是正常&lt;br&gt;可是到下一步&lt;br&gt;&lt;img src=&quot;/img/24-5-14/4.png&quot;&gt;&lt;br&gt;参数map的size大小怎么突然由1变成2了？又没有对map进行任何操作&lt;br&gt;这里LazyMap为什么多了且是什么时候多了一个键值对的？&lt;br&gt;&lt;img src=&quot;/img/24-5-14/5.png&quot;&gt;&lt;br&gt;难道后面remove移除的键值对是这个时候添加上去的吗？&lt;/p&gt;
&lt;p&gt;上面发现这个问题的时候，我去翻了翻以前的笔记：&lt;br&gt;&lt;img src=&quot;/img/24-5-14/6.png&quot;&gt;&lt;br&gt;当时其实也是没搞懂，就描述了情况，并没有想明白&lt;br&gt;（好像也是在网上没找到提到过的文章）&lt;/p&gt;
&lt;h2 id=&quot;问题调试&quot;&gt;&lt;a href=&quot;#问题调试&quot; class=&quot;headerlink&quot; title=&quot;问题调试&quot;&gt;&lt;/a&gt;问题调试&lt;/h2&gt;&lt;p&gt;可能对于刚学java反序列化漏洞不久的来说，可能对这种情况就毫无头绪&lt;br&gt;但凭着我</summary>
      
    
    
    
    <category term="Life" scheme="https://yyjccc.github.io/categories/Life/"/>
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
    <category term="life" scheme="https://yyjccc.github.io/tags/life/"/>
    
    <category term="cc链" scheme="https://yyjccc.github.io/tags/cc%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat 漏洞复现集合</title>
    <link href="https://yyjccc.github.io/2024/05/13/Tomcat-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/"/>
    <id>https://yyjccc.github.io/2024/05/13/Tomcat-%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E9%9B%86%E5%90%88/</id>
    <published>2024-05-13T09:21:13.735Z</published>
    <updated>2024-05-13T09:29:01.076Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Tomcat-漏洞复现集合&quot;&gt;&lt;a href=&quot;#Tomcat-漏洞复现集合&quot; class=&quot;headerlink&quot; title=&quot;Tomcat 漏洞复现集合&quot;&gt;&lt;/a&gt;Tomcat 漏洞复现集合&lt;/h1&gt;&lt;p&gt;&lt;em&gt;Tomcat是常见的web中间间，常用于javaweb&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。&lt;br&gt;Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应HTML（标准通用标记语言下的一个应用）页面的访问请求。实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。&lt;br&gt;诀窍是，当配置正确时，Apache 为HTML页面服务，而Tomcat 实际上运行JSP 页面和Servlet。另外，Tomcat和IIS等Web服务器一样，具有处理HTML页面的功能，另外它还是一个Servlet和JSP容器，独立的Servlet容器是Tomcat的默认模式。不过，Tomcat处理静态HTML的能力不如Apache服务器。&lt;/p&gt;
&lt;h2 id=&quot;Tomcat-任意文件写入（CVE-2017-12615&quot;&gt;&lt;a href=&quot;#Tomcat-任意文件写入（CVE-2017-12615&quot; class=&quot;headerlink&quot; title=&quot;Tomcat 任意文件写入（CVE-2017-12615&quot;&gt;&lt;/a&gt;Tomcat 任意文件写入（CVE-2017-12615</summary>
      
    
    
    
    <category term="web安全" scheme="https://yyjccc.github.io/categories/web%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Tomcat" scheme="https://yyjccc.github.io/tags/Tomcat/"/>
    
    <category term="web中间件" scheme="https://yyjccc.github.io/tags/web%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="漏洞复现" scheme="https://yyjccc.github.io/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>shiro550</title>
    <link href="https://yyjccc.github.io/2024/05/06/shiro550-md-yyj/"/>
    <id>https://yyjccc.github.io/2024/05/06/shiro550-md-yyj/</id>
    <published>2024-05-05T16:41:47.441Z</published>
    <updated>2024-05-05T16:43:37.126Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;shiro550&quot;&gt;&lt;a href=&quot;#shiro550&quot; class=&quot;headerlink&quot; title=&quot;shiro550&quot;&gt;&lt;/a&gt;shiro550&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Apache Shiro是一个强大且易用的Java安全框架，执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API，您可以快速、轻松地获得任何应用程序，从最小的移动应用程序到最大的网络和企业应用程序。&lt;br&gt;Apache Shiro基本功能点如下图所示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Authentication&lt;/strong&gt;：身份认证 / 登录，验证用户是不是拥有相应的身份；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Authorization&lt;/strong&gt;：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Session&lt;/strong&gt; &lt;strong&gt;Management&lt;/strong&gt;：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Cryptography&lt;/strong&gt;：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Web Support&lt;/strong&gt;：Web 支持，可以非常容易的集成到 Web 环境；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Caching&lt;/strong&gt;：缓存，比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Concurrency&lt;/strong&gt;：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Testing&lt;/strong&gt;：提供测试支持；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Run As&lt;/strong</summary>
      
    
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
    <category term="java反序列化漏洞" scheme="https://yyjccc.github.io/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="shiro" scheme="https://yyjccc.github.io/tags/shiro/"/>
    
  </entry>
  
  <entry>
    <title>java Agent</title>
    <link href="https://yyjccc.github.io/2024/05/04/java-Agent/"/>
    <id>https://yyjccc.github.io/2024/05/04/java-Agent/</id>
    <published>2024-05-04T11:12:11.511Z</published>
    <updated>2024-05-04T11:20:00.178Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java-Agent&quot;&gt;&lt;a href=&quot;#java-Agent&quot; class=&quot;headerlink&quot; title=&quot;java Agent&quot;&gt;&lt;/a&gt;java Agent&lt;/h1&gt;&lt;p&gt;JDK1.5开始，Java新增了Instrumentation(Java Agent API)和JVMTI(JVM Tool Interface)功能，允许JVM在加载某个class文件之前对其字节码进行修改，同时也支持对已加载的class(类字节码)进行重新加载(Retransform)。&lt;br&gt;利用Java Agent这一特性衍生出了APM(Application Performance Management，应用性能管理)、RASP(Runtime application self-protection，运行时应用自我保护)、IAST(Interactive Application Security Testing，交互式应用程序安全测试)等相关产品，它们都无一例外的使用了Instrumentation/JVMTI的API来实现动态修改Java类字节码并插入监控或检测代码。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Java Agent 本质上可以理解为一个插件，该插件就是一个精心提供的 Jar 包。只是启动方式和普通 Jar 包有所不同，对于普通的 Jar 包，通过指定类的 main 函数进行启动。但是 Java Agent 并不能单独启动，必须依附在一个 Java 应用程序运行，在面向切面编程方面应用比较广泛&lt;/p&gt;
&lt;p&gt;Java Agent 的 Jar 包通过 JVMTI（JVM Tool Interface）完成加载，最终借助 JPLISAgent（Java Programming Language Instrumentation Services Agent）完成对目标代码的修改。主要功能如下：&lt;/p&gt;
&lt;p&gt;可以在加载 Java 文件之前做拦截把字节码做修改&lt;br&gt;可以在运行期将已经加载的类的字节码做变更&lt;br&gt;在 JDK1.5 版本开始，Java 增加了 Instrumentation（Java Agent API）和 JVMTI（JVM </summary>
      
    
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="java" scheme="https://yyjccc.github.io/tags/java/"/>
    
    <category term="Agent" scheme="https://yyjccc.github.io/tags/Agent/"/>
    
  </entry>
  
  <entry>
    <title>fastjson高版本补丁绕过</title>
    <link href="https://yyjccc.github.io/2024/04/27/fastjson%E9%AB%98%E7%89%88%E6%9C%AC%E8%A1%A5%E4%B8%81%E7%BB%95%E8%BF%87/"/>
    <id>https://yyjccc.github.io/2024/04/27/fastjson%E9%AB%98%E7%89%88%E6%9C%AC%E8%A1%A5%E4%B8%81%E7%BB%95%E8%BF%87/</id>
    <published>2024-04-26T17:01:59.320Z</published>
    <updated>2024-07-18T02:28:00.518Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;fastjson高版本补丁绕过&quot;&gt;&lt;a href=&quot;#fastjson高版本补丁绕过&quot; class=&quot;headerlink&quot; title=&quot;fastjson高版本补丁绕过&quot;&gt;&lt;/a&gt;fastjson高版本补丁绕过&lt;/h1&gt;&lt;h2 id=&quot;补丁分析&quot;&gt;&lt;a href=&quot;#补丁分析&quot; class=&quot;headerlink&quot; title=&quot;补丁分析&quot;&gt;&lt;/a&gt;补丁分析&lt;/h2&gt;&lt;h3 id=&quot;1-2-25&quot;&gt;&lt;a href=&quot;#1-2-25&quot; class=&quot;headerlink&quot; title=&quot;1.2.25&quot;&gt;&lt;/a&gt;1.2.25&lt;/h3&gt;&lt;p&gt;在 Fastjson1.2.25 中使用了 checkAutoType 来修复1.2.22-1.2.24中的漏洞，其中有个 autoTypeSupport 默认为 False。当 autoTypeSupport 为 False 时，先黑名单过滤，再白名单过滤，若白名单匹配上则直接加载该类，否则报错。当 autoTypeSupport 为 True 时，先白名单过滤，匹配成功即可加载该类，否则再黑名单过滤。对于开启或者不开启，都有相应的绕过方法。&lt;/p&gt;
&lt;p&gt;在获取@type的值后，1.2.24以后的版本新增函数checkAutoType,在类加载之前检查是否允许加载&lt;br&gt;&lt;img src=&quot;/img/24-7-18/1.png&quot;&gt;&lt;br&gt;进入ParseConfig#checkAutoType&lt;br&gt;在尝试取缓存无法取到的时候，&lt;br&gt;先进行黑名单过滤，类名不能是以黑名单的开头&lt;br&gt;&lt;img src=&quot;/img/24-7-18/2.png&quot;&gt;&lt;br&gt;黑名单&lt;br&gt;&lt;img src=&quot;/img/24-7-18/3.png&quot;&gt;&lt;br&gt;那基本就是被黑名单限制了，导致异常提前退出异常&lt;br&gt;若是手动开启了AutoType，那么就是先白名单，再黑名单，再取缓存&lt;br&gt;&lt;img src=&quot;/img/24-7-18/4.png&quot;&gt;&lt;br&gt;流程图&lt;br&gt;&lt;img src=&quot;/img/24-7-18/5.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-2-42&quot;&gt;&lt;a href=&quot;#1-2-42&quot; class=&quot;headerlink&quot; title=&quot;1.2.42&quot;&gt;&lt;/a&gt;1.2.42&lt;/h3&gt;&lt;p&gt;1.2.42相较于之前的版本，关键是在</summary>
      
    
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="web安全" scheme="https://yyjccc.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
    <category term="fastjson" scheme="https://yyjccc.github.io/tags/fastjson/"/>
    
  </entry>
  
  <entry>
    <title>fastjson1.2.24反序列化漏洞</title>
    <link href="https://yyjccc.github.io/2024/04/26/fastjson1-2-24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://yyjccc.github.io/2024/04/26/fastjson1-2-24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-04-25T16:49:55.337Z</published>
    <updated>2024-04-26T12:43:16.858Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;fastjson1-2-24反序列化漏洞&quot;&gt;&lt;a href=&quot;#fastjson1-2-24反序列化漏洞&quot; class=&quot;headerlink&quot; title=&quot;fastjson1.2.24反序列化漏洞&quot;&gt;&lt;/a&gt;fastjson1.2.24反序列化漏洞&lt;/h1&gt;&lt;h2 id=&quot;影响版本&quot;&gt;&lt;a href=&quot;#影响版本&quot; class=&quot;headerlink&quot; title=&quot;影响版本&quot;&gt;&lt;/a&gt;影响版本&lt;/h2&gt;&lt;p&gt;Fastjson 1.2.x系列的1.2.22-1.2.24版本。&lt;/p&gt;
&lt;h2 id=&quot;TemplateImpl的利用链&quot;&gt;&lt;a href=&quot;#TemplateImpl的利用链&quot; class=&quot;headerlink&quot; title=&quot;TemplateImpl的利用链&quot;&gt;&lt;/a&gt;TemplateImpl的利用链&lt;/h2&gt;&lt;h3 id=&quot;条件&quot;&gt;&lt;a href=&quot;#条件&quot; class=&quot;headerlink&quot; title=&quot;条件&quot;&gt;&lt;/a&gt;条件&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;服务端使用parseObject()时，必须使用如下格式才能触发漏洞： JSON.parseObject(input, Object.class, Feature.SupportNonPublicField);&lt;/li&gt;
&lt;li&gt;服务端使用parse()时，需要 JSON.parse(text1,Feature.SupportNonPublicField)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;流程&lt;br&gt;&lt;img src=&quot;/img/4-26/1.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;poc&quot;&gt;&lt;a href=&quot;#poc&quot; class=&quot;headerlink&quot; title=&quot;poc&quot;&gt;&lt;/a&gt;poc&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;evilCode&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; Base64.encodeBase64String(Calc.getCodeByte());&lt;/s</summary>
      
    
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
    <category term="反序列化漏洞" scheme="https://yyjccc.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="fastjson" scheme="https://yyjccc.github.io/tags/fastjson/"/>
    
  </entry>
  
  <entry>
    <title>Linux应急响应</title>
    <link href="https://yyjccc.github.io/2024/04/25/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    <id>https://yyjccc.github.io/2024/04/25/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</id>
    <published>2024-04-25T07:23:34.915Z</published>
    <updated>2024-04-25T16:53:44.090Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux应急响应&quot;&gt;&lt;a href=&quot;#Linux应急响应&quot; class=&quot;headerlink&quot; title=&quot;Linux应急响应&quot;&gt;&lt;/a&gt;Linux应急响应&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;关键目录&lt;br&gt;&lt;img src=&quot;/img/4-25/1.png&quot;&gt;&lt;br&gt;思路：&lt;br&gt;账号安全 -&amp;gt; 历史命令 -&amp;gt; 检查异常端口 -&amp;gt; 检查异常进程 -&amp;gt; 检查开机启动项 -&amp;gt; 检查定时任务 -&amp;gt; 检查服务 -&amp;gt; 检查异常文件&lt;/p&gt;
&lt;h2 id=&quot;主机排查&quot;&gt;&lt;a href=&quot;#主机排查&quot; class=&quot;headerlink&quot; title=&quot;主机排查&quot;&gt;&lt;/a&gt;主机排查&lt;/h2&gt;&lt;h3 id=&quot;常见指令&quot;&gt;&lt;a href=&quot;#常见指令&quot; class=&quot;headerlink&quot; title=&quot;常见指令&quot;&gt;&lt;/a&gt;常见指令&lt;/h3&gt;&lt;h4 id=&quot;端口&quot;&gt;&lt;a href=&quot;#端口&quot; class=&quot;headerlink&quot; title=&quot;端口&quot;&gt;&lt;/a&gt;端口&lt;/h4&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta prompt_&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt;查找不常用的监听端口 :&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;netstat -anp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iftop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta prompt_&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta prompt_&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt;运行的进程监听了端口 :&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;lsof -i&lt;/span&gt;&lt;br</summary>
      
    
    
    
    <category term="蓝队" scheme="https://yyjccc.github.io/categories/%E8%93%9D%E9%98%9F/"/>
    
    
    <category term="Liunx" scheme="https://yyjccc.github.io/tags/Liunx/"/>
    
    <category term="应急响应" scheme="https://yyjccc.github.io/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
    
    <category term="蓝队" scheme="https://yyjccc.github.io/tags/%E8%93%9D%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>JNDI注入</title>
    <link href="https://yyjccc.github.io/2024/04/24/JNDI%E6%B3%A8%E5%85%A5/"/>
    <id>https://yyjccc.github.io/2024/04/24/JNDI%E6%B3%A8%E5%85%A5/</id>
    <published>2024-04-23T16:09:46.525Z</published>
    <updated>2024-04-23T16:16:58.253Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JNDI注入&quot;&gt;&lt;a href=&quot;#JNDI注入&quot; class=&quot;headerlink&quot; title=&quot;JNDI注入&quot;&gt;&lt;/a&gt;JNDI注入&lt;/h1&gt;&lt;p&gt;JNDI(Java Naming and Directory Interface)是Java提供的Java命名和目录接口。通过调用JNDI的API可以定位资源和其他程序对象。&lt;br&gt;JNDI是Java EE的重要部分，JNDI可访问的现有的目录及服务有:JDBC、LDAP、RMI、DNS、NIS、CORBA&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;JNDI提供统一的客户端API，并由管理者将JNDI API映射为特定的&lt;strong&gt;命名服务&lt;/strong&gt;和&lt;strong&gt;目录服务&lt;/strong&gt;，为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定义用户、网络、机器、对象和服务等各种资源。简单来说，开发人员通过合理的使用JNDI，能够让用户通过统一的方式访问获取网络上的各种资源和服务。如下图所示&lt;br&gt;&lt;img src=&quot;/img/4-24/1.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;命名服务&quot;&gt;&lt;a href=&quot;#命名服务&quot; class=&quot;headerlink&quot; title=&quot;命名服务&quot;&gt;&lt;/a&gt;命名服务&lt;/h3&gt;&lt;p&gt;(Naming server)&lt;br&gt;命名服务将名称和对象进行关联，提供通过名称找到对象的操作，例如：DNS系统将计算机名和IP地址进行关联、文件系统将文件名和文件句柄进行关联等等。&lt;br&gt;在一些命名服务系统中，系统并不是直接将对象存储在系统中，而是保持对象的引用。引用包含了如何访问实际对象的信息。&lt;br&gt;    其中另一个值得一提的名称服务为 LDAP，全称为 Lightweight Directory Access Protocol，即轻量级目录访问协议，其名称也是从右到左进行逐级定义，各级以逗号分隔，每级为一个 name/value 对，以等号分隔。比如一个 LDAP 名称如下:&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla</summary>
      
    
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="web安全" scheme="https://yyjccc.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
    <category term="java安全" scheme="https://yyjccc.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
    <category term="jndi" scheme="https://yyjccc.github.io/tags/jndi/"/>
    
  </entry>
  
  <entry>
    <title>javassist</title>
    <link href="https://yyjccc.github.io/2024/04/12/Javassist/"/>
    <id>https://yyjccc.github.io/2024/04/12/Javassist/</id>
    <published>2024-04-12T02:48:43.935Z</published>
    <updated>2024-04-12T03:19:29.053Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Javassist&quot;&gt;&lt;a href=&quot;#Javassist&quot; class=&quot;headerlink&quot; title=&quot;Javassist&quot;&gt;&lt;/a&gt;Javassist&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Javassist（Java 编程助手）使 Java 字节码操作变得简单。它是一个用于在 Java 中编辑字节码的类库。它使 Java 程序可以在运行时定义新类，并在 JVM 加载它时修改类文件。与其他类似的字节码编辑器不同，Javassist 提供了两个级别的 API：源级别和字节代码级别。如果用户使用源代码级 API，则他们可以在不了解 Java 字节码规范的情况下编辑类文件。整个 API 仅使用 Java 语言的词汇表进行设计。甚至可以以源文本的形式指定插入的字节码。Javassist 可以即时对其进行编译。另一方面，字节码级别的 API 允许用户像其他编辑器一样直接编辑类文件&lt;/p&gt;
&lt;p&gt;Javassist 是用于编辑（创建，修改）.class字节码文件的 Java 库，一般情况下我们都是在.java文件中写代码，然后编译成.class文件，在加载进 Java 虚拟机中执行代码，如果要修改已编译好的文件，要使用010 Editor去手动的计算一些偏移值进行修改，但是 Javassist 的出现，使得我们操作.class文件变得简单，并且可以在 Java 虚拟机 JVM 运行时动态地改变.class文件&lt;/p&gt;
&lt;p&gt;依赖&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=</summary>
      
    
    
    
    
    <category term="java" scheme="https://yyjccc.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Rome链</title>
    <link href="https://yyjccc.github.io/2024/04/11/Rome%E9%93%BE/"/>
    <id>https://yyjccc.github.io/2024/04/11/Rome%E9%93%BE/</id>
    <published>2024-04-11T03:04:05.520Z</published>
    <updated>2024-04-23T16:22:26.785Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Rome反序列化&quot;&gt;&lt;a href=&quot;#Rome反序列化&quot; class=&quot;headerlink&quot; title=&quot;Rome反序列化&quot;&gt;&lt;/a&gt;Rome反序列化&lt;/h1&gt;&lt;p&gt;&lt;a name=&quot;X3E3n&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;ROME 是一个可以兼容多种格式的 feeds 解析器，可以从一种格式转换成另一种格式，也可返回指定格式或 Java 对象。ROME 兼容了 RSS (0.90, 0.91, 0.92, 0.93, 0.94, 1.0, 2.0), Atom 0.3 以及 Atom 1.0 feeds 格式。&lt;br&gt;Rome 提供了 &lt;strong&gt;ToStringBean&lt;/strong&gt; 这个类，提供深入的 toString 方法对JavaBean进行操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;漏洞原理&lt;/strong&gt;&lt;br&gt;漏洞核心应该是ROME框架里的&lt;strong&gt;com.sun.syndication.feed.impl.ToStringBean&lt;/strong&gt;类利用反射执行了invoke方法，并且参数可控&lt;br&gt;&lt;img src=&quot;/img/4-11/1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;依赖&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; &amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;lt;groupId&amp;gt;rome&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;lt;artifactId&amp;gt;rome&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;lt;version&amp;gt;&lt;span class=&quot;number&quot;&gt;1.0&lt;/span&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;b</summary>
      
    
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
    <category term="反序列化" scheme="https://yyjccc.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    <category term="rome" scheme="https://yyjccc.github.io/tags/rome/"/>
    
  </entry>
  
  <entry>
    <title>反向传播</title>
    <link href="https://yyjccc.github.io/2024/03/25/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/"/>
    <id>https://yyjccc.github.io/2024/03/25/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD/</id>
    <published>2024-03-25T15:40:35.380Z</published>
    <updated>2024-04-11T03:07:51.549Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;反向传播&quot;&gt;&lt;a href=&quot;#反向传播&quot; class=&quot;headerlink&quot; title=&quot;反向传播&quot;&gt;&lt;/a&gt;反向传播&lt;/h1&gt;&lt;p&gt;&lt;a name=&quot;SMMHj&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95&quot;&gt;反向传播&lt;/a&gt;（英语：Backpropagation，缩写为BP）是“误差反向传播”的简称，是一种与最优化方法（如梯度下降法）结合使用的，用来&lt;strong&gt;训练人工神经网络&lt;/strong&gt;的常见方法。该方法对网络中所有权重&lt;strong&gt;计算损失函数的梯度&lt;/strong&gt;。这个梯度会反馈给最优化方法，用来更新权值以最小化损失函数。&lt;br&gt;反向传播要求有对每个输入值想得到的已知输出，来计算损失函数梯度。因此，它通常被认为是一种监督式学习方法，虽然它也用在一些无监督网络（如自动编码器）中。它是多层前馈网络的Delta规则的推广，可以用&lt;strong&gt;链式法则&lt;/strong&gt;对每层迭代计算梯度。反向传播要求人工神经元（或“节点”）的&lt;strong&gt;激励函数&lt;/strong&gt;可微。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;RbIqB&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;梯度下降与损失函数&quot;&gt;&lt;a href=&quot;#梯度下降与损失函数&quot; class=&quot;headerlink&quot; title=&quot;梯度下降与损失函数&quot;&gt;&lt;/a&gt;梯度下降与损失函数&lt;/h2&gt;&lt;p&gt;  损失函数，(Loss Function）在机器学习中的每一种算法中都很重要，因为训练模型的过程就是优化损失函数的过程，损失函数对每个参数的偏导数就是梯度下降中提到的梯度，防止过拟合时添加的正则化项也是加在损失函数后面的。&lt;br&gt;损失函数非常好理解，我觉得其实就是，反映神经网络输出的结果与训练样本的y之间的差别的函数（其中输入变量是神经网络的权重参数）。这个函数要具有一些特性，一般情况下，我们要尽可能的最小化损失函数，寻找损失函数的全局最小值，&lt;/p&gt;
&lt;p&gt;为了完成梯度下降&lt;br&gt;&lt;img src=&quot;</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://yyjccc.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="深度学习" scheme="https://yyjccc.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="神经网络" scheme="https://yyjccc.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
    <category term="算法" scheme="https://yyjccc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>RMI机制</title>
    <link href="https://yyjccc.github.io/2024/03/18/RMI%E6%9C%BA%E5%88%B6/"/>
    <id>https://yyjccc.github.io/2024/03/18/RMI%E6%9C%BA%E5%88%B6/</id>
    <published>2024-03-18T09:51:08.450Z</published>
    <updated>2024-04-23T16:31:39.663Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RMI机制&quot;&gt;&lt;a href=&quot;#RMI机制&quot; class=&quot;headerlink&quot; title=&quot;RMI机制&quot;&gt;&lt;/a&gt;RMI机制&lt;/h1&gt;&lt;p&gt;&lt;a name=&quot;TME8K&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt; RMI（Remote Method Invocation）为远程方法调用，是允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上的对象的方法。 这两个虚拟机可以是运行在相同计算机上的不同进程中，也可以是运行在&lt;strong&gt;网络上的不同计算机中,&lt;strong&gt;它的底层是由&lt;/strong&gt;socket&lt;/strong&gt;和&lt;strong&gt;java序列化和反序列化&lt;/strong&gt;支撑起来的。  &lt;br&gt;它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。&lt;/p&gt;
&lt;p&gt;我们知道远程过程调用（Remote Procedure Call, RPC）可以用于一个进程调用另一个进程（很可能在另一个远程主机上）中的过程，从而提供了过程的分布能力。Java 的 RMI 则在 RPC 的基础上向前又迈进了一步，即提供分布式对象间的通讯。&lt;/p&gt;
&lt;p&gt;RMI依赖的通信协议为JRMP(Java Remote Message Protocol ，Java 远程消息交换协议)，该协议为Java定制，要求服务端与客户端都为Java编写。这个协议就像HTTP协议一样，规定了客户端和服务端通信要满足的规范。在RMI中对象是通过序列化方式进行编码传输的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Client-客户端：客户端调用服务端的方法&lt;/li&gt;
&lt;li&gt;Server-服务端：远程调用方法对象的提供者，也是代码真正执行的地方，执行结束会返回给客户端一个方法执行的结果&lt;/li&gt;
&lt;li&gt;Registry-注册中心：其实本质就是一个map，相当于是字典一样，用于客户端查询要调用的方法的引用（在低版本的JDK中，Server与Registry是可以不在一台服务器上的，而在高版本的JDK中，Server与Registry只能在一台服务器上，否则</summary>
      
    
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="web安全" scheme="https://yyjccc.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
    <category term="java安全" scheme="https://yyjccc.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
    <category term="RMI" scheme="https://yyjccc.github.io/tags/RMI/"/>
    
  </entry>
  
  <entry>
    <title>内存马Tomcat回显</title>
    <link href="https://yyjccc.github.io/2024/03/16/%E5%86%85%E5%AD%98%E9%A9%ACTomcat%E5%9B%9E%E6%98%BE/"/>
    <id>https://yyjccc.github.io/2024/03/16/%E5%86%85%E5%AD%98%E9%A9%ACTomcat%E5%9B%9E%E6%98%BE/</id>
    <published>2024-03-16T10:46:19.806Z</published>
    <updated>2024-04-23T16:32:06.560Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存马Tomcat回显&quot;&gt;&lt;a href=&quot;#内存马Tomcat回显&quot; class=&quot;headerlink&quot; title=&quot;内存马Tomcat回显&quot;&gt;&lt;/a&gt;内存马Tomcat回显&lt;/h1&gt;&lt;p&gt;所谓回显，其实就是获取命令执行的结果，这种技术常用于目标机器不出网，无法反弹shell的情况。&lt;strong&gt;其实关键就是获取request和response对象&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://goodapple.top/archives/1355&quot;&gt;Java安全学习——内存马 - 枫のBlog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://johnfrod.top/%e5%ae%89%e5%85%a8/java-%e5%9b%9e%e6%98%be%e6%8a%80%e6%9c%af/&quot;&gt;https://johnfrod.top/%e5%ae%89%e5%85%a8/java-%e5%9b%9e%e6%98%be%e6%8a%80%e6%9c%af/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xz.aliyun.com/t/12494&quot;&gt;https://xz.aliyun.com/t/12494&lt;/a&gt;&lt;br&gt;&lt;a name=&quot;MpGXn&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;p&gt;我们以上文提到的Tomcat Filter内存马为例，获取对应的回显，关键代码如下&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;%! &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;Shell_Filter&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;</summary>
      
    
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
    <category term="内存马" scheme="https://yyjccc.github.io/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    
    <category term="Tomcat" scheme="https://yyjccc.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>线性回归</title>
    <link href="https://yyjccc.github.io/2024/03/12/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>https://yyjccc.github.io/2024/03/12/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</id>
    <published>2024-03-12T15:45:59.877Z</published>
    <updated>2024-03-12T15:59:32.457Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线性回归（Linear-Regression）&quot;&gt;&lt;a href=&quot;#线性回归（Linear-Regression）&quot; class=&quot;headerlink&quot; title=&quot;线性回归（Linear Regression）&quot;&gt;&lt;/a&gt;线性回归（Linear Regression）&lt;/h1&gt;&lt;p&gt;机器学习中的两大类问题：回归问题和分类问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;回归问题就是进行预测，如股票、房价预测&lt;br&gt;分类问题就是将多个事物进行分类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;线性回归是一种用于预测连续数值输出的监督学习算法，它通过建立一个线性方程来描述输入变量与输出变量之间的关系。该算法的目标是使预测值与真实值之间的差异最小化。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;u4Zwx&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;线性回归是通过&lt;strong&gt;一个或多个自变量与因变量&lt;/strong&gt;之间进行建模的回归分析，其特点为一个或多个称为回归系数的模型参数的线性组合。样本点为历史数据，&lt;strong&gt;回归曲线要能最贴切的模拟样本点的趋势，将误差降到最小&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;Inoua&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;线性回归方程&quot;&gt;&lt;a href=&quot;#线性回归方程&quot; class=&quot;headerlink&quot; title=&quot;线性回归方程&quot;&gt;&lt;/a&gt;线性回归方程&lt;/h3&gt;&lt;p&gt; 线形回归方程，就是有 &lt;strong&gt;n&lt;/strong&gt; 个特征，然后每个特征 **Xi **都有相应的系数 **Wi **，并且在所有特征值为0的情况下，目标值有一个默认值 **W0 **，因此：&lt;br&gt;&lt;img src=&quot;/img/3-13/1.svg&quot;&gt;&lt;br&gt;&lt;strong&gt;整合后的公式为&lt;/strong&gt;：&lt;/p&gt;
&lt;img src=&quot;/img/3-13/2.svg&quot;&gt;

&lt;p&gt;&lt;a name=&quot;ETAVk&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;损失函数&quot;&gt;&lt;a href=&quot;#损失函数&quot; class=&quot;headerlink&quot; title=&quot;损失函数&quot;&gt;&lt;/a&gt;损失函数&lt;/h2&gt;&lt;p&gt;&lt;a name=&quot;NmYVp&quot;&gt;</summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://yyjccc.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="算法" scheme="https://yyjccc.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="线性回归" scheme="https://yyjccc.github.io/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>Spring内存马</title>
    <link href="https://yyjccc.github.io/2024/03/12/Spring%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    <id>https://yyjccc.github.io/2024/03/12/Spring%E5%86%85%E5%AD%98%E9%A9%AC/</id>
    <published>2024-03-12T02:14:53.901Z</published>
    <updated>2024-04-23T16:32:21.544Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring内存马&quot;&gt;&lt;a href=&quot;#Spring内存马&quot; class=&quot;headerlink&quot; title=&quot;Spring内存马&quot;&gt;&lt;/a&gt;Spring内存马&lt;/h1&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://goodapple.top/archives/1355&quot;&gt;Java安全学习——内存马 - 枫のBlog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xz.aliyun.com/t/12047?time__1311=mqmhBKD50KAIKiqGNDQbiQ5SYrhnmqAxGOeD&amp;amp;alichlgref=https://cn.bing.com/&quot;&gt;Spring内存马——Controller/Interceptor构造 - 先知社区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/mole_exp/article/details/123992395&quot;&gt;Java内存马-SpringMVC篇_”expected lookuppath in request attribute &#92;“org.sp-CSDN博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在学习spring内存马的时候，最好知道spring、springmvc、springboot的开发知识和基本使用，下面就不多介绍基础的开发知识&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;p&gt;依赖&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &amp;lt;artifactId&amp;gt;spring-context&amp;l</summary>
      
    
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="web安全" scheme="https://yyjccc.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
    <category term="java安全" scheme="https://yyjccc.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
    <category term="内存马" scheme="https://yyjccc.github.io/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    
    <category term="Spring" scheme="https://yyjccc.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat内存马</title>
    <link href="https://yyjccc.github.io/2024/03/06/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    <id>https://yyjccc.github.io/2024/03/06/Tomcat%E5%86%85%E5%AD%98%E9%A9%AC/</id>
    <published>2024-03-06T15:54:32.706Z</published>
    <updated>2024-04-23T16:31:55.089Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Tomcat内存马&quot;&gt;&lt;a href=&quot;#Tomcat内存马&quot; class=&quot;headerlink&quot; title=&quot;Tomcat内存马&quot;&gt;&lt;/a&gt;Tomcat内存马&lt;/h1&gt;&lt;p&gt;前置知识：&lt;a href=&quot;https://www.yuque.com/yyjccc/pk74ko/ksyiwpex52m9tkdi?view=doc_embed&quot;&gt;Tomcat架构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;br&gt;&lt;a href=&quot;https://goodapple.top/archives/1355&quot;&gt;Java安全学习——内存马 - 枫のBlog&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://drun1baby.top/2022/08/27/Java%E5%86%85%E5%AD%98%E9%A9%AC%E7%B3%BB%E5%88%97-04-Tomcat-%E4%B9%8B-Listener-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/&quot;&gt;Java内存马系列-04-Tomcat 之 Listener 型内存马 | Drunkbaby’s Blog&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://su18.org/post/memory-shell/&quot;&gt;https://su18.org/post/memory-shell/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;就是根据Tomcat的三大件servlet、linstener、filter注入内存马，Servlet在3.0版本之后能够支持动态注册组件。而Tomcat直到7.x才支持Servlet3.0，因此通过动态添加恶意组件注入内存马的方式适合Tomcat7.x及以上&lt;br&gt;调式时候需要导入对应tomcat版本的jar包&lt;br&gt;&lt;strong&gt;依赖&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;g</summary>
      
    
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
    <category term="内存马" scheme="https://yyjccc.github.io/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    
    <category term="Tomcat" scheme="https://yyjccc.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>sklearn与特征工程</title>
    <link href="https://yyjccc.github.io/2024/02/27/sklearn%E4%B8%8E%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    <id>https://yyjccc.github.io/2024/02/27/sklearn%E4%B8%8E%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/</id>
    <published>2024-02-27T14:59:01.549Z</published>
    <updated>2024-02-27T15:07:29.223Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sklearn与特征工程&quot;&gt;&lt;a href=&quot;#sklearn与特征工程&quot; class=&quot;headerlink&quot; title=&quot;sklearn与特征工程&quot;&gt;&lt;/a&gt;sklearn与特征工程&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h3 id=&quot;sklearn&quot;&gt;&lt;a href=&quot;#sklearn&quot; class=&quot;headerlink&quot; title=&quot;sklearn&quot;&gt;&lt;/a&gt;sklearn&lt;/h3&gt;&lt;p&gt;Scikit-learn（简称为 sklearn）是一个流行的 Python 机器学习库，用于在数据挖掘和数据分析领域中进行各种机器学习任务。它提供了简单而高效的工具，用于数据挖掘和数据分析，以及构建和评估各种机器学习模型。以下是关于 scikit-learn 的一些重要信息：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能特点&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;简单而一致的 API： Scikit-learn 提供了简单而一致的 API，使得用户可以方便地使用各种机器学习算法和工具。&lt;/li&gt;
&lt;li&gt;广泛的算法库： Scikit-learn 包含了大量的机器学习算法和工具，涵盖了分类、回归、聚类、降维、模型选择、预处理等多个方面。&lt;/li&gt;
&lt;li&gt;易于使用的工具： Scikit-learn 提供了各种易于使用的工具，如数据预处理、特征提取、模型评估等，使得用户能够更轻松地进行机器学习任务的建模和评估。&lt;/li&gt;
&lt;li&gt;高效的实现： Scikit-learn 的算法和工具都经过了高度优化和性能调整，以保证其在大规模数据集上的高效性和可扩展性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;主要模块&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sklearn.datasets： 包含了一些标准数据集，可以用于练习和测试机器学习算法。&lt;/li&gt;
&lt;li&gt;sklearn.preprocessing： 提供了数据预处理功能，如标准化、归一化、缺失值处理等。&lt;/li&gt;
&lt;li&gt;sklearn.feature_extraction： 提供了特征提取功能，如文本特征提取、图像特征提取等。&lt;/li&gt;
&lt;li&gt;sklearn.model_selection： </summary>
      
    
    
    
    
    <category term="机器学习" scheme="https://yyjccc.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="sklearn" scheme="https://yyjccc.github.io/tags/sklearn/"/>
    
    <category term="特征工程" scheme="https://yyjccc.github.io/tags/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B/"/>
    
    <category term="数据处理" scheme="https://yyjccc.github.io/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>C3P0链</title>
    <link href="https://yyjccc.github.io/2024/02/24/C3P0%E9%93%BE/"/>
    <id>https://yyjccc.github.io/2024/02/24/C3P0%E9%93%BE/</id>
    <published>2024-02-24T14:52:56.486Z</published>
    <updated>2024-04-23T16:32:50.446Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;参考：&lt;a href=&quot;https://goodapple.top/archives/1749&quot;&gt;Java安全学习——C3P0链 - 枫のBlog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;BScjw&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;C3P0介绍&quot;&gt;&lt;a href=&quot;#C3P0介绍&quot; class=&quot;headerlink&quot; title=&quot;C3P0介绍&quot;&gt;&lt;/a&gt;C3P0介绍&lt;/h1&gt;&lt;figure class=&quot;highlight text&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate，Spring等。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;JDBC是Java DataBase Connectivity的缩写，它是Java程序访问数据库的标准接口。&lt;br&gt;使用Java程序访问数据库时，Java代码并不是直接通过TCP连接去访问数据库，而是通过JDBC接口来访问，而JDBC接口则通过JDBC驱动来实现真正对数据库的访问。&lt;br&gt;连接池类似于线程池，在一些情况下我们会频繁地操作数据库，此时Java在连接数据库时会频繁地创建或销毁句柄，增大资源的消耗。为了避免这样一种情况，我们可以提前创建好一些连接句柄，需要使用时直接使用句柄，不需要时可将其放回连接池中，准备下一次的使用。类似这样一种能够复用句柄的技术就是池技术。&lt;/p&gt;
&lt;br&gt;
&lt;a name=&quot;vDNj8&quot;&gt;&lt;/a&gt;
# Gadget
&amp;gt; 导入依赖

&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;gro</summary>
      
    
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="web安全" scheme="https://yyjccc.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
    <category term="java安全" scheme="https://yyjccc.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
    <category term="反序列化" scheme="https://yyjccc.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>SnakeYaml反序列化漏洞</title>
    <link href="https://yyjccc.github.io/2024/01/22/SnakeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://yyjccc.github.io/2024/01/22/SnakeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-01-22T13:53:56.819Z</published>
    <updated>2024-07-29T02:05:54.378Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SnakeYaml反序列化漏洞&quot;&gt;&lt;a href=&quot;#SnakeYaml反序列化漏洞&quot; class=&quot;headerlink&quot; title=&quot;SnakeYaml反序列化漏洞&quot;&gt;&lt;/a&gt;SnakeYaml反序列化漏洞&lt;/h1&gt;&lt;p&gt;​	SnakeYaml 是java解析yaml格式的组件库，将yaml格式的数据转为java对象称为反序列化，反过来就是序列化。&lt;/p&gt;
&lt;p&gt;漏洞版本： 1.xx&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;A4pSC&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Yaml介绍&quot;&gt;&lt;a href=&quot;#Yaml介绍&quot; class=&quot;headerlink&quot; title=&quot;Yaml介绍&quot;&gt;&lt;/a&gt;Yaml介绍&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大小写敏感&lt;/li&gt;
&lt;li&gt;使用缩进表示层级关系&lt;/li&gt;
&lt;li&gt;缩进不允许使用tab，只允许空格&lt;/li&gt;
&lt;li&gt;缩进的空格数不重要，只要相同层级的元素左对齐即可&lt;/li&gt;
&lt;li&gt;‘#’表示注释&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;YAML 支持以下几种数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）&lt;/li&gt;
&lt;li&gt;数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）&lt;/li&gt;
&lt;li&gt;纯量（scalars）：单个的、不可再分的值，就是一些基本数据类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SnakeYaml 解析的时候看到的数据类型名字是mapping（映射）,sequence（序列）,scalars（纯量），而不是对象和数组&lt;/p&gt;
&lt;p&gt;在数据前添加   !!全类名 。表示强制转化数据类型。类似于fastjson中的 @type&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;tgSBe&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;SnakeYaml使用&quot;&gt;&lt;a href=&quot;#SnakeYaml使用&quot; class=&quot;headerlink&quot; title=&quot;SnakeYaml使用&quot;&gt;&lt;/a&gt;SnakeYaml使用&lt;/h2&gt;&lt;p&gt;导入依赖，springboot项目中自带依赖&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;t</summary>
      
    
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
    <category term="反序列化漏洞" scheme="https://yyjccc.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="web" scheme="https://yyjccc.github.io/tags/web/"/>
    
    <category term="SnakeYaml" scheme="https://yyjccc.github.io/tags/SnakeYaml/"/>
    
  </entry>
  
  <entry>
    <title>JDBC反序列化攻击</title>
    <link href="https://yyjccc.github.io/2023/12/26/jdbc%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://yyjccc.github.io/2023/12/26/jdbc%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2023-12-26T14:56:06.264Z</published>
    <updated>2024-04-23T16:31:21.939Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JDBC反序列化攻击&quot;&gt;&lt;a href=&quot;#JDBC反序列化攻击&quot; class=&quot;headerlink&quot; title=&quot;JDBC反序列化攻击&quot;&gt;&lt;/a&gt;JDBC反序列化攻击&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;JDBC（Java DataBase Connectivity）是一种用于执行Sql语句的Java Api，即Java数据库连接，是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，可以为多种关系数据库提供统一访问，提供了诸如查询和更新数据库中数据的方法，是Java访问数据库的标准规范。简单理解为链接数据库、对数据库操作都需要通过jdbc来实现。&lt;/p&gt;
&lt;p&gt;Mysql JDBC 中包含一个危险的扩展参数： “autoDeserialize”。这个参数配置为 true 时，JDBC 客户端将会自动反序列化服务端返回的数据，造成RCE漏洞。&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;JDBC定义了一个叫&lt;strong&gt;java.sql.Driver&lt;/strong&gt;的接口类负责实现对数据库的连接，所有的数据库驱动包都必须实现这个接口才能够完成数据库的连接操作。&lt;strong&gt;java.sql.DriverManager.getConnection(xxx)&lt;strong&gt;其实就是间接的调用了&lt;/strong&gt;java.sql.Driver&lt;/strong&gt;类的&lt;strong&gt;connect&lt;/strong&gt;方法实现数据库连接的。数据库连接成功后会返回一个叫做&lt;strong&gt;java.sql.Connection&lt;/strong&gt;的数据库连接对象，一切对数据库的查询操作都将依赖于这个&lt;strong&gt;Connection&lt;/strong&gt;对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当连接数据库的时候会执行内置的sql语句来确保连接成功&lt;/p&gt;
&lt;img src=&quot;/img/12-26/5.png&quot;&gt;

&lt;p&gt;当我们伪造返回数据为序列化数据时，使服务器触发反序列化&lt;/p&gt;
&lt;p&gt;入口点是&lt;c</summary>
      
    
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="web安全" scheme="https://yyjccc.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
    <category term="java安全" scheme="https://yyjccc.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
    <category term="反序列化漏洞" scheme="https://yyjccc.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>java类加载机制与应用</title>
    <link href="https://yyjccc.github.io/2023/12/10/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <id>https://yyjccc.github.io/2023/12/10/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%BA%94%E7%94%A8/</id>
    <published>2023-12-10T15:21:45.491Z</published>
    <updated>2023-12-10T15:36:27.857Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java类加载机制与应用&quot;&gt;&lt;a href=&quot;#java类加载机制与应用&quot; class=&quot;headerlink&quot; title=&quot;java类加载机制与应用&quot;&gt;&lt;/a&gt;java类加载机制与应用&lt;/h1&gt;&lt;p&gt;&lt;em&gt;学习类加载，有助于更好的进行攻击。如：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;使用冰蝎和哥斯拉的webshell，利用字节码加载的方式绕过&lt;strong&gt;waf&lt;/strong&gt;检测&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在其他反&lt;strong&gt;序列化&lt;/strong&gt;漏洞（比如fastjson反序列化漏洞）中的利用链中使用&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我的感受：&lt;/p&gt;
&lt;p&gt;   开始学java时候学这些东西的时候，我确实搞得一脸懵。当学过一些java反序列化后。学到fastjson反序列化的时候，就是这里没搞好，也搞搞得懵逼了。但又回来学习这个类加载的时候，就感觉刚刚好&lt;/p&gt;
&lt;p&gt;Java是一个依赖于&lt;code&gt;JVM&lt;/code&gt;（Java虚拟机）实现的跨平台的开发语言。Java程序在运行前需要先编译成&lt;code&gt;class文件&lt;/code&gt;，Java类初始化的时候会调用&lt;code&gt;java.lang.ClassLoader&lt;/code&gt;加载类字节码，&lt;code&gt;ClassLoader&lt;/code&gt;会调用JVM的native方法（&lt;code&gt;defineClass0/1/2&lt;/code&gt;）来定义一个&lt;code&gt;java.lang.Class&lt;/code&gt;实例。&lt;/p&gt;
&lt;h2 id=&quot;ClassLoader&quot;&gt;&lt;a href=&quot;#ClassLoader&quot; class=&quot;headerlink&quot; title=&quot;ClassLoader&quot;&gt;&lt;/a&gt;&lt;strong&gt;ClassLoader&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;一切的Java类都必须经过JVM加载后才能运行，而&lt;code&gt;ClassLoader&lt;/code&gt;的主要作用就是Java类文件的加载。在JVM类加载器中最顶层的是&lt;code&gt;Bootstrap ClassLoader（引导类加载器）&lt;/code&gt;、&lt;code&gt;Extension ClassLoader（扩展类加载器）&lt;/code&gt;、&lt;code&gt;App ClassLoader（系统类加载器）&lt;/code&gt;，&lt;code&gt;AppClassLoad</summary>
      
    
    
    
    
    <category term="web安全" scheme="https://yyjccc.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
    <category term="java安全" scheme="https://yyjccc.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>fastjson反序列化解析过程调试</title>
    <link href="https://yyjccc.github.io/2023/12/05/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%B0%83%E8%AF%95/"/>
    <id>https://yyjccc.github.io/2023/12/05/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%B0%83%E8%AF%95/</id>
    <published>2023-12-04T17:10:23.904Z</published>
    <updated>2024-04-23T16:32:58.564Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;fastjson反序列化解析过程调试&quot;&gt;&lt;a href=&quot;#fastjson反序列化解析过程调试&quot; class=&quot;headerlink&quot; title=&quot;fastjson反序列化解析过程调试&quot;&gt;&lt;/a&gt;fastjson反序列化解析过程调试&lt;/h1&gt;&lt;p&gt;简单水一下fastjson反序列化解析过程的调试&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;​    fastjson是阿里巴巴开源的java中解析json的一个组件。其功能就是将json字符串与java对象进行相互转化。正如其名，解析j转化速度很快&lt;/p&gt;
&lt;p&gt;​     但fastjson多个版本都爆出反序列化漏洞，因此当遇到json时，可以看是否用了fastjson，再测是否存在漏洞&lt;/p&gt;
&lt;p&gt;​	当json中含有@type字段时，fastjson会将json解析为对应类的对象&lt;/p&gt;
&lt;p&gt;​	本篇文章主要是fastjson在反序列化解析的调试&lt;/p&gt;
&lt;h2 id=&quot;调式的代码&quot;&gt;&lt;a href=&quot;#调式的代码&quot; class=&quot;headerlink&quot; title=&quot;调式的代码&quot;&gt;&lt;/a&gt;调式的代码&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;环境&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jdk8&lt;/li&gt;
&lt;li&gt;fastjson 1.2.24&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;导入（pom.xml）&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span</summary>
      
    
    
    
    <category term="java安全" scheme="https://yyjccc.github.io/categories/java%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="web安全" scheme="https://yyjccc.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
    <category term="java安全" scheme="https://yyjccc.github.io/tags/java%E5%AE%89%E5%85%A8/"/>
    
    <category term="反序列化" scheme="https://yyjccc.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    <category term="fastjson" scheme="https://yyjccc.github.io/tags/fastjson/"/>
    
  </entry>
  
  <entry>
    <title>IDA的使用与re浅浅入门</title>
    <link href="https://yyjccc.github.io/2023/11/06/IDA%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8Ere%E6%B5%85%E6%B5%85%E5%85%A5%E9%97%A8/"/>
    <id>https://yyjccc.github.io/2023/11/06/IDA%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8Ere%E6%B5%85%E6%B5%85%E5%85%A5%E9%97%A8/</id>
    <published>2023-11-05T16:21:39.023Z</published>
    <updated>2023-11-06T07:14:49.166Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IDA的使用与re浅浅入门&quot;&gt;&lt;a href=&quot;#IDA的使用与re浅浅入门&quot; class=&quot;headerlink&quot; title=&quot;IDA的使用与re浅浅入门&quot;&gt;&lt;/a&gt;IDA的使用与re浅浅入门&lt;/h1&gt;&lt;h2 id=&quot;界面介绍&quot;&gt;&lt;a href=&quot;#界面介绍&quot; class=&quot;headerlink&quot; title=&quot;界面介绍&quot;&gt;&lt;/a&gt;界面介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;左侧是函数窗口，显示一些函数，可以crtf+f寻找main函数,找到主程序&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;/img/11-6/2.png&quot; height=&quot;500px&quot;&gt;

&lt;ul&gt;
&lt;li&gt;主体是汇编代码，可以通过空格切换查看视图&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;/img/11-6/3.png&quot;&gt;

&lt;ul&gt;
&lt;li&gt;内存分段，直接明了看所在内存的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;/img/11-6/4.png&quot;&gt;

&lt;h2 id=&quot;常用快捷键&quot;&gt;&lt;a href=&quot;#常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;常用快捷键&quot;&gt;&lt;/a&gt;常用快捷键&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;F5键–反汇编，，转化为伪C代码&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;/img/11-6/5.png&quot;&gt; 

&lt;ul&gt;
&lt;li&gt;shift+F12 切换到字符串展示界面(String Window)所有字符串在这里显示&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;/img/11-6/6.png&quot;&gt; 

&lt;ul&gt;
&lt;li&gt;crtf+X 交叉引用 寻找数据被引用的地方&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;/img/11-6/7.png&quot;&gt; 

&lt;ul&gt;
&lt;li&gt;g键 跳转到地址处&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;/img/11-6/8.png&quot;&gt; 

&lt;ul&gt;
&lt;li&gt;alt+t  搜索指令&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;/img/11-6/9.png&quot;&gt; 

&lt;img src=&quot;/img/11-6/10.png&quot;&gt; 

&lt;ul&gt;
&lt;li&gt;n键对函数进行重命名&lt;/li&gt;
&lt;/ul&gt;
&lt;img src=&quot;/img/11-6/11.png&quot;&gt; 

&lt;ul&gt;
&lt;li&gt;ctrl+z撤销操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;数据操</summary>
      
    
    
    
    
    <category term="二进制" scheme="https://yyjccc.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    <category term="re入门" scheme="https://yyjccc.github.io/tags/re%E5%85%A5%E9%97%A8/"/>
    
    <category term="工具使用" scheme="https://yyjccc.github.io/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>创建和配置Servlet项目</title>
    <link href="https://yyjccc.github.io/2023/10/15/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AEServlet%E9%A1%B9%E7%9B%AE/"/>
    <id>https://yyjccc.github.io/2023/10/15/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AEServlet%E9%A1%B9%E7%9B%AE/</id>
    <published>2023-10-15T03:45:12.031Z</published>
    <updated>2023-10-15T03:49:39.074Z</updated>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建和配置Servlet项目&quot;&gt;&lt;a href=&quot;#创建和配置Servlet项目&quot; class=&quot;headerlink&quot; title=&quot;创建和配置Servlet项目&quot;&gt;&lt;/a&gt;创建和配置Servlet项目&lt;/h2&gt;&lt;p&gt;servlet是原生的javaweb&lt;/p&gt;
&lt;p&gt;这里学习javaweb时候，配置Servlet项目，idea社区版怎么手动配置Servlet项目,于是就搞了一个教程,也是算入坑javaweb了&lt;/p&gt;
&lt;h5 id=&quot;1-创建一个项目&quot;&gt;&lt;a href=&quot;#1-创建一个项目&quot; class=&quot;headerlink&quot; title=&quot;1.创建一个项目&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.创建一个项目&lt;/strong&gt;&lt;/h5&gt;&lt;img src=&quot;/img/9-8/1.png&quot;&gt; 

&lt;h5 id=&quot;2-添加web模块&quot;&gt;&lt;a href=&quot;#2-添加web模块&quot; class=&quot;headerlink&quot; title=&quot;2.添加web模块&quot;&gt;&lt;/a&gt;&lt;strong&gt;2.添加web模块&lt;/strong&gt;&lt;/h5&gt;&lt;p&gt;先选择创建的项目，打开模块设置&lt;/p&gt;
&lt;img src=&quot;/img/9-8/2.png&quot;&gt; 



&lt;p&gt;在模块中选中自己的项目，添加web模块&lt;/p&gt;
&lt;img src=&quot;/img/9-8/3.png&quot;&gt; 

&lt;p&gt;然后确定&lt;/p&gt;
&lt;img src=&quot;/img/9-8/4.png&quot;&gt; 

&lt;h5 id=&quot;3-配置web模块&quot;&gt;&lt;a href=&quot;#3-配置web模块&quot; class=&quot;headerlink&quot; title=&quot;3.配置web模块&quot;&gt;&lt;/a&gt;&lt;strong&gt;3.配置web模块&lt;/strong&gt;&lt;/h5&gt;&lt;p&gt;在生成的web目录下的WEB-INF目录下创建classes目录，用于存放编译后的文件&lt;/p&gt;
&lt;img src=&quot;/img/9-8/5.png&quot;&gt; 

&lt;p&gt;再次打开模块设置，在模块中选择我们的项目，设置输出路径，将两个路径改为刚创建好的classes目录&lt;/p&gt;
&lt;img src=&quot;/img/9-8/6.png&quot;&gt; 

&lt;p&gt;点击修正，然后创建一个工件&lt;/p&gt;
&lt;img src=&quot;/img/9-8/7.png&quot;&gt; 

&lt;p&gt;最后确定&lt;/p&gt;
&lt;img src=&quot;/img/9-8/8.png&quot;&gt; 

&lt;h5 id=&quot;4-</summary>
      
    
    
    
    
    <category term="java" scheme="https://yyjccc.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>2023SHCTF之web的wp</title>
    <link href="https://yyjccc.github.io/2023/10/03/2023SHCTF%E4%B9%8Bweb%E7%9A%84wp/"/>
    <id>https://yyjccc.github.io/2023/10/03/2023SHCTF%E4%B9%8Bweb%E7%9A%84wp/</id>
    <published>2023-10-03T04:00:06.433Z</published>
    <updated>2023-12-05T05:27:07.581Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;2023-SHCTF-web-wp-week-1&quot;&gt;&lt;a href=&quot;#2023-SHCTF-web-wp-week-1&quot; class=&quot;headerlink&quot; title=&quot;2023 SHCTF web wp[week 1]&quot;&gt;&lt;/a&gt;2023 SHCTF web wp[week 1]&lt;/h1&gt;&lt;p&gt;说明：可能稍微啰嗦了亿点,面向新生，放心慢慢食用,&lt;/p&gt;
&lt;p&gt;下面前言可跳过（纯多bb了一下）&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;首先说web的话是应用层，所以会基本看不到底层的东西(包括c语言/c++)。对于ctf的话，web这块的内容，熟悉HTTP协议（知道计算机质之间是如何传递数据的），html.javaScript（前端语言）是必须要会一点，然后入门级的PHP也要会(比java简单多了)，然后就是Top10漏洞（其中还会涉及数据库mysql），也要知道一些常用的编码和加解密手段(Unicode、md5、base64),会这些后web也算入门了(看到这，要是我，已经当场去世)&lt;/p&gt;
&lt;p&gt;这里再说说why（hihi,装一下）：为什么要搞web 安全，在这互联网的世界，我们能享受各种各样的服务(qq聊天、刷视频)，都离不开web技术，所以web里面也有很多技术（常听的前端和后端），所以就会有许多的漏洞存在，对于企业、学校等等来说web服务器就是面向大伙大门，想要攻入内部系统，首先要拿下web服务器(bushi) ,所以web这块对于整个渗透攻击或者安全防御都重要，企业看重web这块的安全比内网多多了，这里再插一条：2021爆出的史诗级漏洞–log4j2远程代码执行漏洞(CVE-2021-44228)&lt;/p&gt;
&lt;p&gt;从易到难（前三个不好排），题解可能会不唯一，拿到flag就行，下面题目若是看不懂题解，也不要紧，把涉及的知识点记下来，以后慢慢学(hhhh)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前几题不一定要有编程基础！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;WEEK1-登录就给flag&quot;&gt;&lt;a href=&quot;#WEEK1-登录就给flag&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="ctf入门" scheme="https://yyjccc.github.io/tags/ctf%E5%85%A5%E9%97%A8/"/>
    
    <category term="新生赛wp" scheme="https://yyjccc.github.io/tags/%E6%96%B0%E7%94%9F%E8%B5%9Bwp/"/>
    
    <category term="web安全" scheme="https://yyjccc.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>2023MoeCTF之web的wp</title>
    <link href="https://yyjccc.github.io/2023/09/12/2023MoeCTF%E4%B9%8Bweb%E7%9A%84wp/"/>
    <id>https://yyjccc.github.io/2023/09/12/2023MoeCTF%E4%B9%8Bweb%E7%9A%84wp/</id>
    <published>2023-09-12T07:47:46.357Z</published>
    <updated>2023-12-10T15:34:29.859Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2023-MoeCTF-WEB-wp&quot;&gt;&lt;a href=&quot;#2023-MoeCTF-WEB-wp&quot; class=&quot;headerlink&quot; title=&quot;[2023 MoeCTF] WEB wp&quot;&gt;&lt;/a&gt;[2023 MoeCTF] WEB wp&lt;/h1&gt;&lt;p&gt;环境有问题，我开始还能用自己ip访问，后面突然不行了，这导致不能抓取本地的包，没关系照样做(^-^)&lt;/p&gt;
&lt;h1 id=&quot;http&quot;&gt;&lt;a href=&quot;#http&quot; class=&quot;headerlink&quot; title=&quot;http&quot;&gt;&lt;/a&gt;http&lt;/h1&gt;&lt;p&gt;签到题一&lt;/p&gt;
&lt;img src=&quot;&#92;img&#92;9-12&#92;7.png&quot; height=&quot;300px&quot;&gt;

&lt;p&gt;第一眼还没看懂，这应该满足他的条件即可拿到flag&lt;/p&gt;
&lt;p&gt;1和2,分别get和post传参，&lt;/p&gt;
&lt;p&gt;3.修改Cookie为character为admin&lt;/p&gt;
&lt;p&gt;4.添加字段X-Forward-For: 127.0.0.1&lt;/p&gt;
&lt;p&gt;5.修改User-Agent内容为MoeBrowser&lt;/p&gt;
&lt;img src=&quot;&#92;img&#92;9-12&#92;8.png&quot;&gt;



&lt;h1 id=&quot;Web入门指北&quot;&gt;&lt;a href=&quot;#Web入门指北&quot; class=&quot;headerlink&quot; title=&quot;Web入门指北&quot;&gt;&lt;/a&gt;Web入门指北&lt;/h1&gt;&lt;p&gt;签到题二&lt;/p&gt;
&lt;p&gt;解密：&lt;/p&gt;
&lt;figure class=&quot;highlight text&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;666c61673d6257396c5933526d6533637a62454e7662575666564739666257396c513152475831637959 6c396a61474673624756755a3055684958303 &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;对密码不是很熟悉，但对这里应该只能是md5、base64、16进制&lt;/p&gt;
&lt;p&gt;一看只能是16进制&lt;/p&gt;
&lt;p&gt;进行16进制解码：&lt;code&gt;flag=bW9lY3Rme3czbENvbWVfVG</summary>
      
    
    
    
    
    <category term="ctf" scheme="https://yyjccc.github.io/tags/ctf/"/>
    
    <category term="wp" scheme="https://yyjccc.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>入门flask框架</title>
    <link href="https://yyjccc.github.io/2023/08/28/%E5%85%A5%E9%97%A8flask%E6%A1%86%E6%9E%B6/"/>
    <id>https://yyjccc.github.io/2023/08/28/%E5%85%A5%E9%97%A8flask%E6%A1%86%E6%9E%B6/</id>
    <published>2023-08-28T13:46:17.547Z</published>
    <updated>2023-12-10T15:46:08.267Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;入门Flask框架&quot;&gt;&lt;a href=&quot;#入门Flask框架&quot; class=&quot;headerlink&quot; title=&quot;入门Flask框架&quot;&gt;&lt;/a&gt;入门Flask框架&lt;/h1&gt;&lt;p&gt;Flask是一个用Python语言编写的轻量级Web应用框架，它采用WSGI工具箱和Jinja2模板引擎，该框架使用简单的核心和扩展，没有默认的数据库和窗体验证工具，被称为“微框架”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;WSGI工具箱采用Werkzeug(路由模块)，模板引擎采用jinja2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;轻量级，只提供一些核心操作 &lt;/p&gt;
&lt;h2 id=&quot;相关知识&quot;&gt;&lt;a href=&quot;#相关知识&quot; class=&quot;headerlink&quot; title=&quot;相关知识&quot;&gt;&lt;/a&gt;&lt;strong&gt;相关知识&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;框架&lt;/strong&gt;：Web框架是一种用于开发Web应用的软件架构，它提供了一些通用的功能和组件，使得开发者可以更方便、高效、安全地构建Web应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模板引擎&lt;/strong&gt;（Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。&lt;/p&gt;
&lt;p&gt;模板引擎的核心原理就是两个字：&lt;strong&gt;替换&lt;/strong&gt;。将预先定义的标签字符替换为指定的业务数据，或者根据某种定义好的流程进行输出&lt;/p&gt;
&lt;p&gt;模板：模板是一种文件，它可以包含固定的和动态的内容。动态的内容通常是用一种特定的语法来表示的，&lt;/p&gt;
&lt;p&gt;**路由(route)**：简单来说，路由就是URL到视图函数的映射。当访问某个URL时，就会执行对应的函数&lt;/p&gt;
&lt;p&gt;如：/usersu        -&amp;gt;  getAllUsers()&lt;/p&gt;
&lt;p&gt; router 可以理解为一个容器，或者说一种机制，它管理了一组 route。简单来说，route 只是进行了URL和函数的映射，而在当接收到一个URL之后，去路由映射表中查找相应的函数，这个过程是由 router 来处理的。&lt;/p&gt;
&lt;h2 id=&quot;构成&quot;&gt;&lt;a href=&quot;#构成&quot; class=&quot;hea</summary>
      
    
    
    
    
    <category term="web" scheme="https://yyjccc.github.io/tags/web/"/>
    
    <category term="web框架" scheme="https://yyjccc.github.io/tags/web%E6%A1%86%E6%9E%B6/"/>
    
    <category term="python" scheme="https://yyjccc.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>初探python沙箱逃逸</title>
    <link href="https://yyjccc.github.io/2023/08/28/%E5%88%9D%E6%8E%A2python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
    <id>https://yyjccc.github.io/2023/08/28/%E5%88%9D%E6%8E%A2python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</id>
    <published>2023-08-28T13:21:48.688Z</published>
    <updated>2023-12-10T15:44:00.544Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;初探python沙箱逃逸&quot;&gt;&lt;a href=&quot;#初探python沙箱逃逸&quot; class=&quot;headerlink&quot; title=&quot;初探python沙箱逃逸&quot;&gt;&lt;/a&gt;初探python沙箱逃逸&lt;/h1&gt;&lt;p&gt;为了不让恶意用户执行任意的 Python 代码，就需要确保 Python 运行在沙箱中。沙箱经常会禁用一些敏感的函数和模块，例如 os&lt;/p&gt;
&lt;p&gt;沙箱逃逸就是绕过某些函数，特殊字符串，或模块的限制，达到一个漏洞环境&lt;/p&gt;
&lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;&lt;strong&gt;基础知识&lt;/strong&gt;&lt;/h1&gt;&lt;h3 id=&quot;命令执行函数与模块&quot;&gt;&lt;a href=&quot;#命令执行函数与模块&quot; class=&quot;headerlink&quot; title=&quot;命令执行函数与模块&quot;&gt;&lt;/a&gt;命令执行函数与模块&lt;/h3&gt;&lt;p&gt;在 Python 中执行系统命令的方式有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;os：&lt;code&gt;system&lt;/code&gt;,&lt;code&gt;popen&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;commands：(仅限&lt;code&gt;2.x&lt;/code&gt;)&lt;code&gt;getstatusoutput&lt;/code&gt;,&lt;code&gt;getoutput&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;subprocess: &lt;code&gt;getstatusoutput&lt;/code&gt;,&lt;code&gt;getoutput&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;timeit：&lt;code&gt;timeit.sys&lt;/code&gt;、&lt;code&gt;timeit.timeit(&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;, number=1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;platform：&lt;code&gt;platform.os&lt;/code&gt;、&lt;code&gt;platform.sys&lt;/code&gt;、&lt;code&gt;platform.popen(&#39;whoami&#39;, mode=&#39;r&#39;, bufsize=-1).read()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;pty：&lt;code&gt;pty.spawn(&#39;ls&#39;)&lt;/code&gt;、&lt;code&gt;pty.os&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;bdb：&lt;code&gt;bdb.os&lt;/code&gt;、&lt;</summary>
      
    
    
    
    
    <category term="web安全" scheme="https://yyjccc.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
    <category term="python安全" scheme="https://yyjccc.github.io/tags/python%E5%AE%89%E5%85%A8/"/>
    
    <category term="进阶学习" scheme="https://yyjccc.github.io/tags/%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>sql注入漏洞总结</title>
    <link href="https://yyjccc.github.io/2023/08/23/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93-mysql/"/>
    <id>https://yyjccc.github.io/2023/08/23/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93-mysql/</id>
    <published>2023-08-23T03:11:12.921Z</published>
    <updated>2023-12-10T15:42:37.332Z</updated>
    
    
      
      
    <summary type="html">&lt;p&gt;沙上有印，光中有&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;SQL注入总结&quot;&gt;&lt;a href=&quot;#SQL注入总结&quot; class=&quot;headerlink&quot; title=&quot;SQL注入总结&quot;&gt;&lt;/a&gt;SQL注入总结&lt;/h1&gt;&lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;h3 id=&quot;系统函数&quot;&gt;&lt;a href=&quot;#系统函数&quot; class=&quot;headerlink&quot; title=&quot;系统函数&quot;&gt;&lt;/a&gt;系统函数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;system_user()——系统用户名&lt;/p&gt;
&lt;p&gt;user()——用户名&lt;/p&gt;
&lt;p&gt;current_user()——当前用户名&lt;/p&gt;
&lt;p&gt;session_user()——链接数据库的用户名&lt;/p&gt;
&lt;p&gt;database()——数据库名&lt;/p&gt;
&lt;p&gt;version()——数据库版本&lt;/p&gt;
&lt;p&gt;@@datadir——数据库路径&lt;/p&gt;
&lt;p&gt;@@basedir——数据库安装路径&lt;/p&gt;
&lt;p&gt;@@version_conpile_os——操作系统&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;字符串连接函数&quot;&gt;&lt;a href=&quot;#字符串连接函数&quot; class=&quot;headerlink&quot; title=&quot;字符串连接函数&quot;&gt;&lt;/a&gt;字符串连接函数&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;concat(str1,str2,…)——没有分隔符地连接字符串&lt;/p&gt;
&lt;p&gt;concat_ws(separator,str1,str2,…)——含有分隔符地连接字符串&lt;/p&gt;
&lt;p&gt;group_concat(str1,str2,…)——连接一个组的所有字符串，并以逗号分隔每一条数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一般用于尝试的语句&quot;&gt;&lt;a href=&quot;#一般用于尝试的语句&quot; class=&quot;headerlink&quot; title=&quot;一般用于尝试的语句&quot;&gt;&lt;/a&gt;一般用于尝试的语句&lt;/h3&gt;&lt;p&gt;–+可以用#替换，url 提交过程中Url 编码后的#为%23&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;spa</summary>
      
    
    
    
    
    <category term="web安全" scheme="https://yyjccc.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
    <category term="基础漏洞" scheme="https://yyjccc.github.io/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>命令执行漏洞总结</title>
    <link href="https://yyjccc.github.io/2023/08/05/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
    <id>https://yyjccc.github.io/2023/08/05/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</id>
    <published>2023-08-05T15:34:41.951Z</published>
    <updated>2023-12-10T15:44:56.686Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;命令执行漏洞（RCE）&quot;&gt;&lt;a href=&quot;#命令执行漏洞（RCE）&quot; class=&quot;headerlink&quot; title=&quot;命令执行漏洞（RCE）&quot;&gt;&lt;/a&gt;命令执行漏洞（RCE）&lt;/h1&gt;&lt;h2 id=&quot;相关函数&quot;&gt;&lt;a href=&quot;#相关函数&quot; class=&quot;headerlink&quot; title=&quot;相关函数&quot;&gt;&lt;/a&gt;相关函数&lt;/h2&gt;&lt;p&gt;php 常见的调用外部程序的函数&lt;/p&gt;
&lt;p&gt;系统命令执行&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;system(args)–有回显&lt;/li&gt;
&lt;li&gt;shell_exec(args)–无回显必须输出&lt;/li&gt;
&lt;li&gt;passthru()&lt;/li&gt;
&lt;li&gt;popen(handle,mode)–无回显&lt;/li&gt;
&lt;li&gt;exec(args)–回显最后一行，必须加echo输出&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;proc_open()&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;`(反单引号)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出，使用反引号运算符“`”的效果与函数 shell_exec() 相同。&lt;/p&gt;
&lt;p&gt;php代码执行&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;assert()a&lt;/li&gt;
&lt;li&gt;preg_replace ( $pattern ,$replacement ,  $subject [,  $limit = -1 [, &amp;amp;$count ]] )&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;搜索subject中匹配pattern的部分， 以replacement进行替换。当使用被弃用的 e 修饰符时, 这个函数会转义一些字符，在完成替换后，引擎会将结果字符串作为php代码使用eval方式进行评估并将返回值作为最终参与替换的字符串&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;eval()&lt;/li&gt;
&lt;li&gt;call_user_func (  $callback [, $parameter [, $… ]] )&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。 传入call_user_func()的参数不能为引用传递。&lt;/p</summary>
      
    
    
    
    
    <category term="web安全" scheme="https://yyjccc.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
    <category term="基础漏洞" scheme="https://yyjccc.github.io/tags/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的原型链污染</title>
    <link href="https://yyjccc.github.io/2023/07/26/js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"/>
    <id>https://yyjccc.github.io/2023/07/26/js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</id>
    <published>2023-07-26T02:55:53.923Z</published>
    <updated>2023-12-10T15:37:04.808Z</updated>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;js原型链污染&quot;&gt;&lt;a href=&quot;#js原型链污染&quot; class=&quot;headerlink&quot; title=&quot;js原型链污染&quot;&gt;&lt;/a&gt;js原型链污染&lt;/h1&gt;&lt;h2 id=&quot;基础概念辨析&quot;&gt;&lt;a href=&quot;#基础概念辨析&quot; class=&quot;headerlink&quot; title=&quot;基础概念辨析&quot;&gt;&lt;/a&gt;基础概念辨析&lt;/h2&gt;&lt;h3 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;/a&gt;&lt;strong&gt;原型&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;js中一切皆对象,js的每个对象都有一个属性原型（prototype），原型本身也是一个对象，因此该原型也有一个prototype指向上层原型，直到为null，这样就构成了原型链&lt;/p&gt;
&lt;p&gt;简单来说，原型链是javascript中类继承的一种机制，每个对象都有对应的原型，储存了定义的属性和方法，之中包含了prototype，指向上一级的原型。最上层Object原型中的prototype为null&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类定义中的属性，会在创建对象时在对象中创建，类定义的方法而是存在于原型之中。当使用没有定义的属性和方法时，就会顺着原型链一直寻找，直到为undefined,用此来实现继承，子类能用父类的属性和方法&lt;/p&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;Person&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;variable language_&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;property&quot;&gt;name&lt;/span&gt; = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   }&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    
    <category term="web安全" scheme="https://yyjccc.github.io/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>http概述</title>
    <link href="https://yyjccc.github.io/2023/07/20/http%E6%A6%82%E8%BF%B0/"/>
    <id>https://yyjccc.github.io/2023/07/20/http%E6%A6%82%E8%BF%B0/</id>
    <published>2023-07-20T02:28:58.731Z</published>
    <updated>2023-07-20T04:46:54.233Z</updated>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;​	Web 使用一种名为 HTTP（超文本传输协议 ）的协议作为规范，完成从客户端到服务器端等一系列运作流 程。而协议是指规则的约定。Web 是建立在 HTTP 协议上通 信的。 http协议主要是计算机网络系统上的应   用层。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;h4 id=&quot;TCP-IP协议族&quot;&gt;&lt;a href=&quot;#TCP-IP协议族&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP协议族&quot;&gt;&lt;/a&gt;TCP/IP协议族&lt;/h4&gt;&lt;h5 id=&quot;主要内容：&quot;&gt;&lt;a href=&quot;#主要内容：&quot; class=&quot;headerlink&quot; title=&quot;主要内容：&quot;&gt;&lt;/a&gt;主要内容：&lt;/h5&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;应用层：FTP（文件传输协议）和DNS（域名系统）和http协议&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;传输层：TCP（传输控制协议）和UDP（用户数据报协议）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;网络层：处理在网络上流动的数据包 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;链路层：处理连接网络的硬件部分 &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;IP、TCP和DNS：&quot;&gt;&lt;a href=&quot;#IP、TCP和DNS：&quot; class=&quot;headerlink&quot; title=&quot;IP、TCP和DNS：&quot;&gt;&lt;/a&gt;IP、TCP和DNS：&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;</summary>
      
    
    
    
    
    <category term="web基础" scheme="https://yyjccc.github.io/tags/web%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://yyjccc.github.io/2023/07/19/hello-world/"/>
    <id>https://yyjccc.github.io/2023/07/19/hello-world/</id>
    <published>2023-07-19T11:36:43.760Z</published>
    <updated>2023-07-24T10:18:06.168Z</updated>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一篇博客&quot;&gt;&lt;a href=&quot;#第一篇博客&quot; class=&quot;headerlink&quot; title=&quot;第一篇博客&quot;&gt;&lt;/a&gt;第一篇博客&lt;/h2&gt;&lt;p&gt;​	不知道怎么看别人大佬的文章都是好看的博客，也非常系统，然后就想建个自己的博客。成功搭建博客系统。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="web" scheme="https://yyjccc.github.io/tags/web/"/>
    
  </entry>
  
</feed>
